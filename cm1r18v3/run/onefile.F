!<arch>
adv.F           1587424407  1602  20    100644  87020     `


      subroutine advs(nrk,wflag,bflag,bsq,xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,gz,rgz,mh,rmh,  &
                       rho0,rr0,rf0,rrf0,advx,advy,advz,dum,divx,mass,dumx,dumy, &
                       rru,rrv,rrw,s0,s,sten,pdef,dt,weps,                    &
                       flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,rdsf,c1,c2,rho,ri,diffit)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer, intent(in) :: nrk
      integer, intent(in) :: wflag,bflag
      double precision :: bsq
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh,ruh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh,rvh
      real, dimension(itb:ite,jtb:jte) :: gz,rgz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rmh,rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: advx,advy,advz,dum,divx,mass,dumx,dumy
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, dimension(ib:ie,jb:je,kb:ke) :: s0,s,sten
      integer pdef
      real, intent(in) :: dt
      double precision, intent(in) :: weps
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(in), dimension(kb:ke+1) :: rdsf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,ri
      integer, intent(in) :: diffit
 
      integer i,j,k,i1,i2,j1,j2
      logical :: doitw,doite,doits,doitn
      logical :: doweno
      real :: tem0
      double precision, dimension(nk) :: budx,budy

      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      double precision :: bmax
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      logical :: doit
      real :: coef

      integer, dimension(4) :: reqsx,reqsy

!----------------------------------------------------------------

      doweno = .false.
      IF( wflag.eq.1 )THEN
        IF( (advwenos.eq.1) .or. (advwenos.eq.2.and.nrk.eq.3) ) doweno = .true.
      ENDIF

      IF(diffit.eq.1)THEN
        coef = kdiff6/64.0/dt
      ENDIF

!-----------------

      i1 = 1
      i2 = ni+1

      doitw = .false.
      doite = .false.

      IF(wbc.eq.2 .and. ibw.eq.1) doitw = .true.
      IF(ebc.eq.2 .and. ibe.eq.1) doite = .true.

!-----------------

      j1 = 1
      j2 = nj+1

      doits = .false.
      doitn = .false.

      IF(sbc.eq.2 .and. ibs.eq.1) doits = .true.
      IF(nbc.eq.2 .and. ibn.eq.1) doitn = .true.

!-----------------

    hadvsection:  IF(axisymm.eq.1)THEN
      call advsaxi(doweno,bflag,bsq,xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,rmh,gz,rgz, &
                   rho0,rr0,rf0,rrf0,advx,dum,mass,rru,s0,s,sten,pdef,dt,weps, &
                   flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo
    ELSE

!-----------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,bmax,doit)
    DO k=1,nk   ! start of k-loop

      budx(k) = 0.0d0
      budy(k) = 0.0d0

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=i1,i2
        if(rru(i,j,k).ge.0.0)then
          s1=s(i-3,j,k)
          s2=s(i-2,j,k)
          s3=s(i-1,j,k)
          s4=s(i  ,j,k)
          s5=s(i+1,j,k)
        else
          s1=s(i+2,j,k)
          s2=s(i+1,j,k)
          s3=s(i  ,j,k)
          s4=s(i-1,j,k)
          s5=s(i-2,j,k)
        endif

      doit = .true.
      IF( pdef.eq.1 )THEN
        bmax = max(s1,s2,s3,s4,s5)
        if( bmax.lt.Min(1.0d-20,weps) ) doit = .false.
      ENDIF

      IF(doit)THEN

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=rru(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      ELSE
        dum(i,j,k)=0.0
      ENDIF
      enddo
      enddo
    elseif(hadvordrs.eq.5)then
      do j=1,nj
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rru(i,j,k)*( 37.0*(s(i  ,j,k)+s(i-1,j,k))     &
                                -8.0*(s(i+1,j,k)+s(i-2,j,k))     &
                                    +(s(i+2,j,k)+s(i-3,j,k))     &
        -sign(1.0,rru(i,j,k))*( 10.0*(s(i  ,j,k)-s(i-1,j,k))     &
                                -5.0*(s(i+1,j,k)-s(i-2,j,k))     &
                                    +(s(i+2,j,k)-s(i-3,j,k)) ) )*onedsixty
#else
        ! this seems to be faster on most other platforms:
        if(rru(i,j,k).ge.0.)then
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i-3,j,k)-13.*s(i-2,j,k)   &
                +47.*s(i-1,j,k)+27.*s(i,j,k)-3.*s(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i+2,j,k)-13.*s(i+1,j,k)   &
                +47.*s(i,j,k)+27.*s(i-1,j,k)-3.*s(i-2,j,k) )*onedsixty
        endif
#endif
      enddo
      enddo
    elseif(hadvordrs.eq.6)then
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=rru(i,j,k)*( 37.0*(s(i  ,j,k)+s(i-1,j,k))     &
                                -8.0*(s(i+1,j,k)+s(i-2,j,k))     &
                                    +(s(i+2,j,k)+s(i-3,j,k)) )*onedsixty
      enddo
      enddo
    endif

      if(doitw)then
      do j=1,nj
        i=1
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=dum(i+1,j,k)
        endif
      enddo
      endif

      if(doite)then
      do j=1,nj
        i=ni+1
        if(rru(i,j,k).le.0.0)then
          dum(i,j,k)=dum(i-1,j,k)
        endif
      enddo
      endif

      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo

      IF(doitw)THEN
        do j=1,nj
          if(rru(1,j,k).ge.0.0)then
            i=1
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
          endif
        enddo
      ENDIF

      IF(doite)THEN
        do j=1,nj
          if(rru(ni+1,j,k).le.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
          endif
        enddo
      ENDIF

    !-------------------------------------------------------
    ! 6th-order diffusion-s:
    IF(diffit.eq.1)THEN
      do j=1,nj
      do i=1,ni+1
        dum(i,j,k)=( 10.0*(s(i  ,j,k)-s(i-1,j,k))     &
                     -5.0*(s(i+1,j,k)-s(i-2,j,k))     &
                         +(s(i+2,j,k)-s(i-3,j,k)) )   &
                  *0.5*(rho(i-1,j,k)+rho(i,j,k))
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj
        do i=1,ni+1
          if( dum(i,j,k)*(s(i,j,k)-s(i-1,j,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=advx(i,j,k)+coef*(dum(i+1,j,k)-dum(i,j,k))*ri(i,j,k)*rho0(i,j,k)
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

! Advection in y-direction

    if(doweno)then
      do j=j1,j2
      do i=1,ni
        if(rrv(i,j,k).ge.0.0)then
          s1=s(i,j-3,k)
          s2=s(i,j-2,k)
          s3=s(i,j-1,k)
          s4=s(i,j  ,k)
          s5=s(i,j+1,k)
        else
          s1=s(i,j+2,k)
          s2=s(i,j+1,k)
          s3=s(i,j  ,k)
          s4=s(i,j-1,k)
          s5=s(i,j-2,k)
        endif

      doit = .true.
      IF( pdef.eq.1 )THEN
        bmax = max(s1,s2,s3,s4,s5)
        if( bmax.lt.Min(1.0d-20,weps)  ) doit = .false.
      ENDIF

      IF(doit)THEN

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=rrv(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      ELSE
        dum(i,j,k)=0.0
      ENDIF
      enddo
      enddo
    elseif(hadvordrs.eq.5)then
      do j=j1,j2
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rrv(i,j,k)*( 37.0*(s(i,j  ,k)+s(i,j-1,k))     &
                                -8.0*(s(i,j+1,k)+s(i,j-2,k))     &
                                    +(s(i,j+2,k)+s(i,j-3,k))     &
        -sign(1.0,rrv(i,j,k))*( 10.0*(s(i,j  ,k)-s(i,j-1,k))     &
                                -5.0*(s(i,j+1,k)-s(i,j-2,k))     &
                                    +(s(i,j+2,k)-s(i,j-3,k)) ) )*onedsixty
#else
        ! this seems to be faster on most other platforms:
        if(rrv(i,j,k).ge.0.)then
          dum(i,j,k)=rrv(i,j,k)*( 2.*s(i,j-3,k)-13.*s(i,j-2,k)   &
                +47.*s(i,j-1,k)+27.*s(i,j,k)-3.*s(i,j+1,k) )*onedsixty
        else
          dum(i,j,k)=rrv(i,j,k)*( 2.*s(i,j+2,k)-13.*s(i,j+1,k)   &
                +47.*s(i,j,k)+27.*s(i,j-1,k)-3.*s(i,j-2,k) )*onedsixty
        endif
#endif
      enddo
      enddo
    elseif(hadvordrs.eq.6)then
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=rrv(i,j,k)*( 37.0*(s(i,j  ,k)+s(i,j-1,k))     &
                                -8.0*(s(i,j+1,k)+s(i,j-2,k))     &
                                    +(s(i,j+2,k)+s(i,j-3,k)) )*onedsixty
      enddo
      enddo
    endif

      if(doits)then
      do i=1,ni
        j=1
        if(rrv(i,j,k).ge.0.0)then
          dum(i,j,k)=dum(i,j+1,k)
        endif
      enddo
      endif

      if(doitn)then
      do i=1,ni
        j=nj+1
        if(rrv(i,j,k).le.0.0)then
          dum(i,j,k)=dum(i,j-1,k)
        endif
      enddo
      endif

      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo

      IF(doits)THEN
        do i=1,ni
          if(rrv(i,1,k).ge.0.0)then
            j=1
            advy(i,j,k)=advy(i,j,k)-s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
          endif
        enddo
      ENDIF

      IF(doitn)THEN
        do i=1,ni
          if(rrv(i,nj+1,k).le.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
          endif
        enddo
      ENDIF

    !-------------------------------------------------------
    ! 6th-order diffusion-s:
    IF(diffit.eq.1)THEN
      do j=1,nj+1
      do i=1,ni
        dum(i,j,k)=( 10.0*(s(i,j  ,k)-s(i,j-1,k))     &
                     -5.0*(s(i,j+1,k)-s(i,j-2,k))     &
                         +(s(i,j+2,k)-s(i,j-3,k)) )   &
                  *0.5*(rho(i,j-1,k)+rho(i,j,k))
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj+1
        do i=1,ni
          if( dum(i,j,k)*(s(i,j,k)-s(i,j-1,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=advy(i,j,k)+coef*(dum(i,j+1,k)-dum(i,j,k))*ri(i,j,k)*rho0(i,j,k)
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

    ENDDO   ! end of k-loop

!----------------------------------------------------------------
!  Misc for x-direction

      IF(stat_qsrc.eq.1.and.(wbc.eq.2.or.ebc.eq.2).and.bflag.eq.1)THEN
        tem0=dt*dy*dz
        do k=1,nk
          bsq=bsq+budx(k)*tem0
        enddo
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefx1(xh,arh1,arh2,uh,rho0,gz,rgz,rru,advx,dumx,mass,s0,s,dt,flag,sw31,sw32,se31,se32,reqsx)
      ENDIF

!----------------------------------------------------------------
!  Misc for y-direction

      IF(stat_qsrc.eq.1.and.(sbc.eq.2.or.nbc.eq.2).and.bflag.eq.1)THEN
        tem0=dt*dx*dz
        do k=1,nk
          bsq=bsq+budy(k)*tem0
        enddo
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefy1(vh,rho0,gz,rgz,rrv,advy,dumy,mass,s0,s,dt,flag,ss31,ss32,sn31,sn32,reqsy)
      ENDIF

    ENDIF  hadvsection

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,bmax,dd,rr,phi,doit)
  jloops:  DO j=1,nj

    IF(doweno)THEN

      do k=3,nk-1
      do i=1,ni
        if(rrw(i,j,k).ge.0.0)then
          s1=s(i,j,k-3)
          s2=s(i,j,k-2)
          s3=s(i,j,k-1)
          s4=s(i,j,k  )
          s5=s(i,j,k+1)
        else
          s1=s(i,j,k+2)
          s2=s(i,j,k+1)
          s3=s(i,j,k  )
          s4=s(i,j,k-1)
          s5=s(i,j,k-2)
        endif

      doit = .true.
      IF( pdef.eq.1 )THEN
        bmax = max(s1,s2,s3,s4,s5)
        if( bmax.lt.Min(1.0d-20,weps)  ) doit = .false.
      ENDIF
      IF( k.eq.3 .and. rrw(i,j,k).gt.0.0 ) doit = .false.
      IF( k.eq.(nk-1) .and. rrw(i,j,k).lt.0.0 ) doit = .false.

      IF(doit)THEN

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=rrw(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      ELSE
        dum(i,j,k)=0.0
      ENDIF
      enddo
      enddo

      ! flux at k=3 if w > 0
      k = 3
      do i=1,ni
        if( rrw(i,j,k).ge.0.0 )then
          dd = s(i,j,k-1)-s(i,j,k-2)
          rr = (s(i,j,k)-s(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rrw(i,j,k)*( s(i,j,k-1) + 0.5*phi*(s(i,j,k-1)-s(i,j,k-2)) )
        endif
      enddo

      ! flux at k=(nk-1) if w < 0
      k = nk-1
      do i=1,ni
        if( rrw(i,j,k).le.0.0 )then
          dd = s(i,j,k)-s(i,j,k+1)
          rr = (s(i,j,k-1)-s(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rrw(i,j,k)*( s(i,j,k) + 0.5*phi*(s(i,j,k)-s(i,j,k+1)) )
        endif
      enddo

      k = 2
      do i=1,ni
        if( rrw(i,j,k).ge.0.0 )then
          dum(i,j,k)=rrw(i,j,k)*(c1(i,j,k)*s(i,j,k-1)+c2(i,j,k)*s(i,j,k))
        else
          dd = s(i,j,k)-s(i,j,k+1)
          rr = (s(i,j,k-1)-s(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rrw(i,j,k)*( s(i,j,k) + 0.5*phi*(s(i,j,k)-s(i,j,k+1)) )
        endif
      enddo

      k = nk
      do i=1,ni
        if( rrw(i,j,k).gt.0.0 )then
          dd = s(i,j,k-1)-s(i,j,k-2)
          rr = (s(i,j,k)-s(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rrw(i,j,k)*( s(i,j,k-1) + 0.5*phi*(s(i,j,k-1)-s(i,j,k-2)) )
        else
          dum(i,j,k)=rrw(i,j,k)*(c1(i,j,k)*s(i,j,k-1)+c2(i,j,k)*s(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrs.eq.5)THEN

      do k=4,nk-2
      do i=1,ni
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)*( 2.*s(i,j,k-3)-13.*s(i,j,k-2)      &
                +47.*s(i,j,k-1)+27.*s(i,j,k)-3.*s(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=rrw(i,j,k)*( 2.*s(i,j,k+2)-13.*s(i,j,k+1)      &
                +47.*s(i,j,k)+27.*s(i,j,k-1)-3.*s(i,j,k-2) )*onedsixty
        endif
      enddo
      enddo

      k = 3
      do i=1,ni
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)*(-s(i,j,k-2)+5.*s(i,j,k-1)+2.*s(i,j,k))*onedsix
        else
          dum(i,j,k)=rrw(i,j,k)*( 2.*s(i,j,k+2)-13.*s(i,j,k+1)      &
                +47.*s(i,j,k)+27.*s(i,j,k-1)-3.*s(i,j,k-2) )*onedsixty
        endif
      enddo

      k = nk-1
      do i=1,ni
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)*( 2.*s(i,j,k-3)-13.*s(i,j,k-2)      &
                +47.*s(i,j,k-1)+27.*s(i,j,k)-3.*s(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=rrw(i,j,k)*(-s(i,j,k+1)+5.*s(i,j,k)+2.*s(i,j,k-1))*onedsix
        endif
      enddo

      k = 2
      do i=1,ni
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)*(c1(i,j,k)*s(i,j,k-1)+c2(i,j,k)*s(i,j,k))
        else
          dum(i,j,k)=rrw(i,j,k)*(-s(i,j,k+1)+5.*s(i,j,k)+2.*s(i,j,k-1))*onedsix
        endif
      enddo

      k = nk
      do i=1,ni
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)*(-s(i,j,k-2)+5.*s(i,j,k-1)+2.*s(i,j,k))*onedsix
        else
          dum(i,j,k)=rrw(i,j,k)*(c1(i,j,k)*s(i,j,k-1)+c2(i,j,k)*s(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrs.eq.6)THEN

      do k=4,nk-2
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)                                 &
                            *( 37.0*(s(i,j,k  )+s(i,j,k-1))          &
                               -8.0*(s(i,j,k+1)+s(i,j,k-2))          &
                                   +(s(i,j,k+2)+s(i,j,k-3)) )*onedsixty
      enddo
      enddo

      do k=3,(nk-1),(nk-4)
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)                                &
                            *( 7.0*(s(i,j,k  )+s(i,j,k-1))          &
                                  -(s(i,j,k+1)+s(i,j,k-2)) )*onedtwelve
      enddo
      enddo

      do k=2,nk,(nk-2)
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)*(c1(i,j,k)*s(i,j,k-1)+c2(i,j,k)*s(i,j,k))
      enddo
      enddo

    ENDIF

!------

    IF(terrain_flag)THEN

      k=1
      do i=1,ni
        advz(i,j,k)=-dum(i,j,k+1)*rdsf(k)
      enddo
      do k=2,nk-1
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdsf(k)
      enddo
      enddo
      k=nk
      do i=1,ni
        advz(i,j,k)=+dum(i,j,k)*rdsf(k)
      enddo

    ELSE

      k=1
      do i=1,ni
        advz(i,j,k)=-dum(i,j,k+1)*rdz*mh(1,1,k)
      enddo
      do k=2,nk-1
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(1,1,k)
      enddo
      enddo
      k=nk
      do i=1,ni
        advz(i,j,k)=+dum(i,j,k)*rdz*mh(1,1,k)
      enddo

    ENDIF

    ENDDO  jloops

!----------------------------------------------------------------
!  Misc for z-direction

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefz(mh,rho0,gz,rgz,rdsf,rrw,advz,dum,mass,s0,s,dt,flag)
      ENDIF

!----------------------------------------------------------------
!  Finish pdefxy:

      IF(pdscheme.eq.1 .and. pdef.eq.1 .and. axisymm.eq.0)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefx2(xh,arh1,arh2,uh,rho0,gz,rgz,rru,advx,dumx,mass,s0,s,dt,flag,sw31,sw32,se31,se32,reqsx)
        call pdefy2(vh,rho0,gz,rgz,rrv,advy,dumy,mass,s0,s,dt,flag,ss31,ss32,sn31,sn32,reqsy)
      ENDIF

!----------------------------------------------------------------
!  Total advection tendency:

    IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                                 +s(i,j,k)*divx(i,j,k) )*rr0(i,j,k)*gz(i,j)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                                 +s(i,j,k)*divx(i,j,k) )*rr0(1,1,k)
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advs=time_advs+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advu(nrk,arh1,arh2,xf,rxf,arf1,arf2,uf,vh,gz,rgz,gzu,mh,rho0,rr0,rf0,rrf0,dum,advx,advy,advz,divx, &
                       rru,u3d,uten,rrv,rrw,rdsf,c1,c2,rho,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer, intent(in) :: nrk
      real, dimension(ib:ie) :: arh1,arh2
      real, dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(itb:ite,jtb:jte) :: gz,rgz,gzu
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, intent(in), dimension(kb:ke+1) :: rdsf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho
      real, intent(in) :: dt
 
      integer i,j,k,i1,i2,j1,j2,id1,id2
      real :: ubar,vbar,wbar,cc1,cc2
      logical :: doitw,doite,doits,doitn

      logical :: doweno
      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      double precision :: weps
      real :: coef

!------------------------------------------------------------

      doweno = .false.
      IF( (advwenov.eq.1) .or. (advwenov.eq.2.and.nrk.eq.3) ) doweno = .true.
      weps = 100.0*epsilon

      IF( idiff.ge.1 .and. difforder.eq.6 )THEN
        coef = kdiff6/64.0/dt
      ENDIF

!-----------------

      if(ibw.eq.1)then
        i1=2
      else
        i1=1
      endif
 
      if(ibe.eq.1)then
        i2=ni+1-1
      else
        i2=ni+1
      endif

      id1 = i1-1
      id2 = i2

      doitw = .false.
      doite = .false.

      IF(wbc.eq.2 .and. ibw.eq.1) doitw = .true.
      IF(ebc.eq.2 .and. ibe.eq.1) doite = .true.

!-----------------

      j1 = 1
      j2 = nj+1

      doits = .false.
      doitn = .false.

      IF(sbc.eq.2 .and. ibs.eq.1) doits = .true.
      IF(nbc.eq.2 .and. ibn.eq.1) doitn = .true.

!----------------------------------------------------------------

    hadvsection:  IF(axisymm.eq.1)THEN
      call advuaxi(doweno,arh1,arh2,xf,rxf,arf1,arf2,uf,vh,rho0,rr0,rf0,rrf0,dum,advx,rru,u3d,uten)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo
    ELSE

!-----------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,ubar,vbar,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4)
    DO k=1,nk

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=id1,id2
        ubar = 0.5*(rru(i,j,k)+rru(i+1,j,k))
        if(ubar.ge.0.0)then
          s1=u3d(i-2,j,k)
          s2=u3d(i-1,j,k)
          s3=u3d(i  ,j,k)
          s4=u3d(i+1,j,k)
          s5=u3d(i+2,j,k)
        else
          s1=u3d(i+3,j,k)
          s2=u3d(i+2,j,k)
          s3=u3d(i+1,j,k)
          s4=u3d(i  ,j,k)
          s5=u3d(i-1,j,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=ubar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    elseif(hadvordrv.eq.5)then
      do j=1,nj
      do i=id1,id2
        ubar = 0.5*(rru(i,j,k)+rru(i+1,j,k))
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*( 2.*u3d(i-2,j,k)-13.*u3d(i-1,j,k)+47.*u3d(i,j,k)   &
                          +27.*u3d(i+1,j,k)-3.*u3d(i+2,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*( 2.*u3d(i+3,j,k)-13.*u3d(i+2,j,k)+47.*u3d(i+1,j,k)   &
                          +27.*u3d(i,j,k)-3.*u3d(i-1,j,k) )*onedsixty
        endif
      enddo
      enddo
    elseif(hadvordrv.eq.6)then
      do j=1,nj
      do i=id1,id2
        ubar = 0.5*(rru(i,j,k)+rru(i+1,j,k))
        dum(i,j,k)=ubar*( 37.0*(u3d(i+1,j,k)+u3d(i  ,j,k)) &
                          -8.0*(u3d(i+2,j,k)+u3d(i-1,j,k)) &
                              +(u3d(i+3,j,k)+u3d(i-2,j,k)) )*onedsixty
      enddo
      enddo
    endif

      do j=1,nj
      do i=i1,i2
        advx(i,j,k)=-(dum(i,j,k)-dum(i-1,j,k))*rdx*uf(i)
      enddo
      enddo

    !-------------------------------------------------------
    ! 6th-order diffusion-u:
    IF( idiff.ge.1 .and. difforder.eq.6 )THEN
      do j=1,nj
      do i=1,ni+2
        dum(i,j,k)=( 10.0*(u3d(i  ,j,k)-u3d(i-1,j,k))     &
                     -5.0*(u3d(i+1,j,k)-u3d(i-2,j,k))     &
                         +(u3d(i+2,j,k)-u3d(i-3,j,k)) )*rho(i-1,j,k)
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj
        do i=1,ni+2
          if( dum(i,j,k)*(u3d(i,j,k)-u3d(i-1,j,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj
      do i=1,ni+1
        advx(i,j,k)=advx(i,j,k)+coef*(dum(i+1,j,k)-dum(i,j,k))*(rho0(i-1,j,k)+rho0(i,j,k))/(rho(i-1,j,k)+rho(i,j,k))
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

! Advection in y-direction

    if(doweno)then
      do j=j1,j2
      do i=i1,i2
        vbar = 0.5*(rrv(i,j,k)+rrv(i-1,j,k))
        if(vbar.ge.0.0)then
          s1=u3d(i,j-3,k)
          s2=u3d(i,j-2,k)
          s3=u3d(i,j-1,k)
          s4=u3d(i,j  ,k)
          s5=u3d(i,j+1,k)
        else
          s1=u3d(i,j+2,k)
          s2=u3d(i,j+1,k)
          s3=u3d(i,j  ,k)
          s4=u3d(i,j-1,k)
          s5=u3d(i,j-2,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=vbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    elseif(hadvordrv.eq.5)then
      do j=j1,j2
      do i=i1,i2
        vbar = 0.5*(rrv(i,j,k)+rrv(i-1,j,k))
        if(vbar.ge.0.)then
          dum(i,j,k)=vbar*( 2.*u3d(i,j-3,k)-13.*u3d(i,j-2,k)+47.*u3d(i,j-1,k)   &
                          +27.*u3d(i,j,k)-3.*u3d(i,j+1,k) )*onedsixty
        else
          dum(i,j,k)=vbar*( 2.*u3d(i,j+2,k)-13.*u3d(i,j+1,k)+47.*u3d(i,j,k)   &
                          +27.*u3d(i,j-1,k)-3.*u3d(i,j-2,k) )*onedsixty
        endif
      enddo
      enddo
    elseif(hadvordrv.eq.6)then
      do j=j1,j2
      do i=i1,i2
        vbar = 0.5*(rrv(i,j,k)+rrv(i-1,j,k))
        dum(i,j,k)=vbar*( 37.0*(u3d(i,j  ,k)+u3d(i,j-1,k)) &
                          -8.0*(u3d(i,j+1,k)+u3d(i,j-2,k)) &
                              +(u3d(i,j+2,k)+u3d(i,j-3,k)) )*onedsixty
      enddo
      enddo
    endif

      if(doits)then
      do i=i1,i2
        j=1
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
          dum(i,j,k)=dum(i,j+1,k)
        endif
      enddo
      endif

      if(doitn)then
      do i=i1,i2
        j=nj+1
        if((rrv(i,j,k)+rrv(i-1,j,k)).le.0.0)then
          dum(i,j,k)=dum(i,j-1,k)
        endif
      enddo
      endif

      do j=1,nj
      do i=i1,i2
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo

      IF(doits)THEN
        do i=i1,i2
          if((rrv(i,1,k)+rrv(i-1,1,k)).ge.0.0)then
            j=1
            advy(i,j,k)=advy(i,j,k)-u3d(i,j,k)*0.5*(                    &
                            (rrv(i-1,j+1,k)-rrv(i-1,j,k))               &
                           +(rrv(i  ,j+1,k)-rrv(i  ,j,k)) )*rdy*vh(j)
          endif
        enddo
      ENDIF

      IF(doitn)THEN
        do i=i1,i2
          if((rrv(i,nj+1,k)+rrv(i-1,nj+1,k)).le.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-u3d(i,j,k)*0.5*(                    &
                            (rrv(i-1,j+1,k)-rrv(i-1,j,k))               &
                           +(rrv(i  ,j+1,k)-rrv(i  ,j,k)) )*rdy*vh(j)
          endif
        enddo
      ENDIF

    !-------------------------------------------------------
    ! 6th-order diffusion-u:
    IF( idiff.ge.1 .and. difforder.eq.6 )THEN
      do j=1,nj+1
      do i=1,ni+1
        dum(i,j,k)=( 10.0*(u3d(i,j  ,k)-u3d(i,j-1,k))     &
                     -5.0*(u3d(i,j+1,k)-u3d(i,j-2,k))     &
                         +(u3d(i,j+2,k)-u3d(i,j-3,k)) )   &
                  *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))     &
                         +(rho(i-1,j,k)+rho(i,j-1,k)) )
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj+1
        do i=1,ni+1
          if( dum(i,j,k)*(u3d(i,j,k)-u3d(i,j-1,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj
      do i=1,ni+1
        advy(i,j,k)=advy(i,j,k)+coef*(dum(i,j+1,k)-dum(i,j,k))*(rho0(i-1,j,k)+rho0(i,j,k))/(rho(i-1,j,k)+rho(i,j,k))
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

    ENDDO

    ENDIF  hadvsection

!----------------------------------------------------------------
! Advection in z-direction  (Cartesian grid)

  vadvu:  IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,wbar,cc1,cc2,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
  jloopu:  DO j=1,nj

    IF(doweno)THEN

      do k=3,nk-1
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if(wbar.ge.0.0)then
          s1=u3d(i,j,k-3)
          s2=u3d(i,j,k-2)
          s3=u3d(i,j,k-1)
          s4=u3d(i,j,k  )
          s5=u3d(i,j,k+1)
        else
          s1=u3d(i,j,k+2)
          s2=u3d(i,j,k+1)
          s3=u3d(i,j,k  )
          s4=u3d(i,j,k-1)
          s5=u3d(i,j,k-2)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=wbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo

      ! flux at k=3 if w > 0
      k = 3
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if( wbar.gt.0.0 )then
          dd = u3d(i,j,k-1)-u3d(i,j,k-2)
          rr = (u3d(i,j,k)-u3d(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k-1) + 0.5*phi*(u3d(i,j,k-1)-u3d(i,j,k-2)) )
        endif
      enddo

      ! flux at k=(nk-1) if w < 0
      k = nk-1
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if( wbar.lt.0.0 )then
          dd = u3d(i,j,k)-u3d(i,j,k+1)
          rr = (u3d(i,j,k-1)-u3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k) + 0.5*phi*(u3d(i,j,k)-u3d(i,j,k+1)) )
        endif
      enddo

      k = 2
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if( wbar.ge.0.0 )then
          cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*u3d(i,j,k-1)+cc2*u3d(i,j,k))
        else
          dd = u3d(i,j,k)-u3d(i,j,k+1)
          rr = (u3d(i,j,k-1)-u3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k) + 0.5*phi*(u3d(i,j,k)-u3d(i,j,k+1)) )
        endif
      enddo

      k = nk
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if( wbar.gt.0.0 )then
          dd = u3d(i,j,k-1)-u3d(i,j,k-2)
          rr = (u3d(i,j,k)-u3d(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k-1) + 0.5*phi*(u3d(i,j,k-1)-u3d(i,j,k-2)) )
        else
          cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*u3d(i,j,k-1)+cc2*u3d(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrv.eq.5)THEN

      do k=4,nk-2
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k-3)-13.*u3d(i,j,k-2)+47.*u3d(i,j,k-1)   &
                          +27.*u3d(i,j,k)-3.*u3d(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k+2)-13.*u3d(i,j,k+1)+47.*u3d(i,j,k)   &
                          +27.*u3d(i,j,k-1)-3.*u3d(i,j,k-2) )*onedsixty
        endif
      enddo
      enddo

      k = 3
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if((rrw(i,j,k)+rrw(i-1,j,k)).ge.0.)then
          dum(i,j,k)=wbar*(-u3d(i,j,k-2)+5.*u3d(i,j,k-1)+2.*u3d(i,j,k  ))*onedsix
        else
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k+2)-13.*u3d(i,j,k+1)+47.*u3d(i,j,k)   &
                          +27.*u3d(i,j,k-1)-3.*u3d(i,j,k-2) )*onedsixty
        endif
      enddo

      k = nk-1
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if((rrw(i,j,k)+rrw(i-1,j,k)).ge.0.)then
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k-3)-13.*u3d(i,j,k-2)+47.*u3d(i,j,k-1)   &
                          +27.*u3d(i,j,k)-3.*u3d(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=wbar*(-u3d(i,j,k+1)+5.*u3d(i,j,k  )+2.*u3d(i,j,k-1))*onedsix
        endif
      enddo

      k = 2
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if((rrw(i,j,k)+rrw(i-1,j,k)).ge.0.)then
          cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*u3d(i,j,k-1)+cc2*u3d(i,j,k))
        else
          dum(i,j,k)=wbar*(-u3d(i,j,k+1)+5.*u3d(i,j,k  )+2.*u3d(i,j,k-1))*onedsix
        endif
      enddo

      k = nk
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        if((rrw(i,j,k)+rrw(i-1,j,k)).ge.0.)then
          dum(i,j,k)=wbar*(-u3d(i,j,k-2)+5.*u3d(i,j,k-1)+2.*u3d(i,j,k  ))*onedsix
        else
          cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*u3d(i,j,k-1)+cc2*u3d(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrv.eq.6)THEN

      do k=4,nk-2
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        dum(i,j,k)=wbar*( 37.0*(u3d(i,j,k  )+u3d(i,j,k-1)) &
                          -8.0*(u3d(i,j,k+1)+u3d(i,j,k-2)) &
                              +(u3d(i,j,k+2)+u3d(i,j,k-3)) )*onedsixty
      enddo
      enddo

      do k=3,(nk-1),(nk-4)
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        dum(i,j,k)=wbar*( 7.0*(u3d(i,j,k  )+u3d(i,j,k-1)) &
                             -(u3d(i,j,k+1)+u3d(i,j,k-2)) )*onedtwelve
      enddo
      enddo

      do k=2,nk,(nk-2)
      do i=i1,i2
        wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        dum(i,j,k)=wbar*(cc1*u3d(i,j,k-1)+cc2*u3d(i,j,k))
      enddo
      enddo

    ENDIF

!------

      IF(terrain_flag)THEN

        k=1
        do i=i1,i2
          advz(i,j,k)=-dum(i,j,k+1)*rdsf(k)
          uten(i,j,k)=uten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )         &
                  *gzu(i,j)/(0.5*(rho0(i-1,j,k)+rho0(i,j,k)))
        enddo
        do k=2,nk-1
        do i=i1,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdsf(k)
          uten(i,j,k)=uten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )         &
                  *gzu(i,j)/(0.5*(rho0(i-1,j,k)+rho0(i,j,k)))
        enddo
        enddo
        k=nk
        do i=i1,i2
          advz(i,j,k)=+dum(i,j,k)*rdsf(k)
          uten(i,j,k)=uten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )         &
                  *gzu(i,j)/(0.5*(rho0(i-1,j,k)+rho0(i,j,k)))
        enddo

      ELSE

        k=1
        do i=i1,i2
          advz(i,j,k)=-dum(i,j,k+1)*rdz*mh(1,1,k)
          uten(i,j,k)=uten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )*rr0(1,1,k)
        enddo
        do k=2,nk-1
        do i=i1,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(1,1,k)
          uten(i,j,k)=uten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )*rr0(1,1,k)
        enddo
        enddo
        k=nk
        do i=i1,i2
          advz(i,j,k)=+dum(i,j,k)*rdz*mh(1,1,k)
          uten(i,j,k)=uten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )*rr0(1,1,k)
        enddo

      ENDIF

    ENDDO    jloopu

!  end vadvu for Cartesian grid
!----------------------------------------------------------------
! Advection in z-direction  (axisymmetric grid)

  ELSEIF(axisymm.eq.1)THEN

    IF(ebc.eq.3.or.ebc.eq.4) i2 = ni

!$omp parallel do default(shared)   &
!$omp private(i,j,k,wbar,cc1,cc2,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
  jloopuasymm:  DO j=1,nj

    IF(doweno)THEN

      do k=3,nk-1
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if(wbar.ge.0.0)then
          s1=u3d(i,j,k-3)
          s2=u3d(i,j,k-2)
          s3=u3d(i,j,k-1)
          s4=u3d(i,j,k  )
          s5=u3d(i,j,k+1)
        else
          s1=u3d(i,j,k+2)
          s2=u3d(i,j,k+1)
          s3=u3d(i,j,k  )
          s4=u3d(i,j,k-1)
          s5=u3d(i,j,k-2)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=wbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo

      ! flux at k=3 if w > 0
      k = 3
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if( wbar.gt.0.0 )then
          dd = u3d(i,j,k-1)-u3d(i,j,k-2)
          rr = (u3d(i,j,k)-u3d(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k-1) + 0.5*phi*(u3d(i,j,k-1)-u3d(i,j,k-2)) )
        endif
      enddo

      ! flux at k=(nk-1) if w < 0
      k = nk-1
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if( wbar.lt.0.0 )then
          dd = u3d(i,j,k)-u3d(i,j,k+1)
          rr = (u3d(i,j,k-1)-u3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k) + 0.5*phi*(u3d(i,j,k)-u3d(i,j,k+1)) )
        endif
      enddo

      k = 2
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if( wbar.ge.0.0 )then
          dum(i,j,k)=wbar*(c1(1,1,k)*u3d(i,j,k-1)+c2(1,1,k)*u3d(i,j,k))
        else
          dd = u3d(i,j,k)-u3d(i,j,k+1)
          rr = (u3d(i,j,k-1)-u3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k) + 0.5*phi*(u3d(i,j,k)-u3d(i,j,k+1)) )
        endif
      enddo

      k = nk
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if( wbar.gt.0.0 )then
          dd = u3d(i,j,k-1)-u3d(i,j,k-2)
          rr = (u3d(i,j,k)-u3d(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( u3d(i,j,k-1) + 0.5*phi*(u3d(i,j,k-1)-u3d(i,j,k-2)) )
        else
          dum(i,j,k)=wbar*(c1(1,1,k)*u3d(i,j,k-1)+c2(1,1,k)*u3d(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrv.eq.5)THEN

      do k=4,nk-2
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k-3)-13.*u3d(i,j,k-2)+47.*u3d(i,j,k-1)   &
                          +27.*u3d(i,j,k)-3.*u3d(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k+2)-13.*u3d(i,j,k+1)+47.*u3d(i,j,k)   &
                          +27.*u3d(i,j,k-1)-3.*u3d(i,j,k-2) )*onedsixty
        endif
      enddo
      enddo

      k = 3
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(-u3d(i,j,k-2)+5.*u3d(i,j,k-1)+2.*u3d(i,j,k  ))*onedsix
        else
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k+2)-13.*u3d(i,j,k+1)+47.*u3d(i,j,k)   &
                          +27.*u3d(i,j,k-1)-3.*u3d(i,j,k-2) )*onedsixty
        endif
      enddo

      k = nk-1
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*u3d(i,j,k-3)-13.*u3d(i,j,k-2)+47.*u3d(i,j,k-1)   &
                          +27.*u3d(i,j,k)-3.*u3d(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=wbar*(-u3d(i,j,k+1)+5.*u3d(i,j,k  )+2.*u3d(i,j,k-1))*onedsix
        endif
      enddo

      k = 2
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(c1(1,1,k)*u3d(i,j,k-1)+c2(1,1,k)*u3d(i,j,k))
        else
          dum(i,j,k)=wbar*(-u3d(i,j,k+1)+5.*u3d(i,j,k  )+2.*u3d(i,j,k-1))*onedsix
        endif
      enddo

      k = nk
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(-u3d(i,j,k-2)+5.*u3d(i,j,k-1)+2.*u3d(i,j,k  ))*onedsix
        else
          dum(i,j,k)=wbar*(c1(1,1,k)*u3d(i,j,k-1)+c2(1,1,k)*u3d(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrv.eq.6)THEN

      do k=4,nk-2
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        dum(i,j,k)=wbar*( 37.0*(u3d(i,j,k  )+u3d(i,j,k-1)) &
                          -8.0*(u3d(i,j,k+1)+u3d(i,j,k-2)) &
                              +(u3d(i,j,k+2)+u3d(i,j,k-3)) )*onedsixty
      enddo
      enddo

      do k=3,(nk-1),(nk-4)
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        dum(i,j,k)=wbar*( 7.0*(u3d(i,j,k  )+u3d(i,j,k-1)) &
                             -(u3d(i,j,k+1)+u3d(i,j,k-2)) )*onedtwelve
      enddo
      enddo

      do k=2,nk,(nk-2)
      do i=2,i2
        wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
        dum(i,j,k)=wbar*(c1(1,1,k)*u3d(i,j,k-1)+c2(1,1,k)*u3d(i,j,k))
      enddo
      enddo

    ENDIF

!------

        k=1
        do i=2,i2
          advz(i,j,k)=-dum(i,j,k+1)*rdz*mh(1,1,k)
          uten(i,j,k)=uten(i,j,k)+( advx(i,j,k)+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(arf2(i)*divx(i,j,k)+arf1(i)*divx(i-1,j,k)) )*rr0(1,1,k)
        enddo
        do k=2,nk-1
        do i=2,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(1,1,k)
          uten(i,j,k)=uten(i,j,k)+( advx(i,j,k)+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(arf2(i)*divx(i,j,k)+arf1(i)*divx(i-1,j,k)) )*rr0(1,1,k)
        enddo
        enddo
        k=nk
        do i=2,i2
          advz(i,j,k)=+dum(i,j,k)*rdz*mh(1,1,k)
          uten(i,j,k)=uten(i,j,k)+( advx(i,j,k)+advz(i,j,k)    &
                     +u3d(i,j,k)*0.5*(arf2(i)*divx(i,j,k)+arf1(i)*divx(i-1,j,k)) )*rr0(1,1,k)
        enddo

    ENDDO    jloopuasymm

  ELSE
    stop 55555
  ENDIF  vadvu

!  end vadvu for axisymmetric grid
!----------------------------------------------------------------

      if(timestats.ge.1) time_advu=time_advu+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advv(nrk,xh,rxh,arh1,arh2,uh,xf,vf,gz,rgz,gzv,mh,rho0,rr0,rf0,rrf0,dum,advx,advy,advz,divx, &
                       rru,rrv,v3d,vten,rrw,rdsf,c1,c2,rho,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer, intent(in) :: nrk
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je+1) :: vf
      real, dimension(itb:ite,jtb:jte) :: gz,rgz,gzv
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, intent(in), dimension(kb:ke+1) :: rdsf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho
      real, intent(in) :: dt
 
      integer i,j,k,i1,i2,j1,j2,jd1,jd2
      real :: ubar,vbar,wbar,cc1,cc2
      logical :: doitw,doite,doits,doitn

      logical :: doweno
      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      double precision :: weps
      real :: coef

!------------------------------------------------------------

      doweno = .false.
      IF( (advwenov.eq.1) .or. (advwenov.eq.2.and.nrk.eq.3) ) doweno = .true.
      weps = 100.0*epsilon

      IF( idiff.ge.1 .and. difforder.eq.6 )THEN
        coef = kdiff6/64.0/dt
      ENDIF

!-----------------

      i1 = 1
      i2 = ni+1

      doitw = .false.
      doite = .false.

      IF(wbc.eq.2 .and. ibw.eq.1) doitw = .true.
      IF(ebc.eq.2 .and. ibe.eq.1) doite = .true.

!-----------------

      if(ibs.eq.1)then
        j1=2
      else
        j1=1
      endif
 
      if(ibn.eq.1)then
        j2=nj+1-1
      else
        j2=nj+1
      endif

      jd1 = j1-1
      jd2 = j2

      doits = .false.
      doitn = .false.

      IF(sbc.eq.2 .and. ibs.eq.1) doits = .true.
      IF(nbc.eq.2 .and. ibn.eq.1) doitn = .true.

!----------------------------------------------------------------

    hadvsection:  IF(axisymm.eq.1)THEN

      j1 = 1
      j2 = 1
      ! advz stores M
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,1
      do i=0,ni+1
        advz(i,j,k) = xh(i)*( v3d(i,j,k) + 0.5*fcor*xh(i) )
      enddo
      enddo
      enddo
      call advvaxi(doweno,xh,rxh,arh1,arh2,uh,xf,vf,rho0,rr0,rf0,rrf0,dum,advx,advz,rru,vten)

    ELSE

!-----------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,ubar,vbar,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4)
    DO k=1,nk

! Advection in x-direction

    if(doweno)then
      do j=j1,j2
      do i=i1,i2
        ubar = 0.5*(rru(i,j,k)+rru(i,j-1,k))
        if(ubar.ge.0.0)then
          s1=v3d(i-3,j,k)
          s2=v3d(i-2,j,k)
          s3=v3d(i-1,j,k)
          s4=v3d(i  ,j,k)
          s5=v3d(i+1,j,k)
        else
          s1=v3d(i+2,j,k)
          s2=v3d(i+1,j,k)
          s3=v3d(i  ,j,k)
          s4=v3d(i-1,j,k)
          s5=v3d(i-2,j,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=ubar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    elseif(hadvordrv.eq.5)then
      do j=j1,j2
      do i=i1,i2
        ubar = 0.5*(rru(i,j,k)+rru(i,j-1,k))
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*( 2.*v3d(i-3,j,k)-13.*v3d(i-2,j,k)+47.*v3d(i-1,j,k)    &
                          +27.*v3d(i,j,k)-3.*v3d(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*( 2.*v3d(i+2,j,k)-13.*v3d(i+1,j,k)+47.*v3d(i,j,k)    &
                          +27.*v3d(i-1,j,k)-3.*v3d(i-2,j,k) )*onedsixty
        endif
      enddo
      enddo
    elseif(hadvordrv.eq.6)then
      do j=j1,j2
      do i=i1,i2
        ubar = 0.5*(rru(i,j,k)+rru(i,j-1,k))
        dum(i,j,k)=ubar*( 37.0*(v3d(i  ,j,k)+v3d(i-1,j,k))     &
                          -8.0*(v3d(i+1,j,k)+v3d(i-2,j,k))     &
                              +(v3d(i+2,j,k)+v3d(i-3,j,k)) )*onedsixty
      enddo
      enddo
    endif

      if(doitw)then
      do j=j1,j2
        i=1
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.0)then
          dum(i,j,k)=dum(i+1,j,k)
        endif
      enddo
      endif

      if(doite)then
      do j=j1,j2
        i=ni+1
        if((rru(i,j,k)+rru(i,j-1,k)).le.0.0)then
          dum(i,j,k)=dum(i-1,j,k)
        endif
      enddo
      endif

      do j=j1,j2
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo

      IF(doitw)THEN
        do j=j1,j2
          if((rru(1,j,k)+rru(1,j-1,k)).ge.0.0)then
            i=1
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (rru(i+1,j-1,k)-rru(i,j-1,k))               &
                   +(rru(i+1,j  ,k)-rru(i,j  ,k)) )*rdx*uh(i)
          endif
        enddo
      ENDIF

      IF(doite)THEN
        do j=j1,j2
          if((rru(ni+1,j,k)+rru(ni+1,j-1,k)).le.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (rru(i+1,j-1,k)-rru(i,j-1,k))               &
                   +(rru(i+1,j  ,k)-rru(i,j  ,k)) )*rdx*uh(i)
          endif
        enddo
      ENDIF

    !-------------------------------------------------------
    ! 6th-order diffusion-v:
    IF( idiff.ge.1 .and. difforder.eq.6 )THEN
      do j=1,nj+1
      do i=1,ni+1
        dum(i,j,k)=( 10.0*(v3d(i  ,j,k)-v3d(i-1,j,k))     &
                     -5.0*(v3d(i+1,j,k)-v3d(i-2,j,k))     &
                         +(v3d(i+2,j,k)-v3d(i-3,j,k)) )   &
                  *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))     &
                         +(rho(i-1,j,k)+rho(i,j-1,k)) )
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj+1
        do i=1,ni+1
          if( dum(i,j,k)*(v3d(i,j,k)-v3d(i-1,j,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj+1
      do i=1,ni
        advx(i,j,k)=advx(i,j,k)+coef*(dum(i+1,j,k)-dum(i,j,k))*(rho0(i,j-1,k)+rho0(i,j,k))/(rho(i,j-1,k)+rho(i,j,k))
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

! Advection in y-direction

    if(doweno)then
      do j=jd1,jd2
      do i=1,ni
        vbar = 0.5*(rrv(i,j,k)+rrv(i,j+1,k))
        if(vbar.ge.0.0)then
          s1=v3d(i,j-2,k)
          s2=v3d(i,j-1,k)
          s3=v3d(i,j  ,k)
          s4=v3d(i,j+1,k)
          s5=v3d(i,j+2,k)
        else
          s1=v3d(i,j+3,k)
          s2=v3d(i,j+2,k)
          s3=v3d(i,j+1,k)
          s4=v3d(i,j  ,k)
          s5=v3d(i,j-1,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=vbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    elseif(hadvordrv.eq.5)then
      do j=jd1,jd2
      do i=1,ni
        vbar = 0.5*(rrv(i,j,k)+rrv(i,j+1,k))
        if(vbar.ge.0.)then
          dum(i,j,k)=vbar*( 2.*v3d(i,j-2,k)-13.*v3d(i,j-1,k)+47.*v3d(i,j,k)    &
                          +27.*v3d(i,j+1,k)-3.*v3d(i,j+2,k) )*onedsixty
        else
          dum(i,j,k)=vbar*( 2.*v3d(i,j+3,k)-13.*v3d(i,j+2,k)+47.*v3d(i,j+1,k)    &
                          +27.*v3d(i,j,k)-3.*v3d(i,j-1,k) )*onedsixty
        endif
      enddo
      enddo
    elseif(hadvordrv.eq.6)then
      do j=jd1,jd2
      do i=1,ni
        vbar = 0.5*(rrv(i,j,k)+rrv(i,j+1,k))
        dum(i,j,k)=vbar*( 37.0*(v3d(i,j+1,k)+v3d(i,j  ,k)) &
                          -8.0*(v3d(i,j+2,k)+v3d(i,j-1,k)) &
                              +(v3d(i,j+3,k)+v3d(i,j-2,k)) )*onedsixty
      enddo
      enddo
    endif

      do j=j1,j2
      do i=1,ni
        advy(i,j,k)=-(dum(i,j,k)-dum(i,j-1,k))*rdy*vf(j)
      enddo
      enddo

    !-------------------------------------------------------
    ! 6th-order diffusion-v:
    IF( idiff.ge.1 .and. difforder.eq.6 )THEN
      do j=1,nj+2
      do i=1,ni
        dum(i,j,k)=( 10.0*(v3d(i,j  ,k)-v3d(i,j-1,k))     &
                     -5.0*(v3d(i,j+1,k)-v3d(i,j-2,k))     &
                         +(v3d(i,j+2,k)-v3d(i,j-3,k)) )*rho(i,j-1,k)
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj+2
        do i=1,ni
          if( dum(i,j,k)*(v3d(i,j,k)-v3d(i,j-1,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj+1
      do i=1,ni
        advy(i,j,k)=advy(i,j,k)+coef*(dum(i,j+1,k)-dum(i,j,k))*(rho0(i,j-1,k)+rho0(i,j,k))/(rho(i,j-1,k)+rho(i,j,k))
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

    ENDDO

    ENDIF  hadvsection

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k,wbar,cc1,cc2,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
  jloopv:  DO j=j1,j2

    IF(doweno)THEN

      do k=3,nk-1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if(wbar.ge.0.0)then
          s1=v3d(i,j,k-3)
          s2=v3d(i,j,k-2)
          s3=v3d(i,j,k-1)
          s4=v3d(i,j,k  )
          s5=v3d(i,j,k+1)
        else
          s1=v3d(i,j,k+2)
          s2=v3d(i,j,k+1)
          s3=v3d(i,j,k  )
          s4=v3d(i,j,k-1)
          s5=v3d(i,j,k-2)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=wbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo

      ! flux at k=3 if w > 0
      k = 3
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if( wbar.gt.0.0 )then
          dd = v3d(i,j,k-1)-v3d(i,j,k-2)
          rr = (v3d(i,j,k)-v3d(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( v3d(i,j,k-1) + 0.5*phi*(v3d(i,j,k-1)-v3d(i,j,k-2)) )
        endif
      enddo

      ! flux at k=(nk-1) if w < 0
      k = nk-1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if( wbar.lt.0.0 )then
          dd = v3d(i,j,k)-v3d(i,j,k+1)
          rr = (v3d(i,j,k-1)-v3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( v3d(i,j,k) + 0.5*phi*(v3d(i,j,k)-v3d(i,j,k+1)) )
        endif
      enddo

      k = 2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if( wbar.ge.0.0 )then
          cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*v3d(i,j,k-1)+cc2*v3d(i,j,k))
        else
          dd = v3d(i,j,k)-v3d(i,j,k+1)
          rr = (v3d(i,j,k-1)-v3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( v3d(i,j,k) + 0.5*phi*(v3d(i,j,k)-v3d(i,j,k+1)) )
        endif
      enddo

      k = nk
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if( wbar.gt.0.0 )then
          dd = v3d(i,j,k-1)-v3d(i,j,k-2)
          rr = (v3d(i,j,k)-v3d(i,j,k-1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( v3d(i,j,k-1) + 0.5*phi*(v3d(i,j,k-1)-v3d(i,j,k-2)) )
        else
          cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*v3d(i,j,k-1)+cc2*v3d(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrv.eq.5)THEN

      do k=4,nk-2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*v3d(i,j,k-3)-13.*v3d(i,j,k-2)+47.*v3d(i,j,k-1)    &
                          +27.*v3d(i,j,k)-3.*v3d(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=wbar*( 2.*v3d(i,j,k+2)-13.*v3d(i,j,k+1)+47.*v3d(i,j,k)    &
                          +27.*v3d(i,j,k-1)-3.*v3d(i,j,k-2) )*onedsixty
        endif
      enddo
      enddo

      k = 3
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(-v3d(i,j,k-2)+5.*v3d(i,j,k-1)+2.*v3d(i,j,k  ))*onedsix
        else
          dum(i,j,k)=wbar*( 2.*v3d(i,j,k+2)-13.*v3d(i,j,k+1)+47.*v3d(i,j,k)    &
                          +27.*v3d(i,j,k-1)-3.*v3d(i,j,k-2) )*onedsixty
        endif
      enddo

      k = nk-1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*v3d(i,j,k-3)-13.*v3d(i,j,k-2)+47.*v3d(i,j,k-1)    &
                          +27.*v3d(i,j,k)-3.*v3d(i,j,k+1) )*onedsixty
        else
          dum(i,j,k)=wbar*(-v3d(i,j,k+1)+5.*v3d(i,j,k  )+2.*v3d(i,j,k-1))*onedsix
        endif
      enddo

      k = 2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if(wbar.ge.0.)then
          cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*v3d(i,j,k-1)+cc2*v3d(i,j,k))
        else
          dum(i,j,k)=wbar*(-v3d(i,j,k+1)+5.*v3d(i,j,k  )+2.*v3d(i,j,k-1))*onedsix
        endif
      enddo

      k = nk
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(-v3d(i,j,k-2)+5.*v3d(i,j,k-1)+2.*v3d(i,j,k  ))*onedsix
        else
          cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          dum(i,j,k)=wbar*(cc1*v3d(i,j,k-1)+cc2*v3d(i,j,k))
        endif
      enddo

    ELSEIF(vadvordrv.eq.6)THEN

      do k=4,nk-2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        dum(i,j,k)=wbar*( 37.0*(v3d(i,j,k  )+v3d(i,j,k-1)) &
                          -8.0*(v3d(i,j,k+1)+v3d(i,j,k-2)) &
                              +(v3d(i,j,k+2)+v3d(i,j,k-3)) )*onedsixty
      enddo
      enddo

      do k=3,(nk-1),(nk-4)
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        dum(i,j,k)=wbar*( 7.0*(v3d(i,j,k  )+v3d(i,j,k-1)) &
                             -(v3d(i,j,k+1)+v3d(i,j,k-2)) )*onedtwelve
      enddo
      enddo

      do k=2,nk,(nk-2)
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        dum(i,j,k)=wbar*(cc1*v3d(i,j,k-1)+cc2*v3d(i,j,k))
      enddo
      enddo

    ENDIF

!------

      IF(terrain_flag)THEN

        k=1
        do i=1,ni
          advz(i,j,k)=-dum(i,j,k+1)*rdsf(k)
          vten(i,j,k)=vten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )         &
                  *gzv(i,j)/(0.5*(rho0(i,j-1,k)+rho0(i,j,k)))
        enddo
        do k=2,nk-1
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdsf(k)
          vten(i,j,k)=vten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )         &
                  *gzv(i,j)/(0.5*(rho0(i,j-1,k)+rho0(i,j,k)))
        enddo
        enddo
        k=nk
        do i=1,ni
          advz(i,j,k)=+dum(i,j,k)*rdsf(k)
          vten(i,j,k)=vten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )         &
                  *gzv(i,j)/(0.5*(rho0(i,j-1,k)+rho0(i,j,k)))
        enddo

      ELSE

        !--------
        IF( axisymm.eq.0 )THEN
        ! Cartesian grid:
        k=1
        do i=1,ni
          advz(i,j,k)=-dum(i,j,k+1)*rdz*mh(1,1,k)
          vten(i,j,k)=vten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )*rr0(1,1,k)
        enddo
        do k=2,nk-1
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(1,1,k)
          vten(i,j,k)=vten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )*rr0(1,1,k)
        enddo
        enddo
        k=nk
        do i=1,ni
          advz(i,j,k)=+dum(i,j,k)*rdz*mh(1,1,k)
          vten(i,j,k)=vten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                     +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )*rr0(1,1,k)
        enddo
        !--------
        ELSEIF( axisymm.eq.1 )THEN
        ! axisymmetric grid:
        k=1
        do i=1,ni
          advz(i,j,k)=-dum(i,j,k+1)*rdz*mh(1,1,k)
          vten(i,j,k)=vten(i,j,k)+( advx(i,j,k)+advz(i,j,k)    &
                     +v3d(i,j,k)*divx(i,j,k) )*rr0(1,1,k)
        enddo
        do k=2,nk-1
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(1,1,k)
          vten(i,j,k)=vten(i,j,k)+( advx(i,j,k)+advz(i,j,k)    &
                     +v3d(i,j,k)*divx(i,j,k) )*rr0(1,1,k)
        enddo
        enddo
        k=nk
        do i=1,ni
          advz(i,j,k)=+dum(i,j,k)*rdz*mh(1,1,k)
          vten(i,j,k)=vten(i,j,k)+( advx(i,j,k)+advz(i,j,k)    &
                     +v3d(i,j,k)*divx(i,j,k) )*rr0(1,1,k)
        enddo
        ENDIF
        !--------

      ENDIF

    ENDDO  jloopv
!----------------------------------------------------------------

      if(timestats.ge.1) time_advv=time_advv+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advw(nrk,xh,rxh,arh1,arh2,uh,xf,vh,gz,rgz,mf,rho0,rr0,rf0,rrf0,dum,advx,advy,advz,divx, &
                       rru,rrv,rrw,w3d,wten,rds,c1,c2,rho,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer, intent(in) :: nrk
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh
      real, dimension(itb:ite,jtb:jte) :: gz,rgz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,w3d,wten
      real, intent(in), dimension(kb:ke+1) :: rds
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho
      real, intent(in) :: dt
 
      integer i,j,k,i1,i2,j1,j2
      real :: ubar,vbar,wbar,cc1,cc2
      logical :: doitw,doite,doits,doitn

      logical :: doweno
      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      double precision :: weps
      real :: coef

!----------------------------------------------------------------

      doweno = .false.
      IF( (advwenov.eq.1) .or. (advwenov.eq.2.and.nrk.eq.3) ) doweno = .true.
      weps = 100.0*epsilon

      IF( idiff.ge.1 .and. difforder.eq.6 )THEN
        coef = kdiff6/64.0/dt
      ENDIF

!-----------------

      i1 = 1
      i2 = ni+1

      doitw = .false.
      doite = .false.

      IF(wbc.eq.2 .and. ibw.eq.1) doitw = .true.
      IF(ebc.eq.2 .and. ibe.eq.1) doite = .true.

!-----------------

      j1 = 1
      j2 = nj+1

      doits = .false.
      doitn = .false.

      IF(sbc.eq.2 .and. ibs.eq.1) doits = .true.
      IF(nbc.eq.2 .and. ibn.eq.1) doitn = .true.

!----------------------------------------------------------------

    hadvsection:  IF(axisymm.eq.1)THEN
      call advwaxi(doweno,xh,rxh,arh1,arh2,uh,xf,vh,rho0,rr0,rf0,rrf0,dum,advx,rru,w3d,wten,c1,c2)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo
    ELSE

!-----------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,ubar,vbar,cc1,cc2,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4)
    DO k=2,nk

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=i1,i2
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
        if(ubar.ge.0.0)then
          s1=w3d(i-3,j,k)
          s2=w3d(i-2,j,k)
          s3=w3d(i-1,j,k)
          s4=w3d(i  ,j,k)
          s5=w3d(i+1,j,k)
        else
          s1=w3d(i+2,j,k)
          s2=w3d(i+1,j,k)
          s3=w3d(i  ,j,k)
          s4=w3d(i-1,j,k)
          s5=w3d(i-2,j,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=ubar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    elseif(hadvordrv.eq.5)then
      do j=1,nj
      do i=i1,i2
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*( 2.*w3d(i-3,j,k)-13.*w3d(i-2,j,k)+47.*w3d(i-1,j,k)    &
                          +27.*w3d(i,j,k)-3.*w3d(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*( 2.*w3d(i+2,j,k)-13.*w3d(i+1,j,k)+47.*w3d(i,j,k)    &
                          +27.*w3d(i-1,j,k)-3.*w3d(i-2,j,k) )*onedsixty
        endif
      enddo
      enddo
    elseif(hadvordrv.eq.6)then
      do j=1,nj
      do i=i1,i2
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
        dum(i,j,k)=ubar*( 37.0*(w3d(i  ,j,k)+w3d(i-1,j,k)) &
                          -8.0*(w3d(i+1,j,k)+w3d(i-2,j,k)) &
                              +(w3d(i+2,j,k)+w3d(i-3,j,k)) )*onedsixty
      enddo
      enddo
    endif

      if(doitw)then
      do j=1,nj
        i=1
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
        if(ubar.ge.0.0)then
          dum(i,j,k)=dum(i+1,j,k)
        endif
      enddo
      endif

      if(doite)then
      do j=1,nj
        i=ni+1
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
        if(ubar.le.0.0)then
          dum(i,j,k)=dum(i-1,j,k)
        endif
      enddo
      endif

      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo

      IF(doitw)THEN
        do j=1,nj
          i=1
          cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
          if(ubar.ge.0.0)then
            i=1
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*(                    &
                    c1(i,j,k)*(rru(i+1,j,k-1)-rru(i,j,k-1))         &
                   +c2(i,j,k)*(rru(i+1,j,k  )-rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
      ENDIF

      IF(doite)THEN
        do j=1,nj
          i=ni+1
          cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
          if(ubar.le.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*(                    &
                    c1(i,j,k)*(rru(i+1,j,k-1)-rru(i,j,k-1))         &
                   +c2(i,j,k)*(rru(i+1,j,k  )-rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
      ENDIF

    !-------------------------------------------------------
    ! 6th-order diffusion-w:
    IF( idiff.ge.1 .and. difforder.eq.6 )THEN
      do j=1,nj
      do i=1,ni+1
        cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        dum(i,j,k)=( 10.0*(w3d(i  ,j,k)-w3d(i-1,j,k))     &
                     -5.0*(w3d(i+1,j,k)-w3d(i-2,j,k))     &
                         +(w3d(i+2,j,k)-w3d(i-3,j,k)) )   &
              *0.5*( cc2*(rho(i-1,j,k  )+rho(i,j,k  ))    &
                    +cc1*(rho(i-1,j,k-1)+rho(i,j,k-1)) )
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj
        do i=1,ni+1
          if( dum(i,j,k)*(w3d(i,j,k)-w3d(i-1,j,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=advx(i,j,k)+coef*(dum(i+1,j,k)-dum(i,j,k))*rf0(i,j,k)/(0.5*(rho(i,j,k-1)+rho(i,j,k)))
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

! Advection in y-direction

    if(doweno)then
      do j=j1,j2
      do i=1,ni
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
        if(vbar.ge.0.0)then
          s1=w3d(i,j-3,k)
          s2=w3d(i,j-2,k)
          s3=w3d(i,j-1,k)
          s4=w3d(i,j  ,k)
          s5=w3d(i,j+1,k)
        else
          s1=w3d(i,j+2,k)
          s2=w3d(i,j+1,k)
          s3=w3d(i,j  ,k)
          s4=w3d(i,j-1,k)
          s5=w3d(i,j-2,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=vbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    elseif(hadvordrv.eq.5)then
      do j=j1,j2
      do i=1,ni
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
        if(vbar.ge.0.)then
          dum(i,j,k)=vbar*( 2.*w3d(i,j-3,k)-13.*w3d(i,j-2,k)+47.*w3d(i,j-1,k)    &
                          +27.*w3d(i,j,k)-3.*w3d(i,j+1,k) )*onedsixty
        else
          dum(i,j,k)=vbar*( 2.*w3d(i,j+2,k)-13.*w3d(i,j+1,k)+47.*w3d(i,j,k)    &
                          +27.*w3d(i,j-1,k)-3.*w3d(i,j-2,k) )*onedsixty
        endif
      enddo
      enddo
    elseif(hadvordrv.eq.6)then
      do j=j1,j2
      do i=1,ni
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
        dum(i,j,k)=vbar*( 37.0*(w3d(i,j  ,k)+w3d(i,j-1,k)) &
                          -8.0*(w3d(i,j+1,k)+w3d(i,j-2,k)) &
                              +(w3d(i,j+2,k)+w3d(i,j-3,k)) )*onedsixty
      enddo
      enddo
    endif

      if(doits)then
      do i=1,ni
        j=1
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
        if(vbar.ge.0.0)then
          dum(i,j,k)=dum(i,j+1,k)
        endif
      enddo
      endif

      if(doitn)then
      do i=1,ni
        j=nj+1
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
        if(vbar.le.0.0)then
          dum(i,j,k)=dum(i,j-1,k)
        endif
      enddo
      endif

      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo

      IF(doits)THEN
        do i=1,ni
          j=1
          cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
          if(vbar.ge.0.0)then
            j=1
            advy(i,j,k)=advy(i,j,k)-w3d(i,j,k)*(                     &
                           c1(i,j,k)*(rrv(i,j+1,k-1)-rrv(i,j,k-1))   &
                          +c2(i,j,k)*(rrv(i,j+1,k  )-rrv(i,j,k  )) )*rdy*vh(j)
          endif
        enddo
      ENDIF

      IF(doitn)THEN
        do i=1,ni
          j=nj+1
          cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
          cc1 = 1.0-cc2
          vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
          if(vbar.le.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-w3d(i,j,k)*(                     &
                           c1(i,j,k)*(rrv(i,j+1,k-1)-rrv(i,j,k-1))   &
                          +c2(i,j,k)*(rrv(i,j+1,k  )-rrv(i,j,k  )) )*rdy*vh(j)
          endif
        enddo
      ENDIF

    !-------------------------------------------------------
    ! 6th-order diffusion-w:
    IF( idiff.ge.1 .and. difforder.eq.6 )THEN
      do j=1,nj+1
      do i=1,ni
        cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
        cc1 = 1.0-cc2
        dum(i,j,k)=( 10.0*(w3d(i,j  ,k)-w3d(i,j-1,k))     &
                     -5.0*(w3d(i,j+1,k)-w3d(i,j-2,k))     &
                         +(w3d(i,j+2,k)-w3d(i,j-3,k)) )   &
              *0.5*( cc2*(rho(i,j-1,k  )+rho(i,j,k  ))    &
                    +cc1*(rho(i,j-1,k-1)+rho(i,j,k-1)) )
      enddo
      enddo
      if(mdiff.eq.1)then
        do j=1,nj+1
        do i=1,ni
          if( dum(i,j,k)*(w3d(i,j,k)-w3d(i,j-1,k)).le.0.0 )then
            dum(i,j,k)=0.0
          endif
        enddo
        enddo
      endif
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=advy(i,j,k)+coef*(dum(i,j+1,k)-dum(i,j,k))*rf0(i,j,k)/(0.5*(rho(i,j,k-1)+rho(i,j,k)))
      enddo
      enddo
    ENDIF
    !-------------------------------------------------------

    ENDDO

    ENDIF  hadvsection

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k,wbar,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
  jloopw:  DO j=1,nj

    IF(doweno)THEN

      do k=2,nk-1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if(wbar.ge.0.0)then
          s1=w3d(i,j,k-2)
          s2=w3d(i,j,k-1)
          s3=w3d(i,j,k  )
          s4=w3d(i,j,k+1)
          s5=w3d(i,j,k+2)
        else
          s1=w3d(i,j,k+3)
          s2=w3d(i,j,k+2)
          s3=w3d(i,j,k+1)
          s4=w3d(i,j,k  )
          s5=w3d(i,j,k-1)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=wbar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo

      ! flux at k=2 if w > 0
      k = 2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if( wbar.gt.0.0 )then
          dd = w3d(i,j,k)-w3d(i,j,k-1)
          rr = (w3d(i,j,k+1)-w3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( w3d(i,j,k) + 0.5*phi*(w3d(i,j,k)-w3d(i,j,k-1)) )
        endif
      enddo

      ! flux at k=(nk-1) if w < 0
      k = nk-1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if( wbar.lt.0.0 )then
          dd = w3d(i,j,k+1)-w3d(i,j,k+2)
          rr = (w3d(i,j,k)-w3d(i,j,k+1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( w3d(i,j,k+1) + 0.5*phi*(w3d(i,j,k+1)-w3d(i,j,k+2)) )
        endif
      enddo

      k = 1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if( wbar.ge.0.0 )then
          dum(i,j,k)=wbar*0.5*(w3d(i,j,k)+w3d(i,j,k+1))
        else
          dd = w3d(i,j,k+1)-w3d(i,j,k+2)
          rr = (w3d(i,j,k)-w3d(i,j,k+1))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( w3d(i,j,k+1) + 0.5*phi*(w3d(i,j,k+1)-w3d(i,j,k+2)) )
        endif
      enddo

      k = nk
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if( wbar.gt.0.0 )then
          dd = w3d(i,j,k)-w3d(i,j,k-1)
          rr = (w3d(i,j,k+1)-w3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = wbar*( w3d(i,j,k) + 0.5*phi*(w3d(i,j,k)-w3d(i,j,k-1)) )
        else
          dum(i,j,k)=wbar*0.5*(w3d(i,j,k)+w3d(i,j,k+1))
        endif
      enddo

    ELSEIF(vadvordrv.eq.5)THEN

      do k=3,nk-2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*w3d(i,j,k-2)-13.*w3d(i,j,k-1)+47.*w3d(i,j,k)    &
                          +27.*w3d(i,j,k+1)-3.*w3d(i,j,k+2) )*onedsixty
        else
          dum(i,j,k)=wbar*( 2.*w3d(i,j,k+3)-13.*w3d(i,j,k+2)+47.*w3d(i,j,k+1)  &
                          +27.*w3d(i,j,k)-3.*w3d(i,j,k-1) )*onedsixty
        endif
      enddo
      enddo

      k = 2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(-w3d(i,j,k-1)+5.*w3d(i,j,k  )+2.*w3d(i,j,k+1))*onedsix
        else
          dum(i,j,k)=wbar*( 2.*w3d(i,j,k+3)-13.*w3d(i,j,k+2)+47.*w3d(i,j,k+1)  &
                          +27.*w3d(i,j,k)-3.*w3d(i,j,k-1) )*onedsixty
        endif
      enddo

      k = nk-1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*( 2.*w3d(i,j,k-2)-13.*w3d(i,j,k-1)+47.*w3d(i,j,k)    &
                          +27.*w3d(i,j,k+1)-3.*w3d(i,j,k+2) )*onedsixty
        else
          dum(i,j,k)=wbar*(-w3d(i,j,k+2)+5.*w3d(i,j,k+1)+2.*w3d(i,j,k  ))*onedsix
        endif
      enddo

      k = 1
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*0.5*(w3d(i,j,k)+w3d(i,j,k+1))
        else
          dum(i,j,k)=wbar*(-w3d(i,j,k+2)+5.*w3d(i,j,k+1)+2.*w3d(i,j,k  ))*onedsix
        endif
      enddo

      k = nk
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        if(wbar.ge.0.)then
          dum(i,j,k)=wbar*(-w3d(i,j,k-1)+5.*w3d(i,j,k  )+2.*w3d(i,j,k+1))*onedsix
        else
          dum(i,j,k)=wbar*0.5*(w3d(i,j,k)+w3d(i,j,k+1))
        endif
      enddo

    ELSEIF(vadvordrv.eq.6)THEN

      do k=3,nk-2
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        dum(i,j,k)=wbar*( 37.0*(w3d(i,j,k+1)+w3d(i,j,k  )) &
                          -8.0*(w3d(i,j,k+2)+w3d(i,j,k-1)) &
                              +(w3d(i,j,k+3)+w3d(i,j,k-2)) )*onedsixty
      enddo
      enddo

      do k=2,(nk-1),(nk-3)
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        dum(i,j,k)=wbar*( 7.0*(w3d(i,j,k+1)+w3d(i,j,k  )) &
                             -(w3d(i,j,k+2)+w3d(i,j,k-1)) )*onedtwelve
      enddo
      enddo

      do k=1,nk,(nk-1)
      do i=1,ni
        wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
        dum(i,j,k)=wbar*0.5*(w3d(i,j,k)+w3d(i,j,k+1))
      enddo
      enddo

    ENDIF

!------

      IF(terrain_flag)THEN

      do k=2,nk
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k)-dum(i,j,k-1))*rds(k)
        wten(i,j,k)=wten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                   +w3d(i,j,k)*(c2(i,j,k)*divx(i,j,k)+c1(i,j,k)*divx(i,j,k-1)) )*rrf0(i,j,k)*gz(i,j)
      enddo
      enddo

      ELSE

      do k=2,nk
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k)-dum(i,j,k-1))*rdz*mf(1,1,k)
        wten(i,j,k)=wten(i,j,k)+( (advx(i,j,k)+advy(i,j,k))+advz(i,j,k)    &
                   +w3d(i,j,k)*(c2(1,1,k)*divx(i,j,k)+c1(1,1,k)*divx(i,j,k-1)) )*rrf0(1,1,k)
      enddo
      enddo

      ENDIF

    ENDDO  jloopw

!----------------------------------------------------------------

      if(timestats.ge.1) time_advw=time_advw+mytime()
 
      return
      end


advaxi.F        1587424407  1602  20    100644  35546     `


      subroutine advsaxi(doweno,bflag,bsq,xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,rmh,gz,rgz, &
                  rho0,rr0,rf0,rrf0,advx,dum,mass,rru,s0,s,sten,pdef,dt,weps, &
                  flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      logical, intent(in) :: doweno
      integer bflag
      double precision :: bsq
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh,ruh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh,rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,rho0,rr0,rf0,rrf0
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz
      real, dimension(ib:ie,jb:je,kb:ke) :: advx,dum,mass
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je,kb:ke) :: s0,s,sten
      integer pdef
      real, intent(in) :: dt
      double precision, intent(in) :: weps
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
 
      integer i,j,k,i1,i2,j1,j2
      real :: tem0
      double precision, dimension(nk) :: budx

      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      double precision :: bmax
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      logical :: doit

      integer, dimension(4) :: reqsx

!----------------------------------------------------------------

      i1 = 1
      i2 = ni+1

!-----------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,bmax,dd,rr,phi,doit)
    DO k=1,nk   ! start of k-loop

      budx(k) = 0.0d0

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=3,i2
        if(rru(i,j,k).ge.0.0)then
          s1=s(i-3,j,k)
          s2=s(i-2,j,k)
          s3=s(i-1,j,k)
          s4=s(i  ,j,k)
          s5=s(i+1,j,k)
        else
          s1=s(i+2,j,k)
          s2=s(i+1,j,k)
          s3=s(i  ,j,k)
          s4=s(i-1,j,k)
          s5=s(i-2,j,k)
        endif

      doit = .true.
      IF( pdef.eq.1 )THEN
        bmax = max(s1,s2,s3,s4,s5)
        if( bmax.lt.Min(1.0d-20,weps) ) doit = .false.
      ENDIF
      IF( i.eq.3 .and. rru(i,j,k).gt.0.0 ) doit = .false.

      IF(doit)THEN

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=rru(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      ELSE
        dum(i,j,k)=0.0
      ENDIF
      enddo
      enddo
      do j=1,nj
        ! flux at i=3 if u > 0
        i = 3
        if(rru(i,j,k).ge.0.0)then
          dd = s(i-1,j,k)-s(i-2,j,k)
          rr = (s(i,j,k)-s(i-1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( s(i-1,j,k) + 0.5*phi*(s(i-1,j,k)-s(i-2,j,k)) )
        endif
        i = 2
        if(rru(i,j,k).ge.0.0)then
!!!          dum(i,j,k)=rru(i,j,k)*0.5*(s(i-1,j,k)+s(i,j,k))
          ! cm1r18:
          dum(i,j,k)=rru(i,j,k)*s(i-1,j,k)
        else
          dd = s(i,j,k)-s(i+1,j,k)
          rr = (s(i-1,j,k)-s(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( s(i,j,k) + 0.5*phi*(s(i,j,k)-s(i+1,j,k)) )
        endif
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        if(rru(i,j,k).le.0.0)then
          dd = s(i,j,k)-s(i+1,j,k)
          rr = (s(i-1,j,k)-s(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( s(i,j,k) + 0.5*phi*(s(i,j,k)-s(i+1,j,k)) )
        endif
        i = ni
        if(rru(i,j,k).ge.0.0)then
          dd = s(i-1,j,k)-s(i-2,j,k)
          rr = (s(i,j,k)-s(i-1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( s(i-1,j,k) + 0.5*phi*(s(i-1,j,k)-s(i-2,j,k)) )
        else
          dum(i,j,k)=rru(i,j,k)*0.5*(s(i-1,j,k)+s(i,j,k))
        endif
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    elseif(hadvordrs.eq.5)then
      do j=1,nj
      do i=4,i2
        if(rru(i,j,k).ge.0.)then
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i-3,j,k)-13.*s(i-2,j,k)   &
                +47.*s(i-1,j,k)+27.*s(i,j,k)-3.*s(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i+2,j,k)-13.*s(i+1,j,k)   &
                +47.*s(i,j,k)+27.*s(i-1,j,k)-3.*s(i-2,j,k) )*onedsixty
        endif
      enddo
      enddo
      do j=1,nj
        i = 3
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*(-s(i-2,j,k)+5.*s(i-1,j,k)+2.*s(i,j,k))*onedsix
        else
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i+2,j,k)-13.*s(i+1,j,k)   &
                +47.*s(i,j,k)+27.*s(i-1,j,k)-3.*s(i-2,j,k) )*onedsixty
        endif
        i = 2
        if(rru(i,j,k).ge.0.0)then
!!!          dum(i,j,k)=rru(i,j,k)*0.5*(s(i-1,j,k)+s(i,j,k))
          ! cm1r18:
          dum(i,j,k)=rru(i,j,k)*s(i-1,j,k)
        else
          dum(i,j,k)=rru(i,j,k)*(-s(i+1,j,k)+5.*s(i,j,k)+2.*s(i-1,j,k))*onedsix
        endif
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i-3,j,k)-13.*s(i-2,j,k)   &
                +47.*s(i-1,j,k)+27.*s(i,j,k)-3.*s(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=rru(i,j,k)*(-s(i+1,j,k)+5.*s(i,j,k)+2.*s(i-1,j,k))*onedsix
        endif
        i = ni
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*(-s(i-2,j,k)+5.*s(i-1,j,k)+2.*s(i,j,k))*onedsix
        else
          dum(i,j,k)=rru(i,j,k)*0.5*(s(i-1,j,k)+s(i,j,k))
        endif
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    elseif(hadvordrs.eq.6)then
      do j=1,nj
      do i=4,i2
        dum(i,j,k)=rru(i,j,k)*( 37.0*(s(i  ,j,k)+s(i-1,j,k))     &
                                -8.0*(s(i+1,j,k)+s(i-2,j,k))     &
                                    +(s(i+2,j,k)+s(i-3,j,k)) )*onedsixty
      enddo
      enddo
      do j=1,nj
        i = 3
        dum(i,j,k)=rru(i,j,k)*( 7.0*(s(i  ,j,k)+s(i-1,j,k))          &
                                   -(s(i+1,j,k)+s(i-2,j,k)) )*onedtwelve
        i = 2
        dum(i,j,k)=rru(i,j,k)*0.5*(s(i-1,j,k)+s(i,j,k))
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        dum(i,j,k)=rru(i,j,k)*( 7.0*(s(i  ,j,k)+s(i-1,j,k))          &
                                   -(s(i+1,j,k)+s(i-2,j,k)) )*onedtwelve
        i = ni
        dum(i,j,k)=rru(i,j,k)*0.5*(s(i-1,j,k)+s(i,j,k))
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    endif

      IF(ebc.eq.2 .and. ibe.eq.1)THEN
      do j=1,nj
        i=ni+1
        if(rru(i,j,k).le.0.0)then
          dum(i,j,k)=dum(i-1,j,k)*arh1(i-1)/arh2(i-1)
        endif
        budx(k)=budx(k)-dum(ni+1,j,k)*rvh(j)*rmh(ni+1,j,k)
      enddo
      ENDIF

      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(arh2(i)*dum(i+1,j,k)-arh1(i)*dum(i,j,k))*rdx*uh(i)
      enddo
      enddo

      IF(ebc.eq.2 .and. ibe.eq.1)THEN
        do j=1,nj
          if(rru(ni+1,j,k).le.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(arh2(i)*rru(i+1,j,k)-arh1(i)*rru(i,j,k))*rdx*uh(i)
          endif
        enddo
      ENDIF

    ENDDO   ! end of k-loop

!----------------------------------------------------------------
!  Misc for x-direction

      IF(stat_qsrc.eq.1.and.(wbc.eq.2.or.ebc.eq.2).and.bflag.eq.1)THEN
        tem0=dt*dy*dz
        do k=1,nk
          bsq=bsq+budx(k)*tem0
        enddo
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefx1(xh,arh1,arh2,uh,rho0,gz,rgz,rru,advx,dum,mass,s0,s,dt,flag,sw31,sw32,se31,se32,reqsx)
        call pdefx2(xh,arh1,arh2,uh,rho0,gz,rgz,rru,advx,dum,mass,s0,s,dt,flag,sw31,sw32,se31,se32,reqsx)
      ENDIF

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advs=time_advs+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advuaxi(doweno,arh1,arh2,xf,rxf,arf1,arf2,uf,vh,rho0,rr0,rf0,rrf0,dum,advx,rru,u3d,uten)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      logical, intent(in) :: doweno
      real, dimension(ib:ie) :: arh1,arh2
      real, dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru,u3d,uten
 
      integer i,j,k,i1,i2,j1,j2,id1,id2
      real :: ubar

      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      double precision :: weps

!------------------------------------------------------------

      weps = 100.0*epsilon

      if(ibw.eq.1)then
        i1=2
      else
        i1=1
      endif
 
      if(ibe.eq.1)then
        i2=ni+1-1
      else
        i2=ni+1
      endif
 
      id1 = i1-1
      id2 = i2

      i1 = max(2,i1)
      id1 = max(1,id1)

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,ubar,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
    DO k=1,nk

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=2,id2
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
          s1=u3d(i-2,j,k)
          s2=u3d(i-1,j,k)
          s3=u3d(i  ,j,k)
          s4=u3d(i+1,j,k)
          s5=u3d(i+2,j,k)
        else
          s1=u3d(i+3,j,k)
          s2=u3d(i+2,j,k)
          s3=u3d(i+1,j,k)
          s4=u3d(i  ,j,k)
          s5=u3d(i-1,j,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=ubar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
      do j=1,nj
        i = 2
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
          dd = u3d(i,j,k)-u3d(i-1,j,k)
          rr = (u3d(i+1,j,k)-u3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( u3d(i,j,k) + 0.5*phi*(u3d(i,j,k)-u3d(i-1,j,k)) )
        endif
        i = 1
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
!!!          dum(i,j,k)=ubar*0.5*(arh1(i)*u3d(i,j,k)+arh2(i)*u3d(i+1,j,k))
          ! cm1r18:
          dum(i,j,k)=ubar*0.5*(u3d(i,j,k)+u3d(i+1,j,k))
        else
          dd = u3d(i+1,j,k)-u3d(i+2,j,k)
          rr = (u3d(i,j,k)-u3d(i+1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( u3d(i+1,j,k) + 0.5*phi*(u3d(i+1,j,k)-u3d(i+2,j,k)) )
        endif
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.le.0.0)then
          dd = u3d(i+1,j,k)-u3d(i+2,j,k)
          rr = (u3d(i,j,k)-u3d(i+1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( u3d(i+1,j,k) + 0.5*phi*(u3d(i+1,j,k)-u3d(i+2,j,k)) )
        endif
        i = ni
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
          dd = u3d(i,j,k)-u3d(i-1,j,k)
          rr = (u3d(i+1,j,k)-u3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( u3d(i,j,k) + 0.5*phi*(u3d(i,j,k)-u3d(i-1,j,k)) )
        else
          dum(i,j,k)=ubar*0.5*(arh1(i)*u3d(i,j,k)+arh2(i)*u3d(i+1,j,k))
        endif
      enddo
      ENDIF
    elseif(hadvordrv.eq.5)then
      do j=1,nj
      do i=3,id2
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*( 2.*u3d(i-2,j,k)-13.*u3d(i-1,j,k)+47.*u3d(i,j,k)   &
                          +27.*u3d(i+1,j,k)-3.*u3d(i+2,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*( 2.*u3d(i+3,j,k)-13.*u3d(i+2,j,k)+47.*u3d(i+1,j,k)   &
                          +27.*u3d(i,j,k)-3.*u3d(i-1,j,k) )*onedsixty
        endif
      enddo
      enddo
      do j=1,nj
        i = 2
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
          dum(i,j,k)=ubar*(-u3d(i-1,j,k)+5.*u3d(i  ,j,k)+2.*u3d(i+1,j,k))*onedsix
        else
          dum(i,j,k)=ubar*( 2.*u3d(i+3,j,k)-13.*u3d(i+2,j,k)+47.*u3d(i+1,j,k)   &
                          +27.*u3d(i,j,k)-3.*u3d(i-1,j,k) )*onedsixty
        endif
        i = 1
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
!!!          dum(i,j,k)=ubar*0.5*(arh1(i)*u3d(i,j,k)+arh2(i)*u3d(i+1,j,k))
          ! cm1r18:
          dum(i,j,k)=ubar*0.5*(u3d(i,j,k)+u3d(i+1,j,k))
        else
          dum(i,j,k)=ubar*(-u3d(i+2,j,k)+5.*u3d(i+1,j,k)+2.*u3d(i  ,j,k))*onedsix
        endif
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
          dum(i,j,k)=ubar*( 2.*u3d(i-2,j,k)-13.*u3d(i-1,j,k)+47.*u3d(i,j,k)   &
                          +27.*u3d(i+1,j,k)-3.*u3d(i+2,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*(-u3d(i+2,j,k)+5.*u3d(i+1,j,k)+2.*u3d(i  ,j,k))*onedsix
        endif
        i = ni
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        if(ubar.ge.0.0)then
          dum(i,j,k)=ubar*(-u3d(i-1,j,k)+5.*u3d(i  ,j,k)+2.*u3d(i+1,j,k))*onedsix
        else
          dum(i,j,k)=ubar*0.5*(arh1(i)*u3d(i,j,k)+arh2(i)*u3d(i+1,j,k))
        endif
      enddo
      ENDIF
    elseif(hadvordrv.eq.6)then
      do j=1,nj
      do i=3,id2
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        dum(i,j,k)=ubar*( 37.0*(u3d(i+1,j,k)+u3d(i  ,j,k)) &
                          -8.0*(u3d(i+2,j,k)+u3d(i-1,j,k)) &
                              +(u3d(i+3,j,k)+u3d(i-2,j,k)) )*onedsixty
      enddo
      enddo
      do j=1,nj
        i = 2
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        dum(i,j,k) = ubar*(  7.0*(u3d(i+1,j,k)+u3d(i  ,j,k)) &
                            -1.0*(u3d(i+2,j,k)+u3d(i-1,j,k)) )*onedtwelve
        i = 1
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        dum(i,j,k) = ubar*0.5*(u3d(i+1,j,k)+u3d(i,j,k))
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        dum(i,j,k) = ubar*(  7.0*(u3d(i+1,j,k)+u3d(i  ,j,k)) &
                            -1.0*(u3d(i+2,j,k)+u3d(i-1,j,k)) )*onedtwelve
        i = ni
        ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
        dum(i,j,k) = ubar*0.5*(u3d(i+1,j,k)+u3d(i,j,k))
      enddo
      ENDIF
    endif

      do j=1,nj
      advx(1,j,k)=0.0
      do i=2,i2
        advx(i,j,k)=-(arf2(i)*dum(i,j,k)-arf1(i)*dum(i-1,j,k))*rdx*uf(i)
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
        advx(ni+1,j,k)=0.0
      ENDIF
      enddo

    ENDDO

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advu=time_advu+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advvaxi(doweno,xh,rxh,arh1,arh2,uh,xf,vf,rho0,rr0,rf0,rrf0,dum,advx,v3d,rru,vten)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      logical, intent(in) :: doweno
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: v3d
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: vten
 
      integer i,j,k,i1,i2

      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      double precision :: weps

      !----------------------------------------------------------!
      !  cm1r18:   NOTE:  v3d is actually M  (angular momentum)  !
      !----------------------------------------------------------!
 
!------------------------------------------------------------

      weps = 100.0*epsilon

!-----------------

      i1 = 1
      i2 = ni+1

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
    DO k=1,nk

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=3,i2
        if(rru(i,j,k).ge.0.0)then
          s1=v3d(i-3,j,k)
          s2=v3d(i-2,j,k)
          s3=v3d(i-1,j,k)
          s4=v3d(i  ,j,k)
          s5=v3d(i+1,j,k)
        else
          s1=v3d(i+2,j,k)
          s2=v3d(i+1,j,k)
          s3=v3d(i  ,j,k)
          s4=v3d(i-1,j,k)
          s5=v3d(i-2,j,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=rru(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
      do j=1,nj
        i = 3
        if(rru(i,j,k).ge.0.0)then
          dd = v3d(i-1,j,k)-v3d(i-2,j,k)
          rr = (v3d(i,j,k)-v3d(i-1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( v3d(i-1,j,k) + 0.5*phi*(v3d(i-1,j,k)-v3d(i-2,j,k)) )
        endif
        i = 2
        if(rru(i,j,k).ge.0.0)then
!!!          dum(i,j,k)=rru(i,j,k)*0.5*(v3d(i-1,j,k)+v3d(i,j,k))
          ! cm1r18:
          dum(i,j,k)=rru(i,j,k)*v3d(i-1,j,k)
        else
          dd = v3d(i,j,k)-v3d(i+1,j,k)
          rr = (v3d(i-1,j,k)-v3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( v3d(i,j,k) + 0.5*phi*(v3d(i,j,k)-v3d(i+1,j,k)) )
        endif
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        if(rru(i,j,k).le.0.0)then
          dd = v3d(i,j,k)-v3d(i+1,j,k)
          rr = (v3d(i-1,j,k)-v3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( v3d(i,j,k) + 0.5*phi*(v3d(i,j,k)-v3d(i+1,j,k)) )
        endif
        i = ni
        if(rru(i,j,k).ge.0.0)then
          dd = v3d(i-1,j,k)-v3d(i-2,j,k)
          rr = (v3d(i,j,k)-v3d(i-1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = rru(i,j,k)*( v3d(i-1,j,k) + 0.5*phi*(v3d(i-1,j,k)-v3d(i-2,j,k)) )
        else
          dum(i,j,k)=rru(i,j,k)*0.5*(v3d(i-1,j,k)+v3d(i,j,k))
        endif
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    elseif(hadvordrv.eq.5)then
      do j=1,nj
      do i=4,i2
        if(rru(i,j,k).ge.0.)then
          dum(i,j,k)=rru(i,j,k)*( 2.*v3d(i-3,j,k)-13.*v3d(i-2,j,k)+47.*v3d(i-1,j,k)    &
                                +27.*v3d(i,j,k)-3.*v3d(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=rru(i,j,k)*( 2.*v3d(i+2,j,k)-13.*v3d(i+1,j,k)+47.*v3d(i,j,k)    &
                                +27.*v3d(i-1,j,k)-3.*v3d(i-2,j,k) )*onedsixty
        endif
      enddo
      enddo
      do j=1,nj
        i = 3
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*(-v3d(i-2,j,k)+5.*v3d(i-1,j,k)+2.*v3d(i,j,k))*onedsix
        else
          dum(i,j,k)=rru(i,j,k)*( 2.*v3d(i+2,j,k)-13.*v3d(i+1,j,k)+47.*v3d(i,j,k)    &
                                +27.*v3d(i-1,j,k)-3.*v3d(i-2,j,k) )*onedsixty
        endif
        i = 2
        if(rru(i,j,k).ge.0.)then
!!!          dum(i,j,k)=rru(i,j,k)*0.5*(v3d(i-1,j,k)+v3d(i,j,k))
          ! cm1r18:
          dum(i,j,k)=rru(i,j,k)*v3d(i-1,j,k)
        else
          dum(i,j,k)=rru(i,j,k)*(-v3d(i+1,j,k)+5.*v3d(i,j,k)+2.*v3d(i-1,j,k))*onedsix
        endif
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        if(rru(i,j,k).ge.0.)then
          dum(i,j,k)=rru(i,j,k)*( 2.*v3d(i-3,j,k)-13.*v3d(i-2,j,k)+47.*v3d(i-1,j,k)    &
                                +27.*v3d(i,j,k)-3.*v3d(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=rru(i,j,k)*(-v3d(i+1,j,k)+5.*v3d(i,j,k)+2.*v3d(i-1,j,k))*onedsix
        endif
        i = ni
        if(rru(i,j,k).ge.0.)then
          dum(i,j,k)=rru(i,j,k)*(-v3d(i-2,j,k)+5.*v3d(i-1,j,k)+2.*v3d(i,j,k))*onedsix
        else
          dum(i,j,k)=rru(i,j,k)*0.5*(v3d(i-1,j,k)+v3d(i,j,k))
        endif
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    elseif(hadvordrv.eq.6)then
      do j=1,nj
      do i=4,i2
        dum(i,j,k)=rru(i,j,k)*( 37.0*(v3d(i  ,j,k)+v3d(i-1,j,k)) &
                                -8.0*(v3d(i+1,j,k)+v3d(i-2,j,k)) &
                                    +(v3d(i+2,j,k)+v3d(i-3,j,k)) )*onedsixty
      enddo
      enddo
      do j=1,nj
        i = 3
        dum(i,j,k)=rru(i,j,k)*( 7.0*(v3d(i  ,j,k)+v3d(i-1,j,k))          &
                                   -(v3d(i+1,j,k)+v3d(i-2,j,k)) )*onedtwelve
        i = 2
        dum(i,j,k)=rru(i,j,k)*0.5*(v3d(i-1,j,k)+v3d(i,j,k))
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        dum(i,j,k)=rru(i,j,k)*( 7.0*(v3d(i  ,j,k)+v3d(i-1,j,k))          &
                                   -(v3d(i+1,j,k)+v3d(i-2,j,k)) )*onedtwelve
        i = ni
        dum(i,j,k)=rru(i,j,k)*0.5*(v3d(i-1,j,k)+v3d(i,j,k))
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    endif

      IF(ebc.eq.2 .and. ibe.eq.1)THEN
      do j=1,nj
        i=ni+1
        if(rru(i,j,k).le.0.0)then
          i = ni
          dum(ni+1,j,k)=arh1(i)*arh1(i)*dum(i,j,k)/(arh2(i)*arh2(i))
        endif
      enddo
      ENDIF

      do j=1,nj
      do i=1,ni
        ! cm1r17: include centrifugal accel term here
!!!        advx(i,j,k)=-(arh2(i)*arh2(i)*dum(i+1,j,k)-arh1(i)*arh1(i)*dum(i,j,k))*rdx*uh(i)
        ! cm1r18: include centrifugal accel term + Coriolis term here
        advx(i,j,k) = -(arh2(i)*dum(i+1,j,k)-arh1(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)  &
               +0.5*fcor*(xf(i+1)*rru(i+1,j,k)-xf(i)*rru(i,j,k))*rdx*uh(i)
      enddo
      enddo

      IF(ebc.eq.2 .and. ibe.eq.1)THEN
        do j=1,nj
          if(rru(ni+1,j,k).le.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*(arh2(i)*rru(i+1,j,k)-arh1(i)*rru(i,j,k))*rdx*uh(i)
          endif
        enddo
      ENDIF

    ENDDO

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advv=time_advv+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advwaxi(doweno,xh,rxh,arh1,arh2,uh,xf,vh,rho0,rr0,rf0,rrf0,dum,advx,rru,w3d,wten,c1,c2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      logical, intent(in) :: doweno
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w3d,wten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
 
      integer i,j,k,i1,i2,j1,j2
      real :: ubar

      real :: dd,rr,phi
      real :: s1,s2,s3,s4,s5
      real :: f1,f2,f3
      real :: b1,b2,b3
      real :: w1,w2,w3
      double precision :: a1,a2,a3,a4
      double precision :: weps

!----------------------------------------------------------------

      weps = 100.0*epsilon

      i1 = 1
      i2 = ni+1

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k,ubar,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4,dd,rr,phi)
    DO k=2,nk

! Advection in x-direction

    if(doweno)then
      do j=1,nj
      do i=3,i2
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.0)then
          s1=w3d(i-3,j,k)
          s2=w3d(i-2,j,k)
          s3=w3d(i-1,j,k)
          s4=w3d(i  ,j,k)
          s5=w3d(i+1,j,k)
        else
          s1=w3d(i+2,j,k)
          s2=w3d(i+1,j,k)
          s3=w3d(i  ,j,k)
          s4=w3d(i-1,j,k)
          s5=w3d(i-2,j,k)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum(i,j,k)=ubar*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
      do j=1,nj
        i = 3
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.0)then
          dd = w3d(i-1,j,k)-w3d(i-2,j,k)
          rr = (w3d(i,j,k)-w3d(i-1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( w3d(i-1,j,k) + 0.5*phi*(w3d(i-1,j,k)-w3d(i-2,j,k)) )
        endif
        i = 2
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.0)then
!!!          dum(i,j,k)=ubar*0.5*(w3d(i-1,j,k)+w3d(i,j,k))
          ! cm1r18:
          dum(i,j,k)=ubar*w3d(i-1,j,k)
        else
          dd = w3d(i,j,k)-w3d(i+1,j,k)
          rr = (w3d(i-1,j,k)-w3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( w3d(i,j,k) + 0.5*phi*(w3d(i,j,k)-w3d(i+1,j,k)) )
        endif
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.le.0.0)then
          dd = w3d(i,j,k)-w3d(i+1,j,k)
          rr = (w3d(i-1,j,k)-w3d(i,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( w3d(i,j,k) + 0.5*phi*(w3d(i,j,k)-w3d(i+1,j,k)) )
        endif
        i = ni
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.0)then
          dd = w3d(i-1,j,k)-w3d(i-2,j,k)
          rr = (w3d(i,j,k)-w3d(i-1,j,k))/(sign(sngl(weps),dd)+dd)
!!!          phi = max(0.0,min(2.0*rr,min( onedthree+twodthree*rr , 2.0 ) ) )
          phi = min( 2.0*abs(rr) , 1.0 )
          dum(i,j,k) = ubar*( w3d(i-1,j,k) + 0.5*phi*(w3d(i-1,j,k)-w3d(i-2,j,k)) )
        else
          dum(i,j,k)=ubar*0.5*(w3d(i-1,j,k)+w3d(i,j,k))
        endif
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    elseif(hadvordrv.eq.5)then
      do j=1,nj
      do i=4,i2
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*                                              &
                 ( 2.*w3d(i-3,j,k)-13.*w3d(i-2,j,k)+47.*w3d(i-1,j,k)    &
                  +27.*w3d(i,j,k)-3.*w3d(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*                                            &
                 ( 2.*w3d(i+2,j,k)-13.*w3d(i+1,j,k)+47.*w3d(i,j,k)    &
                  +27.*w3d(i-1,j,k)-3.*w3d(i-2,j,k) )*onedsixty
        endif
      enddo
      enddo
      do j=1,nj
        i = 3
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.0)then
          dum(i,j,k)=ubar*(-w3d(i-2,j,k)+5.*w3d(i-1,j,k)+2.*w3d(i  ,j,k))*onedsix
        else
          dum(i,j,k)=ubar*                                            &
                 ( 2.*w3d(i+2,j,k)-13.*w3d(i+1,j,k)+47.*w3d(i,j,k)    &
                  +27.*w3d(i-1,j,k)-3.*w3d(i-2,j,k) )*onedsixty
        endif
        i = 2
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.)then
!!!          dum(i,j,k)=ubar*0.5*(w3d(i-1,j,k)+w3d(i,j,k))
          ! cm1r18:
          dum(i,j,k)=ubar*w3d(i-1,j,k)
        else
          dum(i,j,k)=ubar*(-w3d(i+1,j,k)+5.*w3d(i  ,j,k)+2.*w3d(i-1,j,k))*onedsix
        endif
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*                                              &
                 ( 2.*w3d(i-3,j,k)-13.*w3d(i-2,j,k)+47.*w3d(i-1,j,k)    &
                  +27.*w3d(i,j,k)-3.*w3d(i+1,j,k) )*onedsixty
        else
          dum(i,j,k)=ubar*(-w3d(i+1,j,k)+5.*w3d(i  ,j,k)+2.*w3d(i-1,j,k))*onedsix
        endif
        i = ni
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.ge.0.)then
          dum(i,j,k)=ubar*(-w3d(i-2,j,k)+5.*w3d(i-1,j,k)+2.*w3d(i  ,j,k))*onedsix
        else
          dum(i,j,k)=ubar*0.5*(w3d(i-1,j,k)+w3d(i,j,k))
        endif
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    elseif(hadvordrv.eq.6)then
      do j=1,nj
      do i=4,i2
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        dum(i,j,k)=ubar*                                  &
                   ( 37.0*(w3d(i  ,j,k)+w3d(i-1,j,k))     &
                     -8.0*(w3d(i+1,j,k)+w3d(i-2,j,k))     &
                         +(w3d(i+2,j,k)+w3d(i-3,j,k)) )*onedsixty
      enddo
      enddo
      do j=1,nj
        i = 3
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        dum(i,j,k)=ubar*( 7.0*(w3d(i  ,j,k)+w3d(i-1,j,k))          &
                             -(w3d(i+1,j,k)+w3d(i-2,j,k)) )*onedtwelve
        i = 2
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        dum(i,j,k)=ubar*0.5*(w3d(i-1,j,k)+w3d(i,j,k))
        dum(1,j,k)=0.0
      enddo
      IF(ebc.eq.3.or.ebc.eq.4)THEN
      do j=1,nj
        i = ni-1
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        dum(i,j,k)=ubar*( 7.0*(w3d(i  ,j,k)+w3d(i-1,j,k))          &
                             -(w3d(i+1,j,k)+w3d(i-2,j,k)) )*onedtwelve
        i = ni
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        dum(i,j,k)=ubar*0.5*(w3d(i-1,j,k)+w3d(i,j,k))
        dum(ni+1,j,k)=0.0
      enddo
      ENDIF
    endif

      IF(ebc.eq.2 .and. ibe.eq.1)THEN
      do j=1,nj
        i=ni+1
        ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
        if(ubar.le.0.0)then
          i=ni
          dum(i+1,j,k)=dum(i,j,k)*arh1(i)/arh2(i)
        endif
      enddo
      ENDIF

      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(arh2(i)*dum(i+1,j,k)-arh1(i)*dum(i,j,k))*rdx*uh(i)
      enddo
      enddo

      IF(ebc.eq.2 .and. ibe.eq.1)THEN
        do j=1,nj
          i=ni+1
          ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
          if(ubar.le.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*(                                  &
                    c1(1,1,k)*(arh2(i)*rru(i+1,j,k-1)-arh1(i)*rru(i,j,k-1))         &
                   +c2(1,1,k)*(arh2(i)*rru(i+1,j,k  )-arh1(i)*rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
      ENDIF

    ENDDO

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advw=time_advw+mytime()
 
      return
      end


anelp.F         1587424407  1602  20    100644  7703      `


      subroutine anelp(xh,uh,xf,uf,yh,vh,yf,vf,                     &
                       zh,mh,rmh,mf,rmf,pi0,thv0,rho0,prs0,rf0,     &
                       radbcw,radbce,radbcs,radbcn,dum1,divx,       &
                       u0,us,ua,u3d,uten,                           &
                       v0,vs,va,v3d,vten,                           &
                       ws,wa,w3d,wten,                              &
                       ppi,pp3d,tha,th3d,thten,thv,cfb,cfa,cfc,     &
                        d1, d2,pdt,deft,rhs,trans,dttmp,nrk,rtime)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: xh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rho0,prs0,rf0
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,us,ua,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,vs,va,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: ws,wa,w3d,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,tha,th3d,thten,thv
      real, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, dimension(kpb:kpe) :: cfa,cfc,d1,d2
      complex, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, dimension(ipb:ipe,jpb:jpe) :: rhs,trans
      real dttmp
      integer nrk
      real, intent(in) :: rtime

!-----

      integer :: i,j,k
      real :: tem
      double precision :: fluxout,fluxin,u1,v1

!---------------------------------------------------------------------

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,ua)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,va)
 
        endif

!---------------------------------------------------------------------

        if(ibw.eq.1.and.wbc.eq.2)then
          do k=1,nk
          do j=1,nj
            uten(1,j,k)=uten(1,j,k)-radbcw(j,k)    &
                      *(ua(2,j,k)-ua(1,j,k))*rdx
          enddo
          enddo

          if(dowr) write(outfile,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

        if(ibe.eq.1.and.ebc.eq.2)then
          do k=1,nk
          do j=1,nj
            uten(ni+1,j,k)=uten(ni+1,j,k)-radbce(j,k)     &
                         *(ua(ni+1,j,k)-ua(ni  ,j,k))*rdx
          enddo
          enddo

          if(dowr) write(outfile,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

        if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            vten(i,1,k)=vten(i,1,k)-radbcs(i,k)    &
                      *(va(i,2,k)-va(i,1,k))*rdy
          enddo
          enddo

          if(dowr) write(outfile,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

        if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            vten(i,nj+1,k)=vten(i,nj+1,k)-radbcn(i,k)     &
                         *(va(i,nj+1,k)-va(i,nj  ,k))*rdy
          enddo
          enddo

          if(dowr) write(outfile,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

!---------------------------------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni+1
              u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)
            enddo
            enddo
            enddo
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
            tem=1.0/dttmp
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni+1
              uten(i,j,k) = (u3d(i,j,k)-ua(i,j,k))*tem
            enddo
            enddo
            enddo
          ENDIF
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj+1
            do i=1,ni
              v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)
            enddo
            enddo
            enddo
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
            tem=1.0/dttmp
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj+1
            do i=1,ni
              vten(i,j,k) = (v3d(i,j,k)-va(i,j,k))*tem
            enddo
            enddo
            enddo
          ENDIF
        ENDIF
        if(timestats.ge.1) time_sound=time_sound+mytime()

!---------------------------------------------------------------------
!  Get pressure

        call poiss(uh,vh,mh,rmh,mf,rmf,pi0,thv0,rho0,rf0,    &
                   dum1,divx,ppi,uten,vten,wten,             &
                   cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans,dttmp)

!---------------------------------------------------------------------

        tem=dttmp*rdx

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i-1,j,k))*uf(i))
        enddo
        enddo
        enddo

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcu(u3d)

!-----

      IF(axisymm.eq.0)THEN

        tem=dttmp*rdy

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i,j-1,k))*vf(j))
        enddo
        enddo
        enddo

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcv(v3d)

      ENDIF

!-----

        tem=dttmp*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=wa(i,j,k)+dttmp*wten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i,j,k-1))*mf(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcw(w3d,1)

!-------------------------------------------------------------------- 

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          ppi(i,j,k)=((prs0(1,1,k)+ppi(i,j,k)*rho0(1,1,k))*rp00)**rovcp   &
                    -pi0(1,1,k)
          pp3d(i,j,k)=ppi(i,j,k)
        enddo
        enddo
        do j=1,nj
        do i=1,ni
          th3d(i,j,k)=tha(i,j,k)+dttmp*thten(i,j,k)
        enddo
        enddo
      enddo

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcs(ppi)
        call bcs(pp3d)
        call bcs(th3d)

!-------------------------------------------------------------------- 

      return
      end



base.F          1587424407  1602  20    100644  63930     `

      subroutine base(zh,mh,c1,c2,zf,mf,rho0s,pi0s,prs0s,rth0s,             &
                      pi0,prs0,rho0,thv0,th0,rth0,qv0,u0,v0,                &
                      qc0,qi0,rr0,rf0,rrf0,t0,rh0,                          &
                      reqs_u,reqs_v,reqs_s,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2, &
                      n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,              &
                      uw31,uw32,ue31,ue32,us31,us32,un31,un32,              &
                      vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,              &
                      sw31,sw32,se31,se32,ss31,ss32,sn31,sn32)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'goddard.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,c1,c2
      real, dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf
      real, dimension(ib:ie,jb:je) :: rho0s,pi0s,prs0s,rth0s
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,rho0,thv0,th0,rth0,qv0
      real, dimension(ib:ie,jb:je,kb:ke) :: qc0,qi0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: t0,rh0
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_s
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(cmp,cmp,kmt+1) :: n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2
      real, intent(inout), dimension(cmp,jmp,kmp) :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp) :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp,kmp) :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp) :: ss31,ss32,sn31,sn32

!-----------------------------------------------------------------------

      integer i,j,k,m,n,nn,irec,niter,nsnd,kbot,ktop,tflag,nmax
      real zu,zv
      real z_trop,th_trop,th_sfc,t_trop,prs_sfc,qv_pbl,pi_sfc,t_sfc,rh_sfc,rh_pbl
      real qv_sfc,thv_sfc,psurf,tsurf,qsurf,thsurf,thvsurf
      real qv1,th1,tlast,th2,qv2,ql2,thbar,qvbar,tlcl
      real ns,ns1,ns2,ns3,zl1,zl2,zsfc
      real qcval,qtval,p_sfc,ql_sfc,thn,thlast,qtm,qtp,tavg,lhv,     &
           qvavg,qlavg,qtavg,desdt,gamma,tp,delz,pim,thvm,qvm,qlm,   &
           tm,pm,thm,drdt,pavg,qvl,qvi,fliq,fice,cpml,qim
      real thex,es,qvs,aaa
      real udep,uconst1,uconst2
      real udep1,udep2,umax1,umax2,vmax1,angle,a1,a2,wsp
      real tmp,ql,t1,t2,pitmp
      real hs,lapse
      real alpha,umax,nm,dudz,dvdz,rinum
      real, dimension(:), allocatable :: zsnd,thsnd,qvsnd,usnd,vsnd,   &
                                         thvsnd,pisnd,psnd,tsnd,rhsnd
      real, dimension(:), allocatable :: thinterp,qvinterp,uinterp,vinterp, &
                                         pinterp,tinterp,rhinterp
      integer :: kk,kup,kdn
      real :: interp_frac
      real rslf,rsif

      integer :: flag,ttype
      real :: pisfc,the_sfc,thv1,thv2,pi1,pi2,z1,z2,p2,theq,qt_sfc
      real :: getthe

      real :: ztrop,zmix,qv_mix,zmin,dtheta,thv_trop,qv_trop,pi_trop,p_trop,rhexp
      real :: depth_layer_01,depth_layer_02,shear_layer_01,shear_layer_02
      real :: du,dv

      real, dimension(:), allocatable :: pfoo,tfoo,qvfoo
      real :: cape,cin,zlcl,zlfc,zel,psource,tsource,thsource,qvsource

      integer :: k1,k2
      real :: lr1,lr2,ths1
      real :: tem
      logical :: dothis
      real :: wsp10,cd,znt,ust,wspr,gam,wsp1,wsp2,wtop,wref

!------------------------------------------------------------------

      if(dowr) write(outfile,*) 'Inside BASE'

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  Start definition of base state sounding (isnd opton)  cccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      psurf = 0.0
      tsurf = 0.0
      qsurf = 0.0

!-----------------------------------------------------------------------
!  isnd = 1
!  Dry adiabatic base state

      IF(isnd.eq.1)THEN

        ! Set these two variables for dry adiabatic sounding

        th_sfc   =   300.0   ! Potential temperature of atmosphere (K)
        pi_sfc   =   1.0     ! Exner function at surface

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          th0(i,j,k)=th_sfc
          pi0(i,j,k)=pi_sfc-g*zh(i,j,k)/(cp*th_sfc)
          prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo

        thsurf = th_sfc
        psurf = p00*(pi_sfc**cpdrd)
        tsurf = thsurf*((psurf*rp00)**rovcp)
        qsurf = 0.0

!-----------------------------------------------------------------------
!  isnd = 2
!  Dry isothermal base state
            
      ELSEIF(isnd.eq.2)THEN
          
        ! Set these two variables for dry isothermal sounding

        t_sfc    =   250.0    ! Temperature of atmosphere (K)
        prs_sfc  =   p00      ! Pressure at surface (Pa)


        hs=rd*t_sfc/g        ! scale height of atmosphere

        do k=kb,ke
        do j=jb,je
        do i=ib,ie

          ! calculate pressure field
          prs0(i,j,k)=prs_sfc*EXP(-zh(i,j,k)/hs)

          ! using the pressure field, calculate the exner pressure
          pi0(i,j,k)=(prs0(i,j,k)/p00)**(rd/cp)

          ! using exner pressure, determine the potential temperature
          th0(i,j,k)=t_sfc/pi0(i,j,k)

        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo

        psurf = prs_sfc
        tsurf = t_sfc
        qsurf = 0.0


!-----------------------------------------------------------------------
!  isnd = 3
!  Dry, constant dT/dz sounding.
!  Lapse rate of 0.0065  =  standard dry atmosphere.

      ELSEIF(isnd.eq.3)THEN

        ! Set these three variables for dry constant lapse rate sounding

        th_sfc   =  300.0     ! theta at surface (K)
        prs_sfc  =  p00       ! pressure at surface (Pa)
        lapse    =  0.0065    ! dT/dz (K m^-1)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie

          ! Calculate the temperature using the specified lapse rate.
          t0(i,j,k)=th_sfc-lapse*zh(i,j,k)

          ! Calculate the pressure from the temperature field.
          prs0(i,j,k)=p00*(t0(i,j,k)/th_sfc)**(g/(lapse*rd))

          ! Calculate the exner pressure from the pressure field.
          pi0(i,j,k)=(prs0(i,j,k)/p00)**(rd/cp)

          ! Calculate the theta field from temperature and the 
          ! specified lapse rate.
          th0(i,j,k)=th_sfc*(t0(i,j,k)/th_sfc)**(1-g/(lapse*cp))

        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo

        psurf = prs_sfc
        tsurf = th_sfc*((psurf*rp00)**rovcp)
        qsurf = 0.0


!------------------------------------------------------------------
!  isnd = 4
!  Saturated, neutrally-stable sounding for moist benchmark simulation.
!  reference:  Bryan and Fritsch, 2002, MWR, 130, 2917-2928.

      ELSEIF(isnd.eq.4)THEN

        ! these two parameters define the sounding

        thec_mb   =   320.0     ! wet equivalent potential temp (K)
        qt_mb     =   0.020     ! total water mixing ratio (unitless)


        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Saturated, neutrally-stable sounding'
        if(dowr) write(outfile,*) '    thec,qt=',thec_mb,qt_mb
        if(dowr) write(outfile,*)

        prs_sfc = 100000.0

      do j=jb,je
      do i=ib,ie

        !! First guesses at lowest model level
        prs0(i,j,1)=prs_sfc
        qv1=qt_mb
        tmp=thec_mb
        tlast=tmp

        do n=1,20
          thbar=(tmp*(p00/prs0(i,j,1))**(rd/cp))*(1.0+qv1*reps)/(1.0+qt_mb)
          pi0(i,j,1)=1.0-g*zh(i,j,1)/(cp*thbar)
          prs0(i,j,1)=p00*(pi0(i,j,1)**(cpdrd))
          qv1=rslf(prs0(i,j,1),tmp)
          tmp=thec_mb*((prs0(i,j,1)/(1.0+qv1/eps)/p00)**(rd/(cp+cpl*qt_mb)))  &
             /exp((lv1-lv2*tmp)*qv1/(tmp*(cp+cpl*qt_mb)))
          tmp=tlast+0.3*(tmp-tlast)
          tlast=tmp
        enddo
 
        t0(i,j,1)=tmp
        th0(i,j,1)=tmp/pi0(i,j,1)
        rh0(i,j,1)=1.0
        qv0(i,j,1)=rslf(prs0(i,j,1),tmp)
        t1=tmp
        qv1=qv0(i,j,1)
        th1=th0(i,j,1)

        do k=2,nk
          tlast=th1
          t2=t1
          qv2=qv1
          th2=th1
          n=0
          pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*th2)
100       continue
            n=n+1
            th2=tlast
            t2=th2*pi0(i,j,k)
            thbar=0.5*( th1*(1.0+qv1*reps)/(1.0+qt_mb)    &
                       +th2*(1.0+qv2*reps)/(1.0+qt_mb) )
            pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*thbar)
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cpdrd))
            qv2=rslf(prs0(i,j,k),t2)
            t2=thec_mb*((prs0(i,j,k)/(1.0+qv2/eps)/p00)**(rd/(cp+cpl*qt_mb))) &
             /exp((lv1-lv2*t2)*qv2/(t2*(cp+cpl*qt_mb)))
            th2=t2/pi0(i,j,k)

            if(n.gt.50.and.dowr) write(outfile,*) n,th2
            if(abs(th2-tlast).gt.0.0001 .and. n.lt.100)then
              tlast=tlast+0.3*(th2-tlast)
              go to 100
            elseif(n.ge.100)then
              if(dowr) write(outfile,*) '  stuck in loop!'
              call stopcm1
            endif
 
          t0(i,j,k)=t2
          th0(i,j,k)=th2
          qv0(i,j,k)=rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k))
          rh0(i,j,k)=1.0
 
          th1=th2
          qv1=qv2
          t1=t2
 
        enddo

        do k=1,nk
          qc0(i,j,k)=qt_mb-qv0(i,j,k)
        enddo

      enddo
      enddo

        psurf = prs_sfc
        tsurf = cgs1*t0(1,1,1)+cgs2*t0(1,1,2)+cgs3*t0(1,1,3)
        qsurf = cgs1*qv0(1,1,1)+cgs2*qv0(1,1,2)+cgs3*qv0(1,1,3)


!-----------------------------------------------------------------------
!  isnd = 5
!  Weisman-Klemp analytic sounding.
!  reference:  Weisman and Klemp, 1982, MWR, 110, 504-520.

      ELSEIF(isnd.eq.5)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  WK sounding'

!  variables related to Weisman-Klemp analytic sounding
        z_trop   = 12000.0      ! height of tropopause (m)
        th_trop  = 343.0        ! theta at tropopause (K)
        t_trop   = 213.0        ! temp at tropopause (K)
        th_sfc   = 300.0        ! theta at surface (K)
        prs_sfc  = 100000.0     ! pressure at surface (Pa)
        qv_pbl   = 0.014        ! constant value of mixing ratio in PBL

!--------------

        pi_sfc  = (prs_sfc/p00)**(rd/cp)
        qv_sfc  = rslf(prs_sfc,th_sfc*pi_sfc)
        thv_sfc = th_sfc*(1.0+qv_sfc*reps)/(1.0+qv_sfc)

      do j=jb,je
      do i=ib,ie

        do k=kb,ke
          rh0(i,j,k)=0.0
        enddo

        do k=1,nk
          if(zh(i,j,k).lt.z_trop)then
            th0(i,j,k)=th_sfc+(th_trop-th_sfc)*((zh(i,j,k)/z_trop)**1.25)
            if(imoist.eq.1) rh0(i,j,k)=1.0-0.75*((zh(i,j,k)/z_trop)**1.25)
          else
            th0(i,j,k)=th_trop*exp((g/(t_trop*cp))*(zh(i,j,k)-z_trop))
            if(imoist.eq.1) rh0(i,j,k)=0.25
          endif
        enddo

        th0(i,j,0)=th0(i,j,1)
        th0(i,j,nk+1)=th0(i,j,nk)


!  Get pressure, temperature, and mixing ratio using hydrostatic eqt.

        do k=kb,ke
          qv0(i,j,k)=0.0
        enddo

        do n=1,20
! virtual potential temperature
          do k=kb,ke
            thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k))
          enddo

          pi0(i,j,1)=pi_sfc-g*zh(i,j,1)/(cp*0.5*(thv_sfc+thv0(i,j,1)))
          do k=2,nk
            pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*0.5*(thv0(i,j,k)+thv0(i,j,k-1)))
          enddo

! pressure
          do k=1,nk
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          enddo

! mixing ratio
          do k=1,nk
            qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k))
            if(qv0(i,j,k).gt.qv_pbl) qv0(i,j,k)=qv_pbl
          enddo

        enddo

        do k=1,nk
          rh0(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
        enddo

      enddo
      enddo

        psurf = prs_sfc
        tsurf = th_sfc*((psurf*rp00)**rovcp)
      IF( imoist.eq.1 )THEN
        if( qv0(1,1,1).lt.qv_pbl )then
          qsurf = cgs1*qv0(1,1,1)+cgs2*qv0(1,1,2)+cgs3*qv0(1,1,3)
        else
          qsurf = qv_pbl
        endif
      ELSE
        qsurf = 0.0
      ENDIF

!------------------------------------------------------------------
!  isnd = 6

      ELSEIF(isnd.eq.6)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' isnd = 6 code has been removed (for now)'
        if(dowr) write(outfile,*)
        call stopcm1

!------------------------------------------------------------------
!  isnd = 7
!  Read base-state sounding from an external text file.
!  Assumes file name = input_sounding
!  NOTE:  for isnd=7, iwnd is ignored.
!
!  The format is the same as that for the WRF Model, as well as 
!  for the Klemp-Wilhelmson Model.  Format is:
!
!  1 line header containing: sfc pres (mb)    sfc theta (K)    sfc qv (g/kg)
!  nsnd lines of:  zheight (m)    theta (K)   qv (g/kg)    u (m/s)    v (m/s)
!
!  (Thanks to Leigh Orf, Central Michigan University, for contributing this
!   code.)
!  Note:  This now works with terrain.  (GHB, 061011)
!

      ELSEIF(isnd.eq.7)then

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' Reading sounding from external file, input_sounding'
        if(dowr) write(outfile,*)

        nmax = 100000 !should be enough!

        allocate(   zsnd(nmax) )
        allocate(  thsnd(nmax) )
        allocate(  qvsnd(nmax) )
        allocate(   usnd(nmax) )
        allocate(   vsnd(nmax) )
        allocate( thvsnd(nmax) )
        allocate(  pisnd(nmax) )
        allocate(   psnd(nmax) )
        allocate(   tsnd(nmax) )
        allocate(  rhsnd(nmax) )

        allocate( thinterp(nk) )
        allocate( qvinterp(nk) )
        allocate(  uinterp(nk) )
        allocate(  vinterp(nk) )
        allocate(  pinterp(nk) )
        allocate(  tinterp(nk) )
        allocate( rhinterp(nk) )

        open(unit=40,file='input_sounding',status='old')

        ! read surface parameters:
        read(40,*) p_sfc, th_sfc, qv_sfc
        if(dowr) write(outfile,*) ' p_sfc, th_sfc, qv_sfc = ',p_sfc, th_sfc, qv_sfc

        if(imoist.eq.0) qv_sfc = 0.0

        p_sfc = p_sfc * 100.0
        ! put qv in g/g
        qv_sfc = qv_sfc / 1000.0
        pi_sfc  = (p_sfc/p00)**(rd/cp)
        thv_sfc = th_sfc*(1.0+qv_sfc*reps)/(1.0+qv_sfc)

        psurf  = p_sfc
        thsurf = th_sfc
        tsurf  = th_sfc * pi_sfc
        qsurf  = qv_sfc

        zsnd(1) = 0.0
        thsnd(1) = th_sfc
        qvsnd(1) = qv_sfc

        ! now, read entire sounding until end of file is discovered
        nsnd=1
        do k=1,nmax
          read(40,*,end=445) zsnd(k+1),thsnd(k+1),qvsnd(k+1),usnd(k+1),vsnd(k+1)
          ! put qv in g/g
          qvsnd(k+1) = qvsnd(k+1)/1000.0
          nsnd=nsnd+1
        enddo
445     continue
        if(dowr) write(outfile,*) '  Found ',nsnd,'  levels (including surface)'
        if(dowr) write(outfile,*)
        close(unit=40)

        if(imoist.eq.0) qvsnd = 0.0

        usnd(1) = 1.75*usnd(2)-usnd(3)+0.25*usnd(4)
        vsnd(1) = 1.75*vsnd(2)-vsnd(3)+0.25*vsnd(4)

!--------------------------------------------------------------------
!  Added by GHB, 061021:
!  Get thv and prs ... check if qv is too small.  If so, set rh to 5%
!  (This code has no effect on the sounding if qv > 1e-12 everywere)
!  (It was added to deal with the 0 g/kg qv values in the Trier sounding.)
        do k=1,nsnd
          thvsnd(k)=thsnd(k)*(1.0+reps*qvsnd(k))/(1.0+qvsnd(k))
        enddo
        pisnd(1)=pi_sfc
        do k=2,nsnd
          pisnd(k)=pisnd(k-1)-g*(zsnd(k)-zsnd(k-1))   &
                               /(cp*0.5*(thvsnd(k)+thvsnd(k-1)))
        enddo
        do k=1,nsnd
          psnd(k)=p00*(pisnd(k)**(cp/rd))
          tsnd(k)=thsnd(k)*pisnd(k)
        enddo
      if(imoist.eq.1)then
        do k=1,nsnd
          if(qvsnd(k).lt.1.0e-12)then
            if(dowr) write(outfile,*) '  Qv is too small.  Setting rh to 1%.  k,zsnd=',k,zsnd(k)
            qvsnd(k)=0.01*rslf(psnd(k),thsnd(k)*pisnd(k))
          endif
          rhsnd(k)=qvsnd(k)/rslf(psnd(k),tsnd(k))
        enddo
      endif
!--------------------------------------------------------------------

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '    k,z,th,qv:'
        do k=1,nsnd
          if(dowr) write(outfile,*) k,zsnd(k),thsnd(k),1000.0*qvsnd(k)
        enddo
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '    k,u,v:'
        do k=1,nsnd
          if(dowr) write(outfile,*) k,usnd(k),vsnd(k)
        enddo
        if(dowr) write(outfile,*)

! check to make sure sounding levels span computational grid (WICKER)
!!!        061011, GHB:  Commented this out ... we'll use the surface info.
!!!        if (zsnd(1) .gt. zh(1,1,1)) then
!!!          write(*,*) 'zmin of sounding > zmin of grid!'
!!!          write(*,*) 'zmin of sounding = ',zsnd(1)
!!!          write(*,*) 'zmin of grid = ',zh(1,1,1)
!!!          call stopcm1
!!!        endif

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) 'interpolating sounding to grid: '
        if(dowr) write(outfile,*)

      DO j=jb,je
      DO i=ib,ie

        if (zsnd(nsnd) .lt. zh(i,j,nk)) then
          if(dowr) write(outfile,*) 'zmax of sounding < zmax of grid!'
          if(dowr) write(outfile,*) 'zmax of sounding = ',zsnd(nsnd)
          if(dowr) write(outfile,*) 'zmax of grid  = ',zh(i,j,nk)
          call stopcm1
        endif

        DO k=1,nk

            kk = 1
            do while( zsnd(kk) .lt. zh(i,j,k) )
              kk = kk+1
            enddo
            kdn = kk-1
            kup = kk

            zu=0.5*(zh(max(ib,i-1),j,k)+zh(i,j,k))
            interp_frac = (   zu        - zsnd(kdn) )   &
                        / ( zsnd( kup ) - zsnd(kdn) )
            uinterp(k) =  usnd(kdn) + ( usnd(kup)- usnd(kdn))*interp_frac

            zv=0.5*(zh(i,max(jb,j-1),k)+zh(i,j,k))
            interp_frac = (   zv        - zsnd(kdn) )   &
                        / ( zsnd( kup ) - zsnd(kdn) )
            vinterp(k) =  vsnd(kdn) + ( vsnd(kup)- vsnd(kdn))*interp_frac

!!!            ! if this is first grid point, utilize surface values of th,qv:
!!!            if( k.eq.1 ) kdn = 1

            interp_frac = (   zh(i,j,k) - zsnd(kdn) )   &
                        / ( zsnd( kup ) - zsnd(kdn) )
            thinterp(k) = thsnd(kdn) + (thsnd(kup)-thsnd(kdn))*interp_frac
            qvinterp(k) = qvsnd(kdn) + (qvsnd(kup)-qvsnd(kdn))*interp_frac
             pinterp(k) =  psnd(kdn) + ( psnd(kup)- psnd(kdn))*interp_frac
             tinterp(k) =  tsnd(kdn) + ( tsnd(kup)- tsnd(kdn))*interp_frac
            rhinterp(k) = rhsnd(kdn) + (rhsnd(kup)-rhsnd(kdn))*interp_frac

            if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) '       ',zsnd(kdn),zh(i,j,k),zsnd(kup),interp_frac

        ENDDO
        if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*)

        do k=1,nk
           u0(i,j,k) =  uinterp(k)
           v0(i,j,k) =  vinterp(k)
          qv0(i,j,k) = qvinterp(k)
          th0(i,j,k) = thinterp(k)
         prs0(i,j,k) =  pinterp(k)
           t0(i,j,k) =  tinterp(k)
          rh0(i,j,k) = rhinterp(k)
        enddo

        ! get pi0 and prs0 from thv0, using hydrostatic equation

        do k=1,nk
          ! get qv from linear interpolation of rh:
          qv0(i,j,k) = rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
        enddo

        do k=1,nk
          thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k))
        enddo

        pi0(i,j,1)=pi_sfc-g*zh(i,j,1)/(cp*0.5*(thv_sfc+thv0(i,j,1)))
        do k=2,nk
          pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))   &
                                   /(cp*0.5*(thv0(i,j,k)+thv0(i,j,k-1)))
        enddo

        do k=1,nk
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
        enddo

        ! rh, just in case we want/need it later

      if(imoist.eq.1)then
        do k=1,nk
          rh0(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
        enddo
      endif

      ENDDO    ! enddo for i loop
      ENDDO    ! enddo for j loop


        ! deallocate temporary 1D arrays
        deallocate(   zsnd )
        deallocate(  thsnd )
        deallocate(  qvsnd )
        deallocate(   usnd )
        deallocate(   vsnd )
        deallocate( thvsnd )
        deallocate(  pisnd )
        deallocate(   psnd )
        deallocate(   tsnd )
        deallocate(  rhsnd )
        deallocate( thinterp )
        deallocate( qvinterp )
        deallocate(  uinterp )
        deallocate(  vinterp )
        deallocate(  pinterp )
        deallocate(  tinterp )
        deallocate( rhinterp )


!-----------------------------------------------------------------------
!  isnd = 8
!  Dry, constant d(theta)/dz sounding

      ELSEIF(isnd.eq.8)THEN

        ! Set these three variables for dry, constant d(theta)/dz sounding

        th_sfc   =  300.0     ! theta at surface (K)
        pi_sfc   =    1.0     ! Exner function at surface
        lapse    =  0.0035    ! potential temperature lapse rate (K/m)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie

          ! Calculate theta using the specified lapse rate.
          th0(i,j,k)=th_sfc+lapse*zh(i,j,k)

          ! Calculate pi from theta
          pi0(i,j,k)=pi_sfc-(g/(cp*lapse))*alog(th0(i,j,k)/th_sfc)

          ! Calculate pressure from pi
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))

          ! Calculate temperature from theta and pi
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)

        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo

        thsurf = th_sfc
        psurf = p00*(pi_sfc**(cp/rd))
        tsurf = th_sfc * pi_sfc

!------------------------------------------------------------------
!  isnd = 9
!  Constant Brunt-Vaisala frequency

      ELSEIF(isnd.eq.9)then

        ns1 =  0.0001
        ns2 =  0.0000

        zl1 = 40000.0

      do j=jb,je
      do i=ib,ie
        th_sfc   =  288.00
        pi_sfc   =    1.0
        !-----
        thsurf = th_sfc
        psurf = p00*(pi_sfc**(cp/rd))
        tsurf = th_sfc * pi_sfc
        !-----
        if(zh(i,j,1).lt.zl1)then
          zsfc = 0.0
          ns   = ns1
        else
          if(abs(ns1).lt.1.0e-6)then
            pi_sfc=pi_sfc-g*zl1/(cp*th_sfc)
          else
            pi_sfc=pi_sfc+g*g/(cp*ns1*th_sfc)*(exp(-ns1*zl1/g)-1.0)
            th_sfc=th_sfc*exp(ns1*zl1/g)
          endif
          zsfc = zl1
          ns   = ns2
        endif
        do k=1,nk
          qv0(i,j,k)=0.0
          qc0(i,j,k)=0.0
          rh0(i,j,k)=0.0
          if(abs(ns).lt.1.0e-6)then
            thv0(i,j,k)=th_sfc
            pi0(i,j,k)=pi_sfc-g*(zh(i,j,k)-zsfc)/(cp*th_sfc)
          else
            thv0(i,j,k)=th_sfc*exp(ns*(zh(i,j,k)-zsfc)/g)
            pi0(i,j,k)=pi_sfc+g*g/(cp*ns*th_sfc)   &
                           *(exp(-ns*(zh(i,j,k)-zsfc)/g)-1.0)
          endif
          prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
          th0(i,j,k)=thv0(i,j,k)
          do n=1,20
            t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
            qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
            th0(i,j,k)=thv0(i,j,k)*(1.0+qv0(i,j,k)+qc0(i,j,k))/(1.0+reps*qv0(i,j,k))
!!!            if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) k,n,th0(i,j,k),qv0(i,j,k)
          enddo
          if(zh(i,j,k+1).gt.zl1.and.zsfc.lt.1.0)then
            if(abs(ns1).lt.1.0e-6)then
              pi_sfc=pi_sfc-g*zl1/(cp*th_sfc)
            else
              pi_sfc=pi_sfc+g*g/(cp*ns1*th_sfc)*(exp(-ns1*zl1/g)-1.0)
              th_sfc=th_sfc*exp(ns1*zl1/g)
            endif
            zsfc=zl1
            ns=ns2
          endif
        enddo

      enddo
      enddo

        qsurf = cgs1*qv0(1,1,1)+cgs2*qv0(1,1,2)+cgs3*qv0(1,1,3)

!------------------------------------------------------------------
!  isnd = 10
!  Moist, constant Brunt-Vaisala frequency
!    (assuming reversible moist microphysics)

      ELSEIF(isnd.eq.10)then

        if(dowr) write(outfile,*) '  isnd = 10'

        qcval    =   0.005
        qtval    =   0.00000

        ns1 =  0.0
        ns2 =  4.0e-4

        zl1 = 111700.0

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        ! DEFINE RH here:  saturated (RH = 100%) is assumed by default
        rh0(i,j,k)=1.0
        qc0(i,j,k)=qcval
      enddo
      enddo
      enddo

      if(dowr) write(outfile,*)
      do j=jb,je
      do i=ib,ie
        th_sfc   =  288.0
        pi_sfc   =    1.0
        !-----
        thsurf = th_sfc
        psurf = p00*(pi_sfc**(cp/rd))
        tsurf = th_sfc * pi_sfc
        !-----
        ns=ns1
        p_sfc=p00*(pi_sfc**(cp/rd))
        t_sfc=th_sfc*pi_sfc
        qv_sfc=rh0(i,j,1)*rslf(p_sfc,t_sfc)
        ql_sfc=qcval
!!!        ql_sfc=qtval-qv_sfc
        thv_sfc=th_sfc*(1.0+reps*qv_sfc)/(1.0+qv_sfc+ql_sfc)
        thn=th_sfc
        thlast=thn
      !---------- do k=1 first ----------!
        k=1
        n=1
        qv0(i,j,k)=qv_sfc
        qc0(i,j,k)=ql_sfc
 571      continue
          th0(i,j,k)=thn
          thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))   &
                                /(1.0+qv0(i,j,k)+qc0(i,j,k))
          pi0(i,j,k)=pi_sfc-g*zh(i,j,k)/(cp*0.5*(thv0(i,j,k)+thv_sfc))
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          qvs=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
          qv0(i,j,k)=qvs
          qc0(i,j,k)=qcval
!!!          qc0(i,j,k)=qtval-qv0(i,j,k)
          qtm=qv_sfc+ql_sfc
          qtp=qv0(i,j,k)+qc0(i,j,k)
          tavg=0.5*( t0(i,j,k)+t_sfc )
          lhv=lv1-lv2*tavg
          qvavg=0.5*( qv_sfc + qv0(i,j,k) )
          qlavg=0.5*( ql_sfc + qc0(i,j,k) )
          qtavg=qvavg+qlavg
          desdt=17.67*(273.15-29.65)/((tavg-29.65)**2)
          drdt=17.67*(273.15-29.65)*qvavg/((tavg-29.65)**2)
        if(eqtset.eq.2)then
          gamma=g*(1.0+qtavg)*(1.0+lhv*qvavg/rd/tavg)   &
               /( cp+cpv*qvavg+cpl*qlavg          &
                 +lhv*drdt )
        else
          gamma=g*(1.0+qtavg)*(rd/(rd+rv*qvavg)+lhv*qvavg/rd/tavg)   &
               /( cp+lhv*(1.0+qvavg*reps)*qvavg*desdt )
        endif
          tp=t_sfc*exp( zh(i,j,k)*(                     &
                ((ns/g)+alog((1.0+qtp)/(1.0+qtm))/zh(i,j,k))  &
                   /(1.0+tavg*drdt/(eps+qvavg))-gamma/tavg                  &
                                                      ) )
          thn=tp/pi0(i,j,k)

          n=n+1

          if(n.gt.180.and.dowr) write(outfile,*) n,thn
          if(abs(thn-thlast).gt.0.0001 .and. n.lt.200)then
            thn=thlast+0.3*(thn-thlast)
            thlast=thn
            go to 571
          elseif(n.ge.200)then
            if(dowr) write(outfile,*) '  stuck in loop (111)!'
            call stopcm1
          endif

        th0(i,j,k)=thn
        prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
        t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
        qvs=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
        qv0(i,j,k)=qvs
        qc0(i,j,k)=qcval
!!!        qc0(i,j,k)=qtval-qv0(i,j,k)
        if(qc0(i,j,1).lt.0.0)then
          print *,'  calling stopcm1 (222) '
          call stopcm1
        endif
        if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) k,n,th0(i,j,k),prs0(i,j,k)
      !---------- done with k=1, do all other levels ----------!
        qvs=qv0(i,j,1)
        ns=ns1
        do k=2,nk
        tflag=0
        do niter=1,2
        if(tflag.lt.2)then
          if(zh(i,j,k).gt.zl1.and.ns.eq.ns1.and.tflag.eq.0.and.zh(i,j,k-1).lt.zl1)then
            tflag=1
            delz=zl1-zh(i,j,k-1)
            pim=pi0(i,j,k-1)
            thm=th0(i,j,k-1)
            thvm=thv0(i,j,k-1)
            qtm=qv0(i,j,k-1)+qc0(i,j,k-1)+qi0(i,j,k-1)
            qvm=qv0(i,j,k-1)
            qlm=qc0(i,j,k-1)
            qim=qi0(i,j,k-1)
            tm=t0(i,j,k-1)
            pm=prs0(i,j,k-1)
          elseif(tflag.eq.1)then
            tflag=0
            ns=ns2
            delz=zh(i,j,k)-zl1
            pim=pi0(i,j,k)
            thm=th0(i,j,k)
            thvm=thv0(i,j,k)
            qtm=qv0(i,j,k)+qc0(i,j,k)+qi0(i,j,k)
            qvm=qv0(i,j,k)
            qlm=qc0(i,j,k)
            qim=qi0(i,j,k)
            tm=t0(i,j,k)
            pm=prs0(i,j,k)
          else
            tflag=2
            delz=zh(i,j,k)-zh(i,j,k-1)
            pim=pi0(i,j,k-1)
            thm=th0(i,j,k-1)
            thvm=thv0(i,j,k-1)
            qtm=qv0(i,j,k-1)+qc0(i,j,k-1)+qi0(i,j,k-1)
            qvm=qv0(i,j,k-1)
            qlm=qc0(i,j,k-1)
            qim=qi0(i,j,k-1)
            tm=t0(i,j,k-1)
            pm=prs0(i,j,k-1)
          endif
!!!          t0(i,j,k)=tm
          th0(i,j,k)=thm
          qv0(i,j,k)=qvm
          qc0(i,j,k)=qlm
          qi0(i,j,k)=qim
          thv0(i,j,k)=thvm
!!!          thlast=tm*pim
          thlast=thm
          n=0
          thn=thlast
          thlast=thn
 572      continue
            th0(i,j,k)=thn
            thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))   &
                                  /(1.0+qv0(i,j,k)+qc0(i,j,k)+qi0(i,j,k))
            pi0(i,j,k)=pim-g*delz/(cp*0.5*(thv0(i,j,k)+thvm))
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
            t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          if(iice.eq.0)then
            qvs=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
            qv0(i,j,k)=qvs
            qc0(i,j,k)=qcval
!!!            qc0(i,j,k)=qtval-qv0(i,j,k)
            qtp=qv0(i,j,k)+qc0(i,j,k)
            pavg=0.5*(prs0(i,j,k-1)+prs0(i,j,k))
            tavg=0.5*( t0(i,j,k)+tm )
            qvavg=rh0(i,j,k)*rslf(pavg,tavg)
            qlavg=0.5*( qlm + qc0(i,j,k) )
            qtavg=0.5*( qtm + qtp )
            drdt=17.67*(273.15-29.65)*qvavg/((tavg-29.65)**2)
            lhv=lv1-lv2*tavg
            cpml=cp+cpv*qvavg+cpl*qlavg
          else
            qvl=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
            qvi=rh0(i,j,k)*rsif(prs0(i,j,k),t0(i,j,k))
            fliq=max(min((t0(i,j,k)-t00k)*rt0,1.0),0.0)
            fice=1.0-fliq
            qvs=fliq*qvl+fice*qvi
            qv0(i,j,k)=qvs
            qc0(i,j,k)=fliq*qcval
            qi0(i,j,k)=fice*qcval
            qtp=qv0(i,j,k)+qc0(i,j,k)+qi0(i,j,k)
            pavg=0.5*(prs0(i,j,k-1)+prs0(i,j,k))
            tavg=0.5*( t0(i,j,k)+tm )
            qvl=rh0(i,j,k)*rslf(pavg,tavg)
            qvi=rh0(i,j,k)*rsif(pavg,tavg)
            fliq=max(min((tavg-t00k)*rt0,1.0),0.0)
            fice=1.0-fliq
            qvavg=fliq*qvl+fice*qvi
            qlavg=0.5*( qlm + qc0(i,j,k) )
            qtavg=0.5*( qtm + qtp )
            drdt=fliq*17.67*(273.15-29.65)*qvl/((tavg-29.65)**2)    &
                +fice*21.8745584*(273.15-7.66)*qvi/((tavg-7.66)**2)
            if(tavg.gt.t00k.and.tavg.lt.t0k)then
              drdt=drdt+(qvl-qvi)*rt0
            endif
            lhv=fliq*(lv1-lv2*tavg)+fice*(ls1-ls2*tavg)
            cpml=cp+cpv*qvavg+cpl*qlavg+cpi*(qtavg-qlavg-qvavg)
          endif
          if(eqtset.eq.2)then
            gamma=g*(1.0+qtavg)*(1.0+lhv*qvavg/rd/tavg)   &
                 /( cpml+lhv*drdt )
          else
            gamma=g*(1.0+qtavg)*(rd/(rd+rv*qvavg)+lhv*qvavg/rd/tavg)   &
                 /( cp+lhv*(1.0+qvavg*reps)*qvavg*desdt )
          endif
            tp=tm*exp( delz*(                                 &
                  ((ns/g)+alog((1.0+qtp)/(1.0+qtm))/delz)     &
                     /(1.0+tavg*drdt/(eps+qvavg))-gamma/tavg  &
                                                        ) )
            thn=tp/pi0(i,j,k)

            n=n+1

            if(n.gt.180.and.dowr) write(outfile,*) n,tp,tm,delz
            if(abs(thn-thlast).gt.0.0001 .and. n.lt.200)then
              thn=thlast+0.3*(thn-thlast)
              thlast=thn
              go to 572
            elseif(n.ge.200)then
              if(dowr) write(outfile,*) '  stuck in loop (333)!'
              call stopcm1
            endif

          t0(i,j,k)=tp
          th0(i,j,k)=thn
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          if(iice.eq.0)then
            qvs=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
            qv0(i,j,k)=qvs
            fliq = 1.0
            fice = 0.0
          else
            qvl=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
            qvi=rh0(i,j,k)*rsif(prs0(i,j,k),t0(i,j,k))
            fliq=max(min((t0(i,j,k)-t00k)*rt0,1.0),0.0)
            fice=1.0-fliq
            qvs=fliq*qvl+fice*qvi
            qv0(i,j,k)=qvs
            qc0(i,j,k)=fliq*qcval
            qi0(i,j,k)=fice*qcval
          endif
          if(qc0(i,j,1).lt.0.0)then
            print *,'  calling stopcm1 (444) '
            call stopcm1
          endif
!!!          if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) k,n,zh(i,j,k),th0(i,j,k),prs0(i,j,k)
          if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) k,n,t0(i,j,k),fliq,fice
        endif
        enddo  ! enddo for iteration loop
        enddo  ! enddo for k loop

      enddo  ! enddo for i loop
      enddo  ! enddo for j loop
      if(dowr) write(outfile,*)

        qsurf = cgs1*qv0(1,1,1)+cgs2*qv0(1,1,2)+cgs3*qv0(1,1,3)

!------------------------------------------------------------------
!  constant theta-e, saturated
!  Reference:  Bryan and Rotunno, 2009, JAS, v10, pp. 3042-3060

      ELSEIF(isnd.eq.11)THEN

        IF(imoist.eq.0)THEN
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  isnd=11 requires imoist=1'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  stopping model ...'
          if(dowr) write(outfile,*)
          call stopcm1
        ENDIF

        zl1 = 15000.0    ! tropopause height

        ttype =  2    ! 1 = reversible
                      ! 2 = pseudoadiabatic

        psurf = 101510.0    ! surface pressure (Pa)

      DO j=jb,je
      DO i=ib,ie

        ! use psurf:
        pi_sfc   =  (psurf*rp00)**rovcp
        ! use tsk from namelist.input, make 3 K cooler:
        th_sfc   =  ( tsk0 - 3.0 )/pi_sfc

        !-----
        thsurf = th_sfc
        tsurf = th_sfc * pi_sfc
        !-----

        t_sfc=th_sfc*pi_sfc
        p_sfc=p00*(pi_sfc**(cp/rd))
        qv_sfc=rslf(p_sfc,t_sfc)
        qt_sfc=qv_sfc
        thv_sfc=th_sfc*(1.0+reps*qv_sfc)/(1.0+qv_sfc)

        the_sfc=getthe(ttype,p_sfc,t_sfc,qv_sfc,qt_sfc)
        if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) '  p_sfc,t_sfc,qv_sfc = ',p_sfc,t_sfc,qv_sfc
        if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) '  the_sfc,qt_sfc = ',the_sfc,qt_sfc

        th_sfc=0.0
        qv_sfc=0.0
        call revthe(ttype,the_sfc,p_sfc,qt_sfc,t_sfc,qv_sfc)
        if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) '  p_sfc,t_sfc,qv_sfc = ',p_sfc,t_sfc,qv_sfc

        pi1=pi_sfc
        z1=0.0
        t1=t_sfc
        thv1=thv_sfc
        thv2=thv1
        flag=0

        do k=1,nk

          z2=zh(i,j,k)
          t2=t1
          tlast=0.0
          n=0

        if(z2.le.zl1)then
          ! troposphere
          theq=the_sfc
          ! iterate:
          do while( abs(t2-tlast).gt.0.0001 )
            tlast=t2
            n=n+1
            pi2=pi1-g*(z2-z1)/(cp*0.5*(thv1+thv2))
            p2=p00*(pi2**(cp/rd))
            call revthe(ttype,theq,p2,qt_sfc,t2,qv2)
            th2=t2/pi2
            if(ttype.eq.1)then
              ql2=qt_sfc-qv2
            elseif(ttype.eq.2)then
              ql2=0.0
            endif
            thv2=th2*(1.0+reps*qv2)/(1.0+qv2+ql2)
          enddo
        else
          ! stratosphere
          ns=4.0e-4
          if(flag.eq.0)then
            ! first time in this section ... get sfc params
            !-------------------
            z2=zl1
            t2=t1
            tlast=0.0
            n=0
            theq=the_sfc
            do while( abs(t2-tlast).gt.0.0001 )
              tlast=t2
              n=n+1
              pi2=pi1-g*(z2-z1)/(cp*0.5*(thv1+thv2))
              p2=p00*(pi2**(cp/rd))
              call revthe(ttype,theq,p2,qt_sfc,t2,qv2)
              th2=t2/pi2
              if(ttype.eq.1)then
                ql2=qt_sfc-qv2
              elseif(ttype.eq.2)then
                ql2=0.0
              endif
              thv2=th2*(1.0+reps*qv2)/(1.0+qv2+ql2)
            enddo
            flag=1
            th_sfc=thv2
            pi_sfc=pi2
            zsfc=z2
            !-------------------
            z2=zh(i,j,k)
            t2=t1
            tlast=0.0
            n=0
          endif
          if(abs(ns).lt.1.0e-6)then
            thv2=th_sfc
            pi2=pi_sfc-g*(z2-zsfc)/(cp*th_sfc)
          else
            thv2=th_sfc*exp(ns*(z2-zsfc)/g)
            pi2=pi_sfc+g*g/(cp*ns*th_sfc)   &
                           *(exp(-ns*(z2-zsfc)/g)-1.0)
          endif
          p2=p00*(pi2**cpdrd)
          th2=thv2
          do n=1,20
            t2=th2*pi2
            qv2=rslf(p2,t2)
            if(ttype.eq.1)then
              ql2=qt_sfc-qv2
            elseif(ttype.eq.2)then
              ql2=0.0
            endif
            th2=thv2*(1.0+qv2+ql2)/(1.0+reps*qv2)
          enddo
        endif
!!!          if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) n,p2,th2

          t1=t2
          thv1=thv2
          z1=z2
          pi1=pi2

          pi0(i,j,k)=pi2
          prs0(i,j,k)=p2
          t0(i,j,k)=t2
          th0(i,j,k)=th2
          thv0(i,j,k)=thv2
          rh0(i,j,k)=1.0
          qv0(i,j,k)=qv2
          qc0(i,j,k)=ql2

        enddo

      ENDDO
      ENDDO

        qsurf = cgs1*qv0(1,1,1)+cgs2*qv0(1,1,2)+cgs3*qv0(1,1,3)

!------------------------------------------------------------------
!  PBL simulation:  assumed dry

      ELSEIF(isnd.eq.12)THEN

        pi_sfc = 1.0
        th_sfc = 300.0
        zl1    = 960.0
        lapse  = 0.010

        pisfc = pi_sfc-g*zl1/(cp*th_sfc)

        do k=1,nk
        do j=jb,je
        do i=ib,ie
          IF(zh(i,j,k).le.zl1)THEN
            th0(i,j,k) = th_sfc
            pi0(i,j,k)=pi_sfc-g*zh(i,j,k)/(cp*th_sfc)
          ELSE
            th0(i,j,k) = th_sfc+lapse*(zh(i,j,k)-zl1)
            pi0(i,j,k)=pisfc-(g/(cp*lapse))*alog(th0(i,j,k)/th_sfc)
          ENDIF
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          rh0(i,j,k)=0.0
          qv0(i,j,k)=0.0
          if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,*) k,zh(i,j,k),th0(i,j,k),prs0(i,j,k)
        enddo
        enddo
        enddo

!------------------------------------------------------------------
!  from Klemp (2011)

      ELSEIF(isnd.eq.13)then

        ns1 =  0.0001
        ns2 =  0.0004
        ns3 =  0.0001

        zl1 =  2000.0
        zl2 =  3000.0

      do j=jb,je
      do i=ib,ie
        th_sfc   =  288.00
        pi_sfc   =    1.0
        !-----
        thsurf = th_sfc
        psurf = p00*(pi_sfc**(cp/rd))
        tsurf = th_sfc * pi_sfc
        !-----
        if(zh(i,j,1).lt.zl1)then
          zsfc = 0.0
          ns   = ns1
        else
          if(abs(ns1).lt.1.0e-6)then
            pi_sfc=pi_sfc-g*zl1/(cp*th_sfc)
          else
            pi_sfc=pi_sfc+g*g/(cp*ns1*th_sfc)*(exp(-ns1*zl1/g)-1.0)
            th_sfc=th_sfc*exp(ns1*zl1/g)
          endif
          zsfc = zl1
          ns   = ns2
        endif
        do k=1,nk
          if(abs(ns).lt.1.0e-6)then
            th0(i,j,k)=th_sfc
            pi0(i,j,k)=pi_sfc-g*(zh(i,j,k)-zsfc)/(cp*th_sfc)
          else
            th0(i,j,k)=th_sfc*exp(ns*(zh(i,j,k)-zsfc)/g)
            pi0(i,j,k)=pi_sfc+g*g/(cp*ns*th_sfc)   &
                           *(exp(-ns*(zh(i,j,k)-zsfc)/g)-1.0)
          endif
          prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
          thv0(i,j,k)=th0(i,j,k)
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          if(zh(i,j,k+1).gt.zl1.and.zsfc.lt.1.0)then
            if(abs(ns1).lt.1.0e-6)then
              pi_sfc=pi_sfc-g*zl1/(cp*th_sfc)
            else
              pi_sfc=pi_sfc+g*g/(cp*ns1*th_sfc)*(exp(-ns1*zl1/g)-1.0)
              th_sfc=th_sfc*exp(ns1*zl1/g)
            endif
            zsfc=zl1
            ns=ns2
          elseif(zh(i,j,k+1).gt.zl2.and.zsfc.lt.zl2)then
            if(abs(ns1).lt.1.0e-6)then
              pi_sfc=pi_sfc-g*(zl2-zl1)/(cp*th_sfc)
            else
              pi_sfc=pi_sfc+g*g/(cp*ns2*th_sfc)*(exp(-ns2*(zl2-zl1)/g)-1.0)
              th_sfc=th_sfc*exp(ns2*(zl2-zl1)/g)
            endif
            zsfc=zl2
            ns=ns3
          endif
        enddo

      enddo
      enddo

!------------------------------------------------------------------

      ENDIF

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  End definition of base state sounding (isnd opton)  cccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!------------------------------------------------------------------
!  fill in ghost cells

      call bcs(pi0)
      call bcs(prs0)
      call bcs(th0)
      call bcs(qv0)
      call bcs(qc0)
      call bcs(qi0)
      call bcs(rh0)

#ifdef MPI
      nf=0
      nu=0
      nv=0
      nw=0
      call comm_all_s( pi0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
      call comm_all_s(prs0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
      call comm_all_s( th0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
      call comm_all_s( qv0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
      call comm_all_s( qc0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
      call comm_all_s( qi0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
      call comm_all_s( rh0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
#endif

      call extrapbcs(pi0)
      call extrapbcs(prs0)
      call extrapbcs(th0)
      call extrapbcs(qv0)
      call extrapbcs(qc0)
      call extrapbcs(qi0)
      call extrapbcs(rh0)

    do j=jb,je
    do i=ib,ie

!------------------------------------------------------------------
!  check thv0
!  Assumes th0, qv0 are accurate

      if(imoist.eq.1)then
        do k=kb,ke
          thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k)+qc0(i,j,k)+qi0(i,j,k))
        enddo
      else
        do k=kb,ke
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
          thv0(i,j,k)=th0(i,j,k)
        enddo
      endif

!----------------------------
!  calculate pressure, density, and temperature

      do k=kb,ke
        prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
        rho0(i,j,k)=prs0(i,j,k)/(rd*th0(i,j,k)*pi0(i,j,k)*(1.0+qv0(i,j,k)*reps))
        t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
      enddo

!----------------------------
!  This reduces errors associated with buoyancy term
!  (seems kind of redundant ... but it works)

      !  This qv0 must match specification of qva array in 
      !  the INIT3D subroutine
      !  (i.e., identical bit-for-bit calculation)

!    IF(imoist.eq.1)THEN
!      do k=kb,ke
!        qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k))
!      enddo
!    ENDIF


      !  This thv0 must exactly match the manner in which thv
      !  is calculated in the SOLVE subroutine
      !  (i.e., identical bit-for-bit calculation)

      do k=kb,ke
        if(imoist.eq.1)then
          thv0(i,j,k)=(th0(i,j,k)+0.0)*(1.0+reps*max(0.0,qv0(i,j,k)))  &
                                      /(1.0+max(0.0,qv0(i,j,k))+max(0.0,qc0(i,j,k)+qi0(i,j,k)))
        else
          thv0(i,j,k)=th0(i,j,k)
        endif
      enddo

    enddo
    enddo

      call bcs(rho0)
#ifdef MPI
      call comm_all_s(rho0,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                           n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
#endif
      call extrapbcs(rho0)

      IF( psolver.eq.5 .or. psolver.eq.6 )THEN   
        ! incompressible or compressible-Boussinesq:  set rho0 to a constant

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          rho0(i,j,k) = 1.0
        enddo
        enddo
        enddo

      ENDIF

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rr0(i,j,k)=1.0/rho0(i,j,k)
      enddo
      enddo
      enddo

      do k=2,nk
      do j=jb,je
      do i=ib,ie
        rf0(i,j,k)=c1(i,j,k)*rho0(i,j,k-1)+c2(i,j,k)*rho0(i,j,k)
      enddo
      enddo
      enddo

      do j=jb,je
      do i=ib,ie
        ! cm1r17, 2nd-order extrapolation:
        rf0(i,j,1) = cgs1*rho0(i,j,1)+cgs2*rho0(i,j,2)+cgs3*rho0(i,j,3)
        rf0(i,j,0)=rf0(i,j,1)
        rho0s(i,j) = rf0(i,j,1)
        ! cm1r17, 2nd-order extrapolation:
        rf0(i,j,nk+1) = cgt1*rho0(i,j,nk)+cgt2*rho0(i,j,nk-1)+cgt3*rho0(i,j,nk-2)
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rrf0(i,j,k)=1.0/rf0(i,j,k)
      enddo
      enddo
      enddo

!        i = 1
!        j = 1
!        print *
!        print *,'  nk = ',nk
!        k = 1
!        print *,k,rf0(i,j,k)
!      do k=2,nk+1
!        print *,k,rf0(i,j,k),rf0(i,j,k)-rf0(i,j,k-1)
!      enddo
!        print *
!      stop 11111

!-----------------------------------------------------------------------
!  values at surface:

      ! Get surface p/T/q (for surface models and for CAPE calculation):

      IF( psurf.ge.tsmall .and. tsurf.ge.tsmall .and. (.not.terrain_flag) )THEN
        ! this section of code only if no terrain
#ifdef MPI
        call MPI_BCAST(psurf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(tsurf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(qsurf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
#endif
        thsurf = tsurf/( (psurf*rp00)**rovcp )
        do j=jb,je
        do i=ib,ie
          prs0s(i,j) = psurf
          pi0s(i,j) = (psurf*rp00)**rovcp
          rth0s(i,j) = thsurf**(-1)
        enddo
        enddo
      ELSE
        do j=jb,je
        do i=ib,ie
          thsurf = cgs1*th0(i,j,1)+cgs2*th0(i,j,2)+cgs3*th0(i,j,3)
           qsurf = cgs1*qv0(i,j,1)+cgs2*qv0(i,j,2)+cgs3*qv0(i,j,3)
          thvsurf = thsurf*(1.0+qsurf*reps)/(1.0+qsurf)
          ! use hydrostatic equation:
          pi0s(i,j) = pi0(i,j,1)+zh(i,j,1)*g/(cp*0.5*(thvsurf+thv0(i,j,1)))
          prs0s(i,j) = p00*( pi0s(i,j)**(cp/rd) )
          rth0s(i,j) = thsurf**(-1)
        enddo
        enddo
      ENDIF

      i = 1
      j = 1
      if( psurf.lt.tsmall ) psurf = prs0s(i,j)
      if( tsurf.le.tsmall ) tsurf = cgs1*t0(i,j,1)+cgs2*t0(i,j,2)+cgs3*t0(i,j,3)
      if( qsurf.le.tsmall ) qsurf = cgs1*qv0(i,j,1)+cgs2*qv0(i,j,2)+cgs3*qv0(i,j,3)
      thsurf = tsurf/( (psurf*rp00)**rovcp )


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  Start definition of base state wind (iwnd option)  ccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!-----------------------------------------------------------------------
!  Get wind profiles  ...  assume zero wind to start

!--------------------------
! 061012:
! Ignore this section if isnd = 7;  in that case, wind profile has
! already been retrieved from the input_sounding file
!--------------------------

    IF(isnd.ne.7)THEN

      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        u0(i,j,k)= 0.0
      enddo
      enddo
      enddo

      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        v0(i,j,k)= 0.0
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  iwnd = 1
!  RKW-type wind profile
!  reference: Rotunno, Klemp, and Weisman, 1988, JAS, 463-485.

      if(iwnd.eq.1)then

        udep1   =     0.0    ! height of bottom of shear layer (m)
        udep2   =  2500.0    ! height of top of shear layer (m)
        uconst1 =     0.0    ! u at bottom of shear layer
        uconst2 =    10.0    ! u at top of shear layer

        do k=1,nk
        do j=0,nj+1
        do i=0,ni+2
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.lt.udep1)then
            u0(i,j,k)=uconst1
          elseif(zu.gt.udep1 .and. zu.lt.udep2)then
            u0(i,j,k)=(uconst2-uconst1)*(zu-udep1)/(udep2-udep1)+uconst1
          else
            u0(i,j,k)=uconst2
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=0,nj+2
        do i=0,ni+1
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          v0(i,j,k)=0.0
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 2
!  Weisman-Klemp type supercell profile

      elseif(iwnd.eq.2)then

        udep1=2000.0
        udep2=6000.0
        umax1=7.0
        umax2=31.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.le.udep1)THEN
            ANGLE=90.0*(zu/udep1)*(pi/180.0)
            u0(i,j,k)=umax1-umax1*cos(ANGLE)
          elseif(zu.gt.udep1 .and. zu.le.udep2)THEN
            u0(i,j,k)=umax1+(zu-udep1)*(umax2-umax1)/(udep2-udep1)
          ELSE
            u0(i,j,k)=umax2
          ENDIF
        enddo
        enddo
        enddo

        vmax1=umax1

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          if(zv.le.udep1)THEN
            ANGLE=90.0*(zv/udep1)*(pi/180.0)
            v0(i,j,k)=vmax1*SIN(ANGLE)
          elseif(zv.gt.udep1 .and. zv.le.udep2)THEN
            v0(i,j,k)=vmax1
          ELSE
            v0(i,j,k)=vmax1
          ENDIF
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 3
!  Mulit-cell type profile (?)

      elseif(iwnd.eq.3)then

        udep1=0.0
        udep2=7500.0
        umax1=-40.0/pi
        umax2=40.0/pi+40.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.le.udep2)then
            u0(i,j,k)=umax1+(zu-udep1)*(umax2-umax1)/(udep2-udep1)
          else
            u0(i,j,k)=umax2
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          v0(i,j,k)=40.0/pi
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 4
!  Multi-cell
!  reference:  Weisman and Klemp, 1982, MWR, 110, 504-520.

      elseif(iwnd.eq.4)then

        umax1=35.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u0(i,j,k)=umax1*tanh(0.5*(zh(i-1,j,k)+zh(i,j,k))/3000.0)
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          v0(i,j,k)=0.
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 5
!  reference:  Dornbrack et al., 2005, Atmos. Sci. Let., 6, 118-122

      elseif(iwnd.eq.5)then

        umax  =   15.0
        udep1 = 4000.0
        udep2 = 6000.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.lt.udep1)then
            u0(i,j,k) = umax
          elseif(zu.lt.udep2)then
            alpha=0.25*pi*(1.0+cos(pi*(zu-udep1)/(udep2-udep1)))
            u0(i,j,k) = umax*sin(alpha)
          else
            u0(i,j,k) = 0.0
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          if(zv.lt.udep1)then
            v0(i,j,k) = 0.0
          elseif(zv.lt.udep2)then
            alpha=0.25*pi*(1.0+cos(pi*(zv-udep1)/(udep2-udep1)))
            v0(i,j,k) = umax*cos(alpha)
          else
            v0(i,j,k) = umax
          endif
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 6
!  constant wind

      ELSEIF(iwnd.eq.6)THEN

        do k=kb,ke
        do j=jb,je
        do i=ib,ie+1
          u0(i,j,k) = 10.0
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je+1
        do i=ib,ie
          v0(i,j,k) =  0.0
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------

      ENDIF    ! endif for iwnd options

    ENDIF   ! endif for isnd=7 check


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!-----------------------------------------------------------------------
!  subtract off umove and vmove (if applicable)

      if(imove.eq.1)then
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          u0(i,j,k)=u0(i,j,k)-umove
          v0(i,j,k)=v0(i,j,k)-vmove
        enddo
        enddo
        enddo
      else
        umove=0.0
        vmove=0.0
      endif

!-----------------------------------------------------------------------
!  Fill in ghost cells

      call bcu(u0)
      call bcv(v0)

      !--------
#ifdef MPI
      call comm_3u_start(u0,uw31,uw32,ue31,ue32,   &
                            us31,us32,un31,un32,reqs_u)
      call comm_3u_end(u0,uw31,uw32,ue31,ue32,   &
                          us31,us32,un31,un32,reqs_u)
      call getcorneru3(u0,n3w1(1,1,1),n3w2(1,1,1),n3e1(1,1,1),n3e2(1,1,1),  &
                          s3w1(1,1,1),s3w2(1,1,1),s3e1(1,1,1),s3e2(1,1,1))
      call bcu2(u0)
#endif
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=jb,je
      do i=ib,ie+1
        u0(i,j,0)    = cgs1*u0(i,j,1)+cgs2*u0(i,j,2)+cgs3*u0(i,j,3)
        u0(i,j,nk+1) = cgt1*u0(i,j,nk)+cgt2*u0(i,j,nk-1)+cgt3*u0(i,j,nk-2)
      enddo
      enddo
      !--------
#ifdef MPI
      call comm_3v_start(v0,vw31,vw32,ve31,ve32,   &
                            vs31,vs32,vn31,vn32,reqs_v)
      call comm_3v_end(v0,vw31,vw32,ve31,ve32,   &
                          vs31,vs32,vn31,vn32,reqs_v)
      call getcornerv3(v0,n3w1(1,1,1),n3w2(1,1,1),n3e1(1,1,1),n3e2(1,1,1),  &
                          s3w1(1,1,1),s3w2(1,1,1),s3e1(1,1,1),s3e2(1,1,1))
      call bcv2(v0)
#endif
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=jb,je+1
      do i=ib,ie
        v0(i,j,0)    = cgs1*v0(i,j,1)+cgs2*v0(i,j,2)+cgs3*v0(i,j,3)
        v0(i,j,nk+1) = cgt1*v0(i,j,nk)+cgt2*v0(i,j,nk-1)+cgt3*v0(i,j,nk-2)
      enddo
      enddo
      !--------

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  End definition of base state wind (iwnd option)  ccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!---------------------------------------------------------------------

!  Print out base state

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,101)
      if(dowr) write(outfile,102)
      do k=1,nk
        if(dowr) write(outfile,103) k,prs0(1,1,k),pi0(1,1,k),rho0(1,1,k)
      enddo
      if(dowr) write(outfile,*)

101   format(7x,'k    prs0 (Pa)        pi0        rho0 (kg/m^3)')
102   format(4x,'---------------------------------------------------------------------')
103   format(4x,i4,4x,f9.2,4x,f10.7,4x,f10.7)

!-----

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,104)
      if(dowr) write(outfile,102)
      do k=1,nk
        if(dowr) write(outfile,105) k,th0(1,1,k),thv0(1,1,k),t0(1,1,k),   &
                   -1000*(t0(1,1,k)-t0(1,1,k-1))*rdz*mh(1,1,k),  &
                    1.0e4*g*alog(thv0(1,1,k)/thv0(1,1,k-1))*rdz*mh(1,1,k)
      enddo
      if(dowr) write(outfile,*)

104   format(7x,'k    th0 (K)     thv0 (K)     t0 (K)     l.r. (K/km)     N^2')
105   format(4x,i4,4x,f8.4,4x,f8.4,4x,f8.4,4x,f9.4,4x,f8.4)

!-----
! Ri check ... warn user if Ri < 0.25, but do not stop model
! 061021: added N^2 check ... stop model if N^2 < 0

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Richardson number:  NOTE!!!  Ri should be > 0.25 for most applications!'
      if(dowr) write(outfile,*)
      do k=2,nk
        nm = g*alog(thv0(1,1,k)/thv0(1,1,k-1))*rdz*mf(1,1,k)
        if(nm .lt. -1.0e-12)then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  k,z,N^2:',k,0.5*(zh(1,1,k-1)+zh(1,1,k)),nm
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) ' Warning.  N^2 (Brunt-Vaisala frequency squared) is less than zero!'
          if(dowr) write(outfile,*) ' This is really, really not recommended for the base state.'
          if(dowr) write(outfile,*) ' Stopping model ....'
          if(dowr) write(outfile,*)
          call stopcm1
        endif
        dudz = (u0(1,1,k)-u0(1,1,k-1))*rdz*mf(1,1,k)
        dvdz = (v0(1,1,k)-v0(1,1,k-1))*rdz*mf(1,1,k)
        rinum = nm/(1.0e-12+dudz*dudz+dvdz*dvdz)
        if(rinum.gt.0.25)then
          if(dowr) write(outfile,*) '  k,z,Ri:',k,0.5*(zh(1,1,k-1)+zh(1,1,k)),rinum
        else
          if(dowr) write(outfile,*) '  k,z,Ri:',k,0.5*(zh(1,1,k-1)+zh(1,1,k)),rinum,'<---- NOTE!  Ri < 0.25'
        endif
      enddo
      if(dowr) write(outfile,*)

!-----

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,106)
      if(dowr) write(outfile,102)
      do k=1,nk
        if(rh0(1,1,k).gt.0.999 .or. rh0(1,1,k).lt.0.0001 .or. imoist.eq.0)then
          tlcl=t0(1,1,k)
        else
          tlcl=55.0+(2840./(3.5*alog(t0(1,1,k))-    &
                   alog(0.01*prs0(1,1,k)*qv0(1,1,k)/(0.622+qv0(1,1,k)))-4.805))
        endif
        if(dowr) write(outfile,107) k,                                              &
            th0(1,1,k)*exp((3376./tlcl-2.54)*qv0(1,1,k)*(1.0+0.81*qv0(1,1,k))),  &
            rh0(1,1,k),qv0(1,1,k),qc0(1,1,k),qi0(1,1,k)
      enddo
      if(dowr) write(outfile,*)

106   format(7x,'k  theta-e (K)       rh0          qv0          qc0          qi0')
107   format(4x,i4,4x,f8.4,4x,f9.6,4x,f9.6,4x,f9.6,4x,f9.6)

!------------------------------------------------------------------
!  Get CAPE,CIN,etc:

  IF(imoist.eq.1)THEN

    allocate(  pfoo(nk+1) )
    allocate(  tfoo(nk+1) )
    allocate( qvfoo(nk+1) )

    pfoo(1) = psurf * 0.01
    tfoo(1) = tsurf - 273.15
   qvfoo(1) = max( qsurf , 1.0e-20 )

    do k=1,nk
      pfoo(k+1) = 0.01*prs0(1,1,k)
      tfoo(k+1) = t0(1,1,k) - 273.15
      qvfoo(k+1) = max( qv0(1,1,k) , 1.0e-20 )
    enddo

    if(dowr) write(outfile,*)
    if(dowr) write(outfile,*) '  Thermodynamic properties of base-state sounding:'
  IF(terrain_flag)THEN
    if(dowr) write(outfile,*) '    (for lower-left corner of domain:  i=1,j=1)  '
  ENDIF
    if(dowr) write(outfile,*)
    do n=1,3
      call getcape( n , nk+1 , pfoo , tfoo , qvfoo , cape , cin ,   &
                    zlcl, zlfc, zel , psource , tsource , qvsource )
      if(n.eq.1)then
        if(dowr) write(outfile,*) '    for surface parcel:'
      elseif(n.eq.2)then
        if(dowr) write(outfile,*) '    for most-unstable parcel:'
      elseif(n.eq.3)then
        if(dowr) write(outfile,*) '    for mixed-layer parcel:'
      endif
      if(dowr) write(outfile,116) 0.01*psource,tsource,1000.0*qvsource
      if(dowr) write(outfile,118) zlcl,zlfc,zel
      if(dowr) write(outfile,117) cape,cin
116   format('        source p(mb),T(K),qv(g/kg) = ',3(4x,f6.1))
118   format('        LCL,LFC,EL (m AGL)         = ',3(3x,f7.1))
117   format('        CAPE,CIN (J/kg)            = ',2(4x,f6.1))
      if(dowr) write(outfile,*)
    enddo
    if(dowr) write(outfile,*)

    deallocate(  pfoo )
    deallocate(  tfoo )
    deallocate( qvfoo )

  ENDIF

!------------------------------------------------------------------

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,108)
      if(dowr) write(outfile,102)
      do k=1,nk
        if(dowr) write(outfile,109) k,u0(1,1,k),v0(1,1,k)
      enddo
      if(dowr) write(outfile,*)

108   format(7x,'k     u0 (m/s)     v0 (m/s)')
109   format(4x,i4,4x,f9.4,4x,f9.4)

!------------------------------------------------------------------

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          rth0(i,j,k)=1.0/th0(i,j,k)
        enddo
        enddo
        enddo

!--------------------------------------------------------------

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  psurf,tsurf  = ',psurf,tsurf
      if(dowr) write(outfile,*) '  qsurf,thsurf = ',qsurf,thsurf
      if(dowr) write(outfile,*)

      dothis = .false.
      IF( dothis )THEN
      IF( myid.eq.0 )THEN

        open(unit=21,file='input_sounding_grid')
        i = 1
        j = 1
        write(21,123) 0.01*psurf,thsurf,1000.0*qsurf
123     format(2x,f11.4,2x,f11.4,2x,f10.6)
124     format(2x,f11.4,2x,f11.4,2x,f10.6,2x,f11.4,2x,f11.4)
        do k=1,nk
          write(21,124) zh(i,j,k),th0(i,j,k),1000.0*qv0(i,j,k),u0(i,j,k),v0(i,j,k)
        enddo
          write(21,124) cgt1*zh(i,j,nk)+cgt2*zh(i,j,nk-1)+cgt3*zh(i,j,nk-2),     &
                        cgt1*th0(i,j,nk)+cgt2*th0(i,j,nk-1)+cgt3*th0(i,j,nk-2),  &
                1000.0*(cgt1*qv0(i,j,nk)+cgt2*qv0(i,j,nk-1)+cgt3*qv0(i,j,nk-2)), &
                        cgt1*u0(i,j,nk)+cgt2*u0(i,j,nk-1)+cgt3*u0(i,j,nk-2),     &
                        cgt1*v0(i,j,nk)+cgt2*v0(i,j,nk-1)+cgt3*v0(i,j,nk-2)
        close(unit=21)

      ENDIF
      ENDIF

!------------------------------------------------------------------

      if(dowr) write(outfile,*) 'Leaving BASE'

      return
      end subroutine base

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

    real function getthe(ttype,p,t,qv,qt)
    implicit none
    include 'constants.incl'
    integer ttype
    real p,t,qv,qt

    ! Assumes air is saturated

    real :: pd,cpm,lhv

    getthe = 0.0

  IF(ttype.eq.1)THEN
    pd=p/(1.0+reps*qv)
    cpm=cp+cpl*qt
    lhv=lv1-lv2*t
    getthe=t*((p00/pd)**(rd/cpm))*exp(lhv*qv/(cpm*t))
  ELSEIF(ttype.eq.2)THEN
    getthe=t*( (p00/p)**(0.2854*(1.0-0.28*qv)) )   &
            *exp( ((3376.0/t)-2.54)*qv*(1.0+0.81*qv) )
  ENDIF
    end function getthe

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

    subroutine revthe(ttype,the,p,qt,t,qv)
    implicit none
    include 'constants.incl'
    integer ttype
    real the,p,qt,rh,t,qv

    ! Assumes air is saturated
    ! Input:   the,p,qt  (t is first guess value upon input)
    ! Output:  t,qv

    integer n
    real tlast,tinc,pd,cpm,lhv,thx,diff
    real rslf

    n=1
    tlast=t
    tinc=0.0
250 continue
      t=tlast+tinc
      qv=rslf(p,t)
    IF(ttype.eq.1)THEN
      pd=p/(1.0+reps*qv)
      cpm=cp+cpl*qt
      lhv=lv1-lv2*t
      thx=t*((p00/pd)**(rd/cpm))*exp(lhv*qv/(cpm*t))
    ELSEIF(ttype.eq.2)THEN
      thx=t*( (p00/p)**(0.2854*(1.0-0.28*qv)) )   &
           *exp( ((3376.0/t)-2.54)*qv*(1.0+0.81*qv) )
    ENDIF

      diff=the-thx
      if(n.ge.40) print *,n,p,the,thx
      if(abs(diff).gt.0.0001 .and. n.lt.50)then
        n=n+1
        tinc=0.30*diff
        tlast=t
        if(abs(tinc).ge.0.0001) go to 250
      elseif(n.ge.50)then
        print *,'n exceeded 50!'
        print *,'n=',n
        stop 1222
      endif

    return
    end subroutine revthe

bc.F            1587424407  1602  20    100644  71278     `
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bc2d(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je) :: s

      integer i,j

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(   0,j)=s(ni  ,j)
          s(  -1,j)=s(ni-1,j)
          s(  -2,j)=s(ni-2,j)
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(   0,j)=s( 1,j)
          s(  -1,j)=s( 1,j)
          s(  -2,j)=s( 1,j)
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.(wbc.eq.3.or.wbc.eq.4))then
#else
      elseif(wbc.eq.3.or.wbc.eq.4)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(   0,j)=s(   1,j)
          s(  -1,j)=s(   2,j)
          s(  -2,j)=s(   3,j)
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(ni+1,j)=s(   1,j)
          s(ni+2,j)=s(   2,j)
          s(ni+3,j)=s(   3,j)
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.(ebc.eq.3.or.ebc.eq.4))then
#else
      elseif(ebc.eq.3.or.ebc.eq.4)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(ni+1,j)=s(  ni,j)
          s(ni+2,j)=s(ni-1,j)
          s(ni+3,j)=s(ni-2,j)
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,   0)=s(i,nj  )
          s(i,  -1)=s(i,nj-1)
          s(i,  -2)=s(i,nj-2)
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,   0)=s(i, 1)
          s(i,  -1)=s(i, 1)
          s(i,  -2)=s(i, 1)
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.(sbc.eq.3.or.sbc.eq.4))then
#else
      elseif(sbc.eq.3.or.sbc.eq.4)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,   0)=s(i, 1)
          s(i,  -1)=s(i, 2)
          s(i,  -2)=s(i, 3)
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,nj+1)=s(i,   1)
          s(i,nj+2)=s(i,   2)
          s(i,nj+3)=s(i,   3)
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.(nbc.eq.3.or.nbc.eq.4))then
#else
      elseif(nbc.eq.3.or.nbc.eq.4)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,nj+1)=s(i,nj  )
          s(i,nj+2)=s(i,nj-1)
          s(i,nj+3)=s(i,nj-2)
        enddo
      endif

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcs(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    DO k=1,nk

#ifndef MPI
      if(wbc.eq.1)then
        do j=jb,je
          s(   0,j,k)=s(ni  ,j,k)
          s(  -1,j,k)=s(ni-1,j,k)
          s(  -2,j,k)=s(ni-2,j,k)
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
        do j=0,nj+1
          s(   0,j,k)=s( 1,j,k)
          s(  -1,j,k)=s( 1,j,k)
          s(  -2,j,k)=s( 1,j,k)
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.(wbc.eq.3.or.wbc.eq.4))then
#else
      elseif(wbc.eq.3.or.wbc.eq.4)then
#endif
        do j=0,nj+1
          s(   0,j,k)=s(   1,j,k)
          s(  -1,j,k)=s(   2,j,k)
          s(  -2,j,k)=s(   3,j,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
        do j=jb,je
          s(ni+1,j,k)=s(   1,j,k)
          s(ni+2,j,k)=s(   2,j,k)
          s(ni+3,j,k)=s(   3,j,k)
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
        do j=0,nj+1
          s(ni+1,j,k)=s(ni,j,k)
          s(ni+2,j,k)=s(ni,j,k)
          s(ni+3,j,k)=s(ni,j,k)
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.(ebc.eq.3.or.ebc.eq.4))then
#else
      elseif(ebc.eq.3.or.ebc.eq.4)then
#endif
        do j=0,nj+1
          s(ni+1,j,k)=s(  ni,j,k)
          s(ni+2,j,k)=s(ni-1,j,k)
          s(ni+3,j,k)=s(ni-2,j,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
        do i=ib,ie
          s(i,   0,k)=s(i,nj  ,k)
          s(i,  -1,k)=s(i,nj-1,k)
          s(i,  -2,k)=s(i,nj-2,k)
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
        do i=0,ni+1
          s(i,   0,k)=s(i, 1,k)
          s(i,  -1,k)=s(i, 1,k)
          s(i,  -2,k)=s(i, 1,k)
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.(sbc.eq.3.or.sbc.eq.4))then
#else
      elseif(sbc.eq.3.or.sbc.eq.4)then
#endif
        do i=0,ni+1
          s(i,   0,k)=s(i, 1,k)
          s(i,  -1,k)=s(i, 2,k)
          s(i,  -2,k)=s(i, 3,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
        do i=ib,ie
          s(i,nj+1,k)=s(i,   1,k)
          s(i,nj+2,k)=s(i,   2,k)
          s(i,nj+3,k)=s(i,   3,k)
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
        do i=0,ni+1
          s(i,nj+1,k)=s(i,nj,k)
          s(i,nj+2,k)=s(i,nj,k)
          s(i,nj+3,k)=s(i,nj,k)
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.(nbc.eq.3.or.nbc.eq.4))then
#else
      elseif(nbc.eq.3.or.nbc.eq.4)then
#endif
        do i=0,ni+1
          s(i,nj+1,k)=s(i,nj  ,k)
          s(i,nj+2,k)=s(i,nj-1,k)
          s(i,nj+3,k)=s(i,nj-2,k)
        enddo
      endif

    ENDDO

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcp(p)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: p

      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition

      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(   0,j,k)=p(ni  ,j,k)
          p(  -1,j,k)=p(ni-1,j,k)
          p(  -2,j,k)=p(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(  -1,j,k)=p( 0,j,k)
          p(  -2,j,k)=p( 0,j,k)
        enddo
        enddo
      elseif(wbc.eq.3.or.wbc.eq.4)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(   0,j,k)=p(   1,j,k)
          p(  -1,j,k)=p(   2,j,k)
          p(  -2,j,k)=p(   3,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(ni+1,j,k)=p(   1,j,k)
          p(ni+2,j,k)=p(   2,j,k)
          p(ni+3,j,k)=p(   3,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(ni+2,j,k)=p(ni+1,j,k)
          p(ni+3,j,k)=p(ni+1,j,k)
        enddo
        enddo
      elseif(ebc.eq.3.or.ebc.eq.4)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(ni+1,j,k)=p(  ni,j,k)
          p(ni+2,j,k)=p(ni-1,j,k)
          p(ni+3,j,k)=p(ni-2,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          p(i,   0,k)=p(i,nj  ,k)
          p(i,  -1,k)=p(i,nj-1,k)
          p(i,  -2,k)=p(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,  -1,k)=p(i, 0,k)
          p(i,  -2,k)=p(i, 0,k)
        enddo
        enddo
      elseif(sbc.eq.3.or.sbc.eq.4)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,   0,k)=p(i, 1,k)
          p(i,  -1,k)=p(i, 2,k)
          p(i,  -2,k)=p(i, 3,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          p(i,nj+1,k)=p(i,   1,k)
          p(i,nj+2,k)=p(i,   2,k)
          p(i,nj+3,k)=p(i,   3,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,nj+2,k)=p(i,nj+1,k)
          p(i,nj+3,k)=p(i,nj+1,k)
        enddo
        enddo
      elseif(nbc.eq.3.or.nbc.eq.4)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,nj+1,k)=p(i,nj  ,k)
          p(i,nj+2,k)=p(i,nj-1,k)
          p(i,nj+3,k)=p(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcu(u)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'  

      real, dimension(ib:ie+1,jb:je,kb:ke) :: u

      integer i,j,k  

!-----------------------------------------------------------------------
!  west boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    DO k=1,nk

#ifndef MPI
      if(wbc.eq.1)then
        do j=jb,je
          u(   0,j,k)=u(ni  ,j,k)
          u(  -1,j,k)=u(ni-1,j,k)
          u(  -2,j,k)=u(ni-2,j,k)
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
        do j=0,nj+1
          u(   0,j,k)=u(1,j,k)
          u(  -1,j,k)=u(1,j,k)
          u(  -2,j,k)=u(1,j,k)
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.(wbc.eq.3.or.wbc.eq.4))then
#else
      elseif(wbc.eq.3.or.wbc.eq.4)then
#endif
        do j=0,nj+1
          u(   1,j,k)=0.
          u(   0,j,k)=-u(   2,j,k)
          u(  -1,j,k)=-u(   3,j,k)
          u(  -2,j,k)=-u(   4,j,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
        do j=jb,je
          u(ni+2,j,k)=u(2,j,k)
          u(ni+3,j,k)=u(3,j,k)
          u(ni+4,j,k)=u(4,j,k)
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
        do j=0,nj+1
          u(ni+2,j,k)=u(ni+1,j,k)
          u(ni+3,j,k)=u(ni+1,j,k)
          u(ni+4,j,k)=u(ni+1,j,k)
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.(ebc.eq.3.or.ebc.eq.4))then
#else
      elseif(ebc.eq.3.or.ebc.eq.4)then
#endif
        do j=0,nj+1
          u(ni+1,j,k)=0.0
          u(ni+2,j,k)=-u(ni  ,j,k)
          u(ni+3,j,k)=-u(ni-1,j,k)
          u(ni+4,j,k)=-u(ni-2,j,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
        do i=ib,ie+1
          u(i,   0,k)=u(i,nj  ,k)
          u(i,  -1,k)=u(i,nj-1,k)
          u(i,  -2,k)=u(i,nj-2,k)
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
        do i=0,ni+2
          u(i,   0,k)=u(i, 1,k)
          u(i,  -1,k)=u(i, 1,k)
          u(i,  -2,k)=u(i, 1,k)
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.(sbc.eq.3.or.sbc.eq.4))then
#else
      elseif(sbc.eq.3.or.sbc.eq.4)then
#endif
        do i=0,ni+2
          u(i,   0,k)=u(i, 1,k)
          u(i,  -1,k)=u(i, 2,k)
          u(i,  -2,k)=u(i, 3,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
        do i=ib,ie+1
          u(i,nj+1,k)=u(i,   1,k)
          u(i,nj+2,k)=u(i,   2,k)
          u(i,nj+3,k)=u(i,   3,k)
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
        do i=0,ni+2
          u(i,nj+1,k)=u(i,nj,k)
          u(i,nj+2,k)=u(i,nj,k)
          u(i,nj+3,k)=u(i,nj,k)
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.(nbc.eq.3.or.nbc.eq.4))then
#else
      elseif(nbc.eq.3.or.nbc.eq.4)then
#endif
        do i=0,ni+2
          u(i,nj+1,k)=u(i,nj  ,k)
          u(i,nj+2,k)=u(i,nj-1,k)
          u(i,nj+3,k)=u(i,nj-2,k)
        enddo
      endif

    ENDDO

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcv(v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v
 
      integer i,j,k

!-----------------------------------------------------------------------
!  south boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    DO k=1,nk

#ifndef MPI
      if(sbc.eq.1)then
        do i=ib,ie
          v(i,   0,k)=v(i,nj  ,k)
          v(i,  -1,k)=v(i,nj-1,k)
          v(i,  -2,k)=v(i,nj-2,k)
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
        do i=0,ni+1
          v(i,   0,k)=v(i,1,k)
          v(i,  -1,k)=v(i,1,k)
          v(i,  -2,k)=v(i,1,k)
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.(sbc.eq.3.or.sbc.eq.4))then
#else
      elseif(sbc.eq.3.or.sbc.eq.4)then
#endif
        do i=0,ni+1
          v(i,   1,k)=0.
          v(i,   0,k)=-v(i,2,k)
          v(i,  -1,k)=-v(i,3,k)
          v(i,  -2,k)=-v(i,4,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

      IF(axisymm.eq.1)THEN
        do i=ib,ie
          v(i,2,k)=v(i,1,k)
        enddo
      ENDIF

#ifndef MPI
      if(nbc.eq.1)then
        do i=ib,ie
          v(i,nj+2,k)=v(i,   2,k)
          v(i,nj+3,k)=v(i,   3,k)
          v(i,nj+4,k)=v(i,   4,k)
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
        do i=0,ni+1
          v(i,nj+2,k)=v(i,nj+1,k)
          v(i,nj+3,k)=v(i,nj+1,k)
          v(i,nj+4,k)=v(i,nj+1,k)
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.(nbc.eq.3.or.nbc.eq.4))then
#else
      elseif(nbc.eq.3.or.nbc.eq.4)then
#endif
        do i=0,ni+1
          v(i,nj+1,k)=0.
          v(i,nj+2,k)=-v(i,nj  ,k)
          v(i,nj+3,k)=-v(i,nj-1,k)
          v(i,nj+4,k)=-v(i,nj-2,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
        do j=jb,je+1
          v(   0,j,k)=v(ni  ,j,k)
          v(  -1,j,k)=v(ni-1,j,k)
          v(  -2,j,k)=v(ni-2,j,k)
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
        do j=0,nj+2
          v(   0,j,k)=v( 1,j,k)
          v(  -1,j,k)=v( 1,j,k)
          v(  -2,j,k)=v( 1,j,k)
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.(wbc.eq.3.or.wbc.eq.4))then
#else
      elseif(wbc.eq.3.or.wbc.eq.4)then
#endif
        do j=0,nj+2
          v(   0,j,k)=v( 1,j,k)
          v(  -1,j,k)=v( 2,j,k)
          v(  -2,j,k)=v( 3,j,k)
        enddo
      endif

      IF(axisymm.eq.1)THEN
        do j=0,nj+2
          v( 0,j,k) = -v(1,j,k)
          v(-1,j,k) = -v(2,j,k)
          v(-2,j,k) = -v(3,j,k)
        enddo
      ENDIF

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
        do j=jb,je+1
          v(ni+1,j,k)=v(   1,j,k)
          v(ni+2,j,k)=v(   2,j,k)
          v(ni+3,j,k)=v(   3,j,k)
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
        do j=0,nj+2
          v(ni+1,j,k)=v(ni,j,k)
          v(ni+2,j,k)=v(ni,j,k)
          v(ni+3,j,k)=v(ni,j,k)
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.(ebc.eq.3.or.ebc.eq.4))then
#else
      elseif(ebc.eq.3.or.ebc.eq.4)then
#endif
        do j=0,nj+2
          v(ni+1,j,k)=v(ni  ,j,k)
          v(ni+2,j,k)=v(ni-1,j,k)
          v(ni+3,j,k)=v(ni-2,j,k)
        enddo
      endif

    ENDDO

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcw(w,flag)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w
      integer flag
 
      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    DO k=2,nk
 
#ifndef MPI
      if(wbc.eq.1)then
        do j=jb,je
          w(   0,j,k)=w(ni  ,j,k)
          w(  -1,j,k)=w(ni-1,j,k)
          w(  -2,j,k)=w(ni-2,j,k)
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
        do j=0,nj+1
          w(   0,j,k)=w( 1,j,k)
          w(  -1,j,k)=w( 1,j,k)
          w(  -2,j,k)=w( 1,j,k)
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.(wbc.eq.3.or.wbc.eq.4))then
#else
      elseif(wbc.eq.3.or.wbc.eq.4)then
#endif
        do j=0,nj+1
          w(   0,j,k)=w( 1,j,k)
          w(  -1,j,k)=w( 2,j,k)
          w(  -2,j,k)=w( 3,j,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
        do j=jb,je
          w(ni+1,j,k)=w(   1,j,k)
          w(ni+2,j,k)=w(   2,j,k)
          w(ni+3,j,k)=w(   3,j,k)
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
        do j=0,nj+1
          w(ni+1,j,k)=w(ni,j,k)
          w(ni+2,j,k)=w(ni,j,k)
          w(ni+3,j,k)=w(ni,j,k)
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.(ebc.eq.3.or.ebc.eq.4))then
#else
      elseif(ebc.eq.3.or.ebc.eq.4)then
#endif
        do j=0,nj+1
          w(ni+1,j,k)=w(ni  ,j,k)
          w(ni+2,j,k)=w(ni-1,j,k)
          w(ni+3,j,k)=w(ni-2,j,k)
        enddo 
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
        do i=ib,ie
          w(i,   0,k)=w(i,nj  ,k)
          w(i,  -1,k)=w(i,nj-1,k)
          w(i,  -2,k)=w(i,nj-2,k)
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
        do i=0,ni+1
          w(i,   0,k)=w(i, 1,k)
          w(i,  -1,k)=w(i, 1,k)
          w(i,  -2,k)=w(i, 1,k)
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.(sbc.eq.3.or.sbc.eq.4))then
#else
      elseif(sbc.eq.3.or.sbc.eq.4)then
#endif
        do i=0,ni+1
          w(i,   0,k)=w(i, 1,k)
          w(i,  -1,k)=w(i, 2,k)
          w(i,  -2,k)=w(i, 3,k)
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
        do i=ib,ie
          w(i,nj+1,k)=w(i,   1,k)
          w(i,nj+2,k)=w(i,   2,k)
          w(i,nj+3,k)=w(i,   3,k)
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
        do i=0,ni+1
          w(i,nj+1,k)=w(i,nj,k)
          w(i,nj+2,k)=w(i,nj,k)
          w(i,nj+3,k)=w(i,nj,k)
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.(nbc.eq.3.or.nbc.eq.4))then
#else
      elseif(nbc.eq.3.or.nbc.eq.4)then
#endif
        do i=0,ni+1
          w(i,nj+1,k)=w(i,nj  ,k)
          w(i,nj+2,k)=w(i,nj-1,k)
          w(i,nj+3,k)=w(i,nj-2,k)
        enddo
      endif

    ENDDO

!-----------------------------------------------------------------------
!  top/bottom boundary condition

    IF(flag.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        w(i,j, 1)=0.0
        w(i,j,nk+1)=0.0
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcwsfc(gz,dzdx,dzdy,u,v,w)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(itb:ite,jtb:jte) :: gz
      real, intent(in), dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: w

      integer :: i,j

!-----------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        w(i,j,1) = 0.5*( ( u(i,j,1)+u(i+1,j,1) )*dzdx(i,j) &
                        +( v(i,j,1)+v(i,j+1,1) )*dzdy(i,j) )*gz(i,j)
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine extrapbcs(s)
      implicit none

      include 'input.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: s

      integer :: i,j

      ! cm1r18 extrapolation formulation:
      ! assumes zh(0) is same as zf(1), and zh(nk+1) is same as zf(nk+1)

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=jb,je
      do i=ib,ie
        s(i,j,0)    = cgs1*s(i,j,1)+cgs2*s(i,j,2)+cgs3*s(i,j,3)
        s(i,j,nk+1) = cgt1*s(i,j,nk)+cgt2*s(i,j,nk-1)+cgt3*s(i,j,nk-2)
      enddo
      enddo

      end subroutine extrapbcs


#ifdef MPI
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcs2(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je,kb:ke)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(  -2,j,k)=s( 1,j,k)
            s(  -1,j,k)=s( 1,j,k)
            s(   0,j,k)=s( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(  -2,j,k)=s( 1,j,k)
            s(  -1,j,k)=s( 1,j,k)
            s(   0,j,k)=s( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(ni+1,j,k)=s(ni,j,k)
            s(ni+2,j,k)=s(ni,j,k)
            s(ni+3,j,k)=s(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(ni+1,j,k)=s(ni,j,k)
            s(ni+2,j,k)=s(ni,j,k)
            s(ni+3,j,k)=s(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,  -2,k)=s(i, 1,k)
            s(i,  -1,k)=s(i, 1,k)
            s(i,   0,k)=s(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,  -2,k)=s(i, 1,k)
            s(i,  -1,k)=s(i, 1,k)
            s(i,   0,k)=s(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,nj+1,k)=s(i,nj,k)
            s(i,nj+2,k)=s(i,nj,k)
            s(i,nj+3,k)=s(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,nj+1,k)=s(i,nj,k)
            s(i,nj+2,k)=s(i,nj,k)
            s(i,nj+3,k)=s(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bct2(t)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real t(ib:ie,jb:je,kb:ke+1)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(  -2,j,k)=t( 1,j,k)
            t(  -1,j,k)=t( 1,j,k)
            t(   0,j,k)=t( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(  -2,j,k)=t( 1,j,k)
            t(  -1,j,k)=t( 1,j,k)
            t(   0,j,k)=t( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(ni+1,j,k)=t(ni,j,k)
            t(ni+2,j,k)=t(ni,j,k)
            t(ni+3,j,k)=t(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(ni+1,j,k)=t(ni,j,k)
            t(ni+2,j,k)=t(ni,j,k)
            t(ni+3,j,k)=t(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,  -2,k)=t(i, 1,k)
            t(i,  -1,k)=t(i, 1,k)
            t(i,   0,k)=t(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,  -2,k)=t(i, 1,k)
            t(i,  -1,k)=t(i, 1,k)
            t(i,   0,k)=t(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,nj+1,k)=t(i,nj,k)
            t(i,nj+2,k)=t(i,nj,k)
            t(i,nj+3,k)=t(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,nj+1,k)=t(i,nj,k)
            t(i,nj+2,k)=t(i,nj,k)
            t(i,nj+3,k)=t(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcu2(u)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real u(ib:ie+1,jb:je,kb:ke)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(  -2,j,k)=u( 1,j,k)
            u(  -1,j,k)=u( 1,j,k)
            u(   0,j,k)=u( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(  -2,j,k)=u( 1,j,k)
            u(  -1,j,k)=u( 1,j,k)
            u(   0,j,k)=u( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(ni+2,j,k)=u(ni+1,j,k)
            u(ni+3,j,k)=u(ni+1,j,k)
            u(ni+4,j,k)=u(ni+1,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(ni+2,j,k)=u(ni+1,j,k)
            u(ni+3,j,k)=u(ni+1,j,k)
            u(ni+4,j,k)=u(ni+1,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,  -2,k)=u(i, 1,k)
            u(i,  -1,k)=u(i, 1,k)
            u(i,   0,k)=u(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,  -2,k)=u(i, 1,k)
            u(i,  -1,k)=u(i, 1,k)
            u(i,   0,k)=u(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,nj+1,k)=u(i,nj,k)
            u(i,nj+2,k)=u(i,nj,k)
            u(i,nj+3,k)=u(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,nj+1,k)=u(i,nj,k)
            u(i,nj+2,k)=u(i,nj,k)
            u(i,nj+3,k)=u(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcv2(v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real v(ib:ie,jb:je+1,kb:ke)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(  -2,j,k)=v( 1,j,k)
            v(  -1,j,k)=v( 1,j,k)
            v(   0,j,k)=v( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(  -2,j,k)=v( 1,j,k)
            v(  -1,j,k)=v( 1,j,k)
            v(   0,j,k)=v( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(ni+1,j,k)=v(ni,j,k)
            v(ni+2,j,k)=v(ni,j,k)
            v(ni+3,j,k)=v(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(ni+1,j,k)=v(ni,j,k)
            v(ni+2,j,k)=v(ni,j,k)
            v(ni+3,j,k)=v(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,  -2,k)=v(i, 1,k)
            v(i,  -1,k)=v(i, 1,k)
            v(i,   0,k)=v(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,  -2,k)=v(i, 1,k)
            v(i,  -1,k)=v(i, 1,k)
            v(i,   0,k)=v(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,nj+2,k)=v(i,nj+1,k)
            v(i,nj+3,k)=v(i,nj+1,k)
            v(i,nj+4,k)=v(i,nj+1,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,nj+2,k)=v(i,nj+1,k)
            v(i,nj+3,k)=v(i,nj+1,k)
            v(i,nj+4,k)=v(i,nj+1,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcw2(w)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real w(ib:ie,jb:je,kb:ke+1)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(  -2,j,k)=w( 1,j,k)
            w(  -1,j,k)=w( 1,j,k)
            w(   0,j,k)=w( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(  -2,j,k)=w( 1,j,k)
            w(  -1,j,k)=w( 1,j,k)
            w(   0,j,k)=w( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(ni+1,j,k)=w(ni,j,k)
            w(ni+2,j,k)=w(ni,j,k)
            w(ni+3,j,k)=w(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(ni+1,j,k)=w(ni,j,k)
            w(ni+2,j,k)=w(ni,j,k)
            w(ni+3,j,k)=w(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,  -2,k)=w(i, 1,k)
            w(i,  -1,k)=w(i, 1,k)
            w(i,   0,k)=w(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,  -2,k)=w(i, 1,k)
            w(i,  -1,k)=w(i, 1,k)
            w(i,   0,k)=w(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,nj+1,k)=w(i,nj,k)
            w(i,nj+2,k)=w(i,nj,k)
            w(i,nj+3,k)=w(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,nj+1,k)=w(i,nj,k)
            w(i,nj+2,k)=w(i,nj,k)
            w(i,nj+3,k)=w(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcs2_2d(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je)

      integer i,j

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          do j=-2,0
          s(  -2,j)=s( 1,j)
          s(  -1,j)=s( 1,j)
          s(   0,j)=s( 1,j)
          enddo
        endif

        if(patchnww)then
          do j=nj+1,nj+3
          s(  -2,j)=s( 1,j)
          s(  -1,j)=s( 1,j)
          s(   0,j)=s( 1,j)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          do j=-2,0
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
          enddo
        endif

        if(patchnee)then
          do j=nj+1,nj+3
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          do i=-2,0
          s(i,  -2)=s(i, 1)
          s(i,  -1)=s(i, 1)
          s(i,   0)=s(i, 1)
          enddo
        endif

        if(patchses)then
          do i=ni+1,ni+3
          s(i,  -2)=s(i, 1)
          s(i,  -1)=s(i, 1)
          s(i,   0)=s(i, 1)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          do i=-2,0
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
          enddo
        endif

        if(patchnen)then
          do i=ni+1,ni+3
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcew(radbcw,radbce,ua)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
 
      integer j,k
      real cbcw,cbce
 
      if(ibw.eq.1.and.wbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k,cbcw)
        do k=1,nk
        do j=1,nj
          cbcw=ua(1,j,k)-cstar
          if(cbcw.lt.0.0)then
            radbcw(j,k)=cbcw
          else
            radbcw(j,k)=0.
          endif
        enddo
        enddo
      endif
 
      if(ibe.eq.1.and.ebc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k,cbce)
        do k=1,nk
        do j=1,nj
          cbce=ua(ni+1,j,k)+cstar
          if(cbce.gt.0.0)then
            radbce(j,k)=cbce
          else
            radbce(j,k)=0.
          endif
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcns(radbcs,radbcn,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
 
      integer i,k
      real cbcs,cbcn

      if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k,cbcs)
        do k=1,nk
        do i=1,ni
          cbcs=va(i,1,k)-cstar
          if(cbcs.lt.0.0)then
            radbcs(i,k)=cbcs
          else
            radbcs(i,k)=0.
          endif
        enddo
        enddo
      endif
 
      if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k,cbcn)
        do k=1,nk
        do i=1,ni
          cbcn=va(i,nj+1,k)+cstar
          if(cbcn.gt.0.0)then
            radbcn(i,k)=cbcn
          else
            radbcn(i,k)=0.
          endif
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcew4(ruf,radbcw,radbce,u1,u2,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie+1) :: ruf
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u1,u2
      real dt

      integer j,k
      real umax,avgw,avge,foo,cbcw,cbce

      umax=csmax

      if(ibw.eq.1.and.wbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(j,k,foo,avgw,cbcw)
        do j=1,nj
          avgw=0.
          do k=1,nk
            foo=(u1(3,j,k)-u1(2,j,k))
            cbcw=dx*ruf(2)*(u1(2,j,k)-u2(2,j,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbcw=max(min(cbcw,0.0),-umax)
            avgw=avgw+cbcw
          enddo
          avgw=avgw/float(nk)
          do k=1,nk
            radbcw(j,k)=avgw
          enddo
        enddo
      endif

      if(ibe.eq.1.and.ebc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(j,k,foo,avge,cbce)
        do j=1,nj
          avge=0.
          do k=1,nk
            foo=(u1(ni+1-1,j,k)-u1(ni+1-2,j,k))
            cbce=dx*ruf(ni+1-1)*(u1(ni+1-1,j,k)-u2(ni+1-1,j,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbce=min(max(cbce,0.0),umax)
            avge=avge+cbce
          enddo
          avge=avge/float(nk)
          do k=1,nk
            radbce(j,k)=avge
          enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcns4(rvf,radbcs,radbcn,v1,v2,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(jb:je+1) :: rvf
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v1,v2
      real dt

      integer i,k
      real umax,avgs,avgn,foo,cbcs,cbcn

      umax=csmax

      if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k,avgs,foo,cbcs)
        do i=1,ni
          avgs=0.
          do k=1,nk
            foo=(v1(i,3,k)-v1(i,2,k))
            cbcs=dy*rvf(2)*(v1(i,2,k)-v2(i,2,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbcs=max(min(cbcs,0.0),-umax)
            avgs=avgs+cbcs
          enddo
          avgs=avgs/float(nk)
          do k=1,nk
            radbcs(i,k)=avgs
          enddo
        enddo
      endif

      if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k,avgn,foo,cbcn)
        do i=1,ni
          avgn=0.
          do k=1,nk
            foo=(v1(i,nj+1-1,k)-v1(i,nj+1-2,k))
            cbcn=dy*rvf(nj+1-1)*(v1(i,nj+1-1,k)-v2(i,nj+1-1,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbcn=min(max(cbcn,0.0),umax)
            avgn=avgn+cbcn
          enddo
          avgn=avgn/float(nk)
          do k=1,nk
            radbcn(i,k)=avgn
          enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine restrict_openbc_we(rvh,rmh,rho0,u3d)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u3d

      integer i,j,k
      double precision :: fluxout,fluxin,tem,u1,t3
      double precision, dimension(nk) :: temout,temin

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        temout(k) = 0.0d0
        temin(k)  = 0.0d0
      enddo

      if(wbc.eq.2.and.ibw.eq.1)then
        i=1
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          temout(k)=temout(k)-min(0.0,rho0(1,j,k)*u3d(i,j,k)*rvh(j)*rmh(1,j,k))
          temin(k) =temin(k) +max(0.0,rho0(1,j,k)*u3d(i,j,k)*rvh(j)*rmh(1,j,k))
        enddo
        enddo
      endif

      if(ebc.eq.2.and.ibe.eq.1)then
        i=ni+1
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          temout(k)=temout(k)+max(0.0,rho0(ni,j,k)*u3d(i,j,k)*rvh(j)*rmh(ni,j,k))
          temin(k) =temin(k) -min(0.0,rho0(ni,j,k)*u3d(i,j,k)*rvh(j)*rmh(ni,j,k))
        enddo
        enddo
      endif

      fluxout = 0.0d0
      fluxin  = 0.0d0

      do k=1,nk
        fluxout = fluxout + temout(k)
        fluxin  = fluxin  + temin(k)
      enddo

#ifdef MPI
      tem=0.0d0
      call MPI_ALLREDUCE(fluxout,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxout=tem
      tem=0.0d0
      call MPI_ALLREDUCE(fluxin,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxin=tem
#endif

      t3=(fluxin+1.0d-20)/(fluxout+1.0d-20)

      if(wbc.eq.2.and.ibw.eq.1)then
        i=1
!$omp parallel do default(shared)   &
!$omp private(j,k,u1)
        do k=1,nk
        do j=1,nj
          u1=rho0(1,j,k)*u3d(i,j,k)
          if(u1.lt.0.0)then
            u3d(i,j,k)=u1*t3/rho0(1,j,k)
          endif
        enddo
        enddo
      endif

      if(ebc.eq.2.and.ibe.eq.1)then
        i=ni+1
!$omp parallel do default(shared)   &
!$omp private(j,k,u1)
        do k=1,nk
        do j=1,nj
          u1=rho0(ni,j,k)*u3d(i,j,k)
          if(u1.gt.0.0)then
            u3d(i,j,k)=u1*t3/rho0(ni,j,k)
          endif
        enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine restrict_openbc_sn(ruh,rmh,rho0,v3d)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: ruh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v3d

      integer i,j,k
      double precision :: fluxout,fluxin,tem,u1,t3
      double precision, dimension(nk) :: temout,temin

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        temout(k) = 0.0d0
        temin(k)  = 0.0d0
      enddo

      if(sbc.eq.2.and.ibs.eq.1)then
        j=1
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          temout(k)=temout(k)-min(0.0,rho0(i,1,k)*v3d(i,j,k)*ruh(i)*rmh(i,1,k))
          temin(k) =temin(k) +max(0.0,rho0(i,1,k)*v3d(i,j,k)*ruh(i)*rmh(i,1,k))
        enddo
        enddo
      endif

      if(nbc.eq.2.and.ibn.eq.1)then
        j=nj+1
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          temout(k)=temout(k)+max(0.0,rho0(i,nj,k)*v3d(i,j,k)*ruh(i)*rmh(i,nj,k))
          temin(k) =temin(k) -min(0.0,rho0(i,nj,k)*v3d(i,j,k)*ruh(i)*rmh(i,nj,k))
        enddo
        enddo
      endif

      fluxout = 0.0d0
      fluxin  = 0.0d0

      do k=1,nk
        fluxout = fluxout + temout(k)
        fluxin  = fluxin  + temin(k)
      enddo

#ifdef MPI
      tem=0.0d0
      call MPI_ALLREDUCE(fluxout,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxout=tem
      tem=0.0d0
      call MPI_ALLREDUCE(fluxin,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxin=tem
#endif

      t3=(fluxin+1.0d-20)/(fluxout+1.0d-20)

      if(sbc.eq.2.and.ibs.eq.1)then
        j=1
!$omp parallel do default(shared)   &
!$omp private(i,k,u1)
        do k=1,nk
        do i=1,ni
          u1=rho0(i,1,k)*v3d(i,j,k)
          if(u1.lt.0.0)then
            v3d(i,j,k)=u1*t3/rho0(i,1,k)
          endif
        enddo
        enddo
      endif

      if(nbc.eq.2.and.ibn.eq.1)then
        j=nj+1
!$omp parallel do default(shared)   &
!$omp private(i,k,u1)
        do k=1,nk
        do i=1,ni
          u1=rho0(i,nj,k)*v3d(i,j,k)
          if(u1.gt.0.0)then
            v3d(i,j,k)=u1*t3/rho0(i,nj,k)
          endif
        enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine ssopenbcw(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbcw,dum1,u3d,uten,dts)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(ib:ie) :: uh
      real, intent(in),    dimension(kb:ke) :: rds,sigma
      real, intent(in),    dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gz,rgzu
      real, intent(in),    dimension(itb:ite,jtb:jte,ktb:kte) :: gx
      real, intent(in),    dimension(jb:je,kb:ke) :: radbcw
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: uten
      real, intent(in) :: dts

      integer :: i,j,k
      real :: r1,r2

          IF(.not.terrain_flag)THEN
            ! no terrain:
!$omp parallel do default(shared)   &
!$omp private(j,k)
            do k=1,nk
            do j=1,nj
              u3d(1,j,k)=u3d(1,j,k)+dts*( -radbcw(j,k)       &
                        *(u3d(2,j,k)-u3d(1,j,k))*rdx*uh(1)   &
                           +uten(1,j,k) )
            enddo
            enddo
          ELSE
            ! with terrain:
            ! dum1 stores u at w points:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
            do j=1,nj
              ! lowest model level:
              do i=1,2
                dum1(i,j,1) = cgs1*u3d(i,j,1)+cgs2*u3d(i,j,2)+cgs3*u3d(i,j,3)
              enddo
              ! upper-most model level:
              do i=1,2
                dum1(i,j,nk+1) = cgt1*u3d(i,j,nk)+cgt2*u3d(i,j,nk-1)+cgt3*u3d(i,j,nk-2)
              enddo
              ! interior:
              do k=2,nk
              r2 = (sigmaf(k)-sigma(k-1))*rds(k)
              r1 = 1.0-r2
              do i=1,2
                dum1(i,j,k) = r1*u3d(i,j,k-1)+r2*u3d(i,j,k)
              enddo
              enddo
            enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
              u3d(1,j,k)=u3d(1,j,k)+dts*( -radbcw(j,k)*(                            &
                     gz(1,j)*(u3d(2,j,k)*rgzu(2,j)-u3d(1,j,k)*rgzu(1,j))*rdx*uh(1)  &
                    +0.5*( gx(1,j,k+1)*(dum1(2,j,k+1)+dum1(1,j,k+1))                &
                          -gx(1,j,k  )*(dum1(2,j,k  )+dum1(1,j,k  )) )*rdsf(k)      &
                                                       )+uten(1,j,k) )
            enddo
            enddo
          ENDIF  ! end check for terrain

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine ssopenbce(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbce,dum1,u3d,uten,dts)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(ib:ie) :: uh
      real, intent(in),    dimension(kb:ke) :: rds,sigma
      real, intent(in),    dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gz,rgzu
      real, intent(in),    dimension(itb:ite,jtb:jte,ktb:kte) :: gx
      real, intent(in),    dimension(jb:je,kb:ke) :: radbce
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: uten
      real, intent(in) :: dts

      integer :: i,j,k
      real :: r1,r2

          IF(.not.terrain_flag)THEN
            ! no terrain:
!$omp parallel do default(shared)   &
!$omp private(j,k)
            do k=1,nk
            do j=1,nj
              u3d(ni+1,j,k)=u3d(ni+1,j,k)+dts*( -radbce(j,k)           &
                           *(u3d(ni+1,j,k)-u3d(ni  ,j,k))*rdx*uh(ni)   &
                           +uten(ni+1,j,k) )
            enddo
            enddo
          ELSE
            ! with terrain:
            ! dum1 stores u at w points:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
            do j=1,nj
              ! lowest model level:
              do i=ni,ni+1
                dum1(i,j,1) = cgs1*u3d(i,j,1)+cgs2*u3d(i,j,2)+cgs3*u3d(i,j,3)
              enddo
              ! upper-most model level:
              do i=ni,ni+1
                dum1(i,j,nk+1) = cgt1*u3d(i,j,nk)+cgt2*u3d(i,j,nk-1)+cgt3*u3d(i,j,nk-2)
              enddo
              ! interior:
              do k=2,nk
              r2 = (sigmaf(k)-sigma(k-1))*rds(k)
              r1 = 1.0-r2
              do i=ni,ni+1
                dum1(i,j,k) = r1*u3d(i,j,k-1)+r2*u3d(i,j,k)
              enddo
              enddo
            enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
              u3d(ni+1,j,k)=u3d(ni+1,j,k)+dts*( -radbce(j,k)*(                                &
                     gz(ni,j)*(u3d(ni+1,j,k)*rgzu(ni+1,j)-u3d(ni,j,k)*rgzu(ni,j))*rdx*uh(ni)  &
                    +0.5*( gx(ni,j,k+1)*(dum1(ni+1,j,k+1)+dum1(ni,j,k+1))                     &
                          -gx(ni,j,k  )*(dum1(ni+1,j,k  )+dum1(ni,j,k  )) )*rdsf(k)           &
                                                             )+uten(ni+1,j,k) )
            enddo
            enddo
          ENDIF  ! end check for terrain

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine ssopenbcs(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcs,dum1,v3d,vten,dts)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(jb:je) :: vh
      real, intent(in),    dimension(kb:ke) :: rds,sigma
      real, intent(in),    dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gz,rgzv
      real, intent(in),    dimension(itb:ite,jtb:jte,ktb:kte) :: gy
      real, intent(in),    dimension(ib:ie,kb:ke) :: radbcs
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: vten
      real, intent(in) :: dts

      integer :: i,j,k
      real :: r1,r2

          IF(.not.terrain_flag)THEN
            ! no terrain:
!$omp parallel do default(shared)   &
!$omp private(i,k)
            do k=1,nk
            do i=1,ni
              v3d(i,1,k)=v3d(i,1,k)+dts*( -radbcs(i,k)      &
                        *(v3d(i,2,k)-v3d(i,1,k))*rdy*vh(1)  &
                        +vten(i,1,k) )
            enddo
            enddo
          ELSE
            ! with terrain:
            ! dum1 stores v at w points:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
            do j=1,2
              ! lowest model level:
              do i=1,ni
                dum1(i,j,1) = cgs1*v3d(i,j,1)+cgs2*v3d(i,j,2)+cgs3*v3d(i,j,3)
              enddo
              ! upper-most model level:
              do i=1,ni
                dum1(i,j,nk+1) = cgt1*v3d(i,j,nk)+cgt2*v3d(i,j,nk-1)+cgt3*v3d(i,j,nk-2)
              enddo
              ! interior:
              do k=2,nk
              r2 = (sigmaf(k)-sigma(k-1))*rds(k)
              r1 = 1.0-r2
              do i=1,ni
                dum1(i,j,k) = r1*v3d(i,j,k-1)+r2*v3d(i,j,k)
              enddo
              enddo
            enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do i=1,ni
              v3d(i,1,k)=v3d(i,1,k)+dts*( -radbcs(i,k)*(                            &
                     gz(i,1)*(v3d(i,2,k)*rgzv(i,2)-v3d(i,1,k)*rgzv(i,1))*rdy*vh(1)  &
                    +0.5*( gy(i,1,k+1)*(dum1(i,2,k+1)+dum1(i,1,k+1))                &
                          -gy(i,1,k  )*(dum1(i,2,k  )+dum1(i,1,k  )) )*rdsf(k)      &
                                                       )+vten(i,1,k) )
            enddo
            enddo
          ENDIF  ! end check for terrain

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine ssopenbcn(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcn,dum1,v3d,vten,dts)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(jb:je) :: vh
      real, intent(in),    dimension(kb:ke) :: rds,sigma
      real, intent(in),    dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gz,rgzv
      real, intent(in),    dimension(itb:ite,jtb:jte,ktb:kte) :: gy
      real, intent(in),    dimension(ib:ie,kb:ke) :: radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: vten
      real, intent(in) :: dts

      integer :: i,j,k
      real :: r1,r2

          IF(.not.terrain_flag)THEN
            ! no terrain:
!$omp parallel do default(shared)   &
!$omp private(i,k)
            do k=1,nk
            do i=1,ni
              v3d(i,nj+1,k)=v3d(i,nj+1,k)+dts*( -radbcn(i,k)        &
                           *(v3d(i,nj+1,k)-v3d(i,nj,k))*rdy*vh(nj)  &
                           +vten(i,nj+1,k) )
            enddo
            enddo
          ELSE
            ! with terrain:
            ! dum1 stores v at w points:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
            do j=nj,nj+1
              ! lowest model level:
              do i=1,ni
                dum1(i,j,1) = cgs1*v3d(i,j,1)+cgs2*v3d(i,j,2)+cgs3*v3d(i,j,3)
              enddo
              ! upper-most model level:
              do i=1,ni
                dum1(i,j,nk+1) = cgt1*v3d(i,j,nk)+cgt2*v3d(i,j,nk-1)+cgt3*v3d(i,j,nk-2)
              enddo
              ! interior:
              do k=2,nk
              r2 = (sigmaf(k)-sigma(k-1))*rds(k)
              r1 = 1.0-r2
              do i=1,ni
                dum1(i,j,k) = r1*v3d(i,j,k-1)+r2*v3d(i,j,k)
              enddo
              enddo
            enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do i=1,ni
              v3d(i,nj+1,k)=v3d(i,nj+1,k)+dts*( -radbcn(i,k)*(                                &
                     gz(i,nj)*(v3d(i,nj+1,k)*rgzv(i,nj+1)-v3d(i,nj,k)*rgzv(i,nj))*rdy*vh(nj)  &
                    +0.5*( gy(i,nj,k+1)*(dum1(i,nj+1,k+1)+dum1(i,nj,k+1))                     &
                          -gy(i,nj,k  )*(dum1(i,nj+1,k  )+dum1(i,nj,k  )) )*rdsf(k)           &
                                                             )+vten(i,nj+1,k) )
            enddo
            enddo
          ENDIF  ! end check for terrain

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine movesfc(rmax,dt,weps,uh,vh,sfc,s,dum1,dum2,   &
                         reqs,west,newwest,east,neweast,       &
                         south,newsouth,north,newnorth)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: rmax,dt
      double precision :: weps
      real, dimension(ib:ie) :: uh
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je) :: sfc,s,dum1,dum2
      integer, intent(inout), dimension(8) :: reqs
      real, intent(inout), dimension(cmp,jmp) :: west,newwest,east,neweast
      real, intent(inout), dimension(imp,cmp) :: south,newsouth,north,newnorth

      integer i,j,nrk
      real s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,tem
      double precision :: a1,a2,a3,a4

!------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=1,nj
    do i=1,ni
      s(i,j)=sfc(i,j)
    enddo
    enddo

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=0,nj+1
    do i=0,ni+1
      dum1(i,j)=0.0
      dum2(i,j)=0.0
    enddo
    enddo

    DO nrk=1,3

!-------------------------
!  set boundary conditions

#ifdef MPI
      if(timestats.ge.1) time_swath=time_swath+mytime()
      call comm_2d_start(s,west,newwest,east,neweast,   &
                           south,newsouth,north,newnorth,reqs)
#else
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s( 0,j)=s(ni  ,j)
          s(-1,j)=s(ni-1,j)
          s(-2,j)=s(ni-2,j)
        enddo
      endif
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s(ni+1,j)=s(1,j)
          s(ni+2,j)=s(2,j)
          s(ni+3,j)=s(3,j)
        enddo
      endif
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i, 0)=s(i,nj  )
          s(i,-1)=s(i,nj-1)
          s(i,-2)=s(i,nj-2)
        enddo
      endif
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i,nj+1)=s(i,1)
          s(i,nj+2)=s(i,2)
          s(i,nj+3)=s(i,3)
        enddo
      endif
#endif

      if(ibw.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s( 0,j)=s(1,j)
          s(-1,j)=s(1,j)
          s(-2,j)=s(1,j)
        enddo
      endif

      if(ibe.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
        enddo
      endif

      if(ibs.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i, 0)=s(i,1)
          s(i,-1)=s(i,1)
          s(i,-2)=s(i,1)
        enddo
      endif

      if(ibn.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
        enddo
      endif

!-------------------------

#ifdef MPI
      if(timestats.ge.1) time_swath=time_swath+mytime()
      call comm_2dew_end(s,west,newwest,east,neweast,reqs)
#endif

!-------------------------

    if(abs(umove).gt.0.01)then
!$omp parallel do default(shared)  &
!$omp private(i,j,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4)
      do j=1,nj
      do i=1,ni+1
        if(umove.ge.0.0)then
          s1=s(i+2,j)
          s2=s(i+1,j)
          s3=s(i  ,j)
          s4=s(i-1,j)
          s5=s(i-2,j)
        else
          s1=s(i-3,j)
          s2=s(i-2,j)
          s3=s(i-1,j)
          s4=s(i  ,j)
          s5=s(i+1,j)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum1(i,j)=((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    endif

!-------------------------

#ifdef MPI
      if(timestats.ge.1) time_swath=time_swath+mytime()
      call comm_2dns_end(s,south,newsouth,north,newnorth,reqs)
#endif

!-------------------------

    if(abs(vmove).gt.0.01)then
!$omp parallel do default(shared)  &
!$omp private(i,j,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,a1,a2,a3,a4)
      do j=1,nj+1
      do i=1,ni
        if(vmove.ge.0.0)then
          s1=s(i,j+2)
          s2=s(i,j+1)
          s3=s(i,j  )
          s4=s(i,j-1)
          s5=s(i,j-2)
        else
          s1=s(i,j-3)
          s2=s(i,j-2)
          s3=s(i,j-1)
          s4=s(i,j  )
          s5=s(i,j+1)
        endif

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        ! from Jerry Straka (Univ of Oklahoma):
        ! based on Shen and Zha (2010, Int J Num Meth Fluids)
        ! (GHB 120201:  added the "min" part to prevent overflows)
        a1 = 0.10*(1.0+min(1.0d30,abs(b1-b3)/(b1+weps))**2)
        a2 = 0.60*(1.0+min(1.0d30,abs(b1-b3)/(b2+weps))**2)
        a3 = 0.30*(1.0+min(1.0d30,abs(b1-b3)/(b3+weps))**2)

        a4 = 1.0/(a1+a2+a3)
        w1 = a1*a4
        w2 = a2*a4
        w3 = a3*a4

        f1=( f1a*s1 + f1b*s2 + f1c*s3 )
        f2=( f2a*s2 + f2b*s3 + f2c*s4 )
        f3=( f3a*s3 + f3b*s4 + f3c*s5 )

        dum2(i,j)=((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    endif

      tem=dt/(4-nrk)

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        s(i,j)=max( rmax , sfc(i,j)+tem*(                          &
                          umove*(dum1(i+1,j)-dum1(i,j))*rdx*uh(i)  &
                         +vmove*(dum2(i,j+1)-dum2(i,j))*rdy*vh(j) ) )
      enddo
      enddo

!-------------------------

    ENDDO

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=1,nj
    do i=1,ni
      sfc(i,j)=s(i,j)
    enddo
    enddo

!----------------------------------------------------------------

      if(timestats.ge.1) time_swath=time_swath+mytime()

      return
      end


cm1.F           1587424407  1602  20    100644  75605     `


      program cm1

#ifdef MPI
      use mpi
#endif
      use module_restart
      implicit none

!-----------------------------------------------------------------------
!
!  CM1 Numerical Model, Release 18.3  (cm1r18.3)
!  7 October 2015
!  http://www2.mmm.ucar.edu/people/bryan/cm1/
!
!  Copyright (c) 2000-2015 by George H. Bryan, National Center for 
!  Atmospheric Research, Boulder, Colorado, USA.  
!
!-----------------------------------------------------------------------
!
!  Please see documentation at the top of the "solve.F" file.
!
!  See also documentation at the cm1 website, such as:
!
!    "The governing equations for CM1"
!        http://www2.mmm.ucar.edu/people/bryan/cm1/cm1_equations.pdf
!
!-----------------------------------------------------------------------

      include 'input.incl'
      include 'radcst.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer :: nstep,nstep0
      integer :: nrec,prec,nwrite,nrst
      integer :: rbufsz,num_soil_layers,ndt,ntdiag,nqdiag
      real :: dt,dtlast
      double precision :: mtime,stattim,taptim,rsttim,radtim,prcltim
      double precision :: adt,acfl,dbldt
      double precision :: mass1,mass2
      logical :: dosfcflx
      logical, dimension(maxq) :: cloudvar,rhovar
      character*15 :: tdef
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      double precision, dimension(:), allocatable :: bud,bud2
      double precision, dimension(:), allocatable :: qbudget
      double precision, dimension(:), allocatable :: asq,bsq
      real, dimension(:), allocatable :: xh,rxh,arh1,arh2,uh,ruh
      real, dimension(:), allocatable :: xf,rxf,arf1,arf2,uf,ruf
      real, dimension(:), allocatable :: yh,vh,rvh
      real, dimension(:), allocatable :: yf,vf,rvf
      real, dimension(:), allocatable :: xfref,yfref
      double precision, dimension(:), allocatable :: dumk1,dumk2
      real, dimension(:), allocatable :: rds,sigma,rdsf,sigmaf
      real, dimension(:,:,:), allocatable :: tauh,taus,zh,mh,rmh,c1,c2
      real, dimension(:,:,:), allocatable :: tauf,zf,mf,rmf
      real, dimension(:), allocatable :: rstat
      real, dimension(:,:), allocatable :: rho0s,pi0s,prs0s,rth0s
      real, dimension(:,:,:), allocatable :: pi0,rho0,prs0,thv0,th0,rth0,qv0
      real, dimension(:,:,:), allocatable :: qc0,qi0,rr0,rf0,rrf0,u0,v0
      real, dimension(:,:,:), allocatable :: dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8
      real, dimension(:,:), allocatable :: zs,gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, dimension(:,:,:), allocatable :: gx,gxu,gy,gyv
      real, dimension(:,:,:), allocatable :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(:,:), allocatable :: tsk,znt,ust,thflux,qvflux,cd,ch,cq,u1,v1,s1,xland,psfc,tlh
      real, dimension(:,:), allocatable :: radbcw,radbce
      real, dimension(:,:), allocatable :: radbcs,radbcn
      real, dimension(:,:,:), allocatable :: divx,rho,rr,rf,prs
      real, dimension(:,:,:), allocatable :: t11,t12,t13,t22,t23,t33
      real, dimension(:,:,:), allocatable :: rru,us,ua,u3d,uten,uten1
      real, dimension(:,:,:), allocatable :: rrv,vs,va,v3d,vten,vten1
      real, dimension(:,:,:), allocatable :: rrw,ws,wa,w3d,wten,wten1
      real, dimension(:,:,:), allocatable :: ppi,pp3d,piadv,ppten,sten,ppx
      real, dimension(:,:,:), allocatable :: tha,th3d,thadv,thten,thten1,thterm
      real, dimension(:,:,:), allocatable :: qpten,qtten,qvten,qcten
      real, dimension(:,:,:,:), allocatable :: qa,q3d,qten
      real, dimension(:,:,:), allocatable :: kmh,kmv,khh,khv
      real, dimension(:,:,:), allocatable :: tkea,tke3d,tketen
      real, dimension(:,:,:), allocatable :: nm,defv,defh,dissten
      real, dimension(:,:,:), allocatable :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, dimension(:,:,:), allocatable :: swten,lwten,o30
      real, dimension(:,:), allocatable :: radsw,rnflx,radswnet,radlwin,dsr,olr
      real, dimension(:,:,:), allocatable :: rad2d,effc,effi,effs,effr,effg,effis
      integer, dimension(:,:), allocatable :: lu_index,kpbl2d
      real, dimension(:,:), allocatable :: u10,v10,s10,hfx,qfx,               &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,       &
                                      CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh
      real, dimension(:,:), allocatable :: mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d
      real, dimension(:), allocatable :: slab_zs,slab_dzs
      real, dimension(:,:,:), allocatable :: tslb
      real, dimension(:,:), allocatable :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, dimension(:,:,:,:),  allocatable :: pta,pt3d,ptten
      real, dimension(:,:), allocatable :: dat1,dat2
      real, dimension(:,:,:), allocatable :: dat3
      integer, dimension(:), allocatable :: reqt
      real, dimension(:,:), allocatable :: pdata,packet,ploc
      logical, dimension(:,:,:), allocatable :: flag

!--- arrays for MPI ---
      integer, dimension(:), allocatable :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk
      integer, dimension(:,:),  allocatable :: reqs_q,reqs_t
      real, dimension(:), allocatable :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, dimension(:,:,:), allocatable :: n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2
      real, dimension(:,:), allocatable :: ww1,ww2,we1,we2
      real, dimension(:,:), allocatable :: ws1,ws2,wn1,wn2
      real, dimension(:,:), allocatable :: pw1,pw2,pe1,pe2
      real, dimension(:,:), allocatable :: ps1,ps2,pn1,pn2
      real, dimension(:,:), allocatable :: vw1,vw2,ve1,ve2
      real, dimension(:,:), allocatable :: vs1,vs2,vn1,vn2
      real, dimension(:,:,:), allocatable :: uw31,uw32,ue31,ue32
      real, dimension(:,:,:), allocatable :: us31,us32,un31,un32
      real, dimension(:,:,:), allocatable :: vw31,vw32,ve31,ve32
      real, dimension(:,:,:), allocatable :: vs31,vs32,vn31,vn32
      real, dimension(:,:,:), allocatable :: ww31,ww32,we31,we32
      real, dimension(:,:,:), allocatable :: ws31,ws32,wn31,wn32
      real, dimension(:,:,:), allocatable :: sw31,sw32,se31,se32
      real, dimension(:,:,:), allocatable :: ss31,ss32,sn31,sn32
      real, dimension(:,:,:,:), allocatable :: rw31,rw32,re31,re32
      real, dimension(:,:,:,:), allocatable :: rs31,rs32,rn31,rn32
      real, dimension(:,:,:,:), allocatable :: qw31,qw32,qe31,qe32
      real, dimension(:,:,:,:), allocatable :: qs31,qs32,qn31,qn32
      real, dimension(:,:,:), allocatable :: tkw1,tkw2,tke1,tke2
      real, dimension(:,:,:), allocatable :: tks1,tks2,tkn1,tkn2
      real, dimension(:,:,:), allocatable :: kw1,kw2,ke1,ke2
      real, dimension(:,:,:), allocatable :: ks1,ks2,kn1,kn2
      real, dimension(:,:,:,:), allocatable :: tw1,tw2,te1,te2
      real, dimension(:,:,:,:), allocatable :: ts1,ts2,tn1,tn2

      ! arrays for elliptic solver:
      real, dimension(:,:,:),    allocatable :: cfb
      real, dimension(:),        allocatable :: cfa,cfc,d1,d2
      complex, dimension(:,:,:), allocatable :: pdt,deft
      complex, dimension(:,:),   allocatable :: rhs,trans

      ! diagnostic arrays:
      real, dimension(:,:,:,:), allocatable :: tdiag,qdiag

!-----

      integer count,rate,maxr
      real rtime,xtime,time_solve,time_solve0
      real steptime1,steptime2
      integer :: i,j,k,n,nn,fnum
      real :: sum,tem0
      logical :: getsfc,restart,restart_prcl,reset
#ifdef MPI
      integer rc
      real mp_total
      double precision :: tstart,tend
#endif

      namelist /param0/ nx,ny,nz,nodex,nodey,ppnode,timeformat,timestats,terrain_flag,procfiles

!----------------------------------------------------------------------

      nstep = 0
      nstep0 = 0
      mtime = 0.0d0
      nrec=1
      prec=1
      nwrite=1
      nrst=0
      outfile=6
      stopit = .false.
      smeps = 1.0e-30
      tsmall = 0.0001
      ! (should be same as qsmall in morrison scheme)
      qsmall = 1.0e-14
#ifdef DP
      smeps = 1.0e-60
      tsmall = 0.000000000001
      qsmall = 1.0e-24
#endif
      ndt = 0
      adt = 0.0
      acfl = 0.0
      mass1 = 0.0
      mass2 = 0.0
      ntdiag = 1
      nqdiag = 1
      getsfc = .true.
      restart = .false.
      restart_prcl = .false.
      restart_format = 1
      restart_filetype = 1
      restart_reset_frqtim = .true.
      run_time = -999.0

!----------------------------------------------------------------------
!  Initialize MPI

      myid=0
      numprocs=1

#ifdef MPI
      call MPI_INIT( ierr )
      call MPI_COMM_RANK( MPI_COMM_WORLD, myid, ierr )
      call MPI_COMM_SIZE( MPI_COMM_WORLD, numprocs, ierr )
#endif

!----------------------------------------------------------------------
!  Get domain dimensions, allocate some arrays, then call PARAM

      open(unit=20,file='namelist.input',form='formatted',status='old',    &
           access='sequential',err=8888)
      read(20,nml=param0,err=8888,end=8888)
      close(unit=20)

      IF( procfiles )THEN
#ifdef MPI
        outfile=10
#endif
        dowr = .true.
      ELSE
        dowr = .false.
      ENDIF

      IF( myid.eq.0 ) dowr = .true.

      nodex  = max(1,nodex)
      nodey  = max(1,nodey)
      ppnode = max(1,ppnode)

#ifndef MPI
      ! serial (i.e. single-processor) run:
      nodex = 1
      nodey = 1
      ppnode = 1
#endif

      ni = nx / nodex
      nj = ny / nodey
      nk = nz
      nkp1 = nk+1

      ! (The following are needed by ZVD, but are also included for future 
      !  development, e.g., possible distributed-memory decomposition in 
      !  z direction)
      !
      ! number of 'ghost' points in the horizontal directions:
      ngxy  = 3
      ! number of 'ghost' points in the vertical direction:
      ngz   = 1

!---------------------------------------------------------------------
!      For ZVD:
!      ngz   = 3
!      IF( ngz.eq.3 )THEN
!        kb =  1 - ngz
!        ke = nk + ngz
!      ENDIF
!---------------------------------------------------------------------

      ib =  1 - ngxy
      ie = ni + ngxy
      jb =  1 - ngxy
      je = nj + ngxy
      kb =  1 - ngz
      ke = nk + ngz

      allocate(    xh(ib:ie) )
      xh = 0.0
      allocate(   rxh(ib:ie) )
      rxh = 0.0
      allocate(  arh1(ib:ie) )
      arh1 = 0.0
      allocate(  arh2(ib:ie) )
      arh2 = 0.0
      allocate(    uh(ib:ie) )
      uh = 0.0
      allocate(   ruh(ib:ie) )
      ruh = 0.0
      allocate(    xf(ib:ie+1) )
      xf = 0.0
      allocate(   rxf(ib:ie+1) )
      rxf = 0.0
      allocate(  arf1(ib:ie+1) )
      arf1 = 0.0
      allocate(  arf2(ib:ie+1) )
      arf2 = 0.0
      allocate(    uf(ib:ie+1) )
      uf = 0.0
      allocate(   ruf(ib:ie+1) )
      ruf = 0.0
      allocate(    yh(jb:je) )
      yh = 0.0
      allocate(    vh(jb:je) )
      vh = 0.0
      allocate(   rvh(jb:je) )
      rvh = 0.0
      allocate(    yf(jb:je+1) )
      yf = 0.0
      allocate(    vf(jb:je+1) )
      vf = 0.0
      allocate(   rvf(jb:je+1) )
      rvf = 0.0
      allocate( xfref(-2:nx+4) )
      xfref = 0.0
      allocate( yfref(-2:ny+4) )
      yfref = 0.0
      allocate( dumk1(kb:ke) )
      dumk1 = 0.0
      allocate( dumk2(kb:ke) )
      dumk2 = 0.0
      allocate(   rds(kb:ke) )
      rds = 0.0
      allocate( sigma(kb:ke) )
      sigma = 0.0
      allocate(   rdsf(kb:ke+1) )
      rdsf = 0.0
      allocate( sigmaf(kb:ke+1) )
      sigmaf = 0.0
      allocate(  tauh(ib:ie,jb:je,kb:ke) )
      tauh = 0.0
      allocate(  taus(ib:ie,jb:je,kb:ke) )
      taus = 0.0
      allocate(    zh(ib:ie,jb:je,kb:ke) )
      zh = 0.0
      allocate(    mh(ib:ie,jb:je,kb:ke) )
      mh = 0.0
      allocate(   rmh(ib:ie,jb:je,kb:ke) )
      rmh = 0.0
      allocate(    c1(ib:ie,jb:je,kb:ke) )
      c1 = 0.0
      allocate(    c2(ib:ie,jb:je,kb:ke) )
      c2 = 0.0
      allocate(  tauf(ib:ie,jb:je,kb:ke+1) )
      tauf = 0.0
      allocate(    mf(ib:ie,jb:je,kb:ke+1) )
      mf = 0.0
      allocate(   rmf(ib:ie,jb:je,kb:ke+1) )
      rmf = 0.0

      if(terrain_flag)then
        itb=ib
        ite=ie
        jtb=jb
        jte=je
        ktb=kb
        kte=ke
      else
        itb=1
        ite=1
        jtb=1
        jte=1
        ktb=1
        kte=1
      endif

      allocate(   zs(ib:ie,jb:je) )
      zs = 0.0
      allocate(   gz(itb:ite,jtb:jte) )
      gz = 0.0
      allocate(  rgz(itb:ite,jtb:jte) )
      rgz = 0.0
      allocate(  gzu(itb:ite,jtb:jte) )
      gzu = 0.0
      allocate( rgzu(itb:ite,jtb:jte) )
      rgzu = 0.0
      allocate(  gzv(itb:ite,jtb:jte) )
      gzv = 0.0
      allocate( rgzv(itb:ite,jtb:jte) )
      rgzv = 0.0
      allocate( dzdx(itb:ite,jtb:jte) )
      dzdx = 0.0
      allocate( dzdy(itb:ite,jtb:jte) )
      dzdy = 0.0
      allocate(   gx(itb:ite,jtb:jte,ktb:kte) )
      gx = 0.0
      allocate(  gxu(itb:ite,jtb:jte,ktb:kte) )
      gxu = 0.0
      allocate(   gy(itb:ite,jtb:jte,ktb:kte) )
      gy = 0.0
      allocate(  gyv(itb:ite,jtb:jte,ktb:kte) )
      gyv = 0.0
      allocate(   zf(ib:ie,jb:je,kb:ke+1) )
      zf = 0.0

!------
! allocate the MPI arrays

#ifdef MPI
      imp = max(1,ni)
      jmp = max(1,nj)
      kmp = max(2,nk)
      kmt = max(2,nk+1)
      rmp = 8
      cmp = 3
#else
      imp = 1
      jmp = 1
      kmp = 2
      kmt = 2
      rmp = 1
      cmp = 1
#endif

      allocate( reqs_u(rmp) )
      reqs_u = 0
      allocate( reqs_v(rmp) )
      reqs_v = 0
      allocate( reqs_w(rmp) )
      reqs_w = 0
      allocate( reqs_s(rmp) )
      reqs_s = 0
      allocate( reqs_p(rmp) )
      reqs_p = 0
      allocate( reqs_tk(rmp) )
      reqs_tk = 0

      allocate( nw1(kmt) )
      nw1 = 0.0
      allocate( nw2(kmt) )
      nw2 = 0.0
      allocate( ne1(kmt) )
      ne1 = 0.0
      allocate( ne2(kmt) )
      ne2 = 0.0
      allocate( sw1(kmt) )
      sw1 = 0.0
      allocate( sw2(kmt) )
      sw2 = 0.0
      allocate( se1(kmt) )
      se1 = 0.0
      allocate( se2(kmt) )
      se2 = 0.0

      allocate( n3w1(cmp,cmp,kmt+1) )
      n3w1 = 0.0
      allocate( n3w2(cmp,cmp,kmt+1) )
      n3w2 = 0.0
      allocate( n3e1(cmp,cmp,kmt+1) )
      n3e1 = 0.0
      allocate( n3e2(cmp,cmp,kmt+1) )
      n3e2 = 0.0
      allocate( s3w1(cmp,cmp,kmt+1) )
      s3w1 = 0.0
      allocate( s3w2(cmp,cmp,kmt+1) )
      s3w2 = 0.0
      allocate( s3e1(cmp,cmp,kmt+1) )
      s3e1 = 0.0
      allocate( s3e2(cmp,cmp,kmt+1) )
      s3e2 = 0.0

      allocate( ww1(jmp,kmp-1) )
      ww1 = 0.0
      allocate( ww2(jmp,kmp-1) )
      ww2 = 0.0
      allocate( we1(jmp,kmp-1) )
      we1 = 0.0
      allocate( we2(jmp,kmp-1) )
      we2 = 0.0
      allocate( ws1(imp,kmp-1) )
      ws1 = 0.0
      allocate( ws2(imp,kmp-1) )
      ws2 = 0.0
      allocate( wn1(imp,kmp-1) )
      wn1 = 0.0
      allocate( wn2(imp,kmp-1) )
      wn2 = 0.0

      allocate( pw1(jmp,kmp) )
      pw1 = 0.0
      allocate( pw2(jmp,kmp) )
      pw2 = 0.0
      allocate( pe1(jmp,kmp) )
      pe1 = 0.0
      allocate( pe2(jmp,kmp) )
      pe2 = 0.0
      allocate( ps1(imp,kmp) )
      ps1 = 0.0
      allocate( ps2(imp,kmp) )
      ps2 = 0.0
      allocate( pn1(imp,kmp) )
      pn1 = 0.0
      allocate( pn2(imp,kmp) )
      pn2 = 0.0

      allocate( vw1(jmp,kmp) )
      vw1 = 0.0
      allocate( vw2(jmp,kmp) )
      vw2 = 0.0
      allocate( ve1(jmp,kmp) )
      ve1 = 0.0
      allocate( ve2(jmp,kmp) )
      ve2 = 0.0
      allocate( vs1(imp,kmp) )
      vs1 = 0.0
      allocate( vs2(imp,kmp) )
      vs2 = 0.0
      allocate( vn1(imp,kmp) )
      vn1 = 0.0
      allocate( vn2(imp,kmp) )
      vn2 = 0.0

      allocate( uw31(cmp,jmp,kmp) )
      uw31 = 0.0
      allocate( uw32(cmp,jmp,kmp) )
      uw32 = 0.0
      allocate( ue31(cmp,jmp,kmp) )
      ue31 = 0.0
      allocate( ue32(cmp,jmp,kmp) )
      ue32 = 0.0
      allocate( us31(imp+1,cmp,kmp) )
      us31 = 0.0
      allocate( us32(imp+1,cmp,kmp) )
      us32 = 0.0
      allocate( un31(imp+1,cmp,kmp) )
      un31 = 0.0
      allocate( un32(imp+1,cmp,kmp) )
      un32 = 0.0

      allocate( vw31(cmp,jmp+1,kmp) )
      vw31 = 0.0
      allocate( vw32(cmp,jmp+1,kmp) )
      vw32 = 0.0
      allocate( ve31(cmp,jmp+1,kmp) )
      ve31 = 0.0
      allocate( ve32(cmp,jmp+1,kmp) )
      ve32 = 0.0
      allocate( vs31(imp,cmp,kmp) )
      vs31 = 0.0
      allocate( vs32(imp,cmp,kmp) )
      vs32 = 0.0
      allocate( vn31(imp,cmp,kmp) )
      vn31 = 0.0
      allocate( vn32(imp,cmp,kmp) )
      vn32 = 0.0

      allocate( ww31(cmp,jmp,kmp-1) )
      ww31 = 0.0
      allocate( ww32(cmp,jmp,kmp-1) )
      ww32 = 0.0
      allocate( we31(cmp,jmp,kmp-1) )
      we31 = 0.0
      allocate( we32(cmp,jmp,kmp-1) )
      we32 = 0.0
      allocate( ws31(imp,cmp,kmp-1) )
      ws31 = 0.0
      allocate( ws32(imp,cmp,kmp-1) )
      ws32 = 0.0
      allocate( wn31(imp,cmp,kmp-1) )
      wn31 = 0.0
      allocate( wn32(imp,cmp,kmp-1) )
      wn32 = 0.0

      allocate( sw31(cmp,jmp,kmp) )
      sw31 = 0.0
      allocate( sw32(cmp,jmp,kmp) )
      sw32 = 0.0
      allocate( se31(cmp,jmp,kmp) )
      se31 = 0.0
      allocate( se32(cmp,jmp,kmp) )
      se32 = 0.0
      allocate( ss31(imp,cmp,kmp) )
      ss31 = 0.0
      allocate( ss32(imp,cmp,kmp) )
      ss32 = 0.0
      allocate( sn31(imp,cmp,kmp) )
      sn31 = 0.0
      allocate( sn32(imp,cmp,kmp) )
      sn32 = 0.0

      allocate( rw31(cmp,jmp,kmp,2) )
      rw31 = 0.0
      allocate( rw32(cmp,jmp,kmp,2) )
      rw32 = 0.0
      allocate( re31(cmp,jmp,kmp,2) )
      re31 = 0.0
      allocate( re32(cmp,jmp,kmp,2) )
      re32 = 0.0
      allocate( rs31(imp,cmp,kmp,2) )
      rs31 = 0.0
      allocate( rs32(imp,cmp,kmp,2) )
      rs32 = 0.0
      allocate( rn31(imp,cmp,kmp,2) )
      rn31 = 0.0
      allocate( rn32(imp,cmp,kmp,2) )
      rn32 = 0.0

      allocate( tkw1(cmp,jmp,kmt) )
      tkw1 = 0.0
      allocate( tkw2(cmp,jmp,kmt) )
      tkw2 = 0.0
      allocate( tke1(cmp,jmp,kmt) )
      tke1 = 0.0
      allocate( tke2(cmp,jmp,kmt) )
      tke2 = 0.0
      allocate( tks1(imp,cmp,kmt) )
      tks1 = 0.0
      allocate( tks2(imp,cmp,kmt) )
      tks2 = 0.0
      allocate( tkn1(imp,cmp,kmt) )
      tkn1 = 0.0
      allocate( tkn2(imp,cmp,kmt) )
      tkn2 = 0.0

      allocate( kw1(jmp,kmt,4) )
      kw1 = 0.0
      allocate( kw2(jmp,kmt,4) )
      kw2 = 0.0
      allocate( ke1(jmp,kmt,4) )
      ke1 = 0.0
      allocate( ke2(jmp,kmt,4) )
      ke2 = 0.0
      allocate( ks1(imp,kmt,4) )
      ks1 = 0.0
      allocate( ks2(imp,kmt,4) )
      ks2 = 0.0
      allocate( kn1(imp,kmt,4) )
      kn1 = 0.0
      allocate( kn2(imp,kmt,4) )
      kn2 = 0.0

      call param(dt,dtlast,stattim,taptim,rsttim,radtim,prcltim,  &
                 cloudvar,rhovar,qname,budname,                   &
                 xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf, &
                 yh,vh,rvh,yf,vf,rvf,xfref,yfref,                 &
                 rds,sigma,rdsf,sigmaf,tauh,taus,zh,mh,rmh,c1,c2,tauf,zf,mf,rmf, &
                 zs,gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy,gx,gxu,gy,gyv, &
                 ntdiag,nqdiag,                                   &
                 reqs_u,reqs_v,reqs_s,reqs_p,                     &
                 nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                 n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,         &
                 sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,         &
                 uw31,uw32,ue31,ue32,us31,us32,un31,un32,         &
                 vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,         &
                 ww31,ww32,we31,we32,ws31,ws32,wn31,wn32)

      dbldt = dble(dt)

      allocate( reqs_q(rmp,numq) )
      reqs_q = 0
      allocate( reqs_t(rmp,npt) )
      reqs_t = 0

      allocate( qw31(cmp,jmp,kmp,numq) )
      qw31 = 0.0
      allocate( qw32(cmp,jmp,kmp,numq) )
      qw32 = 0.0
      allocate( qe31(cmp,jmp,kmp,numq) )
      qe31 = 0.0
      allocate( qe32(cmp,jmp,kmp,numq) )
      qe32 = 0.0
      allocate( qs31(imp,cmp,kmp,numq) )
      qs31 = 0.0
      allocate( qs32(imp,cmp,kmp,numq) )
      qs32 = 0.0
      allocate( qn31(imp,cmp,kmp,numq) )
      qn31 = 0.0
      allocate( qn32(imp,cmp,kmp,numq) )
      qn32 = 0.0

      allocate( tw1(cmp,jmp,kmp,npt) )
      tw1 = 0.0
      allocate( tw2(cmp,jmp,kmp,npt) )
      tw2 = 0.0
      allocate( te1(cmp,jmp,kmp,npt) )
      te1 = 0.0
      allocate( te2(cmp,jmp,kmp,npt) )
      te2 = 0.0
      allocate( ts1(imp,cmp,kmp,npt) )
      ts1 = 0.0
      allocate( ts2(imp,cmp,kmp,npt) )
      ts2 = 0.0
      allocate( tn1(imp,cmp,kmp,npt) )
      tn1 = 0.0
      allocate( tn2(imp,cmp,kmp,npt) )
      tn2 = 0.0

!----------------------------------------------------------------------
!  allocate the base state arrays, then call BASE

      allocate( rstat(stat_out) )
      rstat = 0.0
      allocate( rho0s(ib:ie,jb:je) )
      rho0s = 0.0
      allocate(  pi0s(ib:ie,jb:je) )
      pi0s = 0.0
      allocate( prs0s(ib:ie,jb:je) )
      prs0s = 0.0
      allocate( rth0s(ib:ie,jb:je) )
      rth0s = 0.0
      allocate(  pi0(ib:ie,jb:je,kb:ke) )
      pi0 = 0.0
      allocate( rho0(ib:ie,jb:je,kb:ke) )
      rho0 = 0.0
      allocate( prs0(ib:ie,jb:je,kb:ke) )
      prs0 = 0.0
      allocate( thv0(ib:ie,jb:je,kb:ke) )
      thv0 = 0.0
      allocate(  th0(ib:ie,jb:je,kb:ke) )
      th0 = 0.0
      allocate( rth0(ib:ie,jb:je,kb:ke) )
      rth0 = 0.0
      allocate(  qv0(ib:ie,jb:je,kb:ke) )
      qv0 = 0.0
      allocate(  qc0(ib:ie,jb:je,kb:ke) )
      qc0 = 0.0
      allocate(  qi0(ib:ie,jb:je,kb:ke) )
      qi0 = 0.0
      allocate(  rr0(ib:ie,jb:je,kb:ke) )
      rr0 = 0.0
      allocate(  rf0(ib:ie,jb:je,kb:ke) )
      rf0 = 0.0
      allocate( rrf0(ib:ie,jb:je,kb:ke) )
      rrf0 = 0.0
      allocate(   u0(ib:ie+1,jb:je,kb:ke) )
      u0 = 0.0
      allocate(   v0(ib:ie,jb:je+1,kb:ke) )
      v0 = 0.0

      allocate( dum1(ib:ie,jb:je,kb:ke) )
      dum1 = 0.0
      allocate( dum2(ib:ie,jb:je,kb:ke) )
      dum2 = 0.0
      allocate( dum3(ib:ie,jb:je,kb:ke) )
      dum3 = 0.0
      allocate( dum4(ib:ie,jb:je,kb:ke) )
      dum4 = 0.0
      allocate( dum5(ib:ie,jb:je,kb:ke) )
      dum5 = 0.0
      allocate( dum6(ib:ie,jb:je,kb:ke) )
      dum6 = 0.0
      allocate( dum7(ib:ie,jb:je,kb:ke) )
      dum7 = 0.0
      allocate( dum8(ib:ie,jb:je,kb:ke) )
      dum8 = 0.0

      call base(zh,mh,c1,c2,zf,mf,rho0s,pi0s,prs0s,rth0s,             &
                pi0,prs0,rho0,thv0,th0,rth0,qv0,u0,v0,                &
                qc0,qi0,rr0,rf0,rrf0,dum1,dum2,                       &
                reqs_u,reqs_v,reqs_s,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2, &
                n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,              &
                uw31,uw32,ue31,ue32,us31,us32,un31,un32,              &
                vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,              &
                sw31,sw32,se31,se32,ss31,ss32,sn31,sn32)

!----------------------------------------------------------------------
!  Now, allocate the mother lode, then call INIT3D

      allocate(   rain(ib:ie,jb:je,nrain) )
      rain = 0.0
      allocate(    sws(ib:ie,jb:je,nrain) )
      sws = 0.0
      allocate(    svs(ib:ie,jb:je,nrain) )
      svs = 0.0
      allocate(    sps(ib:ie,jb:je,nrain) )
      sps = 0.0
      allocate(    srs(ib:ie,jb:je,nrain) )
      srs = 0.0
      allocate(    sgs(ib:ie,jb:je,nrain) )
      sgs = 0.0
      allocate(    sus(ib:ie,jb:je,nrain) )
      sus = 0.0
      allocate(    shs(ib:ie,jb:je,nrain) )
      shs = 0.0

      allocate(    tsk(ib:ie,jb:je) )
      tsk = 0.0
      allocate(    znt(ib:ie,jb:je) )
      znt = 0.0
      allocate(    ust(ib:ie,jb:je) )
      ust = 0.0
      allocate( thflux(ib:ie,jb:je) )
      thflux = 0.0
      allocate( qvflux(ib:ie,jb:je) )
      qvflux = 0.0
      allocate(     cd(ib:ie,jb:je) )
      cd = 0.0
      allocate(     ch(ib:ie,jb:je) )
      ch = 0.0
      allocate(     cq(ib:ie,jb:je) )
      cq = 0.0
      allocate(     u1(ib:ie,jb:je) )
      u1 = 0.0
      allocate(     v1(ib:ie,jb:je) )
      v1 = 0.0
      allocate(     s1(ib:ie,jb:je) )
      s1 = 0.0
      allocate(  xland(ib:ie,jb:je) )
      xland = 0.0
      allocate(   psfc(ib:ie,jb:je) )
      psfc = 0.0
      allocate(    tlh(ib:ie,jb:je) )
      tlh = l_h

      allocate( radbcw(jb:je,kb:ke) )
      radbcw = 0.0
      allocate( radbce(jb:je,kb:ke) )
      radbce = 0.0
      allocate( radbcs(ib:ie,kb:ke) )
      radbcs = 0.0
      allocate( radbcn(ib:ie,kb:ke) )
      radbcn = 0.0

      allocate( divx(ib:ie,jb:je,kb:ke) )
      divx = 0.0
      allocate(  rho(ib:ie,jb:je,kb:ke) )
      rho = 0.0
      allocate(   rr(ib:ie,jb:je,kb:ke) )
      rr = 0.0
      allocate(   rf(ib:ie,jb:je,kb:ke) )
      rf = 0.0
      allocate(  prs(ib:ie,jb:je,kb:ke) )
      prs = 0.0
      allocate(  t11(ib:ie,jb:je,kb:ke) )
      t11 = 0.0
      allocate(  t12(ib:ie,jb:je,kb:ke) )
      t12 = 0.0
      allocate(  t13(ib:ie,jb:je,kb:ke) )
      t13 = 0.0
      allocate(  t22(ib:ie,jb:je,kb:ke) )
      t22 = 0.0
      allocate(  t23(ib:ie,jb:je,kb:ke) )
      t23 = 0.0
      allocate(  t33(ib:ie,jb:je,kb:ke) )
      t33 = 0.0

      allocate(   rru(ib:ie+1,jb:je,kb:ke) )
      rru = 0.0
      allocate(    us(ib:ie+1,jb:je,kb:ke) )
      us = 0.0
      allocate(    ua(ib:ie+1,jb:je,kb:ke) )
      ua = 0.0
      allocate(   u3d(ib:ie+1,jb:je,kb:ke) )
      u3d = 0.0
      allocate(  uten(ib:ie+1,jb:je,kb:ke) )
      uten = 0.0
      allocate( uten1(ib:ie+1,jb:je,kb:ke) )
      uten1 = 0.0

      allocate(   rrv(ib:ie,jb:je+1,kb:ke) )
      rrv = 0.0
      allocate(    vs(ib:ie,jb:je+1,kb:ke) )
      vs = 0.0
      allocate(    va(ib:ie,jb:je+1,kb:ke) )
      va = 0.0
      allocate(   v3d(ib:ie,jb:je+1,kb:ke) )
      v3d = 0.0
      allocate(  vten(ib:ie,jb:je+1,kb:ke) )
      vten = 0.0
      allocate( vten1(ib:ie,jb:je+1,kb:ke) )
      vten1 = 0.0

      allocate(   rrw(ib:ie,jb:je,kb:ke+1) )
      rrw = 0.0
      allocate(    ws(ib:ie,jb:je,kb:ke+1) )
      ws = 0.0
      allocate(    wa(ib:ie,jb:je,kb:ke+1) )
      wa = 0.0
      allocate(   w3d(ib:ie,jb:je,kb:ke+1) )
      w3d = 0.0
      allocate(  wten(ib:ie,jb:je,kb:ke+1) )
      wten = 0.0
      allocate( wten1(ib:ie,jb:je,kb:ke+1) )
      wten1 = 0.0

      allocate(   ppi(ib:ie,jb:je,kb:ke) )
      ppi = 0.0
      allocate(  pp3d(ib:ie,jb:je,kb:ke) )
      pp3d = 0.0
      allocate( piadv(ib:ie,jb:je,kb:ke) )
      piadv = 0.0
      allocate( ppten(ib:ie,jb:je,kb:ke) )
      ppten = 0.0
      allocate(  sten(ib:ie,jb:je,kb:ke) )
      sten = 0.0
      allocate(   ppx(ib:ie,jb:je,kb:ke) )
      ppx = 0.0

      allocate(   tha(ib:ie,jb:je,kb:ke) )
      tha = 0.0
      allocate(  th3d(ib:ie,jb:je,kb:ke) )
      th3d = 0.0
      allocate( thadv(ib:ie,jb:je,kb:ke) )
      thadv = 0.0
      allocate( thten(ib:ie,jb:je,kb:ke) )
      thten = 0.0
      allocate(thten1(ib:ie,jb:je,kb:ke) )
      thten1 = 0.0
      allocate(thterm(ib:ie,jb:je,kb:ke) )
      thterm = 0.0

      allocate( qpten(ibm:iem,jbm:jem,kbm:kem) )
      qpten = 0.0
      allocate( qtten(ibm:iem,jbm:jem,kbm:kem) )
      qtten = 0.0
      allocate( qvten(ibm:iem,jbm:jem,kbm:kem) )
      qvten = 0.0
      allocate( qcten(ibm:iem,jbm:jem,kbm:kem) )
      qcten = 0.0

      allocate(   bud(nk) )
      bud = 0.0
      allocate(  bud2(nj) )
      bud2 = 0.0
      allocate( qbudget(nbudget) )
      qbudget = 0.0
      allocate(    asq(numq) )
      asq = 0.0
      allocate(    bsq(numq) )
      bsq = 0.0

      allocate(     qa(ibm:iem,jbm:jem,kbm:kem,numq) )
      qa = 0.0
      allocate(    q3d(ibm:iem,jbm:jem,kbm:kem,numq) )
      q3d = 0.0
      allocate(   qten(ibm:iem,jbm:jem,kbm:kem,numq) )
      qten = 0.0

      allocate(    kmh(ibc:iec,jbc:jec,kbc:kec) )
      kmh = 0.0
      allocate(    kmv(ibc:iec,jbc:jec,kbc:kec) )
      kmv = 0.0
      allocate(    khh(ibc:iec,jbc:jec,kbc:kec) )
      khh = 0.0
      allocate(    khv(ibc:iec,jbc:jec,kbc:kec) )
      khv = 0.0
      allocate(   tkea(ibt:iet,jbt:jet,kbt:ket) )
      tkea = 0.0
      allocate(  tke3d(ibt:iet,jbt:jet,kbt:ket) )
      tke3d = 0.0
      allocate( tketen(ibt:iet,jbt:jet,kbt:ket) )
      tketen = 0.0

      allocate(      nm(ib:ie,jb:je,kb:ke+1) )
      nm = 0.0
      allocate(    defv(ib:ie,jb:je,kb:ke+1) )
      defv = 0.0
      allocate(    defh(ib:ie,jb:je,kb:ke+1) )
      defh = 0.0
      allocate( dissten(ib:ie,jb:je,kb:ke+1) )
      dissten = 0.0

      allocate( thpten(ibb:ieb,jbb:jeb,kbb:keb) )
      thpten = 0.0
      allocate( qvpten(ibb:ieb,jbb:jeb,kbb:keb) )
      qvpten = 0.0
      allocate( qcpten(ibb:ieb,jbb:jeb,kbb:keb) )
      qcpten = 0.0
      allocate( qipten(ibb:ieb,jbb:jeb,kbb:keb) )
      qipten = 0.0
      allocate(  upten(ibb:ieb,jbb:jeb,kbb:keb) )
      upten = 0.0
      allocate(  vpten(ibb:ieb,jbb:jeb,kbb:keb) )
      vpten = 0.0

      allocate( swten(ibr:ier,jbr:jer,kbr:ker) )
      swten = 0.0
      allocate( lwten(ibr:ier,jbr:jer,kbr:ker) )
      lwten = 0.0
      allocate(   o30(ibr:ier,jbr:jer,kbr:ker) )
      o30 = 0.0

      IF( radopt .eq. 1 )THEN
        nir = 1
        njr = 1
        nkr = nk+3
        rbufsz = n2d_radiat*nir*njr + n3d_radiat*nir*njr*nkr
      ELSE
        nir = 1
        njr = 1
        nkr = 1
        rbufsz = 1
      ENDIF

      allocate(    radsw(ni,nj) )
      radsw = 0.0
      allocate(    rnflx(ni,nj) )
      rnflx = 0.0
      allocate( radswnet(ni,nj) )
      radswnet = 0.0
      allocate(  radlwin(ni,nj) )
      radlwin = 0.0
      allocate(      dsr(ni,nj) )
      dsr = 0.0
      allocate(      olr(ni,nj) )
      olr = 0.0

      allocate(    rad2d(ni,nj,nrad2d) )
      rad2d = 0.0

      allocate(  effc(ibr:ier,jbr:jer,kbr:ker) )
      effc = 25.0
      allocate(  effi(ibr:ier,jbr:jer,kbr:ker) )
      effi = 25.0
      allocate(  effs(ibr:ier,jbr:jer,kbr:ker) )
      effs = 25.0
      allocate(  effr(ibr:ier,jbr:jer,kbr:ker) )
      effr = 25.0
      allocate(  effg(ibr:ier,jbr:jer,kbr:ker) )
      effg = 25.0
      allocate( effis(ibr:ier,jbr:jer,kbr:ker) )
      effis = 25.0

      if(dowr) write(outfile,*) '  rbufsz,nrad2d = ',rbufsz,nrad2d

      allocate( lu_index(ibl:iel,jbl:jel) )
      lu_index = 0
      allocate(   kpbl2d(ibl:iel,jbl:jel) )
      kpbl2d = 0
      allocate(      u10(ibl:iel,jbl:jel) )
      u10 = 0.0
      allocate(      v10(ibl:iel,jbl:jel) )
      v10 = 0.0
      allocate(      s10(ibl:iel,jbl:jel) )
      s10 = 0.0
      allocate(      hfx(ibl:iel,jbl:jel) )
      hfx = 0.0
      allocate(      qfx(ibl:iel,jbl:jel) )
      qfx = 0.0
      allocate(     hpbl(ibl:iel,jbl:jel) )
      hpbl = 0.0
      allocate(     wspd(ibl:iel,jbl:jel) )
      wspd = 0.0
      allocate(     psim(ibl:iel,jbl:jel) )
      psim = 0.0
      allocate(     psih(ibl:iel,jbl:jel) )
      psih = 0.0
      allocate(   gz1oz0(ibl:iel,jbl:jel) )
      gz1oz0 = 0.0
      allocate(       br(ibl:iel,jbl:jel) )
      br = 0.0
      allocate(      chs(ibl:iel,jbl:jel) )
      chs = 0.0
      allocate(     chs2(ibl:iel,jbl:jel) )
      chs2 = 0.0
      allocate(     cqs2(ibl:iel,jbl:jel) )
      cqs2 = 0.0
      allocate(     cpmm(ibl:iel,jbl:jel) )
      cpmm = 0.0
      allocate(      zol(ibl:iel,jbl:jel) )
      zol = 0.0
      allocate(   mavail(ibl:iel,jbl:jel) )
      mavail = 0.0
      allocate(      mol(ibl:iel,jbl:jel) )
      mol = 0.0
      allocate(     rmol(ibl:iel,jbl:jel) )
      rmol = 0.0
      allocate(   regime(ibl:iel,jbl:jel) )
      regime = 0.0
      allocate(       lh(ibl:iel,jbl:jel) )
      lh = 0.0
      allocate(     flhc(ibl:iel,jbl:jel) )
      flhc = 0.0
      allocate(     flqc(ibl:iel,jbl:jel) )
      flqc = 0.0
      allocate(      qgh(ibl:iel,jbl:jel) )
      qgh = 0.0
      allocate(       ck(ibl:iel,jbl:jel) )
      ck = 0.0
      allocate(      cka(ibl:iel,jbl:jel) )
      cka = 0.0
      allocate(      cda(ibl:iel,jbl:jel) )
      cda = 0.0
      allocate(     ustm(ibl:iel,jbl:jel) )
      ustm = 0.0
      allocate(     qsfc(ibl:iel,jbl:jel) )
      qsfc = 0.0
      allocate(       t2(ibl:iel,jbl:jel) )
      t2 = 0.0
      allocate(       q2(ibl:iel,jbl:jel) )
      q2 = 0.0
      allocate(      th2(ibl:iel,jbl:jel) )
      th2 = 0.0
      allocate(    emiss(ibl:iel,jbl:jel) )
      emiss = 0.0
      allocate(      thc(ibl:iel,jbl:jel) )
      thc = 0.0
      allocate(     albd(ibl:iel,jbl:jel) )
      albd = 0.0
      allocate(      f2d(ibl:iel,jbl:jel) )
      f2d = 0.0
      allocate(      gsw(ibl:iel,jbl:jel) )
      gsw = 0.0
      allocate(      glw(ibl:iel,jbl:jel) )
      glw = 0.0
      allocate(  chklowq(ibl:iel,jbl:jel) )
      chklowq = 0.0
      allocate(     capg(ibl:iel,jbl:jel) )
      capg = 0.0
      allocate(    snowc(ibl:iel,jbl:jel) )
      snowc = 0.0
      allocate(     dsxy(ibl:iel,jbl:jel) )
      dsxy = 0.0
      allocate(    wstar(ibl:iel,jbl:jel) )
      wstar = 0.0
      allocate(    delta(ibl:iel,jbl:jel) )
      delta = 0.0
      allocate(       fm(ibl:iel,jbl:jel) )
      fm = 0.0
      allocate(       fh(ibl:iel,jbl:jel) )
      fh = 0.0

      allocate(     mznt(ibl:iel,jbl:jel) )
      mznt = 0.0
      allocate(    smois(ibl:iel,jbl:jel) )
      smois = 0.0
      allocate(     taux(ibl:iel,jbl:jel) )
      taux = 0.0
      allocate(     tauy(ibl:iel,jbl:jel) )
      tauy = 0.0
      allocate(   hpbl2d(ibl:iel,jbl:jel) )
      hpbl2d = 0.0
      allocate(   evap2d(ibl:iel,jbl:jel) )
      evap2d = 0.0
      allocate(   heat2d(ibl:iel,jbl:jel) )
      heat2d = 0.0
      allocate(     rc2d(ibl:iel,jbl:jel) )
      rc2d = 0.0

      ! start with very small, but non-zero, numbers:
      znt = 1.0e-6
      ust = 1.0e-6
      ! to prevent divide-by-zeros for some combinations of namelist params:
      tsk  = 300.0
      psfc = 100000.0
      qsfc = 0.00001

      num_soil_layers = 5
      allocate(  slab_zs(num_soil_layers) )
      slab_zs = 0.0
      allocate( slab_dzs(num_soil_layers) )
      slab_dzs = 0.0
      allocate(  tslb(ibl:iel,jbl:jel,num_soil_layers) )
      tslb = 0.0
      allocate(   tmn(ibl:iel,jbl:jel) )
      tmn = 0.0

      ! arrays for oml model:
      allocate(   tml(ibl:iel,jbl:jel) )
      tml = 0.0
      allocate(  t0ml(ibl:iel,jbl:jel) )
      t0ml = 0.0
      allocate(   hml(ibl:iel,jbl:jel) )
      hml = 0.0
      allocate(  h0ml(ibl:iel,jbl:jel) )
      h0ml = 0.0
      allocate(  huml(ibl:iel,jbl:jel) )
      huml = 0.0
      allocate(  hvml(ibl:iel,jbl:jel) )
      hvml = 0.0
      allocate( tmoml(ibl:iel,jbl:jel) )
      tmoml = 0.0

      allocate(    pta(ibp:iep,jbp:jep,kbp:kep,npt) )
      pta = 0.0
      allocate(   pt3d(ibp:iep,jbp:jep,kbp:kep,npt) )
      pt3d = 0.0
      allocate(  ptten(ibp:iep,jbp:jep,kbp:kep,npt) )
      ptten = 0.0

      allocate( dat1(ni+1,nj+1) )
      dat1 = 0.0
      allocate( dat2(d2i,d2j) )
      dat2 = 0.0
      allocate( dat3(d3i,d3j,d3n) )
      dat3 = 0.0
      allocate( reqt(d3t) )
      reqt = 0


      allocate(  pdata(npvals,nparcels) )
      pdata = 0.0
      allocate( packet(npvals,nparcels) )
      packet = 0.0
      allocate(   ploc(  3   ,nparcels) )
      ploc = 0.0

      allocate( flag(ib:ie,jb:je,kb:ke) )
      flag = .false.

      allocate(    cfb(ipb:ipe,jpb:jpe,kpb:kpe) )
      cfb = 0.0
      allocate(    cfa(kpb:kpe) )
      cfa = 0.0
      allocate(    cfc(kpb:kpe) )
      cfc = 0.0
      allocate(     d1(kpb:kpe) )
      d1 = 0.0
      allocate(     d2(kpb:kpe) )
      d2 = 0.0
      allocate(    pdt(ipb:ipe,jpb:jpe,kpb:kpe) )
      pdt = 0.0
      allocate(   deft(ipb:ipe,jpb:jpe,kpb:kpe) )
      deft = 0.0
      allocate(    rhs(ipb:ipe,jpb:jpe) )
      rhs = 0.0
      allocate(  trans(ipb:ipe,jpb:jpe) )
      trans = 0.0

      call init3d(xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf,  &
                  xfref,yfref,sigma,c1,c2,gz,                       &
                  zh,mh,rmh,zf,mf,rmf,rho0s,pi0s,prs0s,             &
                  pi0,prs0,rho0,thv0,th0,rth0,qv0,                  &
                  u0,v0,qc0,qi0,rr0,rf0,rrf0,                       &
                  rain,sws,svs,sps,srs,sgs,sus,shs,                 &
                  thflux,qvflux,cd,ch,cq,                           &
                  dum1,dum2,dum3,dum4,divx,rho,prs,                 &
                  t11,t12,t13,t22,t23,t33,                          &
                  rru,ua,u3d,uten,uten1,rrv,va,v3d,vten,vten1,      &
                  rrw,wa,w3d,wten,wten1,ppi,pp3d,ppten,sten,        &
                  tha,th3d,thten,thten1,qa,q3d,qten,                &
                  kmh,kmv,khh,khv,tkea,tke3d,tketen,                &
                  pta,pt3d,ptten,                                   &
                  pdata,cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans)


!----------------------------------------------------------------------

      if(ibalance.eq.2 .and.  psolver.ne.4.and.psolver.ne.5 )then
        deallocate( cfb )
        deallocate( cfa )
        deallocate( cfc )
        deallocate( d1 )
        deallocate( d2 )
        deallocate( pdt )
        deallocate( deft )
        deallocate( rhs )
        deallocate( trans )
        ipb = 1
        ipe = 1
        jpb = 1
        jpe = 1
        kpb = 1
        kpe = 1
        allocate(    cfb(ipb:ipe,jpb:jpe,kpb:kpe) )
        cfb = 0.0
        allocate(    cfa(kpb:kpe) )
        cfa = 0.0
        allocate(    cfc(kpb:kpe) )
        cfc = 0.0
        allocate(     d1(kpb:kpe) )
        d1 = 0.0
        allocate(     d2(kpb:kpe) )
        d2 = 0.0
        allocate(    pdt(ipb:ipe,jpb:jpe,kpb:kpe) )
        pdt = 0.0
        allocate(   deft(ipb:ipe,jpb:jpe,kpb:kpe) )
        deft = 0.0
        allocate(    rhs(ipb:ipe,jpb:jpe) )
        rhs = 0.0
        allocate(  trans(ipb:ipe,jpb:jpe) )
        trans = 0.0
      endif

      if( myid.eq.0 ) print *
      if( myid.eq.0 ) print *,'  allocating diagnostic arrays:  ntdiag,nqdiag = ',ntdiag,nqdiag
      if( myid.eq.0 ) print *

      allocate( tdiag(ibd:ied,jbd:jed,kbd:ked,ntdiag) )
      tdiag = 0.0
      allocate( qdiag(ibd:ied,jbd:jed,kbd:ked,nqdiag) )
      qdiag = 0.0

!----------------------------------------------------------------------

      call setup_output(tdef,qname,budname,xh,xf,yh,yf,xfref,yfref,sigma,sigmaf,zh,zf)

      call init_physics(prs0,rf0,dum1,dum2,dum3,u0,ua,v0,va,o30,   &
                             lu_index,xland,emiss,thc,albd,znt,mavail,f2d,tsk,u1,v1,s1, &
                             zh,u10,v10,wspd)

      call init_surface(num_soil_layers,dosfcflx,xh,ruh,xf,yh,rvh,yf,   &
                        lu_index,xland,tsk,slab_zs,slab_dzs,tslb, &
                        emiss,thc,albd,znt,mavail,dsxy,prs0s,prs0,   &
                        tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml)

      if(irst.eq.1)then
        restart = .true.
        call     read_restart(nstep,nrec,prec,nwrite,nrst,num_soil_layers,         &
                              dt,dtlast,mtime,ndt,adt,acfl,dbldt,mass1,            &
                              stattim,taptim,rsttim,radtim,prcltim,                &
                              qbudget,asq,bsq,qname,                               &
                              xfref,yfref,zh,zf,sigma,sigmaf,zs,                   &
                              th0,prs0,pi0,rho0,qv0,u0,v0,                         &
                              rain,sws,svs,sps,srs,sgs,sus,shs,                    &
                              tsk,znt,ust,cd,ch,cq,u1,v1,s1,thflux,qvflux,         &
                              radbcw,radbce,radbcs,radbcn,                         &
                              rho,prs,ua,va,wa,ppi,tha,qa,tkea,                    &
                              swten,lwten,radsw,rnflx,radswnet,radlwin,rad2d,      &
                              effc,effi,effs,effr,effg,effis,                      &
                              lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,      &
                              hpbl,wspd,psim,psih,gz1oz0,br,                       &
                              CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                       &
                              MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                    &
                              CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,       &
                              f2d,gsw,glw,chklowq,capg,snowc,fm,fh,tslb,           &
                              tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,               &
                              qpten,qtten,qvten,qcten,pta,pdata,ploc,ppx,sten,     &
                              ntdiag,nqdiag,tdiag,qdiag,                           &
                              dum1,dat1,dat2,dat3,reqt,restart_prcl)
        !  In case user wants to change values on a restart:
        IF( restart_reset_frqtim )THEN 
          if( statfrq.gt.0.0 ) stattim = mtime + statfrq
          if(  tapfrq.gt.0.0 ) taptim  = mtime + tapfrq
          if(  rstfrq.gt.0.0 ) rsttim  = mtime + rstfrq
        ENDIF
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Using the following: '
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '   stattim = ',stattim
        if(dowr) write(outfile,*) '   taptim  = ',taptim
        if(dowr) write(outfile,*) '   rsttim  = ',rsttim
        if(dowr) write(outfile,*) '   radtim  = ',radtim
        if(dowr) write(outfile,*)
      else
        restart = .false.
        restart_prcl = .false.
      endif

      IF( run_time .gt. 0.0 )THEN
        timax = mtime + run_time
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Detected positive value for run_time. '
        if(dowr) write(outfile,*) '     Using the following values: '
        if(dowr) write(outfile,*) '        run_time = ',run_time
        if(dowr) write(outfile,*) '        timax    = ',timax
        if(dowr) write(outfile,*)
        call setup_output(tdef,qname,budname,xh,xf,yh,yf,xfref,yfref,sigma,sigmaf,zh,zf)
      ENDIF

      call       getset(restart,mass1,ruh,rvh,xf,                          &
                        gz,sigma,sigmaf,rmh,mf,dzdx,dzdy,                  &
                        pi0,th0,rho0,prs0,ust,u1,v1,s1,                    &
                        zh,c1,c2,zf,rr,rf,rho,prs,dum1,dum2,               &
                        ua,u3d,va,v3d,wa,w3d,ppi,pp3d,                     &
                        tha,th3d,qa,q3d,tkea,tke3d,pta,pt3d,               &
                        reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk,        &
                        nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                   &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                   &
                        uw31,uw32,ue31,ue32,us31,us32,un31,un32,           &
                        vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,           &
                        ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,           &
                        sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,           &
                        tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2)

      rtime=sngl(mtime)

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   Prepare turbulence vars for first time step  cccccccccccccccccc
!cc     (new since cm1r17)                         cccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        getsfc = .true.
        if( restart ) getsfc = .false.
        call sfc_and_turb(getsfc,nstep,dt,dosfcflx,cloudvar,qbudget, &
                   xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf,  &
                   yh,vh,rvh,yf,vf,rvf,                              &
                   rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,zf,mf,rmf,  &
                   pi0s,rth0s,pi0,rho0,prs0,thv0,th0,qv0,            &
                   zs,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv,        &
                   tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,tlh,          &
                   dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,          &
                   divx,rho,rr,rf,prs,                               &
                   t11,t12,t13,t22,t23,t33,                          &
                   u0,ua,v0,va,wa,                                   &
                   ppi,pp3d,ppten,                                   &
                   tha,th3d,thten,thten1,qa,                         &
                   kmh,kmv,khh,khv,tkea,tke3d,                       &
                   nm,defv,defh,dissten,radsw,radswnet,radlwin,      &
                   thpten,qvpten,qcpten,qipten,upten,vpten,          &
                   lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,znt,ust,    &
                   hpbl,wspd,psim,psih,gz1oz0,br,                    &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                    &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                 &
                   CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,    &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh,  &
                   mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d,   &
                   num_soil_layers,slab_zs,slab_dzs,tslb,tmn,        &
                   tml,t0ml,hml,h0ml,huml,hvml,tmoml,                &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,               &
                   nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   kw1,kw2,ke1,ke2,ks1,ks2,kn1,kn2,                  &
                   rtime,ntdiag,tdiag,.false.)
        ! end_sfc_and_turb

!--------------------------------------------------------------------
!  get stress terms for explicit diffusion scheme:

      IF( ((idiff.ge.1).and.(difforder.eq.2)) .or. (dns.eq.1) )THEN
        call diff2def(uh,arh1,arh2,uf,arf1,arf2,vh,vf,mh,c1,c2,mf,ust,znt,u1,v1,s1,  &
                      divx,rho,rr,rf,t11,t12,t13,t22,t23,t33,ua,va,wa,dissten)
      ENDIF

!----------------------------------------------------------------------
!  All done with initialization.  A few more odds and ends ....

      if( adapt_dt.eq.1 )then
        dt = dbldt
        call dtsmall(dt)
        if( .not. restart )then
          call calccflquick(dt,uh,vh,mh,u3d,v3d,w3d)
          ndt = 1
          adt = dt
          acfl = cflmax
        endif
        IF( (imoist.eq.1).and.(ptype.eq.2) )then
          call consat2(dt)
        ENDIF
        IF( (imoist.eq.1).and.(ptype.eq.4) )then
          call lfoice_init(dt)
        ENDIF
      endif

      if( .not. restart )then
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  initial conditions:'
        if(dowr) write(outfile,*)
      endif

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k)=rho(i,j,k)
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
        enddo
        enddo
        enddo
      ENDIF
      reset = .false.
      call       statpack(nrec,ndt,dt,dtlast,rtime,adt,acfl,cloudvar,qname,budname,qbudget,asq,bsq, &
                          xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,vf,zh,mh,rmh,mf,    &
                          zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf,               &
                          rstat,pi0,rho0,thv0,th0,qv0,u0,v0,                &
                          dum1,dum2,dum3,dum4,dum5,ppten,prs,               &
                          ua,va,wa,ppi,tha,qa,qten,kmh,kmv,khh,khv,tkea,pta,u10,v10,reset)
      IF( adapt_dt.eq.1 )THEN
        ndt  = 0
        adt  = 0.0
        acfl = 0.0
      ENDIF

!-------------------------------------------------------------------
    IF( .not. restart )THEN
      ! Initial conditions:  (do not write if this is a restart)
      IF(output_format.eq.1.or.output_format.eq.2)THEN
        sten = 0.0
        nn = 1
        if(terrain_flag .and. output_interp.eq.1) nn = 2
        if(output_format.eq.2) nn = 1
        DO n=1,nn
          if(n.eq.1)then
            fnum = 51
          else
            fnum = 71
          endif
          call writeout(rtime,dt,fnum,nwrite,qname,xh,xf,uf,yh,yf,vf,xfref,yfref,              &
                        rds,sigma,rdsf,sigmaf,zh,zf,mf,gx,gy,                                  &
                        pi0,prs0,rho0,rr0,rf0,rrf0,th0,qv0,u0,v0,                              &
                        zs,rgzu,rgzv,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,psfc,      &
                        rxh,arh1,arh2,uh,ruh,rxf,arf1,arf2,vh,rvh,mh,rmf,rr,rf,                &
                        gz,rgz,gzu,gzv,gxu,gyv,dzdx,dzdy,c1,c2,                                &
                        cd,ch,cq,tlh,dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,                  &
                        t11,t12,t13,t22,t23,t33,rho,prs,sten,                                  &
                        rru,ua,u3d,uten,rrv,va,v3d,vten,rrw,wa,w3d,wten,ppi,tha,               &
                        us,vs,ws,thadv,thten,nm,defv,defh,dissten,                             &
                        thpten,qvpten,qcpten,qipten,upten,vpten,                               &
                        lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,  &
                        qa,kmh,kmv,khh,khv,tkea,swten,lwten,                                   &
                        radsw,rnflx,radswnet,radlwin,dsr,olr,pta,                              &
                        num_soil_layers,u10,v10,t2,q2,znt,ust,u1,v1,s1,                        &
                        hpbl,zol,mol,br,psim,psih,qsfc,                                        &
                        dat1,dat2,dat3,reqt,ntdiag,nqdiag,tdiag,qdiag,                         &
                        nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
        ENDDO
#ifdef HDFOUT
      ELSEIF(output_format.ge.3)THEN
       sten = 0.0
        call writeout_mult_hdf5(0.0,qname,rds,sigma,rdsf,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf, &
                      pi0,prs0,rho0,th0,qv0,u0,v0,                     &
                      zs,gz,rgz,rgzu,rgzv,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cd,ch,cq,dum1,dum2,dum3,dum4,  &
                      t11,t12,rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,    &
                      qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,   &
                      dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
#endif
      ENDIF
    ENDIF  ! endif for .not. restart
!-------------------------------------------------------------------

!-------------------------------------------------------------------
!  Write parcel data:
      IF( iprcl.eq.1 )THEN
      if( .not. restart_prcl )then
        call     parcel_interp(dt,xh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                               zh,mh,rmh,zf,mf,znt,ust,c1,c2,          &
                               pi0,th0,thv0,qv0,qc0,qi0,rth0,          &
                               dum1,dum2,dum3,dum4,dum5,dum6,prs,rho,  &
                               sten,dum7,dum8,wten,wten1,              &
                               u3d,v3d,w3d,pp3d,thten,thten1,th3d,q3d, &
                               kmh,kmv,khh,khv,tke3d,pt3d,pdata,       &
                               packet,reqs_p,                          &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,        &
                               nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
        rtime = sngl(mtime)
        call parcel_write(prec,rtime,qname,pdata,ploc)
      
      else
        if(myid.eq.0) print *
        if(myid.eq.0) print *,'  NOTE:  skipping parcel_write '
        if(myid.eq.0) print *
      endif
        ! next parcel write time will be "prclfrq" seconds in the future:
        prcltim = mtime + prclfrq
        if(myid.eq.0) print *
        if(myid.eq.0) print *,'  prcltim = ',prcltim
        if(myid.eq.0) print *
      ENDIF

!-------------------------------------------------------------------

      rtime=sngl(mtime)
      if(myid.eq.0)then
        if(timeformat.eq.1)then
          write(6,110) nstep,rtime,' sec '
        elseif(timeformat.eq.2)then
          write(6,110) nstep,rtime/60.0,' min '
        elseif(timeformat.eq.3)then
          write(6,110) nstep,rtime/3600.0,' hour'
        elseif(timeformat.eq.4)then
          write(6,110) nstep,rtime/86400.0,' day '
        else
          write(6,110) nstep,rtime,' sec'
        endif
110     format(2x,i12,4x,f18.6,a5)
      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '-------------Done with Preprocessors-----------'
      if(dowr) write(outfile,*)

      if(iconly.eq.1)then
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  User has requested initial conditions only'
        if(dowr) write(outfile,*) '     (iconly = 1)'
        if(dowr) write(outfile,*) '  ... stopping ... '
        if(dowr) write(outfile,*)
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        stop 55555
      endif

!----------------------------------------------------------------------
!  150820:  Write restart file if rstfrq=0 and stop

      IF( abs(rstfrq).lt.0.0001 )THEN
        nrst = 0
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Detected rstfrq = 0 '
        if(dowr) write(outfile,*) '  ... writing restart file ... '
        if(dowr) write(outfile,*)
        call     write_restart(nstep,nrec,prec,nwrite,nrst,num_soil_layers,         &
                               dt,dtlast,mtime,ndt,adt,acfl,dbldt,mass1,            &
                               stattim,taptim,rsttim,radtim,prcltim,                &
                               qbudget,asq,bsq,qname,                               &
                               xfref,yfref,zh,zf,sigma,sigmaf,zs,                   &
                               th0,prs0,pi0,rho0,qv0,u0,v0,                         &
                               rain,sws,svs,sps,srs,sgs,sus,shs,                    &
                               tsk,znt,ust,cd,ch,cq,u1,v1,s1,thflux,qvflux,         &
                               radbcw,radbce,radbcs,radbcn,                         &
                               rho,prs,ua,va,wa,ppi,tha,qa,tkea,                    &
                               swten,lwten,radsw,rnflx,radswnet,radlwin,rad2d,      &
                               effc,effi,effs,effr,effg,effis,                      &
                               lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,      &
                               hpbl,wspd,psim,psih,gz1oz0,br,                       &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                       &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                    &
                               CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,       &
                               f2d,gsw,glw,chklowq,capg,snowc,fm,fh,tslb,           &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,               &
                               qpten,qtten,qvten,qcten,pta,pdata,ploc,ppx,sten,     &
                               ntdiag,nqdiag,tdiag,qdiag,                           &
                               dum1,dat1,dat2,dat3,reqt)
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  ... stopping ... '
        if(dowr) write(outfile,*)
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        stop 55556
      ENDIF

!----------------------------------------------------------------------

      time_sound=0.
      time_poiss=0.
      time_advs=0.
      time_advu=0.
      time_advv=0.
      time_advw=0.
      time_buoyan=0.
      time_turb=0.
      time_diffu=0.
      time_microphy=0.
      time_stat=0.
      time_cflq=0.
      time_bc=0.
      time_misc=0.
      time_integ=0.
      time_rdamp=0.
      time_divx=0.
      time_write=0.
      time_restart=0.
      time_tmix=0.
      time_cor=0.
      time_fall=0.
      time_satadj=0.
      time_sfcphys=0.
      time_parcels=0.0
      time_rad=0.
      time_pbl=0.
      time_swath=0.
      time_pdef=0.
      time_prsrho=0.
#ifdef MPI
      time_mpu1=0.
      time_mpv1=0.
      time_mpw1=0.
      time_mpp1=0.
      time_mpu2=0.
      time_mpv2=0.
      time_mpw2=0.
      time_mpp2=0.
      time_mps1=0.
      time_mps3=0.
      time_mpq1=0.
      time_mptk1=0.
      time_mptk2=0.
      time_mps2=0.
      time_mps4=0.
      time_mpq2=0.
      time_mpb=0.

      call MPI_BARRIER (MPI_COMM_WORLD,ierr)

      if(myid.eq.0)then
        tstart=mpi_wtime()
      endif
#endif

      ! This initializes timer
      if(timestats.ge.1)then
        call system_clock(count,rate,maxr)
        clock_rate=1.0/rate
        xtime=mytime()
      endif

!----------------------------------------------------------------------
!  Time loop

      if(timestats.ge.1)then
        steptime1 = 0.0
        steptime2 = 0.0
      endif

      nstep0 = nstep

      do while( mtime.lt.timax )
        nstep = nstep + 1
        call     solve(nstep,nrec,prec,nwrite,nrst,rbufsz,num_soil_layers,ndt,ntdiag,nqdiag, &
                   dt,dtlast,mtime,stattim,taptim,rsttim,radtim,prcltim,adt,acfl,dbldt,mass1,mass2, &
                   dosfcflx,cloudvar,rhovar,qname,budname,bud,bud2,qbudget,asq,bsq, &
                   xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf,yh,vh,rvh,yf,vf,rvf,   &
                   xfref,yfref,dumk1,dumk2,rds,sigma,rdsf,sigmaf,     &
                   tauh,taus,zh,mh,rmh,c1,c2,tauf,zf,mf,rmf,          &
                   rstat,rho0s,pi0s,prs0s,rth0s,pi0,rho0,prs0,thv0,th0,rth0,qv0,qc0,  &
                   qi0,rr0,rf0,rrf0,                                  &
                   zs,gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy,gx,gxu,gy,gyv, &
                   rain,sws,svs,sps,srs,sgs,sus,shs,                  &
                   tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,tlh,           &
                   radbcw,radbce,radbcs,radbcn,                       &
                   dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,           &
                   divx,rho,rr,rf,prs,                                &
                   t11,t12,t13,t22,t23,t33,                           &
                   u0,rru,us,ua,u3d,uten,uten1,                       &
                   v0,rrv,vs,va,v3d,vten,vten1,                       &
                   rrw,ws,wa,w3d,wten,wten1,                          &
                   ppi,pp3d,piadv,ppten,sten,ppx,                     &
                   tha,th3d,thadv,thten,thten1,thterm,                &
                   qpten,qtten,qvten,qcten,qa,q3d,qten,               &
                   kmh,kmv,khh,khv,tkea,tke3d,tketen,                 &
                   nm,defv,defh,dissten,                              &
                   thpten,qvpten,qcpten,qipten,upten,vpten,           &
                   swten,lwten,o30,radsw,rnflx,radswnet,radlwin,dsr,olr,rad2d, &
                   effc,effi,effs,effr,effg,effis,                    &
                   lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,znt,ust,   &
                   hpbl,wspd,psim,psih,gz1oz0,br,                     &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                     &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                  &
                   CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,     &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh,   &
                   mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d,    &
                   slab_zs,slab_dzs,tslb,tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,        &
                   pta,pt3d,ptten,pdata,packet,ploc,                  &
                   cfb,cfa,cfc, d1, d2,pdt,deft,rhs,trans,flag,       &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk,reqs_q,reqs_t, &
                   nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                  &
                   n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,          &
                   ww1,ww2,we1,we2,ws1,ws2,wn1,wn2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,          &
                   ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,          &
                   sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,          &
                   rw31,rw32,re31,re32,rs31,rs32,rn31,rn32,          &
                   qw31,qw32,qe31,qe32,qs31,qs32,qn31,qn32,          &
                   tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2,          &
                   kw1,kw2,ke1,ke2,ks1,ks2,kn1,kn2,                  &
                   tw1,tw2,te1,te2,ts1,ts2,tn1,tn2,                  &
                   dat1,dat2,dat3,reqt,tdiag,qdiag)
        ! end_solve
        if(timestats.eq.2)then
          steptime2=time_sound+time_poiss+time_buoyan+time_turb+            &
                    time_diffu+time_microphy+time_stat+time_cflq+           &
                    time_bc+time_misc+time_integ+time_rdamp+time_divx+      &
                    time_write+time_restart+time_tmix+time_cor+time_fall+   &
                    time_satadj+time_sfcphys+time_parcels+                  &
                    time_rad+time_pbl+time_swath+time_pdef+time_prsrho+     &
#ifdef MPI
                    time_mpu1+time_mpv1+time_mpw1+time_mpp1+                &
                    time_mpu2+time_mpv2+time_mpw2+time_mpp2+                &
                    time_mps1+time_mps3+time_mpq1+time_mptk1+                         &
                    time_mps2+time_mps4+time_mpq2+time_mptk2+time_mpb+                &
#endif
                    time_advs+time_advu+time_advv+time_advw
          write(6,157) nstep,steptime2-steptime1
157       format('    timing for time step ',i12,':',f12.4,' s')
          steptime1 = steptime2
        endif
      enddo

!----------------------------------------------------------------------
!  write new stats descriptor file, if necessary:

      IF( output_format.eq.1 .and. myid.eq.0 )THEN
        IF( adapt_dt.eq.1 .and. statfrq.lt.0.0 )THEN
          print *,'  re-writing GrADS stats descriptor file .... '
          call write_statsctl(tdef,qname,budname,nstep+1)
        ENDIF
      ENDIF

!----------------------------------------------------------------------

#ifdef MPI
      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
      if(timestats.ge.1) time_mpb=time_mpb+mytime()

      if(myid.eq.0.and.procfiles)then
        tend=mpi_wtime()
        print *
        print *,'Total time (s): ',tend-tstart
        print *
      endif

#endif
!----------------------------------------------------------------------

    IF(timestats.ge.1)THEN

#ifdef MPI
      ! for MPI runs without procfiles, average the timestat terms:
      IF(.not.procfiles)THEN
        sum = 0.0
        call MPI_REDUCE(time_sound   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_sound = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_poiss   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_poiss = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_advs    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_advs = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_advu    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_advu = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_advv    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_advv = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_advw    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_advw = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_divx    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_divx = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_buoyan  ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_buoyan = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_turb    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_turb = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_sfcphys ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_sfcphys = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_tmix    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_tmix = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_cor     ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_cor = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_diffu   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_diffu = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_rdamp   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_rdamp = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_microphy,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_microphy = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_satadj  ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_satadj = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_fall    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_fall = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_rad     ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_rad = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_pbl     ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_pbl = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_stat    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_stat = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_cflq    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_cflq = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_bc      ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_bc = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_integ   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_integ = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_write   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_write = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_restart ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_restart = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_misc    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_misc = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_swath   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_swath = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_pdef    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_pdef = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_prsrho  ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_prsrho = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_parcels ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_parcels = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpu1    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpu1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpv1    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpv1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpw1    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpw1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpp1    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpp1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpu2    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpu2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpv2    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpv2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpw2    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpw2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpp2    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpp2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mps1    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mps1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mps3    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mps3 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpq1    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpq1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mps2    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mps2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mps4    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mps4 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpq2    ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpq2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mptk1   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mptk1 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mptk2   ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mptk2 = sum/float(numprocs)
        sum = 0.0
        call MPI_REDUCE(time_mpb     ,sum,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
        time_mpb = sum/float(numprocs)
      ENDIF
#endif

      time_solve=time_sound+time_poiss+time_buoyan+time_turb+             &
                  time_diffu+time_microphy+time_stat+time_cflq+           &
                  time_bc+time_misc+time_integ+time_rdamp+time_divx+      &
                  time_write+time_restart+time_tmix+time_cor+time_fall+   &
                  time_satadj+time_sfcphys+time_parcels+                  &
                  time_rad+time_pbl+time_swath+time_pdef+time_prsrho+     &
#ifdef MPI
                  time_mpu1+time_mpv1+time_mpw1+time_mpp1+                &
                  time_mpu2+time_mpv2+time_mpw2+time_mpp2+                &
                  time_mps1+time_mps3+time_mpq1+time_mptk1+                         &
                  time_mps2+time_mps4+time_mpq2+time_mptk2+time_mpb+                &
#endif
                  time_advs+time_advu+time_advv+time_advw
      time_solve0 = time_solve

#ifdef MPI
      mp_total=time_mpu1+time_mpv1+time_mpw1+time_mpp1+                   &
               time_mpu2+time_mpv2+time_mpw2+time_mpp2+                   &
               time_mps1+time_mps3+time_mpq1+time_mptk1+                            &
               time_mps2+time_mps4+time_mpq2+time_mptk2+time_mpb
#endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'Total time: ',time_solve
      if(dowr) write(outfile,*)
      time_solve=0.01*time_solve
      if(time_solve.lt.0.0001) time_solve=1.

    IF(dowr)THEN
      write(outfile,100) 'sound   ',time_sound,time_sound/time_solve
      write(outfile,100) 'poiss   ',time_poiss,time_poiss/time_solve
      write(outfile,100) 'advs    ',time_advs,time_advs/time_solve
      write(outfile,100) 'advu    ',time_advu,time_advu/time_solve
      write(outfile,100) 'advv    ',time_advv,time_advv/time_solve
      write(outfile,100) 'advw    ',time_advw,time_advw/time_solve
      write(outfile,100) 'divx    ',time_divx,time_divx/time_solve
      write(outfile,100) 'buoyan  ',time_buoyan,time_buoyan/time_solve
      write(outfile,100) 'turb    ',time_turb,time_turb/time_solve
      write(outfile,100) 'sfcphys ',time_sfcphys,time_sfcphys/time_solve
      write(outfile,100) 'tmix    ',time_tmix,time_tmix/time_solve
      write(outfile,100) 'cor     ',time_cor,time_cor/time_solve
      write(outfile,100) 'diffu   ',time_diffu,time_diffu/time_solve
      write(outfile,100) 'rdamp   ',time_rdamp,time_rdamp/time_solve
      write(outfile,100) 'microphy',time_microphy,time_microphy/time_solve
      write(outfile,100) 'satadj  ',time_satadj,time_satadj/time_solve
      write(outfile,100) 'fallout ',time_fall,time_fall/time_solve
      write(outfile,100) 'radiatio',time_rad,time_rad/time_solve
      write(outfile,100) 'pbl     ',time_pbl,time_pbl/time_solve
      write(outfile,100) 'stat    ',time_stat,time_stat/time_solve
      write(outfile,100) 'cflq    ',time_cflq,time_cflq/time_solve
      write(outfile,100) 'bc      ',time_bc,time_bc/time_solve
      write(outfile,100) 'integ   ',time_integ,time_integ/time_solve
      write(outfile,100) 'write   ',time_write,time_write/time_solve
      write(outfile,100) 'restart ',time_restart,time_restart/time_solve
      write(outfile,100) 'misc    ',time_misc,time_misc/time_solve
      write(outfile,100) 'swaths  ',time_swath,time_swath/time_solve
      write(outfile,100) 'pdef    ',time_pdef,time_pdef/time_solve
      write(outfile,100) 'prsrho  ',time_prsrho,time_prsrho/time_solve
      write(outfile,100) 'parcels ',time_parcels,time_parcels/time_solve
#ifdef MPI
      write(outfile,100) 'mp_total',mp_total,mp_total/time_solve
      write(outfile,*)
      write(outfile,100) 'mpu1    ',time_mpu1,time_mpu1/time_solve
      write(outfile,100) 'mpu2    ',time_mpu2,time_mpu2/time_solve
      write(outfile,100) 'mpv1    ',time_mpv1,time_mpv1/time_solve
      write(outfile,100) 'mpv2    ',time_mpv2,time_mpv2/time_solve
      write(outfile,100) 'mpw1    ',time_mpw1,time_mpw1/time_solve
      write(outfile,100) 'mpw2    ',time_mpw2,time_mpw2/time_solve
      write(outfile,100) 'mpp1    ',time_mpp1,time_mpp1/time_solve
      write(outfile,100) 'mpp2    ',time_mpp2,time_mpp2/time_solve
      write(outfile,100) 'mps1    ',time_mps1,time_mps1/time_solve
      write(outfile,100) 'mps2    ',time_mps2,time_mps2/time_solve
      write(outfile,100) 'mps3    ',time_mps3,time_mps3/time_solve
      write(outfile,100) 'mps4    ',time_mps4,time_mps4/time_solve
      write(outfile,100) 'mpq1    ',time_mpq1,time_mpq1/time_solve
      write(outfile,100) 'mpq2    ',time_mpq2,time_mpq2/time_solve
      write(outfile,100) 'mptk1   ',time_mptk1,time_mptk1/time_solve
      write(outfile,100) 'mptk2   ',time_mptk2,time_mptk2/time_solve
      write(outfile,100) 'mpb     ',time_mpb,time_mpb/time_solve
#endif
      write(outfile,*)
    ENDIF

100   format(3x,a8,' :  ',f10.2,2x,f6.2,'%')

#ifdef MPI
      if(myid.eq.0) print *
      time_solve0 = max( time_solve0 , 1.0e-20 )
      if(myid.eq.0) print *,'  MN = ',float(nx*ny*nz)*float(nstep-nstep0)/((time_solve0/3600.0)*float(numprocs))
      if(myid.eq.0) print *
#endif

    ENDIF

!  End time loop
!----------------------------------------------------------------------

      close(unit=51)
      close(unit=52)
      close(unit=53)
      close(unit=54)
      close(unit=60)

!----------------------------------------------------------------------

#ifdef MPI
      call MPI_FINALIZE(rc)
      print *,'Program terminated normally:  myid=',myid
#else
      print *,'Program terminated normally'
#endif

      stop

8888  print *
      print *,'  8888: error opening or reading namelist.input '
      print *,'    ... stopping cm1 ... '
      call stopcm1

      end program cm1



comm.F          1587424407  1602  20    100644  174434    `
!-----------------------------------------------------------------------
!  message passing routines
!-----------------------------------------------------------------------


      function nabor(i,j,nx,ny)
      implicit none
      integer i,j,nx,ny,nabor
      integer newi,newj

      newi=i
      newj=j

      if ( newi .lt.  1 ) newi = nx
      if ( newi .gt.  nx) newi = 1

      if ( newj .lt.  1 ) newj = ny
      if ( newj .gt.  ny) newj = 1

      nabor = (newi-1) + (newj-1)*nx

      return
      end

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

#ifdef MPI
      subroutine getcorner(s,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: s
      real, intent(inout), dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
 
      integer k,nn,nr,nrb,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!------------------------------------------------------------------

      tag1=5001

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(nw2,nk,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag2=5002

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(sw2,nk,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag3=5003

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(ne2,nk,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag4=5004

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(se2,nk,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!------------------------------------------------------------------

      nrb = 4

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=s(ni,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(se1,nk,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif
 
!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=s(ni,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(ne1,nk,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=s(1,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(sw1,nk,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=s(1,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(nw1,nk,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif
 
!-----

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(0,nj+1,k)=nw2(k)
        enddo
      elseif(index.eq.index_sw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(0,0,k)=sw2(k)
        enddo
      elseif(index.eq.index_ne)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(ni+1,nj+1,k)=ne2(k)
        enddo
      elseif(index.eq.index_se)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(ni+1,0,k)=se2(k)
        enddo
      endif

      enddo

!-----

    nrb = nrb-4

    if( nrb.ge.1 )then
      call MPI_WAITALL(nrb,reqs(5:5+nrb-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornert(t,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: t
      real, intent(inout), dimension(nk+1) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer k,nn,nr,nrb,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-------------------------------------------------------------

      tag1=5001

      if(ibw.eq.0 .and. ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(nw2,nkp1,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag2=5002

      if(ibw.eq.0 .and. ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(sw2,nkp1,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag3=5003

      if(ibe.eq.0 .and. ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(ne2,nkp1,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag4=5004

      if(ibe.eq.0 .and. ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(se2,nkp1,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!-------------------------------------------------------------

      nrb = 4

      if(ibe.eq.0 .and. ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          se1(k)=t(ni,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(se1,nkp1,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      if(ibe.eq.0 .and. ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          ne1(k)=t(ni,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(ne1,nkp1,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      if(ibw.eq.0 .and. ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          sw1(k)=t(1,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(sw1,nkp1,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      if(ibw.eq.0 .and. ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          nw1(k)=t(1,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(nw1,nkp1,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(0,nj+1,k)=nw2(k)
        enddo
      elseif(index.eq.index_sw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(0,0,k)=sw2(k)
        enddo
      elseif(index.eq.index_ne)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(ni+1,nj+1,k)=ne2(k)
        enddo
      elseif(index.eq.index_se)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(ni+1,0,k)=se2(k)
        enddo
      endif

      enddo

!-----

    nrb = nrb-4

    if( nrb.ge.1 )then
      call MPI_WAITALL(nrb,reqs(5:5+nrb-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcorneru(u,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u
      real, intent(inout), dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer k,nn,nr,nrb,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag,count

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-----------------------------------------------------------------------

      tag=5001
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag=5002
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag=5003
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag=5004
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!-----------------------------------------------------------------------

      nrb = 4

      tag=5001
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=u(ni,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5002
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=u(ni,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5003
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=u(2,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5004
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=u(2,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----------------------------------------------------------------------

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(0,nj+1,k)=nw2(k)
        enddo
      elseif(index.eq.index_sw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(0,0,k)=sw2(k)
        enddo
      elseif(index.eq.index_ne)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(ni+2,nj+1,k)=ne2(k)
        enddo
      elseif(index.eq.index_se)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(ni+2,0,k)=se2(k)
        enddo
      endif

      enddo

!-----

    nrb = nrb-4

    if( nrb.ge.1 )then
      call MPI_WAITALL(nrb,reqs(5:5+nrb-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornerv(v,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v
      real, intent(inout), dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer k,nn,nr,nrb,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag,count

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-----------------------------------------------------------------------

      tag=5011
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag=5012
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag=5013
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag=5014
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!-----------------------------------------------------------------------

      nrb = 4

      tag=5011
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=v(ni,2,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5012
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=v(ni,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5013
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=v(1,2,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5014
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=v(1,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----------------------------------------------------------------------

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(0,nj+2,k)=nw2(k)
        enddo
      elseif(index.eq.index_sw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(0,0,k)=sw2(k)
        enddo
      elseif(index.eq.index_ne)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(ni+1,nj+2,k)=ne2(k)
        enddo
      elseif(index.eq.index_se)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(ni+1,0,k)=se2(k)
        enddo
      endif

      enddo

!-----

    nrb = nrb-4

    if( nrb.ge.1 )then
      call MPI_WAITALL(nrb,reqs(5:5+nrb-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornerw(w,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: w
      real, intent(inout), dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer k,nn,nr,nrb,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag,count

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-----------------------------------------------------------------------

      tag=5021
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag=5022
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag=5023
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag=5024
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!-----------------------------------------------------------------------

      nrb = 4

      tag=5021
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=w(ni,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5022
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=w(ni,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5023
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=w(1,1,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      tag=5024
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=w(1,nj,k)
        enddo
        nrb = nrb + 1
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----------------------------------------------------------------------

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          w(0,nj+1,k)=nw2(k)
        enddo
      elseif(index.eq.index_sw)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          w(0,0,k)=sw2(k)
        enddo
      elseif(index.eq.index_ne)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          w(ni+1,nj+1,k)=ne2(k)
        enddo
      elseif(index.eq.index_se)then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          w(ni+1,0,k)=se2(k)
        enddo
      endif

      enddo

!-----

    nrb = nrb-4

    if( nrb.ge.1 )then
      call MPI_WAITALL(nrb,reqs(5:5+nrb-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine getcorner3(s,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: s
      real, intent(inout), dimension(3,3,nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
 
      integer :: i,j,k,nn,nr,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!------------------------------------------------------------------

      tag1=5001

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(nw2,3*3*nk,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag2=5002

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(sw2,3*3*nk,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag3=5003

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(ne2,3*3*nk,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag4=5004

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(se2,3*3*nk,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!------------------------------------------------------------------

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          se1(i,j,k)=s(ni,1,k)
          se1(i,j,k)=s(ni-3+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(se1,3*3*nk,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif
 
!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          ne1(i,j,k)=s(ni,nj,k)
          ne1(i,j,k)=s(ni-3+i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(ne1,3*3*nk,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          sw1(i,j,k)=s(1,1,k)
          sw1(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(sw1,3*3*nk,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          nw1(i,j,k)=s(1,nj,k)
          nw1(i,j,k)=s(i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(nw1,3*3*nk,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif
 
!-----

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          s(0,nj+1,k)=nw2(i,j,k)
          s(-3+i,nj+j,k)=nw2(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_sw)then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          s(0,0,k)=sw2(i,j,k)
          s(-3+i,-3+j,k)=sw2(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_ne)then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          s(ni+1,nj+1,k)=ne2(i,j,k)
          s(ni+i,nj+j,k)=ne2(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_se)then
        do k=1,nk
        do j=1,3
        do i=1,3
!!!          s(ni+1,0,k)=se2(i,j,k)
          s(ni+i,-3+j,k)=se2(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),MPI_STATUS_IGNORE,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),MPI_STATUS_IGNORE,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(7),MPI_STATUS_IGNORE,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(8),MPI_STATUS_IGNORE,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2we_start(s,west,newwest,east,neweast,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je,kb:ke)
      real west(2,nj,nk),newwest(2,nj,nk)
      real east(2,nj,nk),neweast(2,nj,nk)
      integer reqs(4)

      integer i,j,k,nr
      integer tag1,tag2

!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs2we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs2we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------

      nr = 2

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          west(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        nr = nr+1
        call mpi_isend(west,cs2we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          east(i,j,k)=s(ni-2+i,j,k)
        enddo
        enddo
        enddo
        nr = nr+1
        call mpi_isend(east,cs2we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps3=time_mps3+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2we_end(s,west,newwest,east,neweast,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je,kb:ke)
      real west(2,nj,nk),newwest(2,nj,nk)
      real east(2,nj,nk),neweast(2,nj,nk)
      integer reqs(4)

      integer i,j,k,nn,nr,index
      integer :: index_east,index_west

!-------------------------------------------------------------------

      index_east = -1
      index_west = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          s(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          s(i-2,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(3:3+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps4=time_mps4+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2sn_start(s,south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je,kb:ke)
      real south(ni,2,nk),newsouth(ni,2,nk)
      real north(ni,2,nk),newnorth(ni,2,nk)
      integer reqs(4)

      integer i,j,k,nr
      integer tag3,tag4

!----------

      nr = 0

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs2sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs2sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nr = 2

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          north(i,j,k)=s(i,nj-2+j,k)
        enddo
        enddo
        enddo
        nr = nr+1
        call mpi_isend(north,cs2sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          south(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        nr = nr+1
        call mpi_isend(south,cs2sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps3=time_mps3+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2sn_end(s,south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je,kb:ke)
      real south(ni,2,nk),newsouth(ni,2,nk)
      real north(ni,2,nk),newnorth(ni,2,nk)
      integer reqs(4)

      integer i,j,k,nn,nr,index
      integer :: index_south,index_north

!----------

      index_south = -1
      index_north = -1

      nr = 0
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          s(i,j-2,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          s(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

!----------

      nr = 0

      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(3:3+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps4=time_mps4+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3s_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs3we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs3we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs3sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs3sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          west(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cs3we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          east(i,j,k)=s(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cs3we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          north(i,j,k)=s(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cs3sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          south(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cs3sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3s_end(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!-------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

    nn = 1
    do while( nn .le. nr )
      call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
      nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          s(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          s(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          s(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          s(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif

    enddo

      if(timestats.ge.1) time_mps2=time_mps2+mytime()
 
!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!-----------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      ! tk1
      subroutine comm_3t_start(t,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk+1),newwest(3,nj,nk+1)
      real east(3,nj,nk+1),neweast(3,nj,nk+1)
      real south(ni,3,nk+1),newsouth(ni,3,nk+1)
      real north(ni,3,nk+1),newnorth(ni,3,nk+1)
      integer reqs(8)

      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4

!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,ct3we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,ct3we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,ct3sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,ct3sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          west(i,j,k)=t(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,ct3we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          east(i,j,k)=t(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,ct3we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          north(i,j,k)=t(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,ct3sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          south(i,j,k)=t(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,ct3sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3t_end(t,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk+1),newwest(3,nj,nk+1)
      real east(3,nj,nk+1),neweast(3,nj,nk+1)
      real south(ni,3,nk+1),newsouth(ni,3,nk+1)
      real north(ni,3,nk+1),newnorth(ni,3,nk+1)
      integer reqs(8)

      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!-------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          t(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          t(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          t(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          t(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner

     if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then

        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then

          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni,0,k)
            enddo
          endif

          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni,nj+1,k)
            enddo
          endif

        endif

      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then

        if(ibs.eq.1)then

          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(0,1,k)
            enddo
          endif

          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni+1,1,k)
            enddo
          endif

        endif

        if(ibn.eq.1)then

          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(0,nj,k)
            enddo
          endif

          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni+1,nj,k)
            enddo
          endif

        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

      return
      end
      ! tk2


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3u_start(u,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real u(ib:ie+1,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni+1,3,nk),newsouth(ni+1,3,nk)
      real north(ni+1,3,nk),newnorth(ni+1,3,nk)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nu=nu+1
      tag1=1000+nu

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs3we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nu=nu+1
      tag2=1000+nu
 
      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs3we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nu=nu+1
      tag3=1000+nu

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cu3sn,MPI_REAL,mynorth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nu=nu+1
      tag4=1000+nu

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cu3sn,MPI_REAL,mysouth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          west(i,j,k)=u(i+1,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cs3we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          east(i,j,k)=u(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cs3we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          south(i,j,k)=u(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cu3sn,MPI_REAL,mysouth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          north(i,j,k)=u(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cu3sn,MPI_REAL,mynorth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      if(timestats.ge.1) time_mpu1=time_mpu1+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3u_end(u,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real u(ib:ie+1,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni+1,3,nk),newsouth(ni+1,3,nk)
      real north(ni+1,3,nk),newnorth(ni+1,3,nk)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!----------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          u(ni+1+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          u(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          u(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          u(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mpu2=time_mpu2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+1,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+2,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+2,nj,k)
            enddo
          endif
 
        endif
 
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mpu2=time_mpu2+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3v_start(v,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real v(ib:ie,jb:je+1,kb:ke)
      real west(3,nj+1,nk),newwest(3,nj+1,nk)
      real east(3,nj+1,nk),neweast(3,nj+1,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nv=nv+1
      tag1=2000+nv

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cv3we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nv=nv+1
      tag2=2000+nv
 
      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cv3we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nv=nv+1
      tag3=2000+nv
 
      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs3sn,MPI_REAL,mynorth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nv=nv+1
      tag4=2000+nv
 
      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs3sn,MPI_REAL,mysouth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          west(i,j,k)=v(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cv3we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          east(i,j,k)=v(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cv3we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          south(i,j,k)=v(i,j+1,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cs3sn,MPI_REAL,mysouth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          north(i,j,k)=v(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cs3sn,MPI_REAL,mynorth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      if(timestats.ge.1) time_mpv1=time_mpv1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3v_end(v,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real v(ib:ie,jb:je+1,kb:ke)
      real west(3,nj+1,nk),newwest(3,nj+1,nk)
      real east(3,nj+1,nk),neweast(3,nj+1,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north
 
!--------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          v(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          v(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          v(i,nj+1+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          v(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mpv2=time_mpv2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(1,nj+2,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni,nj+2,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(0,nj+1,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!--------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mpv2=time_mpv2+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3w_start(w,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk-1),newwest(3,nj,nk-1)
      real east(3,nj,nk-1),neweast(3,nj,nk-1)
      real south(ni,3,nk-1),newsouth(ni,3,nk-1)
      real north(ni,3,nk-1),newnorth(ni,3,nk-1)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nw=nw+1
      tag1=3000+nw

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cw3we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nw=nw+1
      tag2=3000+nw
 
      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cw3we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      nw=nw+1
      tag3=3000+nw
 
      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cw3sn,MPI_REAL,mynorth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nw=nw+1
      tag4=3000+nw
 
      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cw3sn,MPI_REAL,mysouth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          west(i,j,k-1)=w(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cw3we,MPI_REAL,mywest,tag1,    &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          east(i,j,k-1)=w(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cw3we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          south(i,j,k-1)=w(i,j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cw3sn,MPI_REAL,mysouth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          north(i,j,k-1)=w(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cw3sn,MPI_REAL,mynorth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------

      if(timestats.ge.1) time_mpw1=time_mpw1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3w_end(w,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk-1),newwest(3,nj,nk-1)
      real east(3,nj,nk-1),neweast(3,nj,nk-1)
      real south(ni,3,nk-1),newsouth(ni,3,nk-1)
      real north(ni,3,nk-1),newnorth(ni,3,nk-1)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!--------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          w(ni+i,j,k)=neweast(i,j,k-1)
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          w(i-3,j,k)=newwest(i,j,k-1)
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          w(i,nj+j,k)=newnorth(i,j,k-1)
        enddo
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          w(i,j-3,k)=newsouth(i,j,k-1)
        enddo
        enddo
        enddo
      endif

      enddo
 
      if(timestats.ge.1) time_mpw2=time_mpw2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!--------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mpw2=time_mpw2+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1s2d_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je)
      real west(nj),newwest(nj)
      real east(nj),neweast(nj)
      real south(ni),newsouth(ni)
      real north(ni),newnorth(ni)
      integer reqs(8)
 
      integer i,j,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,nj,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,nj,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,ni,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,ni,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j)
        do j=1,nj
          west(j)=s(1,j)
        enddo
        nr = nr + 1
        call mpi_isend(west,nj,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j)
        do j=1,nj
          east(j)=s(ni,j)
        enddo
        nr = nr + 1
        call mpi_isend(east,nj,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i)
        do i=1,ni
          north(i)=s(i,nj)
        enddo
        nr = nr + 1
        call mpi_isend(north,ni,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i)
        do i=1,ni
          south(i)=s(i,1)
        enddo
        nr = nr + 1
        call mpi_isend(south,ni,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1s2d_end(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je)
      real west(nj),newwest(nj)
      real east(nj),neweast(nj)
      real south(ni),newsouth(ni)
      real north(ni),newnorth(ni)
      integer reqs(8)
 
      integer i,j,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!---------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(j)
        do j=1,nj
          s(ni+1,j)=neweast(j)
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(j)
        do j=1,nj
          s(0,j)=newwest(j)
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i)
        do i=1,ni
          s(i,0)=newsouth(i)
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i)
        do i=1,ni
          s(i,nj+1)=newnorth(i)
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
              s(0,0)=s(1,0)
          endif
 
          if(p2tchnww)then
              s(0,nj+1)=s(1,nj+1)
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
              s(ni+1,0)=s(ni,0)
          endif
 
          if(p2tchnee)then
              s(ni+1,nj+1)=s(ni,nj+1)
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
              s(0,0)=s(0,1)
          endif
 
          if(p2tchses)then
              s(ni+1,0)=s(ni+1,1)
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
              s(0,nj+1)=s(0,nj)
          endif
 
          if(p2tchnen)then
              s(ni+1,nj+1)=s(ni+1,nj)
          endif
 
        endif
 
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1s_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs1we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs1we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs1sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs1sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          west(j,k)=s(1,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cs1we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          east(j,k)=s(ni,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cs1we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          north(i,k)=s(i,nj,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cs1sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          south(i,k)=s(i,1,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cs1sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1s_end(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!---------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          s(ni+1,j,k)=neweast(j,k)
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          s(0,j,k)=newwest(j,k)
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          s(i,0,k)=newsouth(i,k)
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          s(i,nj+1,k)=newnorth(i,k)
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1t_start(t,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(nj,nk+1),newwest(nj,nk+1)
      real east(nj,nk+1),neweast(nj,nk+1)
      real south(ni,nk+1),newsouth(ni,nk+1)
      real north(ni,nk+1),newnorth(ni,nk+1)
      integer reqs(8)

      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4

!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,ct1we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,ct1we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,ct1sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,ct1sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          west(j,k)=t(1,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,ct1we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          east(j,k)=t(ni,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,ct1we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          north(i,k)=t(i,nj,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,ct1sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          south(i,k)=t(i,1,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,ct1sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1t_end(t,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(nj,nk+1),newwest(nj,nk+1)
      real east(nj,nk+1),neweast(nj,nk+1)
      real south(ni,nk+1),newsouth(ni,nk+1)
      real north(ni,nk+1),newnorth(ni,nk+1)
      integer reqs(8)

      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!---------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          t(ni+1,j,k)=neweast(j,k)
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          t(0,j,k)=newwest(j,k)
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          t(i,0,k)=newsouth(i,k)
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          t(i,nj+1,k)=newnorth(i,k)
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner

      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then

        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then

          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni,0,k)
            enddo
          endif

          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni,nj+1,k)
            enddo
          endif

        endif

      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then

        if(ibs.eq.1)then

          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(0,1,k)
            enddo
          endif

          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni+1,1,k)
            enddo
          endif

        endif

        if(ibn.eq.1)then

          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(0,nj,k)
            enddo
          endif

          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni+1,nj,k)
            enddo
          endif

        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1u_start(u,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(in   ), dimension(ib:ie+1,jb:je,kb:ke) :: u
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni+1,nk),newsouth(ni+1,nk)
      real north(ni+1,nk),newnorth(ni+1,nk)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nu=nu+1
      tag1=1000+nu

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs1we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nu=nu+1
      tag2=1000+nu

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs1we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nu=nu+1
      tag3=1000+nu

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cu1sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nu=nu+1
      tag4=1000+nu

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cu1sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          west(j,k)=u(2,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cs1we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          east(j,k)=u(ni,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cs1we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni+1
          north(i,k)=u(i,nj,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cu1sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni+1
          south(i,k)=u(i,1,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cu1sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      if(timestats.ge.1) time_mpu1=time_mpu1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1u_end(u,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni+1,nk),newsouth(ni+1,nk)
      real north(ni+1,nk),newnorth(ni+1,nk)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!---------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          u(ni+2,j,k)=neweast(j,k)
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          u(0,j,k)=newwest(j,k)
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni+1
          u(i,0,k)=newsouth(i,k)
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni+1
          u(i,nj+1,k)=newnorth(i,k)
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mpu2=time_mpu2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+1,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

 
      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+2,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+2,nj,k)
            enddo
          endif
 
        endif
 
      endif
 
      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mpu2=time_mpu2+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1v_start(v,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(in   ), dimension(ib:ie,jb:je+1,kb:ke) :: v
      real west(nj+1,nk),newwest(nj+1,nk)
      real east(nj+1,nk),neweast(nj+1,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nv=nv+1
      tag1=2000+nv

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cv1we,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nv=nv+1
      tag2=2000+nv

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cv1we,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nv=nv+1
      tag3=2000+nv

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs1sn,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nv=nv+1
      tag4=2000+nv

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs1sn,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj+1
          west(j,k)=v(1,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cv1we,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj+1
          east(j,k)=v(ni,j,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cv1we,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          north(i,k)=v(i,nj,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cs1sn,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          south(i,k)=v(i,2,k)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cs1sn,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1v_end(v,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v
      real west(nj+1,nk),newwest(nj+1,nk)
      real east(nj+1,nk),neweast(nj+1,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!---------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
 
      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj+1
          v(ni+1,j,k)=neweast(j,k)
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj+1
          v(0,j,k)=newwest(j,k)
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          v(i,0,k)=newsouth(i,k)
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          v(i,nj+2,k)=newnorth(i,k)
        enddo
        enddo
      endif

      enddo

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(1,nj+2,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni,nj+2,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(0,nj+1,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif
 
      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()
 
!----------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1w_start(w,ww1,ww2,we1,we2,   &
                                 ws1,ws2,wn1,wn2,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real ww1(nj,nk-1),ww2(nj,nk-1)
      real we1(nj,nk-1),we2(nj,nk-1)
      real ws1(ni,nk-1),ws2(ni,nk-1)
      real wn1(ni,nk-1),wn2(ni,nk-1)
      integer reqs(8)
 
      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4

      nr = 0

!-----

      nw=nw+1
      tag1=3000+nw
 
        ! receive east
        if(ibe.eq.0)then
          nr = nr+1
          call mpi_irecv(we2,cw1we,MPI_REAL,myeast,tag1,   &
                        MPI_COMM_WORLD,reqs(nr),ierr)
        endif

!-----

      nw=nw+1
      tag2=3000+nw
 
        ! receive west
        if(ibw.eq.0)then
          nr = nr+1
          call mpi_irecv(ww2,cw1we,MPI_REAL,mywest,tag2,   &
                        MPI_COMM_WORLD,reqs(nr),ierr)
        endif

!-----

      nw=nw+1
      tag3=3000+nw
 
        ! receive north
        if(ibn.eq.0)then
          nr = nr+1
          call mpi_irecv(wn2,cw1sn,MPI_REAL,mynorth,tag3,   &
                        MPI_COMM_WORLD,reqs(nr),ierr)
        endif

!-----

      nw=nw+1
      tag4=3000+nw
 
        ! receive south
        if(ibs.eq.0)then
          nr = nr+1
          call mpi_irecv(ws2,cw1sn,MPI_REAL,mysouth,tag4,   &
                        MPI_COMM_WORLD,reqs(nr),ierr)
        endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

        ! send west
        if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=2,nk
          do j=1,nj
            ww1(j,k-1)=w(1,j,k)
          enddo
          enddo
          nr = nr+1
          call mpi_isend(ww1,cw1we,MPI_REAL,mywest,tag1,   &
                         MPI_COMM_WORLD,reqs(nr),ierr)
        endif

        ! send east
        if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=2,nk
          do j=1,nj
            we1(j,k-1)=w(ni,j,k)
          enddo
          enddo
          nr = nr+1
          call mpi_isend(we1,cw1we,MPI_REAL,myeast,tag2,   &
                         MPI_COMM_WORLD,reqs(nr),ierr)
        endif

        ! send south
        if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=2,nk
          do i=1,ni
            ws1(i,k-1)=w(i,1,k)
          enddo
          enddo
          nr = nr+1
          call mpi_isend(ws1,cw1sn,MPI_REAL,mysouth,tag3,   &
                         MPI_COMM_WORLD,reqs(nr),ierr)
        endif

        ! send north
        if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=2,nk
          do i=1,ni
            wn1(i,k-1)=w(i,nj,k)
          enddo
          enddo
          nr = nr+1
          call mpi_isend(wn1,cw1sn,MPI_REAL,mynorth,tag4,   &
                         MPI_COMM_WORLD,reqs(nr),ierr)
        endif

!-----

      if(timestats.ge.1) time_mpw1=time_mpw1+mytime()
 
      return
      end

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1w_end(w,ww1,ww2,we1,we2,   &
                               ws1,ws2,wn1,wn2,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real ww1(nj,nk-1),ww2(nj,nk-1)
      real we1(nj,nk-1),we2(nj,nk-1)
      real ws1(ni,nk-1),ws2(ni,nk-1)
      real wn1(ni,nk-1),wn2(ni,nk-1)
      integer reqs(8)
 
      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north
 
!-----

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=2,nk
        do j=1,nj
          w(ni+1,j,k)=we2(j,k-1)
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=2,nk
        do j=1,nj
          w(0,j,k)=ww2(j,k-1)
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=2,nk
        do i=1,ni
          w(i,nj+1,k)=wn2(i,k-1)
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=2,nk
        do i=1,ni
          w(i,0,k)=ws2(i,k-1)
        enddo
        enddo
      endif

      enddo

!-----

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mpw2=time_mpw2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=2,nk
!        do i=0,ni+1
!          w(i,nj+1,k)=w(i,nj  ,k)
!          w(i,nj+2,k)=w(i,nj-1,k)
!          w(i,nj+3,k)=w(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=2,nk
!        do j=0,nj+1
!          w(-2,j,k)=w(3,j,k)
!          w(-1,j,k)=w(2,j,k)
!          w( 0,j,k)=w(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2d_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je) :: s
      real, dimension(3,nj) :: west,newwest,east,neweast
      real, dimension(ni,3) :: south,newsouth,north,newnorth
      integer reqs(8)

      integer i,j,nr
      integer tag1,tag2,tag3,tag4

!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,3*nj,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,3*nj,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,ni*3,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,ni*3,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          west(i,j)=s(i,j)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,3*nj,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          east(i,j)=s(ni-3+i,j)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,3*nj,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          north(i,j)=s(i,nj-3+j)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,ni*3,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          south(i,j)=s(i,j)
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,ni*3,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      if(timestats.ge.1) time_mpq1=time_mpq1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2dew_end(s,west,newwest,east,neweast,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je) :: s
      real, dimension(3,nj) :: west,newwest,east,neweast
      integer reqs(8)

      integer i,j,nn,nr,index

!-------------------------------------------------------------------

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
      endif
      if(ibw.eq.0)then
        nr = nr + 1
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
      enddo

      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          s(ni+i,j)=neweast(i,j)
        enddo
        enddo
      endif

      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          s(i-3,j)=newwest(i,j)
        enddo
        enddo
      endif

!----------

      if(timestats.ge.1) time_mpq2=time_mpq2+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2dns_end(s,south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je) :: s
      real, dimension(ni,3) :: south,newsouth,north,newnorth
      integer reqs(8)

      integer i,j,nn,nr1,nr,index

!-------------------------------------------------------------------

      nr1 = 0
      if(ibe.eq.0)then
        nr1 = nr1 + 1
      endif
      if(ibw.eq.0)then
        nr1 = nr1 + 1
      endif

      nr = 0
      if(ibs.eq.0)then
        nr = nr + 1
      endif
      if(ibn.eq.0)then
        nr = nr + 1
      endif

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(nr1+1:nr1+nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1
      enddo

      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          s(i,j-3)=newsouth(i,j)
        enddo
        enddo
      endif

      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          s(i,nj+j)=newnorth(i,j)
        enddo
        enddo
      endif

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif

      if(ibe.eq.0)then
        nr = nr+1
      endif

      if(ibn.eq.0)then
        nr = nr+1
      endif

      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

!----------

      if(timestats.ge.1) time_mpq2=time_mpq2+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2d_corner(s)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je) :: s

      integer reqs(8)
      integer :: tag1,tag2,tag3,tag4,nr,nrb

!------------------------------------------------

      nr = 0

!-----

      tag1=5061

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(s(0,nj+1),1,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
      endif

!-----

      tag2=5062

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(s(0,0),1,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
      endif

!-----

      tag3=5063

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(s(ni+1,nj+1),1,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
      endif

!-----

      tag4=5064

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(s(ni+1,0),1,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nrb = 4

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nrb = nrb + 1
        call mpi_isend(s(ni,1),1,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nrb = nrb + 1
        call mpi_isend(s(ni,nj),1,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nrb = nrb + 1
        call mpi_isend(s(1,1),1,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nrb = nrb + 1
        call mpi_isend(s(1,nj),1,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(nrb),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      if( nr.ge.1 )then
        call MPI_WAITALL(nr,reqs(1:nr),MPI_STATUSES_IGNORE,ierr)
      endif

!-----

    nrb = nrb-4

    if( nrb.ge.1 )then
      call MPI_WAITALL(nrb,reqs(5:5+nrb-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine getcorner3_2d(s)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(inout), dimension(ib:ie,jb:je) :: s
 
      real, dimension(3,3) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer :: i,j,nn,nr,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4

!-----

      nr = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!------------------------------------------------------------------

      tag1=5001

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(nw2,3*3,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_nw = nr
      endif

!-----

      tag2=5002

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(sw2,3*3,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_sw = nr
      endif

!-----

      tag3=5003

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr = nr + 1
        call mpi_irecv(ne2,3*3,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_ne = nr
      endif

!-----

      tag4=5004

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr = nr + 1
        call mpi_irecv(se2,3*3,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr),ierr)
        index_se = nr
      endif

!------------------------------------------------------------------

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do j=1,3
        do i=1,3
          se1(i,j)=s(ni-3+i,j)
        enddo
        enddo
        call mpi_isend(se1,3*3,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif
 
!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do j=1,3
        do i=1,3
          ne1(i,j)=s(ni-3+i,nj-3+j)
        enddo
        enddo
        call mpi_isend(ne1,3*3,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do j=1,3
        do i=1,3
          sw1(i,j)=s(i,j)
        enddo
        enddo
        call mpi_isend(sw1,3*3,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do j=1,3
        do i=1,3
          nw1(i,j)=s(i,nj-3+j)
        enddo
        enddo
        call mpi_isend(nw1,3*3,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif
 
!-----

      nn = 1
      do while( nn .le. nr )
        call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if(index.eq.index_nw)then
        do j=1,3
        do i=1,3
          s(-3+i,nj+j)=nw2(i,j)
        enddo
        enddo
      elseif(index.eq.index_sw)then
        do j=1,3
        do i=1,3
          s(-3+i,-3+j)=sw2(i,j)
        enddo
        enddo
      elseif(index.eq.index_ne)then
        do j=1,3
        do i=1,3
          s(ni+i,nj+j)=ne2(i,j)
        enddo
        enddo
      elseif(index.eq.index_se)then
        do j=1,3
        do i=1,3
          s(ni+i,-3+j)=se2(i,j)
        enddo
        enddo
      endif

      enddo

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),MPI_STATUS_IGNORE,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),MPI_STATUS_IGNORE,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(7),MPI_STATUS_IGNORE,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(8),MPI_STATUS_IGNORE,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3r_start(th,pp,west,newwest,east,neweast,   &
                                     south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real th(ib:ie,jb:je,kb:ke)
      real pp(ib:ie,jb:je,kb:ke)
      real west(3,nj,nk,2),newwest(3,nj,nk,2)
      real east(3,nj,nk,2),neweast(3,nj,nk,2)
      real south(ni,3,nk,2),newsouth(ni,3,nk,2)
      real north(ni,3,nk,2),newnorth(ni,3,nk,2)
      integer reqs(8)

      integer i,j,k,nr
      integer tag1,tag2,tag3,tag4

!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs3we*2,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs3we*2,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)

      endif

!----------

      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs3sn*2,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs3sn*2,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,3
          west(i,j,k,1)=th(i,j,k)
        enddo
        enddo
        do j=1,nj
        do i=1,3
          west(i,j,k,2)=pp(i,j,k)
        enddo
        enddo
      enddo
        nr = nr + 1
        call mpi_isend(west,cs3we*2,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,3
          east(i,j,k,1)=th(ni-3+i,j,k)
        enddo
        enddo
        do j=1,nj
        do i=1,3
          east(i,j,k,2)=pp(ni-3+i,j,k)
        enddo
        enddo
      enddo
        nr = nr + 1
        call mpi_isend(east,cs3we*2,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,3
        do i=1,ni
          north(i,j,k,1)=th(i,nj-3+j,k)
        enddo
        enddo
        do j=1,3
        do i=1,ni
          north(i,j,k,2)=pp(i,nj-3+j,k)
        enddo
        enddo
      enddo
        nr = nr + 1
        call mpi_isend(north,cs3sn*2,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,3
        do i=1,ni
          south(i,j,k,1)=th(i,j,k)
        enddo
        enddo
        do j=1,3
        do i=1,ni
          south(i,j,k,2)=pp(i,j,k)
        enddo
        enddo
      enddo
        nr = nr + 1
        call mpi_isend(south,cs3sn*2,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3r_end(th,pp,west,newwest,east,neweast,   &
                                   south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real th(ib:ie,jb:je,kb:ke)
      real pp(ib:ie,jb:je,kb:ke)
      real west(3,nj,nk,2),newwest(3,nj,nk,2)
      real east(3,nj,nk,2),neweast(3,nj,nk,2)
      real south(ni,3,nk,2),newsouth(ni,3,nk,2)
      real north(ni,3,nk,2),newnorth(ni,3,nk,2)
      integer reqs(8)

      integer i,j,k,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!-------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

    nn = 1
    do while( nn .le. nr )
      call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
      nn = nn + 1

    if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,3
          th(ni+i,j,k)=neweast(i,j,k,1)
        enddo
        enddo
        do j=1,nj
        do i=1,3
          pp(ni+i,j,k)=neweast(i,j,k,2)
        enddo
        enddo
      enddo
    elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,3
          th(i-3,j,k)=newwest(i,j,k,1)
        enddo
        enddo
        do j=1,nj
        do i=1,3
          pp(i-3,j,k)=newwest(i,j,k,2)
        enddo
        enddo
      enddo
    elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,3
        do i=1,ni
          th(i,j-3,k)=newsouth(i,j,k,1)
        enddo
        enddo
        do j=1,3
        do i=1,ni
          pp(i,j-3,k)=newsouth(i,j,k,2)
        enddo
        enddo
      enddo
    elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,3
        do i=1,ni
          th(i,nj+j,k)=newnorth(i,j,k,1)
        enddo
        enddo
        do j=1,3
        do i=1,ni
          pp(i,nj+j,k)=newnorth(i,j,k,2)
        enddo
        enddo
      enddo
    else
      print *,'  unknown index '
      print *,'  myid,index = ',myid,index
      call stopcm1
    endif

    enddo

    if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner

      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then

        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(0,0,k)=th(1,0,k)
              pp(0,0,k)=pp(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(0,nj+1,k)=th(1,nj+1,k)
              pp(0,nj+1,k)=pp(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then

          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(ni+1,0,k)=th(ni,0,k)
              pp(ni+1,0,k)=pp(ni,0,k)
            enddo
          endif

          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(ni+1,nj+1,k)=th(ni,nj+1,k)
              pp(ni+1,nj+1,k)=pp(ni,nj+1,k)
            enddo
          endif

        endif

      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then

        if(ibs.eq.1)then

          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(0,0,k)=th(0,1,k)
              pp(0,0,k)=pp(0,1,k)
            enddo
          endif

          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(ni+1,0,k)=th(ni+1,1,k)
              pp(ni+1,0,k)=pp(ni+1,1,k)
            enddo
          endif

        endif

        if(ibn.eq.1)then

          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(0,nj+1,k)=th(0,nj,k)
              pp(0,nj+1,k)=pp(0,nj,k)
            enddo
          endif

          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              th(ni+1,nj+1,k)=th(ni+1,nj,k)
              pp(ni+1,nj+1,k)=pp(ni+1,nj,k)
            enddo
          endif

        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!-----------------------------------------------------------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3q_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je,kb:ke,numq)
      real west(3,nj,nk,numq),newwest(3,nj,nk,numq)
      real east(3,nj,nk,numq),neweast(3,nj,nk,numq)
      real south(ni,3,nk,numq),newsouth(ni,3,nk,numq)
      real north(ni,3,nk,numq),newnorth(ni,3,nk,numq)
      integer reqs(8)
 
      integer i,j,k,n,nr
      integer tag1,tag2,tag3,tag4
 
!------------------------------------------------

      nr = 0

      nf=nf+1
      tag1=nf

      ! receive east
      if(ibe.eq.0)then
        nr = nr + 1
        call mpi_irecv(neweast,cs3we*numq,MPI_REAL,myeast,tag1,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nf=nf+1
      tag2=nf

      ! receive west
      if(ibw.eq.0)then
        nr = nr + 1
        call mpi_irecv(newwest,cs3we*numq,MPI_REAL,mywest,tag2,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!----------
 
      nf=nf+1
      tag3=nf

      ! receive south
      if(ibs.eq.0)then
        nr = nr + 1
        call mpi_irecv(newsouth,cs3sn*numq,MPI_REAL,mysouth,tag3,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      nf=nf+1
      tag4=nf

      ! receive north
      if(ibn.eq.0)then
        nr = nr + 1
        call mpi_irecv(newnorth,cs3sn*numq,MPI_REAL,mynorth,tag4,   &
                      MPI_COMM_WORLD,reqs(nr),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr = 4

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,nj
        do i=1,3
          west(i,j,k,n)=s(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(west,cs3we*numq,MPI_REAL,mywest,tag1,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,nj
        do i=1,3
          east(i,j,k,n)=s(ni-3+i,j,k,n)
        enddo
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(east,cs3we*numq,MPI_REAL,myeast,tag2,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,3
        do i=1,ni
          north(i,j,k,n)=s(i,nj-3+j,k,n)
        enddo
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(north,cs3sn*numq,MPI_REAL,mynorth,tag3,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,3
        do i=1,ni
          south(i,j,k,n)=s(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
        nr = nr + 1
        call mpi_isend(south,cs3sn*numq,MPI_REAL,mysouth,tag4,   &
                       MPI_COMM_WORLD,reqs(nr),ierr)
      endif
 
!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3q_end(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      use mpi
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real s(ib:ie,jb:je,kb:ke,numq)
      real west(3,nj,nk,numq),newwest(3,nj,nk,numq)
      real east(3,nj,nk,numq),neweast(3,nj,nk,numq)
      real south(ni,3,nk,numq),newsouth(ni,3,nk,numq)
      real north(ni,3,nk,numq),newnorth(ni,3,nk,numq)
      integer reqs(8)
 
      integer i,j,k,n,nn,nr,index
      integer :: index_east,index_west,index_south,index_north

!-------------------------------------------------------------------

      index_east = -1
      index_west = -1
      index_south = -1
      index_north = -1

      nr = 0
      if(ibe.eq.0)then
        nr = nr + 1
        index_east = nr
      endif
      if(ibw.eq.0)then
        nr = nr + 1
        index_west = nr
      endif
      if(ibs.eq.0)then
        nr = nr + 1
        index_south = nr
      endif
      if(ibn.eq.0)then
        nr = nr + 1
        index_north = nr
      endif

    nn = 1
    do while( nn .le. nr )
      call MPI_WAITANY(nr,reqs(1:nr),index,MPI_STATUS_IGNORE,ierr)
      nn = nn + 1

      if(index.eq.index_east)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,nj
        do i=1,3
          s(ni+i,j,k,n)=neweast(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      elseif(index.eq.index_west)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,nj
        do i=1,3
          s(i-3,j,k,n)=newwest(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      elseif(index.eq.index_south)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,3
        do i=1,ni
          s(i,j-3,k,n)=newsouth(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      elseif(index.eq.index_north)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k,n)
        do k=1,nk
        do n=1,numq
        do j=1,3
        do i=1,ni
          s(i,nj+j,k,n)=newnorth(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      else
        print *,'  unknown index '
        print *,'  myid,index = ',myid,index
        call stopcm1
      endif

    enddo

    if(timestats.ge.1) time_mps2=time_mps2+mytime()
 
!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(0,0,k,n)=s(1,0,k,n)
            enddo
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(0,nj+1,k,n)=s(1,nj+1,k,n)
            enddo
            enddo
          endif

        endif

        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(ni+1,0,k,n)=s(ni,0,k,n)
            enddo
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(ni+1,nj+1,k,n)=s(ni,nj+1,k,n)
            enddo
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(0,0,k,n)=s(0,1,k,n)
            enddo
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(ni+1,0,k,n)=s(ni+1,1,k,n)
            enddo
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(0,nj+1,k,n)=s(0,nj,k,n)
            enddo
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k,n)
            do k=1,nk
            do n=1,numq
              s(ni+1,nj+1,k,n)=s(ni+1,nj,k,n)
            enddo
            enddo
          endif
 
        endif
 
      endif
 
      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      nr = 0

      if(ibw.eq.0)then
        nr = nr+1
      endif
      if(ibe.eq.0)then
        nr = nr+1
      endif
      if(ibn.eq.0)then
        nr = nr+1
      endif
      if(ibs.eq.0)then
        nr = nr+1
      endif

    if( nr.ge.1 )then
      call MPI_WAITALL(nr,reqs(5:5+nr-1),MPI_STATUSES_IGNORE,ierr)
    endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!-----------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_all_s(s,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                              n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)

      implicit none

      include 'input.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: s
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(inout), dimension(cmp,cmp,kmt+1) :: n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2
      integer, intent(inout), dimension(rmp) :: reqs_s

      call comm_3s_start(s,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(  s,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,reqs_s)
      call getcorner3(s,n3w1(1,1,1),n3w2(1,1,1),n3e1(1,1,1),n3e2(1,1,1),   &
                        s3w1(1,1,1),s3w2(1,1,1),s3e1(1,1,1),s3e2(1,1,1))
      call bcs2(s)

      return
      end


#endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine prepcorners(s,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,comm)
      implicit none

      include 'input.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: s
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      integer, intent(inout), dimension(rmp) :: reqs_p
      integer, intent(in) :: comm

      integer :: i,j

!--------------------------------------------!
!  This subroutine is ONLY for parcel_interp !
!--------------------------------------------!

      IF( comm.eq.1 )THEN
        call bcs(s)
      ENDIF
#ifdef MPI
      IF( comm.eq.1 )THEN
        call comm_1s_start(s,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
        call comm_1s_end(  s,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
      ENDIF
      call getcorner(s,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcs2(s)
#endif

      IF( bbc.eq.1 .or. bbc.eq.2 .or. bbc.eq.3 )THEN
        ! extrapolate:
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          s(i,j,0) = cgs1*s(i,j,1)+cgs2*s(i,j,2)+cgs3*s(i,j,3)
        enddo
        enddo
      ENDIF

      IF( tbc.eq.1 .or. tbc.eq.2 )THEN
        ! extrapolate:
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          s(i,j,nk+1) = cgt1*s(i,j,nk)+cgt2*s(i,j,nk-1)+cgt3*s(i,j,nk-2)
        enddo
        enddo
      ENDIF

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine prepcornert(t,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,comm)
      implicit none

      include 'input.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: t
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      integer, intent(inout), dimension(rmp) :: reqs_p
      integer, intent(in) :: comm

      integer :: i,j
      real :: c1,c2

!--------------------------------------------!
!  This subroutine is ONLY for parcel_interp !
!--------------------------------------------!

      IF( comm.eq.1 )THEN
        call bcw(t,0)
      ENDIF
#ifdef MPI
      IF( comm.eq.1 )THEN
        call comm_1s_start(t(ib,jb,kb),pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
        call comm_1s_end(  t(ib,jb,kb),pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
      ENDIF
      call bct2(t)
      call getcorner(t(ib,jb,kb),nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
#endif

      return
      end


#ifdef MPI
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcorneru3(u,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u
      real, intent(inout), dimension(3,3,nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer :: i,j,k,nn,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4,count,nr1,nr2

      count=3*3*nk
      nr1 = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-----

      tag1=5031

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_nw = nr1
      endif

!-----

      tag2=5032

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_sw = nr1
      endif

!-----

      tag3=5033

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_ne = nr1
      endif

!-----

      tag4=5034

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(se2,count,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_se = nr1
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr2 = 0

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          se1(i,j,k)=u(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(se1,count,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          ne1(i,j,k)=u(ni-3+i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(ne1,count,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          sw1(i,j,k)=u(1+i,j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          nw1(i,j,k)=u(1+i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nn = 1
      do while( nn .le. nr1 )

        call MPI_WAITANY(nr1,reqs(1:nr1),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if( index.eq.index_nw )then
        do k=1,nk
        do j=1,3
        do i=1,3
          u(-3+i,nj+j,k)=nw2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_sw )then
        do k=1,nk
        do j=1,3
        do i=1,3
          u(-3+i,-3+j,k)=sw2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_ne )then
        do k=1,nk
        do j=1,3
        do i=1,3
          u(ni+1+i,nj+j,k)=ne2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_se )then
        do k=1,nk
        do j=1,3
        do i=1,3
          u(ni+1+i,-3+j,k)=se2(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

    if( nr2.ge.1 )then
      call MPI_WAITALL(nr2,reqs(5:5+nr2-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornerv3(v,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v
      real, intent(inout), dimension(3,3,nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer :: i,j,k,nn,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4,count,nr1,nr2

      count=3*3*nk
      nr1 = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-----

      tag1=5041

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_nw = nr1
      endif

!-----

      tag2=5042

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_sw = nr1
      endif

!-----

      tag3=5043

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_ne = nr1
      endif

!-----

      tag4=5044

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(se2,count,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_se = nr1
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr2 = 0

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          se1(i,j,k)=v(ni-3+i,1+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(se1,count,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          ne1(i,j,k)=v(ni-3+i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(ne1,count,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          sw1(i,j,k)=v(i,1+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nk
        do j=1,3
        do i=1,3
          nw1(i,j,k)=v(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nn = 1
      do while( nn .le. nr1 )

        call MPI_WAITANY(nr1,reqs(1:nr1),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if( index.eq.index_nw )then
        do k=1,nk
        do j=1,3
        do i=1,3
          v(-3+i,nj+1+j,k)=nw2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_sw )then
        do k=1,nk
        do j=1,3
        do i=1,3
          v(-3+i,-3+j,k)=sw2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_ne )then
        do k=1,nk
        do j=1,3
        do i=1,3
          v(ni+i,nj+1+j,k)=ne2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_se )then
        do k=1,nk
        do j=1,3
        do i=1,3
          v(ni+i,-3+j,k)=se2(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

    if( nr2.ge.1 )then
      call MPI_WAITALL(nr2,reqs(5:5+nr2-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornerw3(w,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      use mpi
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: w
      real, intent(inout), dimension(3,3,nk+1) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer :: i,j,k,nn,index
      integer :: index_nw,index_sw,index_ne,index_se
      integer reqs(8)
      integer tag1,tag2,tag3,tag4,count,nr1,nr2

      count=3*3*nkp1
      nr1 = 0
      index_nw = -1
      index_sw = -1
      index_ne = -1
      index_se = -1

!-----

      tag1=5051

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag1,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_nw = nr1
      endif

!-----

      tag2=5052

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag2,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_sw = nr1
      endif

!-----

      tag3=5053

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag3,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_ne = nr1
      endif

!-----

      tag4=5054

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        nr1 = nr1+1
        call mpi_irecv(se2,count,MPI_REAL,myse,tag4,MPI_COMM_WORLD,   &
                       reqs(nr1),ierr)
        index_se = nr1
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nr2 = 0

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          se1(i,j,k)=w(ni-3+i,j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(se1,count,MPI_REAL,myse,tag1,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          ne1(i,j,k)=w(ni-3+i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(ne1,count,MPI_REAL,myne,tag2,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          sw1(i,j,k)=w(i,j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag3,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          nw1(i,j,k)=w(i,nj-3+j,k)
        enddo
        enddo
        enddo
        nr2 = nr2+1
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag4,MPI_COMM_WORLD,   &
                       reqs(4+nr2),ierr)
      endif

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

      nn = 1
      do while( nn .le. nr1 )

        call MPI_WAITANY(nr1,reqs(1:nr1),index,MPI_STATUS_IGNORE,ierr)
        nn = nn + 1

      if( index.eq.index_nw )then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          w(-3+i,nj+j,k)=nw2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_sw )then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          w(-3+i,-3+j,k)=sw2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_ne )then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          w(ni+i,nj+j,k)=ne2(i,j,k)
        enddo
        enddo
        enddo
      elseif( index.eq.index_se )then
        do k=1,nkp1
        do j=1,3
        do i=1,3
          w(ni+i,-3+j,k)=se2(i,j,k)
        enddo
        enddo
        enddo
      endif

      enddo

!------------------------------------------------
!------------------------------------------------
!------------------------------------------------

    if( nr2.ge.1 )then
      call MPI_WAITALL(nr2,reqs(5:5+nr2-1),MPI_STATUSES_IGNORE,ierr)
    endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end

#endif
diff2.F         1587424407  1602  20    100644  33190     `


      subroutine diff2u(flag,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                        dum,diffx,diffy,diffz,uten,ust,rho,rr,rf,divx,t11,t12,t13)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, intent(in), dimension(ib:ie) :: rxh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: xf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum,diffx,diffy,diffz
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: uten
      real, intent(in), dimension(ib:ie,jb:je) :: ust
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr,rf,divx,t11,t12,t13

      integer :: i,j,k,i2

      real, parameter :: twdth = 2.0/3.0

!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns viscosity term
!
!-----------------------------------------------------------------------

      IF(terrain_flag)THEN
        if(myid.eq.0) print *,'  cannot use diff2u with terrain (yet) '
        call stopcm1
      ENDIF

!-----------------------------------------------------------------------

    IF(axisymm.eq.0)THEN
      ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        !  x-direction
        do j=1,nj
        do i=0,ni+1
          dum(i,j,k)=2.0*t11(i,j,k)-rho(i,j,k)*twdth*divx(i,j,k)
        enddo
        enddo
        do j=1,nj
        do i=1,ni+1
          diffx(i,j,k)=(dum(i,j,k)-dum(i-1,j,k))*rdx*uf(i)
        enddo
        enddo
        !  y-direction
        do j=1,nj
        do i=1,ni+1
          diffy(i,j,k)=(t12(i,j+1,k)-t12(i,j,k))*rdy*vh(j)
        enddo
        enddo
      enddo

    ELSE
      ! axisymmetric grid:

      i2 = ni+1
      IF( ebc.eq.3 .or. ebc.eq.4 ) i2 = ni

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        do i=2,i2
          diffx(i,j,k)=2.0*(arf2(i)*arf2(i)*t11(i,j,k)-arf1(i)*arf1(i)*t11(i-1,j,k))*rdx*uf(i) &
                      -twdth*(rho(i,j,k)*divx(i,j,k)-rho(i-1,j,k)*divx(i-1,j,k))*rdx*uf(i)
        enddo
        IF( ebc.eq.3 .or. ebc.eq.4 ) diffx(ni+1,j,k) = 0.0
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------
!  z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO j=1,nj

        do k=1,nk
        do i=1,ni+1
          diffz(i,j,k)=(t13(i,j,k+1)-t13(i,j,k))*rdz*mh(1,1,k)
        enddo
        enddo

        IF( axisymm.eq.1 .and. (ebc.eq.3 .or. ebc.eq.4) )THEN
          do k=1,nk
            diffz(ni+1,j,k)=0.0
          enddo
        ENDIF

      ENDDO

!-----------------------------------------------------------------------

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten(i,j,k)=uten(i,j,k)+((diffx(i,j,k)+diffy(i,j,k))+diffz(i,j,k))  &
                                 /(0.5*(rho(i-1,j,k)+rho(i,j,k)))
        enddo
        enddo
        enddo

      ELSE
        ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=2,ni+1
          uten(i,j,k)=uten(i,j,k)+(diffx(i,j,k)+diffz(i,j,k))  &
                                 /(0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k)))
        enddo
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine diff2v(flag,xh,arh1,arh2,uh,rxf,arf1,arf2,uf,vh,vf,mh,mf,  &
                        dum,diffx,diffy,diffz,vten,ust,rho,rr,rf,divx,t22,t12,t23)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, intent(in), dimension(ib:ie) :: xh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: rxf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum,diffx,diffy,diffz
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: vten
      real, intent(in), dimension(ib:ie,jb:je) :: ust
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr,rf,divx,t22,t12,t23
 
      integer :: i,j,k,j1,j2

      real, parameter :: twdth = 2.0/3.0
 
!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns viscosity term
!
!-----------------------------------------------------------------------

      IF(terrain_flag)THEN
        if(myid.eq.0) print *,'  cannot use diff2v with terrain (yet) '
        call stopcm1
      ENDIF

!-----------------------------------------------------------------------

    IF(axisymm.eq.0)THEN
      ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj+1
        do i=1,ni
          diffx(i,j,k)=(t12(i+1,j,k)-t12(i,j,k))*rdx*uh(i)
        enddo
        enddo
        !  y-direction
        do j=0,nj+1
        do i=1,ni
          dum(i,j,k)=2.0*t22(i,j,k)-rho(i,j,k)*twdth*divx(i,j,k)
        enddo
        enddo
        do j=1,nj+1
        do i=1,ni
          diffy(i,j,k)=(dum(i,j,k)-dum(i,j-1,k))*rdy*vf(j)
        enddo
        enddo
      enddo

    ELSE
      ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(j,k)
      do k=1,nk
      do j=1,nj
        do i=1,ni
          diffx(i,j,k)=(arh2(i)*arh2(i)*t12(i+1,j,k)-arh1(i)*arh1(i)*t12(i,j,k))*rdx*uh(i)
        enddo
      enddo
      enddo

    ENDIF
 
!-----------------------------------------------------------------------
!  z-direction

      j1 = 1
      j2 = nj+1
      IF( axisymm.eq.1 ) j2 = nj

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO j=j1,j2

        do k=1,nk
        do i=1,ni
          diffz(i,j,k)=(t23(i,j,k+1)-t23(i,j,k))*rdz*mh(1,1,k)
        enddo
        enddo

      ENDDO

!-----------------------------------------------------------------------

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten(i,j,k)=vten(i,j,k)+((diffx(i,j,k)+diffy(i,j,k))+diffz(i,j,k))  &
                                 /(0.5*(rho(i,j-1,k)+rho(i,j,k)))
        enddo
        enddo
        enddo

      ELSE
        ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          vten(i,j,k)=vten(i,j,k)+(diffx(i,j,k)+diffz(i,j,k))*rr(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine diff2w(flag,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                        dum,diffx,diffy,diffz,wten,rho,rr,rf,divx,t33,t13,t23)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, intent(in), dimension(ib:ie) :: rxh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: xf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum,diffx,diffy,diffz
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: wten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr,rf,divx,t33,t13,t23
 
      integer :: i,j,k

      real, parameter :: twdth = 2.0/3.0

!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns viscosity term
!
!-----------------------------------------------------------------------

      IF(terrain_flag)THEN
        if(myid.eq.0) print *,'  cannot use diff2w with terrain (yet) '
        call stopcm1
      ENDIF

!-----------------------------------------------------------------------

    IF(axisymm.eq.0)THEN
      ! Cartesian grid:

      !  x-direction
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
        do j=1,nj
        do i=1,ni
          diffx(i,j,k)=(t13(i+1,j,k)-t13(i,j,k))*rdx*uh(i)
        enddo
        enddo
        do j=1,nj
        do i=1,ni
          diffy(i,j,k)=(t23(i,j+1,k)-t23(i,j,k))*rdy*vh(j)
        enddo
        enddo
      enddo

    ELSE
      ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        do i=1,ni
          diffx(i,j,k)=(arh2(i)*t13(i+1,j,k)-arh1(i)*t13(i,j,k))*rdx*uh(i)
        enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------
!  z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO j=1,nj

        do k=1,nk
        do i=1,ni
          dum(i,j,k)=2.0*t33(i,j,k)-rho(i,j,k)*twdth*divx(i,j,k)
        enddo
        enddo

        do k=2,nk
        do i=1,ni
          diffz(i,j,k)=(dum(i,j,k)-dum(i,j,k-1))*rdz*mf(1,1,k)
        enddo
        enddo

      ENDDO

!-----------------------------------------------------------------------

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=wten(i,j,k)+((diffx(i,j,k)+diffy(i,j,k))+diffz(i,j,k))/rf(i,j,k)
        enddo
        enddo
        enddo

      ELSE
        ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=wten(i,j,k)+(diffx(i,j,k)+diffz(i,j,k))/rf(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 
 
      subroutine diff2s(flag,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                        dum,diffx,diffy,diffz,s,sten,rho,rr,rf)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, dimension(ib:ie) :: rxh,arh1,arh2,uh
      real, dimension(ib:ie+1) :: xf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum,diffx,diffy,diffz
      real, dimension(ib:ie,jb:je,kb:ke) :: s,sten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr,rf
 
      integer :: i,j,k
      real :: coef

!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns conduction term
!
!-----------------------------------------------------------------------

      IF(terrain_flag)THEN
        if(myid.eq.0) print *,'  cannot use diff2s with terrain (yet) '
        call stopcm1
      ENDIF

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity/pr_num
      endif

!-----------------------------------------------------------------------
!  x-direction
!  y-direction

    IF(axisymm.eq.0)THEN
      ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)=0.5*(rho(i,j,k)+rho(i-1,j,k))*(s(i,j,k)-s(i-1,j,k))*rdx*uf(i)
        enddo
        enddo
        do j=1,nj
        do i=1,ni
          diffx(i,j,k)=coef*(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
        enddo
        enddo
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)=0.5*(rho(i,j,k)+rho(i,j-1,k))*(s(i,j,k)-s(i,j-1,k))*rdy*vf(j)
        enddo
        enddo
        do j=1,nj
        do i=1,ni
          diffy(i,j,k)=coef*(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
        enddo
        enddo
      enddo

    ELSE
      ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        dum(1,j,k)=0.0
        do i=2,ni+1
          dum(i,j,k)=(s(i,j,k)-s(i-1,j,k))*rdx*uf(i)   &
                *0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))
        enddo
        !-----
        ! assume zero flux:
        if(wbc.eq.3.or.wbc.eq.4)then
          dum(1,j,k) = 0.0
        endif
        if(ebc.eq.3.or.ebc.eq.4)then
          dum(ni+1,j,k) = 0.0
        endif
        !-----
        do i=1,ni
          diffx(i,j,k)=coef*(arh2(i)*dum(i+1,j,k)-arh1(i)*dum(i,j,k))*rdx*uh(i)
        enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------
!  z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO j=1,nj

        do k=2,nk
        do i=1,ni
          dum(i,j,k)=(s(i,j,k)-s(i,j,k-1))*rdz*mf(1,1,k)
        enddo
        enddo

        IF(flag.eq.1)THEN

          do i=1,ni
            dum(i,j,1)=0.0
            dum(i,j,nk+1)=0.0
          enddo

        ELSEIF(flag.eq.2)THEN

          if(bc_temp.eq.1)then      ! constant theta at boundary

            do i=1,ni
              dum(i,j,1)=2.0*(s(i,j,1)-ptc_bot)*rdz*mf(1,1,1)
            enddo
            do i=1,ni
              dum(i,j,nk+1)=2.0*(ptc_top-s(i,j,nk))*rdz*mf(1,1,nk+1)
            enddo

          elseif(bc_temp.eq.2)then      ! constant flux at boundary

            do i=1,ni
              dum(i,j,1)=ptc_bot
            enddo
            do i=1,ni
              dum(i,j,nk+1)=ptc_top
            enddo

          endif

        ENDIF

        do k=1,nk
        do i=1,ni
          diffz(i,j,k)=coef*(rf(i,j,k+1)*dum(i,j,k+1)-rf(i,j,k)*dum(i,j,k))*rdz*mh(1,1,k)
        enddo
        enddo

      ENDDO

!-----------------------------------------------------------------------

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          sten(i,j,k)=sten(i,j,k)+((diffx(i,j,k)+diffy(i,j,k))+diffz(i,j,k))*rr(i,j,k)
        enddo
        enddo
        enddo

      ELSE
        ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          sten(i,j,k)=sten(i,j,k)+(diffx(i,j,k)+diffz(i,j,k))*rr(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      subroutine diff2def(uh,arh1,arh2,uf,arf1,arf2,vh,vf,mh,c1,c2,mf,ust,znt,u1,v1,s1,  &
                          divx,rho,rr,rf,t11,t12,t13,t22,t23,t33,ua,va,wa,dissten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie) :: uh,arh1,arh2
      real, intent(in), dimension(ib:ie+1) :: uf,arf1,arf2
      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je) :: ust,znt,u1,v1,s1
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: divx,rho,rr,rf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: dissten

      integer :: i,j,k
      real :: coef,rcoef,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23,tem

!--------------------------------------------------------------------
!  NOTE:  diff2 arrays all assume no terrain
!--------------------------------------------------------------------

      if((idiff.ge.1).and.(difforder.eq.2))then
        coef=kdiff2
      elseif(dns.eq.1)then
        coef=viscosity
      else
        stop 222
      endif

      rcoef = 1.0/coef

!-----------------------------------------------------------------------
!  Cartesian grid:

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k=1,nk

          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)        &
                       +(va(i,j+1,k)-va(i,j,k))*rdy*vh(j)        &
                       +(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(1,1,k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo

          do j=0,nj+1
          do i=0,ni+1
            t11(i,j,k) = coef*rho(i,j,k)*(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)
            t22(i,j,k) = coef*rho(i,j,k)*(va(i,j+1,k)-va(i,j,k))*rdy*vh(j)
            t33(i,j,k) = coef*rho(i,j,k)*(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(1,1,k)
            t12(i,j,k) = coef*( (ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)    &
                               +(va(i,j,k)-va(i-1,j,k))*rdx*uf(i) )  &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
          enddo
          enddo

          !-----
          ! lateral boundary conditions:
          if(wbc.eq.3.and.ibw.eq.1)then
            ! free slip b.c.
            do j=1,nj+1
              t12(1,j,k) = t12(2,j,k)
            enddo
          elseif(wbc.eq.4.and.ibw.eq.1)then
            ! no slip b.c.
            i = 1
            do j=1,nj+1
              t12(1,j,k) = coef*2.0*va(1,j,k)*rdx*uf(1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          if(ebc.eq.3.and.ibe.eq.1)then
            ! free slip b.c.
            do j=1,nj+1
              t12(ni+1,j,k) = t12(ni,j,k)
            enddo
          elseif(ebc.eq.4.and.ibe.eq.1)then
            ! no slip b.c.
            i = ni+1
            do j=1,nj+1
              t12(ni+1,j,k) = -coef*2.0*va(ni,j,k)*rdx*uf(ni+1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          !-----
          !-----
          if(sbc.eq.3.and.ibs.eq.1)then
            ! free slip b.c.
            do i=1,ni+1
              t12(i,1,k) = t12(i,2,k)
            enddo
          elseif(sbc.eq.4.and.ibs.eq.1)then
            ! no slip b.c.
            j = 1
            do i=1,ni+1
              t12(i,1,k) = coef*2.0*ua(i,1,k)*rdy*vf(1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          if(nbc.eq.3.and.ibn.eq.1)then
            ! free slip b.c.
            do i=1,ni+1
              t12(i,nj+1,k) = t12(i,nj,k)
            enddo
          elseif(nbc.eq.4.and.ibn.eq.1)then
            ! no slip b.c.
            j = nj+1
            do i=1,ni+1
              t12(i,nj+1,k) = -coef*2.0*ua(i,nj,k)*rdy*vf(nj+1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          !-----

          IF(k.ne.1)THEN
            do j=1,nj+1
            do i=1,ni+1
              t13(i,j,k)=coef*( (ua(i,j,k)-ua(i,j,k-1))*rdz*mf(1,1,k)  &
                               +(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i) )
              t23(i,j,k)=coef*( (va(i,j,k)-va(i,j,k-1))*rdz*mf(1,1,k)  &
                               +(wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j) )
            enddo
            enddo
            !-----
            ! lateral boundary conditions:
            if(wbc.eq.3.and.ibw.eq.1)then
              ! free slip b.c.
              do j=1,nj
                t13(1,j,k) = t13(2,j,k)
              enddo
            elseif(wbc.eq.4.and.ibw.eq.1)then
              ! no slip b.c.
              do j=1,nj
                t13(1,j,k) = coef*2.0*wa(1,j,k)*rdx*uf(1)
              enddo
            endif
            if(ebc.eq.3.and.ibe.eq.1)then
              ! free slip b.c.
              do j=1,nj
                t13(ni+1,j,k) = t13(ni,j,k)
              enddo
            elseif(ebc.eq.4.and.ibe.eq.1)then
              ! no slip b.c.
              do j=1,nj
                t13(ni+1,j,k) = -coef*2.0*wa(ni,j,k)*rdx*uf(ni+1)
              enddo
            endif
            !-----
            !-----
            if(sbc.eq.3.and.ibs.eq.1)then
              ! free slip b.c.
              do i=1,ni
                t23(i,1,k) = t23(i,2,k)
              enddo
            elseif(sbc.eq.4.and.ibs.eq.1)then
              ! no slip b.c.
              do i=1,ni
                t23(i,1,k) = coef*2.0*wa(i,1,k)*rdy*vf(1)
              enddo
            endif
            if(nbc.eq.3.and.ibn.eq.1)then
              ! free slip b.c.
              do i=1,ni
                t23(i,nj+1,k) = t23(i,nj,k)
              enddo
            elseif(nbc.eq.4.and.ibn.eq.1)then
              ! no slip b.c.
              do i=1,ni
                t23(i,nj+1,k) = -coef*2.0*wa(i,nj,k)*rdy*vf(nj+1)
              enddo
            endif
            !-----
          ENDIF  ! endif for k.ne.1

        ENDDO  ! enddo for k loop

        !---------------------------------
        ! bottom/top boundary conditions:
        !---------------------------------

        if(bbc.eq.1)then
          ! free slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,1)=t13(i,j,2)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            t23(i,j,1)=t23(i,j,2)
          enddo
          enddo
        elseif(bbc.eq.2)then
          ! no slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,1)=coef*2.0*ua(i,j,1)*rdz*mf(1,1,1)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            t23(i,j,1)=coef*2.0*va(i,j,1)*rdz*mf(1,1,1)
          enddo
          enddo
        elseif(bbc.eq.3)then
          ! semi-slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,1) = 0.5*( (ust(i-1,j)**2)*(u1(i-1,j)/max(s1(i-1,j),0.01)) &
                              +(ust(i  ,j)**2)*(u1(i  ,j)/max(s1(i  ,j),0.01)) )
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            t23(i,j,1) = 0.5*( (ust(i,j-1)**2)*(v1(i,j-1)/max(s1(i,j-1),0.01)) &
                              +(ust(i,j  )**2)*(v1(i,j  )/max(s1(i,j  ),0.01)) )
          enddo
          enddo
        endif

        if(tbc.eq.1)then
          ! free slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,nk+1)=t13(i,j,nk)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            t23(i,j,nk+1)=t23(i,j,nk)
          enddo
          enddo
        elseif(tbc.eq.2)then
          ! no slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,nk+1)=-coef*2.0*ua(i,j,nk)*rdz*mf(1,1,nk+1)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            t23(i,j,nk+1)=-coef*2.0*va(i,j,nk)*rdz*mf(1,1,nk+1)
          enddo
          enddo
        endif

        ! mult t13,t23 by density:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj+1
        do i=1,ni+1
          t13(i,j,k)=t13(i,j,k)*0.5*(rf(i-1,j,k)+rf(i,j,k))
          t23(i,j,k)=t23(i,j,k)*0.5*(rf(i,j-1,k)+rf(i,j,k))
        enddo
        enddo
        enddo

        ! get dissipation rate:
        IF(idiss.eq.1.or.output_dissten.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23,tem)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            tmp11=( c1(i,j,k)*t11(i,j,k-1)**2 + c2(i,j,k)*t11(i,j,k)**2 )
            tmp22=( c1(i,j,k)*t22(i,j,k-1)**2 + c2(i,j,k)*t22(i,j,k)**2 )
            tmp33=( c1(i,j,k)*t33(i,j,k-1)**2 + c2(i,j,k)*t33(i,j,k)**2 )
            tmp12=0.25*( c1(i,j,k)*( ( t12(i,j  ,k-1)**2 + t12(i+1,j+1,k-1)**2 )     &
                                   + ( t12(i,j+1,k-1)**2 + t12(i+1,j  ,k-1)**2 ) )   &
                        +c2(i,j,k)*( ( t12(i,j  ,k  )**2 + t12(i+1,j+1,k  )**2 )     &
                                   + ( t12(i,j+1,k  )**2 + t12(i+1,j  ,k  )**2 ) ) ) 
            tmp13=0.5*( t13(i,j,k)**2 + t13(i+1,j,k)**2 )
            tmp23=0.5*( t23(i,j,k)**2 + t23(i,j+1,k)**2 )
            dissten(i,j,k)= rcoef*( ( 2.0*( tmp33 ) + ( tmp13 + tmp23 )               &
                                     +2.0*( tmp11 + tmp22 ) + tmp12 )/(rf(i,j,k)**2)  &
                   -twodthree*(divx(i,j,k)**2) )
          enddo
          enddo
          enddo
          IF(bbc.eq.3)THEN
            do j=1,nj
            do i=1,ni
              dissten(i,j,1) = (ust(i,j)**3)/(karman*znt(i,j))
            enddo
            enddo
          ELSE
            do j=1,nj
            do i=1,ni
              dissten(i,j,1) = rcoef*0.5*( ( t13(i,j,1)**2 + t13(i+1,j,1)**2 ) &
                                          +( t23(i,j,1)**2 + t23(i,j+1,1)**2 ) )/(rf(i,j,1)**2)
            enddo
            enddo
          ENDIF
          do j=1,nj
          do i=1,ni
            dissten(i,j,nk+1) = rcoef*0.5*( ( t13(i,j,nk+1)**2 + t13(i+1,j,nk+1)**2 ) &
                                           +( t23(i,j,nk+1)**2 + t23(i,j+1,nk+1)**2 ) )/(rf(i,j,nk+1)**2)
          enddo
          enddo
        ENDIF

!-----------------------------------------------------------------------
!  axisymmetric grid:

      ELSEIF(axisymm.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k=1,nk

          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(arh2(i)*ua(i+1,j,k)-arh1(i)*ua(i,j,k))*rdx*uh(i)   &
                       +(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(1,1,k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo

          do j=1,nj
          do i=0,ni+1
            t11(i,j,k) = coef*rho(i,j,k)*(arf1(i+1)*ua(i+1,j,k)-arf2(i)*ua(i,j,k))*rdx*uh(i)
            t33(i,j,k) = coef*rho(i,j,k)*(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(1,1,k)
            t12(i,j,k) = coef*(arh1(i)*va(i,j,k)-arh2(i-1)*va(i-1,j,k))*rdx*uf(i)  &
                        *0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))
          enddo
          enddo

          !-----
          ! lateral boundary conditions:
          j = 1
          if(wbc.eq.3)then
            ! free slip b.c.
            t12(1,j,k) = 0.0
          elseif(wbc.eq.4)then
            ! no slip b.c.
            i = 1
            t12(1,j,k) = coef*2.0*va(1,j,k)*rdx*uf(1)   &
                      *0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))
          endif
          if(ebc.eq.3)then
            ! free slip b.c.
            t12(ni+1,j,k) = t12(ni,j,k)
          elseif(ebc.eq.4)then
            ! no slip b.c.
            i = ni+1
            t12(ni+1,j,k) = -coef*2.0*va(ni,j,k)*rdx*uf(ni+1)   &
                      *0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))
          endif
          !-----

          IF(k.ne.1)THEN
            do j=1,nj
            do i=1,ni+1
              t13(i,j,k)=coef*( (ua(i,j,k)-ua(i,j,k-1))*rdz*mf(1,1,k)  &
                               +(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i) )
              t23(i,j,k)=coef*(va(i,j,k)-va(i,j,k-1))*rdz*mf(1,1,k)
            enddo
            enddo
            !-----
            ! lateral boundary conditions:
            j = 1
            if(wbc.eq.3)then
              ! free slip b.c.
              t13(1,j,k) = 0.0
            elseif(wbc.eq.4)then
              ! no slip b.c.
              t13(1,j,k) = coef*2.0*wa(1,j,k)*rdx*uf(1)
            endif
            if(ebc.eq.3)then
              ! free slip b.c.
              t13(ni+1,j,k) = t13(ni,j,k)
            elseif(ebc.eq.4)then
              ! no slip b.c.
              t13(ni+1,j,k) = -coef*2.0*wa(ni,j,k)*rdx*uf(ni+1)
            endif
            !-----
          ENDIF  ! endif for k.ne.1

        ENDDO  ! enddo for k-loop

        !---------------------------------
        ! bottom/top boundary conditions:
        !---------------------------------

        if(bbc.eq.1)then
          ! free slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,1)=t13(i,j,2)
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            t23(i,j,1)=t23(i,j,2)
          enddo
          enddo
        elseif(bbc.eq.2)then
          ! no slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,1)=coef*2.0*ua(i,j,1)*rdz*mf(1,1,1)
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            t23(i,j,1)=coef*2.0*va(i,j,1)*rdz*mf(1,1,1)
          enddo
          enddo
        elseif(bbc.eq.3)then
          ! semi-slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,1) = 0.5*( arf1(i)*(ust(i-1,j)**2)*(u1(i-1,j)/max(s1(i-1,j),0.01)) &
                              +arf2(i)*(ust(i  ,j)**2)*(u1(i  ,j)/max(s1(i  ,j),0.01)) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            t23(i,j,1) = (ust(i,j)**2)*(v1(i,j)/max(s1(i,j),0.01))
          enddo
          enddo
        endif

        if(tbc.eq.1)then
          ! free slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,nk+1)=t13(i,j,nk)
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            t23(i,j,nk+1)=t23(i,j,nk)
          enddo
          enddo
        elseif(tbc.eq.2)then
          ! no slip b.c.
          do j=1,nj
          do i=1,ni+1
            t13(i,j,nk+1)=-coef*2.0*ua(i,j,nk)*rdz*mf(1,1,nk+1)
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            t23(i,j,nk+1)=-coef*2.0*va(i,j,nk)*rdz*mf(1,1,nk+1)
          enddo
          enddo
        endif

        ! mult t13,t23 by density:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni+1
          t13(i,j,k)=t13(i,j,k)*0.5*(arf1(i)*rf(i-1,j,k)+arf2(i)*rf(i,j,k))
          t23(i,j,k)=t23(i,j,k)*rf(i,j,k)
        enddo
        enddo
        enddo

        ! get dissipation rate:
        IF(idiss.eq.1.or.output_dissten.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23,tem)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            tmp11=( c1(1,1,k)*t11(i,j,k-1)**2 + c2(1,1,k)*t11(i,j,k)**2 )
            tmp33=( c1(1,1,k)*t33(i,j,k-1)**2 + c2(1,1,k)*t33(i,j,k)**2 )
            tmp12=0.5*( c1(1,1,k)*( t12(i,j  ,k-1)**2 + t12(i+1,j  ,k-1)**2 ) &
                       +c2(1,1,k)*( t12(i,j  ,k  )**2 + t12(i+1,j  ,k  )**2 ) ) 
            tmp13=0.5*( t13(i,j,k)**2 + t13(i+1,j,k)**2 )
            tmp23=      t23(i,j,k)**2
            dissten(i,j,k)= rcoef*( ( 2.0*( tmp33 ) + ( tmp13 + tmp23 )               &
                                     +2.0*( tmp11 + tmp22 ) + tmp12 )/(rf(i,j,k)**2)  &
                   -twodthree*(divx(i,j,k)**2) )
          enddo
          enddo
          enddo
          IF(bbc.eq.3)THEN
            do j=1,nj
            do i=1,ni
              dissten(i,j,1) = (ust(i,j)**3)/(karman*znt(i,j))
            enddo
            enddo
          ELSE
            do j=1,nj
            do i=1,ni
              dissten(i,j,1) = rcoef*( 0.5*( t13(i,j,1)**2 + t13(i+1,j,1)**2 ) &
                                          +( t23(i,j,1)**2 )                 )/(rf(i,j,1)**2)
            enddo
            enddo
          ENDIF
          do j=1,nj
          do i=1,ni
            dissten(i,j,nk+1) = rcoef*( 0.5*( t13(i,j,nk+1)**2 + t13(i+1,j,nk+1)**2 ) &
                                           +( t23(i,j,nk+1)**2 )                      )/(rf(i,j,nk+1)**2)
          enddo
          enddo
        ENDIF

!-----------------------------------------------------------------------

      ELSE
        stop 333
      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end

goddard.F       1587424407  1602  20    100644  61869     `
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine satadj_ice(nrk,dt,tcond,tevac,ruh,rvh,rmh,pi0,th0,   &
                            rho,rr,pp3d,prs,th3d,                  &
                            qv3d,qc3d,qr3d,                        &
                            qi3d,qs3d,qg3d)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      integer nrk
      real, intent(in) :: dt
      double precision :: tcond,tevac
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,rr,pp3d,prs,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem) :: qv3d,qc3d,qr3d
      real, dimension(ibi:iei,jbi:jei,kbi:kei) :: qi3d,qs3d,qg3d

      integer :: i,j,k,n,nmax,omax,iflag
      real :: tnew,pnew,qvs,qvnew,qcnew,qinew,cvml,rm,lhv,lhs
      real :: fliq,fice,tem,tlast,dqv,qsw,qsi,cnd,dep,term1,term2
      real :: converge,t1,t2,dum,rdt
      double precision :: tem6
      double precision, dimension(nk) :: bud1,bud2
      real rslf,rsif
      logical :: doit

!--------------------------------------------------------------------
!  iterative sat adj.

    nmax=0
    iflag=0

    IF(eqtset.eq.2)THEN

      if(nrk.eq.4)then
!!!        converge=0.0005
        converge=2.0*tsmall
      else
!!!        converge=0.01
        converge=20.0*tsmall
      endif

      rdt = 1.0/dt

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tnew,pnew,qvs,qvnew,qcnew,qinew,cvml,rm,   &
!$omp lhv,lhs,fliq,fice,tem,tlast,dqv,qsw,qsi,cnd,dep,term1,term2,      &
!$omp t1,t2,dum,doit)
      do k=1,nk
      bud1(k)=0.0d0
      bud2(k)=0.0d0
      do j=1,nj
      do i=1,ni

        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        fliq=max(min((tnew-t00k)*rt0,1.0),0.0)
        fice=1.0-fliq
        qsw=0.0
        if(tnew.gt.t00k)then
          qsw=fliq*rslf(prs(i,j,k),tnew)
        endif
        qsi=0.0
        if(tnew.lt.t0k)then
          qsi=fice*rsif(prs(i,j,k),tnew)
        endif
        qvs=qsw+qsi

        IF(qc3d(i,j,k).gt.1.0e-12 .or. qi3d(i,j,k).gt.1.0e-12     &
           .or. qv3d(i,j,k).gt.qvs)THEN

          qvnew=qv3d(i,j,k)
          qcnew=qc3d(i,j,k)
          qinew=qi3d(i,j,k)

          tem=cpl*(qc3d(i,j,k)+qr3d(i,j,k))               &
             +cpi*(qi3d(i,j,k)+qs3d(i,j,k)+qg3d(i,j,k))
          cvml=cv+cvv*qv3d(i,j,k)+tem
          lhv=lv1-lv2*tnew
          lhs=ls1-ls2*tnew

          t1=1.0/cvml
          t2=rv*tnew/cvml

          n=0
          tlast=tnew
          doit=.true.

          do while( doit )
            n=n+1
            term1=0.0
            if(tnew.gt.t00k)then
              term1=qsw*(fliq*C409/((tnew-C358)**2))
            endif
            term2=0.0
            if(tnew.lt.t0k)then
              term2=qsi*(fice*C580/((tnew-C76)**2))
            endif
            dqv=(qvs-qvnew)/(1.0+((lhv*fliq+lhs*fice)*t1-t2)*(term1+term2) )
            dqv=min(dqv,qcnew+qinew)
            if( (dqv*qcnew.gt.0.0.and.qinew.eq.0.0) .or.   &
                (dqv*qinew.gt.0.0.and.qcnew.eq.0.0) )then
              fliq=qcnew/(qcnew+qinew)
              fice=1.0-fliq
            endif
            if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
            cnd=min(fliq*dqv,qcnew)
            dep=min(fice*dqv,qinew)
            dqv=cnd+dep

            qvnew=qvnew+dqv
            qcnew=max(qcnew-cnd,0.0)
            qinew=max(qinew-dep,0.0)

            tnew=tnew-( (lhv*cnd+lhs*dep)*t1 - dqv*t2 )
            pnew=rho(i,j,k)*(rd+rv*qvnew)*tnew

            doit = .false.
            if( abs(tnew-tlast).gt.converge )then
              tlast=tnew
              fliq=max(min((tnew-t00k)*rt0,1.0),0.0)
              fice=1.0-fliq
              qsw=0.0
              if(tnew.gt.t00k)then
                qsw=fliq*rslf(prs(i,j,k),tnew)
              endif
              qsi=0.0
              if(tnew.lt.t0k)then
                qsi=fice*rsif(prs(i,j,k),tnew)
              endif
              qvs=qsw+qsi
              doit = .true.
            endif

            if(n.gt.50) print *,'  satadj_ice:',myid,n,tnew,pnew
            if(n.eq.100)then
              print *,'  infinite loop!'
              print *,'  i,j,k=',i,j,k
              iflag=1
              doit=.false.
            endif

          enddo

          dum=ruh(i)*rvh(j)*rmh(i,j,k)

          bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-qc3d(i,j,k),0.0)*dum
          bud1(k)=bud1(k)+rr(i,j,k)*max(qinew-qi3d(i,j,k),0.0)*dum
          bud2(k)=bud2(k)-rr(i,j,k)*min(qcnew-qc3d(i,j,k),0.0)*dum
          bud2(k)=bud2(k)-rr(i,j,k)*min(qinew-qi3d(i,j,k),0.0)*dum
          
          prs(i,j,k) = pnew
          pp3d(i,j,k) = (pnew*rp00)**rovcp - pi0(i,j,k)
          th3d(i,j,k) = tnew/(pi0(i,j,k)+pp3d(i,j,k))-th0(i,j,k)
          qc3d(i,j,k)=qcnew
          qv3d(i,j,k)=qvnew
          qi3d(i,j,k)=qinew
          
          nmax=max(n,nmax)

        ENDIF

      enddo
      enddo
      enddo

    ELSE

      nmax=1

!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvnew,qcnew,qinew,tnew,fliq,fice,qvs,lhv,lhs,dqv,   &
!$omp qsw,qsi,cnd,dep,term1,term2,dum,rm)
      do k=1,nk
      bud1(k)=0.0d0
      bud2(k)=0.0d0
      do j=1,nj
      do i=1,ni

        qvnew=qv3d(i,j,k)
        qcnew=qc3d(i,j,k)
        qinew=qi3d(i,j,k)
        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        fliq=max(min((tnew-t00k)*rt0,1.0),0.0)
        fice=1.0-fliq
        qsw=0.0
        term1=0.0
        if(tnew.gt.t00k)then
          qsw=fliq*rslf(prs(i,j,k),tnew)
          term1=qsw*(fliq*C409/((tnew-C358)**2))
        endif
        qsi=0.0
        term2=0.0
        if(tnew.lt.t0k)then
          qsi=fice*rsif(prs(i,j,k),tnew)
          term2=qsi*(fice*C580/((tnew-C76)**2))
        endif
        qvs=qsw+qsi
        lhv=lv1-lv2*tnew
        lhs=ls1-ls2*tnew
        dqv=(qvs-qvnew)/(1.0+(lhv*fliq+lhs*fice)*(term1+term2)*rcp)
        dqv=min(dqv,qcnew+qinew)
        if( (dqv*qcnew.gt.0.0.and.qinew.eq.0.0) .or.   &
            (dqv*qinew.gt.0.0.and.qcnew.eq.0.0) )then
          fliq=qcnew/(qcnew+qinew)
          fice=qinew/(qcnew+qinew)
        endif
        if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
        cnd=min(fliq*dqv,qcnew)
        dep=min(fice*dqv,qinew)

        qvnew=qvnew+cnd+dep
        qcnew=qcnew-cnd
        qinew=qinew-dep

        dum=ruh(i)*rvh(j)*rmh(i,j,k)

        bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-qc3d(i,j,k),0.0)*dum
        bud1(k)=bud1(k)+rr(i,j,k)*max(qinew-qi3d(i,j,k),0.0)*dum
        bud2(k)=bud2(k)-rr(i,j,k)*min(qcnew-qc3d(i,j,k),0.0)*dum
        bud2(k)=bud2(k)-rr(i,j,k)*min(qinew-qi3d(i,j,k),0.0)*dum

        th3d(i,j,k)=th3d(i,j,k)-( (lhv*cnd+lhs*dep)   &
                                 /(cp*(pi0(i,j,k)+pp3d(i,j,k))) )
        qc3d(i,j,k)=qcnew
        qv3d(i,j,k)=qvnew
        qi3d(i,j,k)=qinew
        rho(i,j,k)=prs(i,j,k)   &
           /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qvnew*reps))

      enddo
      enddo
      enddo

    ENDIF

    IF(nrk.ge.3)THEN
      tem6=dx*dy*dz
      do k=1,nk
        tcond=tcond+bud1(k)*tem6
      enddo

      do k=1,nk
        tevac=tevac+bud2(k)*tem6
      enddo
    ENDIF

!!!#ifdef MPI
!!!      omax=0
!!!      call MPI_REDUCE(nmax,omax,1,MPI_INTEGER,MPI_MAX,0,MPI_COMM_WORLD,ierr)
!!!      nmax=omax
!!!#endif
!!!

      if(iflag.ne.0)then
        print *
        print *,' Convergence cannot be reached in satadj_ice subroutine.'
        print *
        print *,' This may be a problem with the algorithm in satadj_ice.'
        print *,' However, the model may have became unstable somewhere'
        print *,' else and the symptoms first appeared here.'
        print *
        print *,' Try decreasing the timestep (dtl and/or nsound).'
        print *
        print *,'  ... stopping cm1 ... '
        print *
        call stopcm1
      endif

      if(timestats.ge.1) time_satadj=time_satadj+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine goddard(dt,tauto,taccr,tevar,ruh,rvh,rmh,pi0,th0,   &
                         rhod,rr,prs,pp3d,th3d,                   &
                         qv3d,qc3d,qr3d,vtr,                      &
                         qi3d,vti,qs3d,vts,                       &
                         qg3d,vtg)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      real :: dt
      double precision :: tauto,taccr,tevar
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rhod,rr,prs,pp3d,th3d,qv3d,qc3d,   &
                                            qr3d,vtr,qi3d,vti,qs3d,vts,qg3d,vtg

!----------------------------------------------------------------------------
!                                                                       
!***********************************************************************
!     LIN ET AL (83) ICE PHASE MICROPHYSICAL PROCESSES                 *
!     MODIFIED AND CODED BY GODDARD CUMULUS ENSEMBLE MODELING GROUP    *
!     TAO, SIMPSON AND MCCUMBER`S SATURATION TECHNIQUE (MWR, 1989)     *
!     TAO AND SIMPSON (JAS, 1989; TAO, 1993),                          *
!     BRAUN AND TAO (MWR, 2000), BRAUN ET AL. (JAM, 2001, submitted)   *
!                                                                      *
!     D2T - LEAPFROG TIME STEP (S)                                     *
!     DPT - DEVIATION POTENTIAL TEMPERATURE FIELD (K)                  *
!     DQV - DEVIATION WATER VAPOR FIELD (G/G)                          *
!     QCL - CLOUD WATER FIELD (G/G)                                    *
!     QRN - RAIN FIELD (G/G)                                           *
!     QCI - CLOUD ICE FIELD (G/G)                                      *
!     QCS - SNOW FIELD (G/G)                                           *
!     QCG - HAIL FIELD (G/G)                                           *
!     RHO - AIR DENSITY (G/CM3)                                        *
!     TA1 - BASE AIR POTENTIAL TEMPERATURE AT THE LEVEL (K)            *
!     QA1 - BASE WATER VAPOR AT THE LEVEL (G/G)                        *
!     P0 - AIR PRESSURE (UB=1.E-3MB)                                   *
!     PI - EXNER FUNCTION (P/1000.E3)**R/CP                            *
!                                                                      *
!     MIX: DIMENSION IN X-DIRECTION                                    *
!     MKX: DIMENSION IN Z-DIRECTION                                    *
!     NOTE: PHYSICAL DOMAIN EXTENDS FROM K=1 TO K=MKX-1                *
!           AND I=2 TO I=MIX-1                                         *
!     C.G.S UNITS                                                      *
!                                                                      *
!     THIS ICE SCHEME HAS BEEN IMPLEMENTED INTO                        *
!     ARPS (CAPS - V. WONG, M. XUE, K. DROEGEMEIER) - 1993             *
!     GODDARD`S SCHLENSINGER MODEL (SIMPSON ET AL., 1991)              *
!     CHEN`S MODEL (C. CHEN) - 1992                                    *
!     GMASS (BIAK ET AL., 1992)                                        *
!     MM5V1 (LIU ET AL., 1994)                                         *
!                                                                      *
!     RECENT CHANGES (6.25.01) BY SCOTT BRAUN INCLUDE                  *
!       * OPTION TO CHOOSE HAIL OR GRAUPEL AS THIRD ICE CATEGORY       *
!	* OPTION OF SATURATION ADJUSTMENT SCHEMES                      *      
!	* NEW FORMULATION OF PSFI                                      *      
!	* REDUCED COLLECTION EFFICIENCIES (EGS) FOR COLLECTION OF SNOW *      
!	  BY GRAUPEL                                                   *      
!	* MODIFICATIONS TO PIDEP, PINT INCLUDING NEW COEFFICIENTS FOR  *      
!	  THE FLETCHER EQ., A LIMIT OF 1 CM**-3 FOR THE NUMBER         *      
!         CONCENTRATION OF ICE NUCLEI, INCLUSION OF A PISUB TERM       *
!	* ELIMINATED THE PGAUT TERM                                    *      
!***********************************************************************
!                                                                       
!     THE FOLLOWINGS ARE LOCALLY USED VARIABLES                         
!                                                                       
      real d2t,VFR,VFS,VFG
      real RHO,P0,PPI,rho0
      integer i,j,k
      real COL,DEP,RGMP,DD,DD1,QVS,DM,RSUB1,WGACR,CND,RQ,             &
       ERN,SCV,TCA,DWV,ZR,VR,ZS,VS,ZG,VG,EGS,ESI,                     &
       QSI,SSI,QSW,SSW,PIHOM,PIDW,PIMLT,PSAUT,PSACI,PSACW,QSACW,      &
       PRACI,PIACR,PRAUT,PRACW,PSFW,PSFI,DGACS,DGACW,DGACI,DGACR,     &
       PGACS,WGACS,QGACW,WGACI,QGACR,PGWET,PGAUT,PRACS,PSACR,QSACR,   &
       PGFR,PSMLT,PGMLT,PSDEP,PSSUB,PGSUB,PINT,PIDEP,PISUB,           &
       PT,QV,QC,QR,QI,QS,QG,TAIR,TAIRC,PR,PS,PG,PRN,                  &
       PSN,DLT1,DLT2,DLT3,RTAIR,DDA,DDB,Y1,Y2,Y3,Y4,Y5,FV

      integer index,IT
      real cmin,cmin1,vgcr,vgcf,r3456,        &
           a2,ee1,ee2,a1,r7r,r8r,del,r11rt,nci
      real tem1,tem2,tem3,tem4
      real rrho,rp0,rpi
      real ene1,ene2,lhv,lhs,lhf
      real tem5,rdt,temp,f1,f2,r1,dum1,cpml,cvml,rm,dum

      double precision :: tem6
      double precision, dimension(nk) :: bud1,bud2,bud3

      parameter(cmin=1.e-14)
      parameter(cmin1=1.e-12)
      parameter(r1=1.0/1.0e-9)

      tem5=.5/(SQRT(AMI100)-SQRT(AMI40))
      d2t=dt
      rdt=1.0/D2T

!     ******   TWO CLASS WATER AND THREE CLASS OF ICE-PHASE    *********


!$omp parallel do default(shared)  &
!$omp private(i,j,k,VFR,VFS,VFG,RHO,P0,PPI,rho0,COL,DEP,RGMP,DD,DD1,QVS,    &
!$omp DM,RSUB1,WGACR,CND,RQ,ERN,SCV,TCA,DWV,ZR,VR,ZS,VS,ZG,VG,EGS,ESI,QSI,  &
!$omp SSI,QSW,SSW,PIHOM,PIDW,PIMLT,PSAUT,PSACI,PSACW,QSACW,PRACI,PIACR,     &
!$omp PRAUT,PRACW,PSFW,PSFI,DGACS,DGACW,DGACI,DGACR,PGACS,WGACS,QGACW,      &
!$omp WGACI,QGACR,PGWET,PGAUT,PRACS,PSACR,QSACR,PGFR,PSMLT,PGMLT,PSDEP,     &
!$omp PSSUB,PGSUB,PINT,PIDEP,PISUB,PT,QV,QC,QR,QI,QS,QG,TAIR,TAIRC,PR,PS,   &
!$omp PG,PRN,PSN,DLT1,DLT2,DLT3,RTAIR,DDA,DDB,Y1,Y2,Y3,Y4,Y5,FV,index,IT,   &
!$omp vgcr,vgcf,r3456,a2,ee1,ee2,a1,r7r,r8r,del,r11rt,nci,tem1,tem2,tem3,   &
!$omp tem4,rrho,rp0,rpi,ene1,ene2,lhv,lhs,lhf,temp,f1,f2,dum1,cpml,cvml,    &
!$omp rm,dum)
      DO k=1,nk
      bud1(k)=0.0d0
      bud2(k)=0.0d0
      bud3(k)=0.0d0
      DO j=1,nj
      DO i=1,ni
          rho0=1.0e-3*rhod(i,j,1)

          vtr(i,j,k)=0.0
          vts(i,j,k)=0.0
          vtg(i,j,k)=0.0

        IT=1                                                           
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!C    ******************************************************************
          fv=rho0                                               
          RHO=1.0e-3*rhod(i,j,k)
          PPI=pi0(i,j,k)+pp3d(i,j,k)
          P0=10.0*prs(i,j,k)
          PT=th3d(i,j,k)
          QV=QV3D(I,J,K)
          QC=QC3D(I,J,K)
          QR=QR3D(I,J,K)
          QI=QI3D(I,J,K)
          QS=QS3D(I,J,K)
          QG=QG3D(I,J,K)
          QV=max(QV,cmin1)
          IF(QC.LT.cmin)  QC=0.0                                  
          IF(QR.LT.cmin)  QR=0.0                                  
          IF(QI.LT.cmin)  QI=0.0                                  
          IF(QS.LT.cmin)  QS=0.0                                  
          IF(QG.LT.cmin)  QG=0.0                                  
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          TAIRC=TAIR-T0K                                          
!----------------------------------------------------
!  variables added to improve performance
          tem1=1.0/(sqrt(sqrt(rho)))
          tem2=sqrt(FV/RHO)
          tem3=1.0/(sqrt(rho))
          tem4=sqrt(sqrt(FV/RHO))
          rrho=1.0/rho
          rp0=1.0/p0
          rpi=1.0/ppi
!----------------------------------------------------
!  variables for new equation set
          if(eqtset.eq.2)then
            dum1=cpl*(qc+qr)+cpi*(qi+qs+qg)
            cvml=cv+cvv*qv+dum1
            cpml=cp+cpv*qv+dum1
            rm=rd+rv*qv
            ene1=cv/(cp*cvml*ppi)
            ene2=(th0(i,j,k)+pt)*(rv/cvml)*(1.0-rovcp*cpml/rm)
          else
            ene1=1.0/(cp*ppi)
            ene2=0.0
          endif
          lhv=lv1-lv2*tair
          lhs=ls1-ls2*tair
          lhf=lhs-lhv
!----------------------------------------------------
!     ***   COMPUTE ZR,ZS,ZG,VR,VS,VG      *****************************
          ZR=1.E5*ZRC*tem1
          ZS=1.E5*ZSC*tem1
          ZG=1.E5*ZGC*tem1
          VR=0.0                                                     
          VS=0.0                                                     
          VG=0.0                                                     
          IF(QR.GT.cmin)THEN                                         
            DD=RHO*QR                                          
            Y1=sqrt(sqrt(DD))
            ZR=ZRC/Y1                                             
            temp=r1*min(50.0e-6,max(0.0,DD))
            index=int(temp)
            f1=pwr2(index)
            f2=pwr2(index+1)
            VR=VRC*tem2*(f1+(f2-f1)*(temp-index))
          ENDIF                                                         
          IF(QS.GT.cmin)THEN                                         
            DD=RHO*QS                                          
            Y1=sqrt(sqrt(DD))
            ZS=ZSC/Y1                                             
!!!            VS=VSC*tem2*sqrt(sqrt(y1))
            VS=VSC*tem2*DD**BSQ
          ENDIF                                                         
          if (qg .gt. cmin) then                                     
            dd=rho*qg                                         
            y1=sqrt(sqrt(dd))
            zg=zgc/y1                                             
            if (ihail .eq. 1) then                                      
              vgcr=vgc*tem3
              vg=vgcr*sqrt(y1)
            else                                                        
              vgcf=vgc*tem2
              vg=vgcf*exp(alog(dd)*bgq)
            endif                                                       
          endif                                                         
          VFR=VR                                                
          VFS=VS                                                
          VFG=VG                                                
!     ******************************************************************
!     ***   Y1 : DYNAMIC VISCOSITY OF AIR (U)                           
!     ***   DWV : DIFFUSIVITY OF WATER VAPOR IN AIR (PI)                
!     ***   TCA : THERMAL CONDUCTIVITY OF AIR (KA)                      
!     ***   Y2 : KINETIC VISCOSITY (V)                                  
          Y1=C149*TAIR*sqrt(TAIR)/(TAIR+120.)
          temp=min(150.0,max(0.0,TAIR-173.15))
          index=int(temp)
          f1=pwr81(index)
          f2=pwr81(index+1)
          DWV=C879*rp0*TAIR*(f1+(f2-f1)*(temp-index))
          TCA=C141*Y1                                             
          SCV=exp(alog(RHO/(Y1*DWV**2))*.1666667)
!*  1 * PSAUT : AUTOCONVERSION OF QI TO QS                        ***1**
!*  3 * PSACI : ACCRETION OF QI TO QS                             ***3**
!*  4 * PSACW : ACCRETION OF QC BY QS (RIMING) (QSACW FOR PSMLT)  ***4**
!*  5 * PRACI : ACCRETION OF QI BY QR                             ***5**
!*  6 * PIACR : ACCRETION OF QR OR QG BY QI                       ***6**
          PSAUT=0.0                                                  
          PSACI=0.0                                                  
          PRACI=0.0                                                  
          PIACR=0.0                                                  
          PSACW=0.0                                                  
          QSACW=0.0                                                  
          PRAUT=0.0                                                  
          PRACW=0.0                                                  
          r3456=tem2
!!!          DD=1.0/(sqrt(sqrt(ZS))*ZS**3)
          DD=1.0/ZS**BS3
          IF( (QI.GT.CMIN) .or. (QC.GT.CMIN) )THEN
            temp=exp(alog(ZR)*(-BW3))
          ENDIF
          IF(QI.GT.CMIN) THEN                                        
           IF(TAIR.LT.T0K)THEN                                       
             ESI=EXP(.025*TAIRC)                                  
             PSAUT=MAX(RN1*ESI*(QI-BND1),0.0)                
             PSACI=RN3*R3456*.1*QI*DD                          
             PRACI=RN5*R3456*QI*temp
             PIACR=RN6*R3456*QI*exp(alog(ZR)*(-BW6))
           ENDIF                                                        
          ENDIF                                                         
          IF(QC.GT.CMIN) THEN                                        
            IF(TAIR.LT.T0K)THEN                                      
              PSACW=RN4*R3456*QC*DD                            
            ELSE                                                        
              QSACW=RN4*R3456*QC*DD                            
            ENDIF                                                       
!* 21 * PRAUT : AUTOCONVERSION OF QC TO QR                        **21**
!* 22 * PRACW : ACCRETION OF QC BY QR                             **22**
           PRACW=RN22*tem2*QC*temp
           IF(iautoc.eq.1)THEN
             Y1=QC-BND3                                             
             IF(Y1.GT.cmin)THEN                                        
               PRAUT=RHO*Y1*Y1/(1.2E-4+RN21/Y1)            
             ENDIF                                                        
           ENDIF
          ENDIF                                                         
!* 12 * PSFW : BERGERON PROCESSES FOR QS (KOENING, 1971)          **12**
!* 13 * PSFI : BERGERON PROCESSES FOR QI                          **13**
!* 32 * PIDEP : DEPOSITION OF QI                                  **32**
          PSFW=0.0                                                   
          PSFI=0.0                                                   
          PIDEP=0.0                                                  
          PISUB=0.0                                                  
          IF(TAIR.LT.T0K.AND.QI.GT.cmin)THEN                      
            Y1=MAX(MIN(TAIRC,-1.),-31.)                       
            IT=INT(ABS(Y1))                                       
            Y1=RN12A(IT)                                          
            Y2=RN12B(IT)                                          
            PSFW=MAX(D2T*Y1*(RN12*RHO*QC)*QI,0.0)      
            RTAIR=1./(TAIR-C76)                                   
            Y2=EXP(C218-C580*RTAIR)                               
            QSI=C380*rp0*Y2                                   
            ESI=C610*Y2                                           
            SSI=QV/QSI-1.                                
            NCI=MIN(RN25*EXP(BETA*TAIRC),1.)                       
            DM=QV-QSI                                      
            RSUB1=C580*ASC*QSI*RTAIR*RTAIR                  
            Y3=1./TAIR                                            
            DD=Y3*(RN30A*Y3-RN30B)+RN30C*TAIR/ESI        
            Y1=206.18*SSI/DD                                   
            DEP=DM/(1.+RSUB1)*rdt
            PIDEP=Y1*SQRT(NCI*QI*rrho)                       
            IF(DM.GT.cmin) THEN                                      
               a2=1.                                                    
               if(pidep.gt.dep .and. pidep .gt. cmin) then     
                  a2=dep/pidep                                    
                  pidep=dep                                       
               endif                                                    
               PSFI=a2*QI*Y1*tem5
            ELSEIF(DM.LT.-cmin) THEN                                 
               PISUB=MAX(-QI*rdt,PIDEP)                      
               PISUB=MIN(-PISUB,-DM*rdt)                     
               PIDEP=0.                                              
               PSFI=0.                                               
            ELSE                                                        
               PISUB=0.                                              
               PIDEP=0.                                              
               PSFI=0.                                               
            ENDIF                                                       
          ENDIF                                                         
!TTT***** QG=QG+MIN(PGDRY,PGWET)                                        
!*  9 * PGACS : ACCRETION OF QS BY QG (DGACS,WGACS: DRY AND WET)  ***9**
!* 14 * DGACW : ACCRETION OF QC BY QG (QGACW FOR PGMLT)           **14**
!* 16 * DGACR : ACCRETION OF QR TO QG (QGACR FOR PGMLT)           **16**
          DGACS=0.0                                                  
          WGACS=0.0                                                  
          DGACW=0.0                                                  
          DGACR=0.0                                                  
          PGACS=0.0                                                  
          QGACW=0.0                                                  
          QGACR=0.0                                                  
          DGACI=0.0                                                  
          WGACI=0.0                                                  
          PGWET=0.0                                                  
        IF(QG.GT.CMIN)THEN                                           
                                                                        
          IF(QC+QR.LT.1.e-4) THEN
             EE1=.01
          ELSE
             EE1=1.
          ENDIF
          EE2=0.09                                                      
          EGS=EE1*EXP(EE2*TAIRC)                                  
          IF(TAIR.GE.T0K)EGS=1.0                                  
          Y1=ABS(VG-VS)                                        
          Y2=ZS*ZG                                             
          Y3=5./Y2                                                
          Y4=.08*Y3*Y3                                         
          Y5=.05*Y3*Y4                                         
          DD=Y1*(Y3/ZS**5+Y4/ZS**3+Y5/ZS)       
          PGACS=RN9*rrho*EGS*DD                              
          DGACS=PGACS                                             
          WGACS=RN9*rrho*DD                                     
          IF(IHAIL.EQ.1) THEN                                           
             Y1=1.0/(sqrt(ZG)*ZG**3)
             DGACW=MAX(RN14*QC*Y1*tem3,0.0)          
          ELSE                                                          
             Y1=exp(alog(ZG)*(-BG3))
             DGACW=MAX(RN14*QC*Y1*R3456,0.0)                 
          ENDIF                                                         
          QGACW=DGACW                                             
          Y1=ABS(VG-VR)                                        
          Y2=ZR*ZG                                             
          Y3=5./Y2                                                
          Y4=.08*Y3*Y3                                         
          Y5=.05*Y3*Y4                                         
          DD=Y1*(Y3/ZR**5+Y4/ZR**3+Y5/ZR)*RN16   &
                *rrho                                                  
          DGACR=MAX(DD,0.0)                                     
          QGACR=DGACR                                             
          IF(TAIR.GE.T0K)THEN                                        
            DGACS=0.0                                                
            WGACS=0.0                                                
            DGACW=0.0                                                
            DGACR=0.0                                                
          ELSE                                                          
            PGACS=0.0                                                
            QGACW=0.0                                                
            QGACR=0.0                                                
          ENDIF                                                         
!*******PGDRY : DGACW+DGACI+DGACR+DGACS                           ******
!* 15 * DGACI : ACCRETION OF QI BY QG (WGACI FOR WET GROWTH)      **15**
!* 17 * PGWET : WET GROWTH OF QG                                  **17**
          IF(TAIR.LT.T0K.AND.TAIR.GT.T0K-40.)THEN                 
            IF(IHAIL.EQ.1) THEN                                         
               Y1=QI/(sqrt(ZG)*ZG**3)
               DGACI=Y1*RN15*tem3
               WGACI=Y1*RN15A*tem3
            ELSE                                                        
               Y1=QI/ZG**BG3                                      
               DGACI=Y1*RN15*R3456                                
               WGACI=Y1*RN15A*R3456                               
            ENDIF                                                       
            Y1=1./(ALF+RN17C*TAIRC)                               
            IF(IHAIL.EQ.1) THEN                                         
               Y3=.78/ZG**2+SCV*RN17A*tem1*exp(alog(ZG)*(-BGH5))
            ELSE                                                        
               Y3=.78/ZG**2+SCV*RN17A*tem4*exp(alog(ZG)*(-BGH5))
            ENDIF                                                       
            Y4=RHO*ALV*DWV*(C380*rp0-QV)-TCA*   &
                  TAIRC                                              
            DD=Y1*(Y4*Y3*RN17*rrho+(WGACI+WGACS)*(   &
                  ALF+RN17B*TAIRC))                                  
            PGWET=MAX(DD,0.0)                                   
          ENDIF                                                         
        ENDIF                                                           
!********   HANDLING THE NEGATIVE CLOUD WATER (QC)    ******************
!********   HANDLING THE NEGATIVE CLOUD ICE (QI)      ******************
!********   DIFFERENT FROM LIN ET AL                  ******************
           y1=qc*rdt
          psacw=MIN(y1, psacw)                               
          praut=MIN(y1, praut)                               
          pracw=MIN(y1, pracw)                               
          psfw= MIN(y1, psfw)                                
          dgacw=MIN(y1, dgacw)                               
          qsacw=MIN(y1, qsacw)                               
          qgacw=MIN(y1, qgacw)                               
                                                                        
          Y1=(PSACW+PRAUT+PRACW+PSFW+DGACW+QSACW+   &
                QGACW)*D2T                                           
          QC=QC-Y1                                             
                                                                        
          IF(QC.LT.0.0) THEN                                         
             a1=1.                                                      
              if (y1 .ne. 0.0) A1=QC/Y1+1.                     
            PSACW=PSACW*A1                                        
            PRAUT=PRAUT*A1                                        
            PRACW=PRACW*A1                                        
            PSFW=PSFW*A1                                          
            DGACW=DGACW*A1                                        
            QSACW=QSACW*A1                                        
            QGACW=QGACW*A1                                        
            QC=0.0                                                   
          ENDIF                                                         

          dum=ruh(i)*rvh(j)*rmh(i,j,k)

          bud1(k)=bud1(k)+rr(i,j,k)*PRAUT*dum
          bud2(k)=bud2(k)+rr(i,j,k)*PRACW*dum

!                                                                       
!******** SHED PROCESS (WGACR=PGWET-DGACW-WGACI-WGACS)                  
!     CALCULATIONS OF THIS TERM HAS BEEN MOVED TO THIS LOCATION TO      
!     ACCOUNT FOR RESCALING OF THE DGACW TERM ABOVE. ALTHOUGH RESCALING 
!     OF THE PGWET, WGACI AND WGACS TERMS OCCURS BELOW, THESE CHANGES   
!     ARE EXPECTED TO BE LESS THAN THAT ASSOCIATED WITH DGACW. THIS CALC
!     IS NOT DONE AFTER RESCALING OF ALL TERMS SINCE WGACR IS NEEDED BEL
!     FOR RAIN AND WGACI AND DGACI ARE NEEDED FOR ICE.                  
          WGACR=PGWET-DGACW-WGACI-WGACS                  
          Y2=DGACW+DGACI+DGACR+DGACS                     
          IF(PGWET.GE.Y2)THEN                                     
            WGACR=0.0                                                
            WGACI=0.0                                                
            WGACS=0.0                                                
          ELSE                                                          
            DGACR=0.0                                                
            DGACI=0.0                                                
            DGACS=0.0                                                
          ENDIF                                                         
                                                                        
            y1=qi*rdt
           psaut=MIN(y1, psaut)                              
           psaci=MIN(y1, psaci)                              
           praci=MIN(y1, praci)                              
           psfi= MIN(y1, psfi)                               
           dgaci=MIN(y1, dgaci)                              
           wgaci=MIN(y1, wgaci)                              

          Y1=(PSAUT+PSACI+PRACI+PSFI+DGACI+WGACI   &
                +PISUB)*D2T                                          

           qi=qi-y1+PIDEP*D2T                               
           if(qi.lt.0.0) then                                        
               a2=1.                                                    
                if (y1 .ne. 0.0) a2=qi/y1+1.                   
            psaut=psaut*a2                                        
            psaci=psaci*a2                                        
            praci=praci*a2                                        
            psfi=psfi*a2                                          
            dgaci=dgaci*a2                                        
            wgaci=wgaci*a2                                        
            pisub=pisub*a2                                        
            qi=0.0                                                   
           endif                                                        
!                                                                       
          DLT3=0.0                                                   
          DLT2=0.0                                                   
          IF(TAIR.LT.T0K)THEN                                        
            IF(QR.LT.1.E-4)THEN                                      
              DLT3=1.0                                               
              DLT2=1.0                                               
            ENDIF                                                       
            IF(QS.GE.1.E-4)DLT2=0.0                               
          ENDIF                                                         
          PR=(QSACW+PRAUT+PRACW+QGACW)*D2T               
          PS=(PSAUT+PSACI+PSACW+PSFW+PSFI+DLT3*    &
                PRACI)*D2T                                           
          PG=((1.-DLT3)*PRACI+DGACI+WGACI+DGACW)*D2T  
!*  7 * PRACS : ACCRETION OF QS BY QR                             ***7**
!*  8 * PSACR : ACCRETION OF QR BY QS (QSACR FOR PSMLT)           ***8**
            PRACS=0.0                                                
            PSACR=0.0                                                
            QSACR=0.0                                                
            PGFR=0.0                                                 
            PGAUT=0.0                                                
        IF(QR.GT.CMIN)THEN                                           
          Y1=ABS(VR-VS)                                        
          Y2=ZR*ZS                                             
          Y3=5./Y2                                                
          Y4=.08*Y3*Y3                                         
          Y5=.05*Y3*Y4                                         
          R7R=RN7*rrho                                                
          PRACS=R7R*Y1*(Y3/ZS**5+Y4/ZS**3+Y5/ZS)
          R8R=RN8*rrho                                                
          PSACR=R8R*Y1*(Y3/ZR**5+Y4/ZR**3+Y5/ZR)
          QSACR=PSACR                                             
          IF(TAIR.GE.T0K)THEN                                        
            PRACS=0.0                                                
            PSACR=0.0                                                
          ELSE                                                          
            QSACR=0.0                                                
          ENDIF                                                         
!*  2 * PGAUT : AUTOCONVERSION OF QS TO QG                        ***2**
!* 18 * PGFR  : FREEZING OF QR TO QG                              **18**
          IF(TAIR.LT.T0K)THEN                                        
!           Y1=EXP(.09*TAIRC)                                     
!           if (ihail .eq. 1) PGAUT=MAX(RN2*Y1*(QS-BND2),0.0)
            Y2=EXP(RN18A*(T0K-TAIR))                              
            PGFR=MAX((Y2-1.)*RN18*rrho/ZR**7,0.0)       
          ENDIF                                                         
        ENDIF                                                           
!********   HANDLING THE NEGATIVE RAIN WATER (QR)    *******************
!********   HANDLING THE NEGATIVE SNOW (QS)          *******************
!********   DIFFERENT FROM LIN ET AL                 *******************
          y1=qr*rdt
          Y2=-QG*rdt
         piacr=MIN(y1, piacr)                                
         dgacr=MIN(y1, dgacr)                                
         wgacr=MIN(y1, wgacr)                                
         wgacr=MAX(y2, wgacr)                                
         psacr=MIN(y1, psacr)                                
         pgfr= MIN(y1, pgfr)                                 

         del=0.                                                         
         IF(WGACR.LT.0.) del=1.                                      
          Y1=(PIACR+DGACR+(1.-del)*WGACR+PSACR+          &
                  PGFR)*D2T                                          
          qr=qr+pr-y1-del*WGACR*D2T                      
                                                                        
          if(qr.lt.0.0) then                                         
            a1=1.0                                                      
             if(y1 .ne. 0.) a1=qr/y1+1.                        
            piacr=piacr*a1                                        
            dgacr=dgacr*a1                                        
            if(wgacr.gt.0) wgacr=wgacr*a1                      
            pgfr=pgfr*a1                                          
            psacr=psacr*a1                                        
            qr=0.0                                                   
          endif                                                         

          PRN=D2T*((1.-DLT3)*PIACR+DGACR+WGACR+(1.-      &
                 DLT2)*PSACR+PGFR)                             
          PS=PS+D2T*(DLT3*PIACR+DLT2*PSACR)           

           y1=qs*rdt
          pgacs=MIN(y1, pgacs)                               
          dgacs=MIN(y1, dgacs)                               
          wgacs=MIN(y1, wgacs)                               
          pgaut=MIN(y1, pgaut)                               
          pracs=MIN(y1, pracs)                               

          PRACS=(1.-DLT2)*PRACS                                
          PSN=D2T*(PGACS+DGACS+WGACS+PGAUT+PRACS)     
          QS=QS+PS-PSN                                      
          if(qs .lt. 0.0) then                                       
            a2=1.                                                       
              if(psn .ne. 0.) a2=qs/psn+1.                     
            pgacs=pgacs*a2                                        
            dgacs=dgacs*a2                                        
            wgacs=wgacs*a2                                        
            pgaut=pgaut*a2                                        
            pracs=pracs*a2                                        
            psn=psn*a2                                            
            qs=0.0                                                   
          endif                                                         
          Y2=D2T*(PSACW+PSFW+DGACW+PIACR+DGACR+       &
                WGACR+PSACR+PGFR)                              
          PT=PT+lhf*ene1*Y2                                   
          QG=QG+PG+PRN+PSN                               
!* 11 * PSMLT : MELTING OF QS                                     **11**
!* 19 * PGMLT : MELTING OF QG TO QR                               **19**
          PSMLT=0.0                                                  
          PGMLT=0.0                                                  
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          r3456=tem2
          IF(TAIR.GE.T0K .AND. (QS+QG).GT.CMIN) THEN           
            TAIRC=TAIR-T0K                                        
            Y1=TCA*TAIRC-RHO*ALV*DWV    &
                       *(C380*rp0-QV)
            Y2=.78/ZS**2+RN101*tem4*SCV    &
                 *exp(alog(ZS)*(-BSH5))
            R11RT=RN11*D2T*rrho                                       
            DD=R11RT*Y1*Y2+R11AT*TAIRC*(QSACW+QSACR)  
            PSMLT=MAX(0.0,MIN(DD,QS))                      
            IF(IHAIL.EQ.1) THEN                                         
               Y3=.78/ZG**2+SCV*RN19A*tem1*exp(alog(ZG)*(-BGH5))
            ELSE                                                        
               Y3=.78/ZG**2+SCV*RN19A*tem4*exp(alog(ZG)*(-BGH5))
            ENDIF                                                       
            DD1=Y1*Y3*RN19*D2T*rrho+R19BT*TAIRC*(QGACW   &
                   +QGACR)                                            
            PGMLT=MAX(0.0,MIN(DD1,QG))                     
            PT=PT-lhf*ene1*(PSMLT+PGMLT)
            QR=QR+PSMLT+PGMLT                               
            QS=QS-PSMLT                                        
            QG=QG-PGMLT                                        
          ENDIF                                                         
!* 24 * PIHOM : HOMOGENEOUS FREEZING OF QC TO QI (T < T00K)    **24**   
!* 25 * PIDW : DEPOSITION GROWTH OF QC TO QI ( T0K < T <= T00K)**25**   
!* 26 * PIMLT : MELTING OF QI TO QC (T >= T0K)                 **26**   
          IF(QC.LE.cmin)QC=0.0                                    
          IF(QI.LE.cmin)QI=0.0                                    
          PIHOM=0.                                                   
          PIMLT=0.                                                   
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          IF((TAIR-T00K).LE.0.) PIHOM=QC                       
          IF((TAIR-T0K) .GE.0.) PIMLT=QI                       
          PIDW=0.0                                                   
          IF(TAIR.LT.T0K.AND.TAIR.GT.T00K.AND.QC.GT.CMIN)THEN  
            TAIRC=TAIR-T0K                                        
            Y1=MAX(MIN(TAIRC,-1.),-31.)                       
            Y2=RN25A(INT(ABS(Y1)))                                
            Y3=MIN(RN25*EXP(BETA*TAIRC),1.)                     
            PIDW=MIN(Y2*Y3*D2T*rrho,QC)                 
          ENDIF                                                         
          Y1=PIHOM-PIMLT+PIDW                               
          PT=PT+lhf*ene1*Y1    &
                     +(lhs*ene1-ene2)*(PIDEP-PISUB)*D2T
          QV=QV-(PIDEP-PISUB)*D2T                           
          QC=QC-Y1                                             
          QI=QI+Y1                                             
!* 31 * PINT  : INITIATION OF QI                                  **31**
!****** DIFFERENT FROM LIN ET AL.                                 ******
          PINT=0.0                                                   
          TAIR=(th0(i,j,k)+PT)*PPI                                     
           if (qi .le. cmin) qi=0.0                               
          IF(TAIR.LT.T0K)THEN                                        
            TAIRC=TAIR-T0K                                        
            RTAIR=1./(TAIR-C76)                                   
            Y2=EXP(C218-C580*RTAIR)                               
            QSI=C380*rp0*Y2                                   
            ESI=C610*Y2                                           
            SSI=QV/QSI-1.                                
            NCI=MIN(RN25*EXP(BETA*TAIRC),1.)                       
!     Do not initiate the maximum number of nuclei. Some ice may already
!     present, so only initiate that needed to get up to the maximum num
!     Use ami50 g as mass of 50 micron size particle (assumed to be the 
!     size of ice particles), and use 1.e-9 g as initial mass of ice    
!     particles                                                         
            dd=MAX(1.e-9*nci*rrho-qi*1.e-9/ami50 , 0.)        
            DM=MAX((QV-QSI),0.)                          
            RSUB1=C580*ASC*QSI*RTAIR*RTAIR                  
            PINT=MIN(DD,DM)                                  
            DEP=DM/(1.+RSUB1)                                  
            PINT=MIN(PINT,DEP)                               
            if (pint .le. cmin) pint=0.0                          
            PT=PT+(lhs*ene1-ene2)*PINT
            QV=QV-PINT                                         
            QI=QI+PINT                                         
          ENDIF                                                         
!--------------------------------------
!  cut saturation .... do later
!--------------------------------------
!* 10 * PSDEP : DEPOSITION OR SUBLIMATION OF QS                   **10**
!* 20 * PGSUB : SUBLIMATION OF QG                                 **20**
          PSDEP=0.0                                                  
          PSSUB=0.0                                                  
          PGSUB=0.0                                                  
          r3456=tem2
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          IF((QS+QG).GT.CMIN)THEN              
            IF(QS.LT.cmin) QS=0.0                                 
            IF(QG.LT.cmin) QG=0.0                                 
            RTAIR=1./(TAIR-C76)                                   
            QSI=C380*rp0*EXP(C218-C580*RTAIR)                 
            SSI=QV/QSI-1.                                
            Y1=RN10A*RHO/(TCA*TAIR**2)+1./(DWV*QSI)   
            Y2=.78/ZS**2+RN101*tem4*SCV    &
                 *exp(alog(ZS)*(-BSH5))
            PSDEP=R10T*SSI*Y2/Y1                            
            PSSUB=PSDEP                                           
            PSDEP=MAX(PSDEP,0.)                                 
            PSSUB=MAX(-QS,MIN(PSSUB,0.))                   
            IF(IHAIL.EQ.1) THEN                                         
               Y2=.78/ZG**2+SCV*RN20B*tem1*exp(alog(ZG)*(-BGH5))
            ELSE                                                        
               Y2=.78/ZG**2+SCV*RN20B*tem4*exp(alog(ZG)*(-BGH5))
            ENDIF                                                       
            PGSUB=R20T*SSI*Y2/Y1                            
            DM=QV-QSI                                      
            RSUB1=C580*ASC*QSI*RTAIR*RTAIR                  
!     ********   DEPOSITION OR SUBLIMATION OF QS  **********************
            Y1=DM/(1.+RSUB1)                                   
            PSDEP=MIN(PSDEP,MAX(Y1,0.))                    
            Y2=MIN(Y1,0.)                                       
            PSSUB=MAX(PSSUB,Y2)                              
!     ********   SUBLIMATION OF QG   ***********************************
            DD=MAX((-Y2-QS),0.)                              
            PGSUB=MIN(DD,QG,MAX(PGSUB,0.))              
!      DLT1=CVMGP(1.,0.,QC+QI-1.E-5)                           
            IF((QC+QI-1.E-5).GE.0.)THEN                           
              DLT1=1.                                                
            ELSE                                                        
              DLT1=0.                                                
            ENDIF                                                       
            PSDEP=DLT1*PSDEP                                   
            PSSUB=(1.-DLT1)*PSSUB                              
            PGSUB=(1.-DLT1)*PGSUB                              
            PT=PT+(lhs*ene1-ene2)*(PSDEP+PSSUB-PGSUB)
            QV=QV+PGSUB-PSSUB-PSDEP                      
            QS=QS+PSDEP+PSSUB                               
            QG=QG-PGSUB                                        
          ENDIF                                                         
!* 23 * ERN : EVAPORATION OF QR (SUBSATURATION)                   **23**
          ERN=0.0                                                    
          IF(QR.GT.CMIN)THEN                                         
            TAIR=(th0(i,j,k)+PT)*PPI                                   
            RTAIR=1./(TAIR-C358)                                  
            QSW=C380*rp0*EXP(C172-C409*RTAIR)                 
            SSW=QV/QSW-1.0                               
            DM=QV-QSW                                      
            RSUB1=C409*AVC*QSW*RTAIR*RTAIR                  
            DD1=MAX(-DM/(1.+RSUB1),0.0)                      
            Y1=.78/ZR**2+RN23A*tem4*SCV    &
                 *exp(alog(ZR)*(-BWH5))
            Y2=RN23B*RHO/(TCA*TAIR**2)+1./(DWV*QSW)   
            ERN=R23T*SSW*Y1/Y2                              
            ERN=MIN(DD1,QR,MAX(ERN,0.))                 
            PT=PT-(lhv*ene1-ene2)*ERN
            QV=QV+ERN                                          
            QR=QR-ERN                                          
          ENDIF                                                         
          dum=ruh(i)*rvh(j)*rmh(i,j,k)
          bud3(k)=bud3(k)+rr(i,j,k)*ERN*dum
          IF(QC.LE.cmin)QC=0.                                     
          IF(QR.LE.cmin)QR=0.                                     
          IF(QI.LE.cmin)QI=0.                                     
          IF(QS.LE.cmin)QS=0.                                     
          IF(QG.LE.cmin)QG=0.                                     
        IF(eqtset.eq.2)THEN
          dum1=abs(qv-qv3d(i,j,k))+abs(qc-qc3d(i,j,k))+abs(qr-qr3d(i,j,k))   &
              +abs(qi-qi3d(i,j,k))+abs(qs-qs3d(i,j,k))+abs(qg-qg3d(i,j,k))
          if(dum1.gt.1.0e-7)then
            pp3d(i,j,k)=((rhod(i,j,k)*(rd+rv*qv)*(th0(i,j,k)+pt)*rp00)**rddcv)-pi0(i,j,k)
            prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
          endif
        ELSE
          rhod(i,j,k)=prs(i,j,k)/(rd*(th0(i,j,k)+pt)*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qv*reps))
        ENDIF

          TH3D(I,J,K)=PT
          QV3D(I,J,K)=QV
          QC3D(I,J,K)=QC
          QR3D(I,J,K)=QR
          QI3D(I,J,K)=QI
          QS3D(I,J,K)=QS
          QG3D(I,J,K)=QG
          vtr(i,j,k)=vfr*0.01
          vts(i,j,k)=vfs*0.01
          vtg(i,j,k)=vfg*0.01
          vti(i,j,k)=0.200

      enddo
      enddo
      enddo

      tem6=dx*dy*dz

      do k=1,nk
        tauto=tauto+bud1(k)*tem6
      enddo

      do k=1,nk
        taccr=taccr+bud2(k)*tem6
      enddo

      do k=1,nk
        tevar=tevar+bud3(k)*tem6
      enddo

      if(timestats.ge.1) time_microphy=time_microphy+mytime()

!C**********************************************************************
!                                                                       
      RETURN                                                            
      END                                                               


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!***********************************************************************
      SUBROUTINE CONSAT
      implicit none
      include 'input.incl'
      include 'goddard.incl'
!***********************************************************************
!     (LIN) SPECIFY SOME CONSTANTS IN SATICE ROUTINE                   *
!     LIN ET.AL.  J. CLIM. APPL. METEOR.  22, 1065-1092                *
!     MODIFIED AND CODED BY TAO AND SIMPSON (JAS, 1989; TAO, 1993)     *
!     RECENT CHANGES (6.25.01) BY SCOTT BRAUN INCLUDE
!         * OPTION TO CHOOSE HAIL OR GRAUPEL AS THIRD ICE CATEGORY
!         * OPTION OF SATURATION ADJUSTMENT SCHEMES
!         * INCLUSION OF GAMMA FUNCTION FOR EASIER VARIATION OF FALL
!           SPEED COEFFICIENTS
!***********************************************************************

      real A1(31),A2(31)
      DATA A1/.7939E-7,.7841E-6,.3369E-5,.4336E-5,.5285E-5,.3728E-5,       &
         .1852E-5,.2991E-6,.4248E-6,.7434E-6,.1812E-5,.4394E-5,.9145E-5,   &
         .1725E-4,.3348E-4,.1725E-4,.9175E-5,.4412E-5,.2252E-5,.9115E-6,   &
         .4876E-6,.3473E-6,.4758E-6,.6306E-6,.8573E-6,.7868E-6,.7192E-6,   &
         .6513E-6,.5956E-6,.5333E-6,.4834E-6/
      DATA A2/.4006,.4831,.5320,.5307,.5319,.5249,.4888,.3894,.4047,    &
         .4318,.4771,.5183,.5463,.5651,.5813,.5655,.5478,.5203,.4906,   &
         .4447,.4126,.3960,.4149,.4320,.4506,.4483,.4460,.4433,.4413,   &
         .4382,.4361/

      real gamma

      real cp,cpi,cpi2,grvt,tca,dwv,dva,amw,ars,scv,rw,cw,ci,cd1,cd2,     &
           ga3b,ga4b,ga6b,ga5bh,ga3g,ga4g,ga5gh,ga3d,ga4d,ga5dh,esw,      &
           eri,ami,esr,eiw,ui50,ri50,cmn,y1,rn13,egw,egi,egi2,egr,apri,   &
           bpri,erw,cn0

      integer i,k

!
!
!     USE GRAUPEL OR HAIL (0=GRAUPEL, 1=HAIL)
!
!!!!!! 
!!!!!!      IHAIL=1       ! Now specified in namelist.input
!!!!!! 
!
!*****   IWATER=0 USES A SLIGHT VARIANT OF THE ORIGINAL TAO ET AL METHOD
!*****   THE ONLY DIFFERENCE IS THAT THE WEIGHTING BETWEEN THE LIQUID
!*****   AND ICE SATURATION VALUES IS DONE BY TEMPERATURE RATHER THAN MA
!*****   IWATER=1 USES A SEQUENTIAL METHOD IN WHICH THE ADJUSTMENT IS FI
!*****   DONE FOR LIQUID WATER FOR TEMPERATURES WARMER THAN 253K, THEN F
!*****   ICE ONLY WHERE THE TEMPERATURE IS COLDER THAN 258K. THE MAIN EF
!*****   THIS CHANGE IS TO REDUCE THE AMOUNT OF SUPERCOOLED WATER AT VER
!*****   TEMPERATURES
!!!!!! 
!!!!!!      IWATER=1
!!!!!! 
!*****************************************************************
 
!
      CP=1.0057E7
      CPI=4.*ATAN(1.)
      CPI2=CPI*CPI
      GRVT=981.
      TCA=2.43E3
      DWV=.226
      DVA=1.718E-4
      AMW=18.016
      ARS=8.314E7
      SCV=2.2904487
      T0K=273.15
      T00K=233.15
      ALV=2.501000E10
      ALS=2.834000E10
      ALF=ALS-ALV
      AVC=ALV/CP
      AFC=ALF/CP
      ASC=ALS/CP
      RW=4.615E6
      CW=4.190E7
      CI=2.106000E7
      C76=7.66
      C358=29.65
      C172=17.67
      C409=17.67*(273.15-29.65)
      C218=21.8745584
      C580=21.8745584*(273.15-7.66)
      C380=10.0*611.2*287.04/461.5
      C610=6.1078E3
      C149=1.496286E-5
      C879=8.794142
      C141=1.4144354E7
 
!***   DEFINE THE DENSITY AND SIZE DISTRIBUTION OF PRECIPITATION
!***   DEFINE THE COEFFICIENTS USED IN TERMINAL VELOCITY
!**********   HAIL OR GRAUPEL PARAMETERS   **********
      if (ihail .eq. 1) then
        ROQG=.9
        TNG=.0002
        CD1=6.E-1
        CD2=4.*GRVT/(3.*CD1)
        AGG=SQRT(CD2*ROQG)
        BGG=.5
      else
        ROQG=.4
        TNG=.04
        AGG=351.2
        BGG=.37
      endif
!**********         SNOW PARAMETERS        **********
! Note ... see Potter, 1991, JAM, p. 1040 for more info about these changes
      ROQS=.1
      ROQS_POTTER=1.0
      TNSS=1.
!!!      ASS=152.93
!!!      BSS=.25
      ASS=179.2
      BSS=.42
!**********         RAIN PARAMETERS        **********
      ROQR=1.
      TNW=.08
      AWW=2115.
      BWW=.8
!*****************************************************************
!
!
      BGH=.5*BGG
      BSH=.5*BSS
      BWH=.5*BWW
      BGQ=.25*BGG
      BSQ=.25*BSS
      BWQ=.25*BWW
      GA3B=gamma(3.+BWW)
      GA4B=gamma(4.+BWW)
      GA6B=gamma(6.+BWW)
      GA5BH=gamma((5.+BWW)/2.)
      GA3G=gamma(3.+BGG)
      GA4G=gamma(4.+BGG)
      GA5GH=gamma((5.+BGG)/2.)
      GA3D=gamma(3.+BSS)
      GA4D=gamma(4.+BSS)
      GA5DH=gamma((5.+BSS)/2.)
      ZRC=(CPI*ROQR*TNW)**0.25
      ZSC=(CPI*ROQS_POTTER*TNSS)**0.25
      ZGC=(CPI*ROQG*TNG)**0.25
      VRC=AWW*GA4B/(6.*ZRC**BWW)
      VSC=ASS*GA4D/(6.*ZSC**BSS)
      VGC=AGG*GA4G/(6.*ZGC**BGG)
!-------------------------------
!  fudge check
      if(ihail.eq.1 .and. bgg.ne.0.5)then
        print *,'  BGG must be 0.5 for hail (its fudged into code)!'
        print *,'        (sorry)'
        call stopcm1
      endif
!!!      if(bss.ne.0.25)then
!!!        print *,'  BSS must be 0.25 (its fudged into code)!'
!!!        print *,'        (sorry)'
!!!        call stopcm1
!!!      endif
      if(bww.ne.0.8)then
        print *,'  BWW must be 0.8 (its fudged into code)!'
        print *,'        (sorry)'
        call stopcm1
      endif
!-------------------------------
!     ****************************
      RN1=1.E-3
      RN2=1.E-3
      BND1=5.E-4
      BND2=1.25E-3
      RN3=.25*CPI*TNSS*ASS*GA3D
      ESW=1.
      RN4=.25*CPI*ESW*TNSS*ASS*GA3D
      ERI=1.
      RN5=.25*CPI*ERI*TNW*AWW*GA3B
      AMI=1./(24.*4.19E-10)
      RN6=CPI2*ERI*TNW*AWW*ROQR*GA6B*AMI
      ESR=1.
      RN7=CPI2*ESR*TNW*TNSS*ROQS
      RN8=CPI2*ESR*TNW*TNSS*ROQR
      RN9=CPI2*TNSS*TNG*ROQS
      RN10=2.*CPI*TNSS
      RN101=.31*GA5DH*SQRT(ASS)
      RN10A=ALS*ALS/RW
      RN11=2.*CPI*TNSS/ALF
      RN11A=CW/ALF
      AMI40=2.41e-8
      AMI50=3.76e-8
      AMI100=1.51e-7
      EIW=1.
      UI50=20.
      RI50=10.e-3
      CMN=1.05E-15
      RN12=CPI*EIW*UI50*RI50**2
      DO 10 K=1,31
        Y1=1.-A2(K)
        RN13=A1(K)*Y1/(AMI100**Y1-AMI40**Y1)
        RN12A(K)=RN13/AMI100
        RN12B(K)=A1(K)*AMI100**A2(K)
        RN25A(K)=A1(K)*CMN**A2(K)
   10 CONTINUE
      EGW=1.
      EGI=.1
      EGI2=1.
      RN14=.25*CPI*EGW*TNG*GA3G*agg
      RN15=.25*CPI*EGI*TNG*GA3G*agg
      RN15A=.25*CPI*EGI2*TNG*GA3G*agg
      EGR=1.
      RN16=CPI2*EGR*TNG*TNW*ROQR
      RN17=2.*CPI*TNG
      RN17A=.31*GA5GH*sqrt(agg)
      RN17B=CW-CI
      RN17C=CW
      APRI=.66
      BPRI=1.E-4
      RN18=20.*CPI2*BPRI*TNW*ROQR
      RN18A=APRI
      RN19=2.*CPI*TNG/ALF
      RN19A=.31*GA5GH*sqrt(agg)
      RN19B=CW/ALF
      RN20=2.*CPI*TNG
      RN20A=ALS*ALS/RW
      RN20B=.31*GA5GH*sqrt(agg)
      BND3=2.0E-3
      RN21=1.E3*1.569E-12/0.15
      ERW=1.
      RN22=.25*CPI*ERW*AWW*TNW*GA3B
      RN23=2.*CPI*TNW
      RN23A=.31*GA5BH*SQRT(AWW)
      RN23B=ALV*ALV/RW
      CN0=1.E-6
      RN25=CN0
      RN30A=ALV*ALS*AMW/(TCA*ARS)
      RN30B=ALV/TCA
      RN30C=ARS/(DWV*AMW)
      RN31=1.E-17
      BETA=-.46
      RN32=4.*51.545E-4
!-----------------------------------------------
      RT0=1./(T0K-T00K)
      BW3=BWW+3.
      BS3=BSS+3.
      BG3=BGG+3.
      BWH5=2.5+BWH
      BSH5=2.5+BSH
      BGH5=2.5+BGH
      BW6=BWW+6.
      BS6=BSS+6.
      BETAH=.5*BETA
!-----------------------------------------------
!  lookup tables
!
!  for pwr81, temperature range is from -100 to +50 Celsius in increments
!  of 1 Celsius
      do i=0,151
        pwr81(i)=(173.15+i)**0.81
      enddo
!  rho*q from 0 to 50e-6 in increments of 1e-9
      do i=0,50001
        pwr2(i)=(i*1.0e-9)**bwq
      enddo
!-----------------------------------------------
      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!***********************************************************************
      SUBROUTINE CONSAT2(d2t)
      implicit none
      include 'goddard.incl'
      real d2t
      R10T=RN10*D2T
      R11AT=RN11A*D2T
      R19BT=RN19B*D2T
      R20T=-RN20*D2T
      R23T=-RN23*D2T
      RETURN
      END


init3d.F        1587424407  1602  20    100644  53493     `

      subroutine init3d(xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf,  &
                        xfref,yfref,sigma,c1,c2,gz,                       &
                        zh,mh,rmh,zf,mf,rmf,rho0s,pi0s,prs0s,             &
                        pi0,prs0,rho0,thv0,th0,rth0,qv0,                  &
                        u0,v0,qc0,qi0,rr0,rf0,rrf0,                       &
                        rain,sws,svs,sps,srs,sgs,sus,shs,                 &
                        thflux,qvflux,cd,ch,cq,                           &
                        dum1,dum2,dum3,dum4,divx,rho,prs,                 &
                        t11,t12,t13,t22,t23,t33,                          &
                        rru,ua,u3d,uten,uten1,rrv,va,v3d,vten,vten1,      &
                        rrw,wa,w3d,wten,wten1,ppi,pp3d,ppten,sten,        &
                        tha,th3d,thten,thten1,qa,q3d,qten,                &
                        kmh,kmv,khh,khv,tkea,tke3d,tketen,                &
                        pta,pt3d,ptten,                                   &
                        pdata,cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans)

      use module_mp_nssl_2mom, only: ccn, lccn

      implicit none
 
      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf,rxf,uf,ruf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: yf,vf,rvf
      real, dimension(-2:nx+4) :: xfref
      real, dimension(-2:ny+4) :: yfref
      real, intent(in), dimension(kb:ke) :: sigma
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf,rmf
      real, dimension(ib:ie,jb:je) :: rho0s,pi0s,prs0s
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,rho0,thv0,th0,rth0,qv0
      real, dimension(ib:ie,jb:je,kb:ke) :: qc0,qi0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,cd,ch,cq
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4
      real, dimension(ib:ie,jb:je,kb:ke) :: divx,rho,prs
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,rru,ua,u3d,uten,uten1
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,rrv,va,v3d,vten,vten1
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,wa,w3d,wten,wten1
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten,sten
      real, dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thten,thten1
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,q3d,qten
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d,tketen
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta,pt3d,ptten
      real, dimension(npvals,nparcels) :: pdata
      real, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, dimension(kpb:kpe) :: cfa,cfc,ad1,ad2
      complex, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, dimension(ipb:ipe,jpb:jpe) :: rhs,trans
 
!-----------------------------------------------------------------------

      integer i,j,k,l,n,nn,nbub,nloop
      integer ic,jc,ifoo,jfoo
      real ric,rjc
      real xc,yc,zc,bhrad,bvrad,bptpert,beta,omega,tmp,zdep
      real thvnew(nk),pinew(nk)
      real thl,ql,qt,th1,t1,ql2,rm,cpm,v1,v2,th2

      real, dimension(:), allocatable :: rref
      real, dimension(:,:), allocatable :: vref,piref,thref,thvref,qvref
      double precision :: rmax,vmax,frac,angle
      real :: r0,zdd,dd2,dd1,vr,rr,diff,xref,yref,xmax,ymax
      real :: mult,nominal_dx
      integer :: ival,ni1,ni2,ni3
      integer :: i1,i2,ii,jj,nref

      real rmin,foo1,foo2,umax,umin,vmin
      real :: rand,amplitude
      integer, dimension(:), allocatable :: sand
      double precision :: dpi

      logical :: setppi,maintain_rh

      real :: rm1,rm2,rm3,rdc,w2,w3,v3

!--------------------------

      real rslf

      if(dowr) write(outfile,*) 'Inside INIT3D'
      if(dowr) write(outfile,*)

      convinit = 0
      setppi = .true.
      maintain_rh = .false.

!------------------------------------------------------------------
!  Initialize surface swath arrays:

      do n=1,nrain
      do j=jb,je
      do i=ib,ie
        ! these are all positive-definite, so set initial value to zero:
        rain(i,j,n)=0.0
        sws(i,j,n)=0.0
        srs(i,j,n)=0.0
        sgs(i,j,n)=0.0
        shs(i,j,n)=0.0
        ! for sps, we want to get a MINIMUM value at the surface, so...
        ! set sps to an absurdly large number:
        sps(i,j,n)=200000.0
        ! svs and sus can be negative or positive, 
        ! but we want to get a MAXIMUM value, so...
        ! set svs and sus to an absurdly low (negative) number:
        svs(i,j,n)=-1000.0
        sus(i,j,n)=-1000.0
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  Set winds to base-state values:

      do k=kb,ke
      do j=jb,je
      do i=ib,ie+1
        ua(i,j,k)=u0(i,j,k)
        u3d(i,j,k)=u0(i,j,k)
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je+1
      do i=ib,ie
        va(i,j,k)=v0(i,j,k)
        v3d(i,j,k)=v0(i,j,k)
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------

    IF ( ptype .ge. 26 .and. lccn .gt. 0 ) THEN
! initialize CCN concentrations as constant mixing ratios througout the domain
      do k=kbm,kem
      do j=jbm,jem
      do i=ibm,iem
       qa (i,j,k,lccn-1) = ccn/1.225
       q3d(i,j,k,lccn-1) = ccn/1.225
      enddo
      enddo
      enddo
    ENDIF

!-----------------------------------------------------------------------
!  Set qv to base state value:

    IF(imoist.eq.1)THEN

      do k=kbm,kem
      do j=jbm,jem
      do i=ibm,iem
        qa(i,j,k,nqv)=qv0(i,j,k)
      enddo
      enddo
      enddo

!---- This is here to ensure that certain idealized cases work ----

      IF( (isnd.eq.4 .or. isnd.eq.9 .or. isnd.eq.10 .or. isnd.eq.11) )THEN

        do k=kbm,kem
        do j=jbm,jem
        do i=ibm,iem
          qa(i,j,k,nqc)=qc0(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

      IF( (isnd.eq.4 .or. isnd.eq.9 .or. isnd.eq.10) .and. iice.eq.1 )THEN

        do k=kbm,kem
        do j=jbm,jem
        do i=ibm,iem
          qa(i,j,k,nqi)=qi0(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

    ENDIF

!-----

    IF(iptra.eq.1)THEN
      ! define concentrations for passive fluid tracers here:
      do n=1,npt
      do k=kbp,kep
      do j=jbp,jep
      do i=ibp,iep
        if(n.eq.1)then
          pta(i,j,k,n)=0.0
          if(zh(i,j,k).lt.3000.0) pta(i,j,k,n)=0.001
        endif
        if(n.eq.2)then
          pta(i,j,k,n)=0.0
          if(zh(i,j,k).gt.3000.0.and.zh(i,j,k).lt.6000.0) pta(i,j,k,n)=0.001
        endif
        if(n.eq.3)then
          pta(i,j,k,n)=0.0
          if(zh(i,j,k).gt.6000.0.and.zh(i,j,k).lt.9000.0) pta(i,j,k,n)=0.001
        endif
      enddo
      enddo
      enddo
      enddo
    ENDIF

!-----
!  parcel info:

      IF(iprcl.eq.1)THEN
        ! define initial locations of parcels here:
        !   pdata(1,*) = x location (m)
        !   pdata(2,*) = y location (m)
        !   pdata(3,*) = z location (m)

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Parcels ! '
        if(dowr) write(outfile,*) '  npvals,nparcels = ',npvals,nparcels
        if(dowr) write(outfile,*) '  Initial parcel locations (x,y,z):'
        n = 0
        do k=1,10
        do j=1,60
        do i=1,60
          n = n + 1
          if(n.gt.nparcels)then
            if(dowr) write(outfile,*)
            if(dowr) write(outfile,*) ' You are trying to define too many parcels'
            if(dowr) write(outfile,*)
            if(dowr) write(outfile,*) ' Increase the value of nparcels in namelist.input'
            if(dowr) write(outfile,*)
            call stopcm1
          endif
          pdata(1,n) = minx + 2000.0*(i-1)
          pdata(2,n) = miny + 2000.0*(j-1)
          pdata(3,n) = zh(1,1,1) + 1000.0*(k-1)
!!!          if(dowr) write(outfile,*) n,pdata(1,n),pdata(2,n),pdata(3,n)
        enddo
        enddo
        enddo
        if(dowr) write(outfile,*)

      ENDIF

!-----------------------------------------------------------------------
!  initialize random number generator:

        !-----------------------------------!
        !----- don't change this code) -----!
        ! initialize the random number generator
        call random_seed(size=k)
        k = max(2,k)
        if(dowr) write(outfile,*) '  seed_size = ',k
        allocate( sand(k) )
        do n=1,k
          sand(n) = nint( 2.0e9*(2.0*float(n-1)/float(k-1)-1.0) )
        enddo
        call random_seed(put=sand(1:k))
        call random_number(rand)
        if(dowr) write(outfile,*) '  rand-1 = ',rand
        deallocate( sand )
        !----- don't change this code) -----!
        !-----------------------------------!

!-----------------------------------------------------------------------
!  iinit = 1
!  Warm bubble
!  reference:

      IF(iinit.eq.1)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Warm bubble'
        if(dowr) write(outfile,*)

        ric     =      0.0  ! center of bubble in x-direction (m)
        rjc     =      0.0  ! center of bubble in y-direction (m)
        zc      =   1400.0  ! height of center of bubble above ground (m)
        bhrad   =  10000.0  ! horizontal radius of bubble (m)
        bvrad   =   1400.0  ! vertical radius of bubble (m)
        bptpert =      1.0  ! max potential temp perturbation (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .false.

        do k=1,nk
        do j=1,nj
        do i=1,ni
          beta=sqrt(                             &
                    ((xh(i)-ric)/bhrad)**2       &
                   +((yh(j)-rjc)/bhrad)**2       &
                   +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            tha(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
          else
            tha(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iinit = 2
!  Cold pool (dam break style)
!  reference:  

      ELSEIF(iinit.eq.2)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Cold pool .... periodic in N-S'
        if(dowr) write(outfile,*)

        ric      =  200000.0   ! eastern edge of cold pool
        zdep     =    2500.0   ! depth of cold pool (m)
        bptpert  =      -6.0   ! max temp perturbation at sfc (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .true.

        do k=1,nk
        do j=1,nj
        do i=1,ni
          if( (xh(i).le.ric).and.(zh(i,j,k).lt.zdep) )then
            tha(i,j,k)=bptpert*(zdep-zh(i,j,k))/zdep
          else
            tha(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo


!-----------------------------------------------------------------------
!  iinit = 3
!  Line of warm bubbles
!  reference:  

      ELSEIF(iinit.eq.3)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Line of warm bubbles'
        if(dowr) write(outfile,*)
 
        nbub    =      3     ! number of warm bubbles
        ric     =  30000.0   ! center of bubble in x-direction (m)
        zc      =   1400.0   ! height of center of bubble above ground (m)
        bhrad   =  10000.0   ! horizontal radius of bubble (m)
        bvrad   =   1400.0   ! vertical radius of bubble (m)
        bptpert =      2.0   ! max potential temp perturbation (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .false.

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          tha(i,j,k)=0.0
        enddo
        enddo
        enddo

        do n=1,nbub

          if(n.eq.1) rjc=  3000.0
          if(n.eq.2) rjc= 33000.0
          if(n.eq.3) rjc= 63000.0

          if(dowr) write(outfile,*) '  ric,rjc=',n,ric,rjc
 
          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            beta=sqrt(                        &
                    ((xh(i)-ric)/bhrad)**2    &
                   +((yh(j)-rjc)/bhrad)**2    &
                   +((zh(i,j,k)-zc)/bvrad)**2)
            if(beta.lt.1.0)then
              tha(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
            else
              tha(i,j,k)=max(0.0,tha(i,j,k))
            endif
          enddo
          enddo
          enddo

        enddo


!-----------------------------------------------------------------------
!  iinit = 4
!  moist bubble for moist benchmark
!  reference:  Bryan and Fritsch, 2002, MWR, 130, 2917-2928.

      ELSEIF(iinit.eq.4)THEN

        ! parameters for dry counterpart bubble

        ric      =      0.0       ! x-location of bubble center (m)
        zc       =   2000.0       ! z-location of bubble center (m)
        bhrad    =   2000.0       ! horizontal radius of bubble (m)
        bvrad    =   2000.0       ! vertical radius of bubble (m)
        bptpert  =      2.0       ! maximum potential temp. pert. (K)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          beta=sqrt( ((xh(i)-ric)/bhrad)**2    &
                    +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            dum1(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
          else
            dum1(i,j,k)=0.
          endif
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          tha(i,j,k)=0.
          ppi(i,j,k)=0.
          dum2(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
        enddo
        enddo
        enddo

        do nn=1,30
          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            qa(i,j,k,nqv)=dum2(i,j,k)*rslf(prs0(i,j,k),(th0(i,j,k)+tha(i,j,k))*pi0(i,j,k))
          enddo
          enddo
          enddo

          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            qa(i,j,k,nqc)=max(qt_mb-qa(i,j,k,nqv),0.0)
          enddo
          enddo
          enddo

          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            tha(i,j,k)=( (dum1(i,j,k)/300.)+(1.0+qt_mb)/(1.0+qa(i,j,k,nqv)) )  &
               *thv0(i,j,k)*(1.0+qa(i,j,k,nqv))/(1.0+reps*qa(i,j,k,nqv)) - th0(i,j,k)
            if(abs(tha(i,j,k)).lt.1.e-4) tha(i,j,k)=0.
          enddo
          enddo
          enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qa(i,j,k,nqv)=rslf(prs0(i,j,k),(th0(i,j,k)+tha(i,j,k))*pi0(i,j,k))
          qa(i,j,k,nqc)=max(qt_mb-qa(i,j,k,nqv),0.0)
        enddo
        enddo
        enddo

!-----------------------------------------------------------------
!  iinit = 5
!  density current sim

      ELSEIF(iinit.eq.5)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Cold pool (elipse, following Straka)'
        if(dowr) write(outfile,*)

        ric     =     0.0
        rjc     =     0.0
        zc      =  3000.0
        bhrad   =  4000.0
        bvrad   =  2000.0
        bptpert =   -15.0

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          beta=sqrt(                           &
                     ((xh(i)-ric)/bhrad)**2    &
!!!                    +((yh(j)-rjc)/bhrad)**2    &
                    +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            dum1(i,j,k)=bptpert*(cos(pi*beta)+1.0)*0.5
          else
            dum1(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          tmp=(th0(i,j,k)*pi0(i,j,k))+dum1(i,j,k)
          tha(i,j,k)=tmp/pi0(i,j,k)-th0(i,j,k)
          if(abs(tha(i,j,k)).lt.1.e-4) tha(i,j,k)=0.0
          ppi(i,j,k)=0.0
        enddo
        enddo
        enddo

!------------------------------------------------------------------
!  Rotunno-Emanuel tropical cyclone vortex
!  (see Rotunno and Emanuel, 1987, JAS, for more information)

      ELSEIF(iinit.eq.7)THEN

        r0     =   412500.0
        rmax   =    82500.0
        vmax   =       15.0
        zdd    =    20000.0

        dd2 = 2.0 * rmax / ( r0 + rmax )

        allocate(  rref(nx)       )
        allocate(  vref(nx,0:nk+1))
        allocate( piref(nx,0:nk+1))
        allocate( thref(nx,0:nk+1))
        allocate(thvref(nx,0:nk+1))
        allocate( qvref(nx,0:nk+1))

          rref=0.0
          vref=0.0
         piref=0.0
         thref=0.0
        thvref=0.0
         qvref=0.0

        IF(ibalance.ne.0)THEN
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) ' Please use ibalance = 0 with iinit=7'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) ' ... stopping inside init3d ... '
          if(dowr) write(outfile,*)
          call stopcm1
        ENDIF
        IF(terrain_flag)THEN
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) ' iinit=7 is not setup for use with terrain'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) ' ... stopping inside init3d ... '
          if(dowr) write(outfile,*)
          call stopcm1
        ENDIF

        IF(axisymm.eq.1)THEN
          nref = nx
          xref = 0.0
          do i=1,nref
            rref(i) = 0.5*(xfref(i)+xfref(i+1))
          enddo
        ELSE
          nref = nx/2+1
          xref = xfref(nx/2+1)
          yref = yfref(ny/2+1)
          xmax = 0.5*(xfref(nx)+xfref(nx+1))
          ymax = 0.5*(yfref(ny)+yfref(ny+1))
          do i=1,nref
            rref(i) = 0.5*(xfref(nx/2+i)+xfref(nx/2+i+1))-xref
          enddo
        ENDIF

!!!        print *
!!!        print *,'  v:'
        do k=1,nk
        do i=1,nref
          if(rref(i).lt.r0)then
            dd1 = 2.0 * rmax / ( rref(i) + rmax )
            vr = sqrt( vmax**2 * (rref(i)/rmax)**2     &
            * ( dd1 ** 3 - dd2 ** 3 ) + 0.25*fcor*fcor*rref(i)*rref(i) )   &
                    - 0.5 * fcor * rref(i)
          else
            vr = 0.0
          endif
!-------------------------------------------
!  alternative:  modified Rankine vortex
!          rm1  =   15000.0
!          rm2  = 2000000.0
!          rm3  = 8000000.0
!          vmax =   80.0
!          rdc  =  -0.50
!          if( rref(i).lt.rm1 )then
!            vr = vmax*rref(i)/rm1
!          elseif( rref(i).lt.rm2 )then
!            vr = vmax*( (rref(i)/rm1)**rdc )
!          elseif( rref(i).lt.rm3 )then
!            v2 = vmax*( (rref(i)/rm1)**rdc )
!            v3 = vmax*0.5*(1.0-(rref(i)-rm2)/(rm3-rm2))
!            w3 = (rref(i)-rm2)/(rm3-rm2)
!            w2 = 1.0-w3
!            vr = w2*v2+w3*v3
!          else
!            vr = 0.0
!          endif
!-------------------------------------------
          if(zh(1,1,k).lt.zdd)then
            vref(i,k) = vr * (zdd-zh(1,1,k))/(zdd-0.0)
          else
            vref(i,k) = 0.0
          endif
!!!          if(k.eq.1) print *,i,xh(ni/2+i),rref(i),vref(i,k)
        enddo
        enddo
!!!        print *

        do k=1,nk
          dum2(1,1,k)=qv0(1,1,k)/(rslf(prs0(1,1,k),th0(1,1,k)*pi0(1,1,k)))
        enddo

      ! need to iterate for qv to converge:
      DO nloop=1,20

        do k=1,nk
        do i=1,nref
          if(imoist.eq.1)   &
          qvref(i,k) = dum2(1,1,k)*rslf(p00*((pi0(1,1,k)+piref(i,k))**cpdrd),   &
                             (pi0(1,1,k)+piref(i,k))*(th0(1,1,k)+thref(i,k)) )
          thvref(i,k)=(th0(1,1,k)+thref(i,k))*(1.0+reps*qvref(i,k))   &
                                             /(1.0+qvref(i,k))
        enddo
        enddo

!!!        print *,'  pi:'
        do k=1,nk
          piref(nref,k)=0.0
          do i=nref,2,-1
            piref(i-1,k) = piref(i,k)                                       &
         + (rref(i-1)-rref(i))/(cp*0.5*(thvref(i-1,k)+thvref(i,k))) * 0.5 * &
             ( vref(i  ,k)*vref(i  ,k)/rref(i)                              &
              +vref(i-1,k)*vref(i-1,k)/rref(i-1)                            &
               + fcor * ( vref(i,k) + vref(i-1,k) ) )
!!!            if(k.eq.1) print *,i-1,rref(i-1),piref(i-1,k)
          enddo
        enddo
!!!        print *

        do i=1,nref
          piref(i,   0) = piref(i, 1)
          piref(i,nk+1) = piref(i,nk)
        enddo

        do k=2,nk
        do i=1,nref
          thref(i,k) = 0.5*( cp*0.5*(thvref(i,k)+thvref(i,k+1))*(piref(i,k+1)-piref(i,k))*rdz*mf(1,1,k+1)     &
                            +cp*0.5*(thvref(i,k)+thvref(i,k-1))*(piref(i,k)-piref(i,k-1))*rdz*mf(1,1,k) )   &
                          *thv0(1,1,k)/g
          thref(i,k)=(thv0(1,1,k)+thref(i,k))*(1.0+qvref(i,k))/(1.0+reps*qvref(i,k))-th0(1,1,k)
        enddo
        enddo

        k=1
        do i=1,nref
          thref(i,k) = ( cp*0.5*(thvref(i,k)+thvref(i,k+1))*(piref(i,k+1)-piref(i,k))*rdz*mf(1,1,k+1) )   &
                          *thv0(1,1,k)/g
          thref(i,k)=(thv0(1,1,k)+thref(i,k))*(1.0+qvref(i,k))/(1.0+reps*qvref(i,k))-th0(1,1,k)
        enddo

        if(dowr) write(outfile,*) nloop,thref(1,1),qvref(1,1),piref(1,1)

      ENDDO   ! enddo for iteration

        IF(axisymm.eq.1)THEN

          do k=1,nk
          do i=1,ni
             va(i,1,k) =  vref(i,k)
            ppi(i,1,k) = piref(i,k)
            tha(i,1,k) = thref(i,k)
            if(imoist.eq.1) qa(i,1,k,nqv) = qvref(i,k)
          enddo
          enddo

        ELSE

          do j=1,nj+1
          do i=1,ni+1
            ! scalar points:
            rr = sqrt( (xh(i)-xref)**2 + (yh(j)-yref)**2 )
            rr = min( rr , xmax-xref )
            ! need to account for grid stretching.  Do simple search:
            diff = -1.0e20
            ii = 0
            do while( diff.lt.0.0 )
              ii = ii + 1
              if( ii.gt.nref )then
                write(6,*)
                write(6,*) ' ii,nref = ',ii,nref
                write(6,*) ' rr      = ',rr,xmax,xref
                write(6,*) ' rref    = ',rref(ii-1),rref(ii-1)-rr
                write(6,*)
                call stopcm1
              endif
              diff = rref(ii)-rr
            enddo
            i2 = ii
            i1 = i2-1
            frac = (      rr-rref(i1))   &
                  /(rref(i2)-rref(i1))
            do k=1,nk
              ppi(i,j,k) = piref(i1,k)+(piref(i2,k)-piref(i1,k))*frac
              tha(i,j,k) = thref(i1,k)+(thref(i2,k)-thref(i1,k))*frac
              if(imoist.eq.1) qa(i,j,k,nqv) = qvref(i1,k)+(qvref(i2,k)-qvref(i1,k))*frac
            enddo

            ! u:
            rr = sqrt( (xf(i)-xref)**2 + (yh(j)-yref)**2 )
            rr = min( rr , xmax-xref )
            ! need to account for grid stretching.  Do simple search:
            diff = -1.0e20
            ii = 0
            do while( diff.lt.0.0 )
              ii = ii + 1
              if( ii.gt.nref )then
                write(6,*)
                write(6,*) ' ii,nref = ',ii,nref
                write(6,*) ' rr      = ',rr,xmax,xref
                write(6,*)
                call stopcm1
              endif
              diff = rref(ii)-rr
            enddo
            if( abs(rr-rref(ii)).lt.tsmall .and. ii.eq.1 ) ii = 2
            i2 = ii
            i1 = i2-1
            frac = (      rr-rref(i1))   &
                  /(rref(i2)-rref(i1))
            do k=1,nk
              angle = datan2(dble(yh(j)-yref),dble(xf(i)-xref))
              ua(i,j,k) = -( vref(i1,k)+( vref(i2,k)- vref(i1,k))*frac )*sin(angle)
            enddo

            ! v:
            rr = sqrt( (yf(j)-yref)**2 + (xh(i)-xref)**2 )
            rr = min( rr , xmax-xref )
            ! need to account for grid stretching.  Do simple search:
            diff = -1.0e20
            ii = 0
            do while( diff.lt.0.0 )
              ii = ii + 1
              if( ii.gt.nref )then
                write(6,*)
                write(6,*) ' ii,nref = ',ii,nref
                write(6,*) ' rr      = ',rr,xmax,xref
                write(6,*)
                call stopcm1
              endif
              diff = rref(ii)-rr
            enddo
            if( abs(rr-rref(ii)).lt.tsmall .and. ii.eq.1 ) ii = 2
            i2 = ii
            i1 = i2-1
            frac = (      rr-rref(i1))   &
                  /(rref(i2)-rref(i1))
            do k=1,nk
              angle = datan2(dble(yf(j)-yref),dble(xh(i)-xref))
              va(i,j,k) = (vref(i1,k)+( vref(i2,k)- vref(i1,k))*frac )*cos(angle)
            enddo
          enddo
          enddo

!!!          print *
!!!          print *,'  symmtest:'
!!!          j = nj/2 + 5
!!!          k = 1
!!!          do i=1,nref
!!!            print *,i,j,ua(i,j,k),va(j,i,k),ua(i,j,k)+va(j,i,k)
!!!          enddo
!!!          print *

        ENDIF

        call bcu(ua)
        call bcv(va)
        call bcs(ppi)
        call bcs(tha)

        call calcprs(pi0,prs,ppi)

        deallocate(  rref)
        deallocate(  vref)
        deallocate( piref)
        deallocate( thref)
        deallocate(thvref)
        deallocate( qvref)

        setppi = .false.

      !-----------------------------------
      ! add random theta perts for 3d runs:
      ! (plus or minus this value in K)

      IF( nx.gt.3 .and. ny.gt.3 )THEN

        amplitude = 0.1

        do k=1,nk
          ! cm1r17: loop over entire domain
          do jj=1,ny
          do ii=1,nx
            call random_number(rand)
            i = ii - (myi-1)*ni
            j = jj - (myj-1)*nj
            ! check to see if this processor has this gridpoint:
            IF( i.ge.ib .and. i.le.ie .and. j.ge.jb .and. j.le.je )THEN
              ! only add perts in the warm core:
              if( tha(i,j,k).ge.0.1 )  &
              tha(i,j,k)=tha(i,j,k)+amplitude*(2.0*rand-1.0)
            ENDIF
          enddo
          enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------
!  iinit = 8
!  Line thermal with random small-amplitude perturbations

      ELSEIF(iinit.eq.8)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Warm bubble'
        if(dowr) write(outfile,*)

        ric     = 150000.0  ! center of bubble in x-direction (m)
        zc      =   1500.0  ! height of center of bubble above ground (m)
        bhrad   =  10000.0  ! horizontal radius of bubble (m)
        bvrad   =   1500.0  ! vertical radius of bubble (m)
        bptpert =      2.0  ! max potential temp perturbation (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .false.

        ! amplitude of random perturbations:
        amplitude = 0.20

        do k=1,nk
        do jj=1,ny
        do ii=1,nx
          call random_number(rand)
          i = ii - (myi-1)*ni
          j = jj - (myj-1)*nj
        IF( i.ge.ib .and. i.le.ie .and. j.ge.jb .and. j.le.je )THEN
          beta=sqrt(                             &
                    ((xh(i)-ric)/bhrad)**2       &
                   +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            tha(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)   &
                      +amplitude*(2.0*rand-1.0)
          else
            tha(i,j,k)=0.0
          endif
        ENDIF
        enddo
        enddo
        enddo

!------------------------------------------------------------------
!  iinit = 9
!  Forced convergence
!  Reference:  Loftus et al, 2008: MWR, v. 136, pp. 2408--2421.

      ELSEIF(iinit.eq.9)THEN

        ! User-defined settings:
        Dmax     =  -1.0e-3     ! maximum divergence (s^{-1})
        zdeep    =  2000.0      ! depth (m) of forced convergence
        lamx     = 10000.0      ! Loftus et al lambda_x parameter
        lamy     = 10000.0      ! Loftus at al lambda_y parameter
        xcent    =     0.0      ! x-location (m)
        ycent    =     0.0      ! y-location (m)
        convtime =   900.0      ! time (s) at beginning of simulation over
                                ! which convergence is applied

        ! Don't change anything below here:
        convinit = 1
        IF( ny.eq.1 )THEN
          ! 2D (x-z):
          Aconv = (-0.5*Dmax)/( (1.0/(lamx**2)) )
          lamy = 1.0e20
        ELSEIF( nx.eq.1 )THEN
          ! 2D (y-z):
          Aconv = (-0.5*Dmax)/( (1.0/(lamy**2)) )
          lamx = 1.0e20
        ELSE
          ! 3D:
          Aconv = (-0.5*Dmax)/( (1.0/(lamx**2))+(1.0/(lamy**2)) )
        ENDIF

!------------------------------------------------------------------
!  iinit = 10
!  momentum (u) forcing scheme (Morrison et al, 2015, JAS, pg 315)

      ELSEIF(iinit.eq.10)THEN

        xc_uforce     =  minx + 0.5*(maxx-minx)    ! x_c (m), center point of forcing in x
        xr_uforce     =  10000.0                   ! x_r (m), radius of forcing in x
        zr_uforce     =  10000.0                   ! z_r (m), radius of forcing in z
        alpha_uforce  =    0.1                     ! alpha (m/s/s), max intensity of forcing
        t1_uforce     =  3300.0                    ! time (s) to start ramping down u-forcing
        t2_uforce     =  3600.0                    ! time (s) to turn off u-forcing

!------------------------------------------------------------------
!  iinit = 11
!  Potential-temperature perturbation for inertia-gravity wave test case.
!  Reference:  Skamarock and Klemp, 1994, MWR, 122, 2623-2630.

      ELSEIF(iinit.eq.11)THEN

        do k=1,nk
        do j=1,nj
        do i=1,ni
          !----------
          ! Skamarock-Klemp-94 nonhydrostatic-scale inertia-gravity wave test:
          tha(i,j,k)=0.01*(sin(pi*zh(i,j,k)/10000.0))   &
                         /(1.0+((xh(i)-100000.0)/5000.0)**2)
          !----------
          ! Skamarock-Klemp-94 hydrostatic-scale inertia-gravity wave test:
!!!          tha(i,j,k)=0.01*(sin(pi*zh(i,j,k)/10000.0))   &
!!!                         /(1.0+((xh(i)-0.0)/100000.0)**2)
          !----------
        enddo
        enddo
        enddo

!------------------------------------------------------------------

      ENDIF    ! end of iinit options

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

! Random perturbations:

      IF( irandp.eq.1 )THEN

        ! this is the amplitude of the theta perturbations
        ! (plus or minus this value in K)
        amplitude = 0.25

        ! random numbers added here
        ! (can be modified to only place perturbations in certain
        !  locations, but this default code simply puts them
        !  everywhere)
        do k=1,nk
          ! cm1r17: loop over entire domain
          do jj = 0,ny+1
          do ii = 0,nx+1
            call random_number(rand)
            i = ii - (myi-1)*ni
            j = jj - (myj-1)*nj
            ! check to see if this processor has this gridpoint:
            IF( i.ge.ib .and. i.le.ie .and. j.ge.jb .and. j.le.je )THEN
              tha(i,j,k)=tha(i,j,k)+amplitude*(2.0*rand-1.0)
            ENDIF
          enddo
          enddo
        enddo

      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!----------------------------------------------
!  arrays for elliptic solver

      IF( (ibalance.eq.2).or.(psolver.eq.4).or.(psolver.eq.5) )THEN

        dpi = 4.0d0*datan(1.0d0)
        if(dowr) write(outfile,*) '  dpi = ',dpi

        IF(psolver.le.3)THEN
          do k=1,nk
            cfa(k)=mh(1,1,k)*mf(1,1,k  )*rf0(1,1,k  )*0.5*(thv0(1,1,k-1)+thv0(1,1,k))/(dz*dz*rho0(1,1,k)*thv0(1,1,k))
            cfc(k)=mh(1,1,k)*mf(1,1,k+1)*rf0(1,1,k+1)*0.5*(thv0(1,1,k)+thv0(1,1,k+1))/(dz*dz*rho0(1,1,k)*thv0(1,1,k))
            ad1(k) = 1.0/(cp*rho0(1,1,k)*thv0(1,1,k))
            ad2(k) = 1.0
          enddo
          cfa( 1) = 0.0
          cfc(nk) = 0.0
          do j=jpb,jpe
          do i=ipb,ipe
            do k=1,nk
              cfb(i,j,k)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                                +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                                -2.0d0)/(dx*dx) - cfa(k) - cfc(k)
            enddo
          enddo
          enddo
        ELSE
          do k=1,nk
            cfa(k)=mh(1,1,k)*mf(1,1,k  )*rf0(1,1,k  )/(dz*dz*rho0(1,1,k-1))
            cfc(k)=mh(1,1,k)*mf(1,1,k+1)*rf0(1,1,k+1)/(dz*dz*rho0(1,1,k+1))
            ad1(k) = 1.0
            ad2(k) = 1.0/rho0(1,1,k)
          enddo
          cfa( 1) = 0.0
          cfc(nk) = 0.0
          do j=jpb,jpe
          do i=ipb,ipe
            do k=2,nk-1
              cfb(i,j,k)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                                +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                                -2.0d0)/(dx*dx)                               &
                    -mh(1,1,k)*mf(1,1,k+1)*rf0(1,1,k+1)/(dz*dz*rho0(1,1,k))   &
                    -mh(1,1,k)*mf(1,1,k  )*rf0(1,1,k  )/(dz*dz*rho0(1,1,k))
            enddo
            cfb(i,j,1)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                              +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                              -2.0d0)/(dx*dx)                               &
                  -mh(1,1,1)*mf(1,1,2  )*rf0(1,1,2  )/(dz*dz*rho0(1,1,1))
            cfb(i,j,nk)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                              +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                              -2.0d0)/(dx*dx)                               &
                  -mh(1,1,nk)*mf(1,1,nk  )*rf0(1,1,nk  )/(dz*dz*rho0(1,1,nk))
          enddo
          enddo
        ENDIF

      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!-----------------------------------------------------------------
!  Get 3d pressure
        
      if(imoist.eq.1 .and. maintain_rh)then

        !! maintain rh
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Constant rh across domain:'
        if(dowr) write(outfile,*)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          dum2(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
          qa(i,j,k,nqv)=dum2(i,j,k)*rslf(prs0(i,j,k),(th0(i,j,k)+tha(i,j,k))*pi0(i,j,k))
        enddo
        enddo
        enddo

      endif


    IF(setppi)THEN

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        ppi(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(ibalance.eq.1)THEN

        ! hydrostatic balance ... integrate top-down

        do j=1,nj
        do i=1,ni
          ! virtual potential temperature

          if(imoist.eq.1)then
            do k=1,nk
              qt=0.0
              do n=nql1,nql2
                qt=qt+qa(i,j,k,n)
              enddo
              if(iice.eq.1)then
                do n=nqs1,nqs2
                  qt=qt+qa(i,j,k,n)
                enddo
              endif
              thvnew(k)=(th0(i,j,k)+tha(i,j,k))*(1.0+reps*qa(i,j,k,nqv))   &
                                               /(1.0+qa(i,j,k,nqv)+qt)
            enddo
          else
            do k=1,nk
              thvnew(k)=th0(i,j,k)+tha(i,j,k)
            enddo
          endif

          ! non-dimensional pressure
          pinew(nk)=pi0(i,j,nk)
          do k=nk-1,1,-1
            pinew(k)=pinew(k+1)+g*(zh(i,j,k+1)-zh(i,j,k))   &
                    /(cp*0.5*(thvnew(k+1)+thvnew(k)))
          enddo

          ! new pressure
          do k=1,nk
            ppi(i,j,k)=pinew(k)-pi0(i,j,k)
            if(abs(ppi(i,j,k)).lt.1.0e-6) ppi(i,j,k)=0.0
          enddo

        enddo
        enddo

      ELSEIF(ibalance.eq.2)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  ibalance = 2'
        if(dowr) write(outfile,*)

        if(stretch_x.ge.1.or.stretch_y.ge.1)then
          print *,'  this option not supported with horizontal grid stretching'
          print *,'  (yet)'
          call stopcm1
        endif

#ifdef MPI
        print *,'  This option is not (yet) supported in MPI mode'
        print *,'  (sorry)'
        print *
        call stopcm1
#endif

        ! buoyancy pressure

        ! th3d stores theta-v

        if(imoist.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qt=0.0
            do n=nql1,nql2
              qt=qt+qa(i,j,k,n)
            enddo
            if(iice.eq.1)then
              do n=nqs1,nqs2
                qt=qt+qa(i,j,k,n)
              enddo
            endif
            th3d(i,j,k)=(th0(i,j,k)+tha(i,j,k))*(1.0+reps*qa(i,j,k,nqv))   &
                       /(1.0+qa(i,j,k,nqv)+qt)
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=th0(i,j,k)+tha(i,j,k)
          enddo
          enddo
          enddo
        endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          th3d(i,j,0   ) = th3d(i,j,1)
          th3d(i,j,nk+1) = th3d(i,j,nk)
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum4(i,j,k)=g*( th3d(i,j,k)/thv0(i,j,k)-1.0 )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum4(i,j,0   ) = -dum4(i,j,1)
          dum4(i,j,nk+1) = -dum4(i,j,nk)
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=0.5*( dum4(i,j,k-1)+dum4(i,j,k) )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          ppi(i,j,k)=0.0
          dum3(i,j,k)=0.0
          divx(i,j,k)=0.0
          uten(i,j,k)=0.0
          vten(i,j,k)=0.0
        enddo
        enddo
        enddo

        call poiss(uh,vh,mh,rmh,mf,rmf,pi0,thv0,rho0,rf0,    &
                   dum3,divx,ppi,uten,vten,wten,             &
                   cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans,dtl)

        IF(psolver.eq.4.or.psolver.eq.5.or.psolver.eq.6)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            ppi(i,j,k)=((prs0(1,1,k)+ppi(i,j,k)*rho0(1,1,k))*rp00)**rovcp   &
                      -pi0(1,1,k)
            pp3d(i,j,k)=ppi(i,j,k)
          enddo
          enddo
          enddo

        ENDIF

        call bcs(ppi)

      ENDIF

    ENDIF

!------------------------------------------------------------------

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'Leaving INIT3D'

      end subroutine init3d


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getset(restart,mass1,ruh,rvh,xf,                          &
                        gz,sigma,sigmaf,rmh,mf,dzdx,dzdy,                  &
                        pi0,th0,rho0,prs0,ust,u1,v1,s1,                    &
                        zh,c1,c2,zf,rr,rf,rho,prs,dum1,dum2,               &
                        ua,u3d,va,v3d,wa,w3d,ppi,pp3d,                     &
                        tha,th3d,qa,q3d,tkea,tke3d,pta,pt3d,               &
                        reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk,        &
                        nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                   &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                   &
                        uw31,uw32,ue31,ue32,us31,us32,un31,un32,           &
                        vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,           &
                        ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,           &
                        sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,           &
                        tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2)
#ifdef MPI
      use mpi
#endif
      implicit none
 
      include 'input.incl'
      include 'constants.incl'

      logical, intent(in) :: restart
      double precision, intent(inout) :: mass1
      real, intent(in), dimension(ib:ie) :: ruh
      real, intent(in), dimension(jb:je) :: rvh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz
      real, intent(in), dimension(kb:ke) :: sigma
      real, intent(in), dimension(kb:ke+1) :: sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,th0,rho0,prs0
      real, intent(inout), dimension(ib:ie,jb:je) :: ust,u1,v1,s1
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,c1,c2
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: rr,rf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,prs,dum1,dum2
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua,u3d
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va,v3d
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d
      real, dimension(ib:ie,jb:je,kb:ke) :: tha,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,q3d
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta,pt3d
      integer, dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      real, dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, dimension(cmp,jmp,kmt)   :: tkw1,tkw2,tke1,tke2
      real, dimension(imp,cmp,kmt)   :: tks1,tks2,tkn1,tkn2

!----------
 
      integer :: i,j,k,n
      double precision :: p0

!------------------------------------------------------------------
!  Make sure boundary values are set properly

      if(dowr) write(outfile,*) 'Inside GETSET'
      if(dowr) write(outfile,*)

      call bcu(ua)
      call bcv(va)
      call bcw(wa,1)
      call bcs(ppi)
      call bcs(tha)
      if(imoist.eq.1)then
        do n=1,numq
          call bcs(qa(ibm,jbm,kbm,n))
        enddo
      endif
      if(iturb.eq.1)then
        call bcw(tkea,1)
      endif
      if(iptra.eq.1)then
        do n=1,npt
          call bcs(pta(ib,jb,kb,n))
        enddo
      endif

#ifdef MPI
!------------------------------------------------------------------

      nf=0
      nu=0
      nv=0
      nw=0

      call comm_3u_start(ua,uw31,uw32,ue31,ue32,   &
                            us31,us32,un31,un32,reqs_u)
      call comm_3u_end(ua,uw31,uw32,ue31,ue32,   &
                          us31,us32,un31,un32,reqs_u)

      call comm_3v_start(va,vw31,vw32,ve31,ve32,   &
                            vs31,vs32,vn31,vn32,reqs_v)
      call comm_3v_end(va,vw31,vw32,ve31,ve32,   &
                          vs31,vs32,vn31,vn32,reqs_v)

      call comm_3w_start(wa,ww31,ww32,we31,we32,   &
                            ws31,ws32,wn31,wn32,reqs_w)
      call comm_3w_end(wa,ww31,ww32,we31,we32,   &
                          ws31,ws32,wn31,wn32,reqs_w)

      call comm_3s_start(ppi,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(ppi,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)

      call comm_3s_start(tha,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(tha,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)

      IF(imoist.eq.1)THEN
        do n=1,numq
          call comm_3s_start(qa(ibm,jbm,kbm,n),sw31,sw32,se31,se32,   &
                                               ss31,ss32,sn31,sn32,reqs_s)
          call comm_3s_end(qa(ibm,jbm,kbm,n),sw31,sw32,se31,se32,   &
                                             ss31,ss32,sn31,sn32,reqs_s)
        enddo
      ENDIF

      IF(iturb.eq.1)THEN
        call comm_3t_start(tkea,tkw1,tkw2,tke1,tke2,   &
                                tks1,tks2,tkn1,tkn2,reqs_tk)
        call comm_3t_end(tkea,tkw1,tkw2,tke1,tke2,   &
                              tks1,tks2,tkn1,tkn2,reqs_tk)
      ENDIF

      IF(iptra.eq.1)THEN
        do n=1,npt
          call comm_3s_start(pta(ib,jb,kb,n),sw31,sw32,se31,se32,   &
                                             ss31,ss32,sn31,sn32,reqs_s)
          call comm_3s_end(pta(ib,jb,kb,n),sw31,sw32,se31,se32,   &
                                           ss31,ss32,sn31,sn32,reqs_s)
        enddo
      ENDIF

      call MPI_BARRIER (MPI_COMM_WORLD,ierr)

#endif
      if(terrain_flag)then
        call bcwsfc(gz,dzdx,dzdy,ua,va,wa)
        call bc2d(wa(ib,jb,1))
      endif
!------------------------------------------------------------------
!  Get stuff

  IF( .not. restart )THEN

    IF(psolver.eq.4.or.psolver.eq.5.or.psolver.eq.6)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        rho(i,j,k)=rho0(i,j,k)
        prs(i,j,k)=prs0(i,j,k)
      enddo
      enddo
      enddo

    ELSE

      call calcprs(pi0,prs,ppi)
 
      call calcrho(pi0,th0,rho,prs,ppi,tha,qa)

    ENDIF

  ENDIF


        call bcs(rho)
#ifdef MPI
        call comm_1s_start(rho,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        call comm_1s_end(rho,pw1,pw2,pe1,pe2,   &
                             ps1,ps2,pn1,pn2,reqs_p)
        call bcs2(rho)
        call getcorner(rho,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=0,nj+1
          k = 1
          do i=0,ni+1
            rr(i,j,k) = 1.0/rho(i,j,k)
            ! cm1r17, 2nd-order extrapolation:
            rf(i,j,1) = cgs1*rho(i,j,1)+cgs2*rho(i,j,2)+cgs3*rho(i,j,3)
          enddo
          do k=2,nk
          do i=0,ni+1
            rr(i,j,k) = 1.0/rho(i,j,k)
            rf(i,j,k) = (c1(i,j,k)*rho(i,j,k-1)+c2(i,j,k)*rho(i,j,k))
          enddo
          enddo
          do i=0,ni+1
            ! cm1r17, 2nd-order extrapolation:
            rf(i,j,nk+1) = cgt1*rho(i,j,nk)+cgt2*rho(i,j,nk-1)+cgt3*rho(i,j,nk-2)
          enddo
        enddo

!------------------------------------------------------------------
!  cm1r18:  get total mass of dry air at t=0

      IF( .not. restart )THEN

        mass1 = 0.0

        IF( axisymm.eq.0 )THEN
          do k=1,nk
          do j=1,nj
          do i=1,ni
            mass1 = mass1 + rho(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
          enddo
          enddo
          enddo
        ELSEIF( axisymm.eq.1 )THEN
          do k=1,nk
          do j=1,nj
          do i=1,ni
            mass1 = mass1 + rho(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)
          enddo
          enddo
          enddo
        ELSE
          stop 2223
        ENDIF

#ifdef MPI
        p0=0.0d0
        call MPI_ALLREDUCE(mass1,p0,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        mass1 = p0*(dx*dy*dz)
#else
        mass1 = mass1*(dx*dy*dz)
#endif

        if( myid.eq.0 ) print *,'  mass1 = ',mass1

      ENDIF

!------------------------------------------------------------------

      do k=kb,ke
      do j=jb,je
      do i=ib,ie+1
        u3d(i,j,k)=ua(i,j,k)
      enddo
      enddo
      enddo
 
      do k=kb,ke
      do j=jb,je+1
      do i=ib,ie
        v3d(i,j,k)=va(i,j,k)
      enddo
      enddo
      enddo
 
      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        w3d(i,j,k)=wa(i,j,k)
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        pp3d(i,j,k)=ppi(i,j,k)
        th3d(i,j,k)=tha(i,j,k)
      enddo
      enddo
      enddo

      if(imoist.eq.1)then
        do n=1,numq
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          q3d(i,j,k,n)=qa(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      endif

      if(iturb.eq.1)then
        do k=kbt,ket
        do j=jbt,jet
        do i=ibt,iet
          tke3d(i,j,k)=tkea(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(iptra.eq.1)then
        do n=1,npt
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          pt3d(i,j,k,n)=pta(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'Leaving GETSET'
 
      end subroutine getset


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
      implicit none

      integer, intent(in) :: myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe
      real, intent(in) :: zdeep,lamx,lamy,xcent,ycent,aconv
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u3d

      integer :: i,j,k
      real :: term1,term2,term3,term4,umo

!!!      if(myid.eq.0) print *,'    convinitu '
!$omp parallel do default(shared)   &
!$omp private(i,j,k,term1,term2,term3,term4,umo)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        term4 = (zdeep-0.5*(zh(i-1,j,k)+zh(i,j,k)))/zdeep
        if (term4 .gt. 0.0) then
          term1 = -(2.0*Aconv*(xf(i)-xcent))/(lamx**2)
          term2 = -((xf(i)-xcent)/lamx)**2
          term3 = -((yh(j)-ycent)/lamy)**2
          umo = term1*(exp(term2)*exp(term3))*term4
          if( abs(umo).gt.0.01 ) u3d(i,j,k) = u0(i,j,k)+umo
        endif
      enddo
      enddo
      enddo

      return
      end subroutine convinitu


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
      implicit none

      integer, intent(in) :: myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn
      real, intent(in) :: zdeep,lamx,lamy,xcent,ycent,aconv
      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(jb:je+1) :: yf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v3d

      integer :: i,j,k
      real :: term1,term2,term3,term4,vmo

!!!      if(myid.eq.0) print *,'    convinitv '
!$omp parallel do default(shared)   &
!$omp private(i,j,k,term1,term2,term3,term4,vmo)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        term4 = (zdeep-0.5*(zh(i,j-1,k)+zh(i,j,k)))/zdeep
        if (term4 .gt. 0.0) then
          term1 = -(2.0*Aconv*(yf(j)-ycent))/(lamy**2)
          term2 = -((xh(i)-xcent)/lamx)**2
          term3 = -((yf(j)-ycent)/lamy)**2
          vmo = term1*(exp(term2)*exp(term3))*term4
          if( abs(vmo).gt.0.01 ) v3d(i,j,k) = v0(i,j,k)+vmo
        endif
      enddo
      enddo
      enddo

      return
      end subroutine convinitv


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

init_physics.F  1587424407  1602  20    100644  10520     `

      subroutine init_physics(prs0,rf0,dum1,dum2,dum3,u0,ua,v0,va,o30,   &
                             lu_index,xland,emiss,thc,albd,znt,mavail,f2d,tsk,u1,v1,s1, &
                             zh,u10,v10,wspd)
      use module_sf_slab
      use module_sf_sfclay
      use module_sf_sfclayrev
      implicit none

      include 'input.incl'
      include 'radcst.incl'

      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: prs0,rf0
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
      real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: o30
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: emiss,thc,albd,mavail,f2d
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,znt,u1,v1,s1,xland
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: u10,v10,wspd

      real :: foo1,foo2,foo3,foo4,foo5,foo6

!-----------------------------------------------------------------------
!-----  USERS SHOULD NOT NEED TO CHANGE ANYTHING IN THIS FILE ----------
!-----  (unless you really, really know what you are doing -------------
!-----------------------------------------------------------------------

      if(radopt.eq.1)then
        ! initialize radiation code:
        call setradwrk(nir,njr,nkr)
        call julday( year, month, day, jday )
        if(dowr) write(outfile,*) '  jday = ',jday
        call initrad(myid,year,month,day,hour,minute,second,jday,nir,njr,nkr)
        o30 = 1.0e-6
        call fito3(nir,njr,1,1,nkr,dum1(1,1,1),dum2(1,1,1),prs0,o30,ib,ie,jb,je,kb,ke,nk)
        ! Settings from Goddard scheme:
        call getgoddardvars(foo1,foo2,foo3,foo4,foo5,foo6,ptype)
        roqr = foo1
        tnw  = foo2
        roqs = foo3
        tns  = foo4
        roqg = foo5
        tng  = foo6
      endif

      IF( isfcflx.eq.1 )THEN
        if( sfcmodel.eq.2 )then
          call sfclayinit
        endif
        if( sfcmodel.eq.3 )then
          call sfclayrevinit
        endif
      ENDIF

      f2d = fcor

!-----------------------------------------------------------------------

      end subroutine init_physics


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getgoddardvars(foo1,foo2,foo3,foo4,foo5,foo6,ptype)
      implicit none
      include 'goddard.incl'

      real, intent(inout) :: foo1,foo2,foo3,foo4,foo5,foo6
      integer, intent(in) :: ptype

    IF(ptype.eq.2)THEN
      foo1 = roqr
      foo2 = tnw
      foo3 = roqs
      foo4 = tnss
      foo5 = roqg
      foo6 = tng
    ELSE
      ! 130903: set to reasonable values to prevent divide-by-zeros
      ! if goodard microphysics scheme is not being used
      foo1 = 1.
      foo2 = .08
      foo3 = .1
      foo4 = 1.
      foo5 = .4
      foo6 = .04
    ENDIF

      end subroutine getgoddardvars


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine initrad(myid,year,month,day,hour,minute,second,jday,   &
                         nir,njr,nkr)
      implicit none

      include 'irrad.incl'
      include 'radzen.incl'
      include 'radmore.incl'

      integer, intent(in) :: myid,year,month,day,hour,minute,second,jday,   &
                             nir,njr,nkr

      integer :: ip,iw,it
      logical :: high

!----------------------------------------------------------------------

  IF ( rlwopt == 0 ) THEN
    high = .false.
  ELSE
    high = .true.
  END IF

  if(myid.eq.0) print *,'  high = ',high

!----------------------------------------------------------------------
!  from zenangl:

    pi2 = 2.0 * pi
    deg2rad = pi/180.0
    rad2deg = 1./deg2rad

    hour0 = FLOAT(hour)                                                 &
          + FLOAT(minute)/60.0                                          &
          + FLOAT(second)/3600.0

    IF ( MOD(year, 4) == 0 ) THEN
      yrday = 366.
    ELSE
      yrday = 365.
    END IF

!!! not using arps MPI code:  GHB, 100720
!!! hard-wire these in, just in case:
    nxmid = 1
    nymid = 1
    source = 0

!----------------------------------------------------------------------
!  from irrad:

!-----tables co2 and h2o are only used with 'high' option

    IF (high) THEN

      DO iw=1,nh
        DO ip=1,nx
          h11(ip,iw,1)=1.0-h11(ip,iw,1)
          h21(ip,iw,1)=1.0-h21(ip,iw,1)
          h71(ip,iw,1)=1.0-h71(ip,iw,1)
        END DO
      END DO

      DO iw=1,nc
        DO ip=1,nx
          c1(ip,iw,1)=1.0-c1(ip,iw,1)
        END DO
      END DO

!-----tables are replicated to avoid memory bank conflicts

      DO it=2,nt
        DO iw=1,nc
          DO ip=1,nx
            c1 (ip,iw,it)= c1(ip,iw,1)
            c2 (ip,iw,it)= c2(ip,iw,1)
            c3 (ip,iw,it)= c3(ip,iw,1)
          END DO
        END DO
        DO iw=1,nh
          DO ip=1,nx
            h11(ip,iw,it)=h11(ip,iw,1)
            h12(ip,iw,it)=h12(ip,iw,1)
            h13(ip,iw,it)=h13(ip,iw,1)
            h21(ip,iw,it)=h21(ip,iw,1)
            h22(ip,iw,it)=h22(ip,iw,1)
            h23(ip,iw,it)=h23(ip,iw,1)
            h71(ip,iw,it)=h71(ip,iw,1)
            h72(ip,iw,it)=h72(ip,iw,1)
            h73(ip,iw,it)=h73(ip,iw,1)
          END DO
        END DO
      END DO

    END IF

!-----always use table look-up for ozone transmittance

    DO iw=1,no
      DO ip=1,nx
        o1(ip,iw,1)=1.0-o1(ip,iw,1)
      END DO
    END DO

    DO it=2,nt
      DO iw=1,no
        DO ip=1,nx
          o1 (ip,iw,it)= o1(ip,iw,1)
          o2 (ip,iw,it)= o2(ip,iw,1)
          o3 (ip,iw,it)= o3(ip,iw,1)
        END DO
      END DO
    END DO

      return
      end subroutine initrad


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getlanduse(season,myid,ib,ie,jb,je,ibl,iel,jbl,jel,   &
                            lu_index,xland,emiss,thc,albedo,znt,mavail)
#ifdef MPI
      use mpi
#endif
      implicit none

      integer, intent(in) :: season,myid,ib,ie,jb,je,ibl,iel,jbl,jel
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: emiss,thc,albedo,mavail
      real, intent(inout), dimension(ib:ie,jb:je) :: znt,xland

      integer, parameter :: max_cats = 33    ! max categories
      integer, parameter :: max_seas =  2    ! max seasons

      integer, parameter :: iswater = 16  ! water must be category 16

      real, dimension(:,:), allocatable :: albd,slmo,sfem,sfz0,therin,scfx,sfhc
      integer :: cat,sea

      integer :: i,j,is,isn,ierr

      allocate(   albd(max_cats,max_seas) )
      allocate(   slmo(max_cats,max_seas) )
      allocate(   sfem(max_cats,max_seas) )
      allocate(   sfz0(max_cats,max_seas) )
      allocate( therin(max_cats,max_seas) )
      allocate(   scfx(max_cats,max_seas) )
      allocate(   sfhc(max_cats,max_seas) )

!-----------------------------------------------------------------------

      IF( myid.eq.0 )THEN
        open(unit=11,file='LANDUSE.TBL',status='old',err=888)
        read(11,*)
        read(11,*)
        do isn=1,max_seas
          read(11,*)
          do is=1,max_cats
            read(11,*) i,albd(is,isn),slmo(is,isn),sfem(is,isn),sfz0(is,isn), &
                       therin(is,isn),scfx(is,isn),sfhc(is,isn)
          enddo
        enddo
!        print *
!        print *,'  summer:'
!        print *,'  albd = ',albd(:,1)
!        print *,'  slmo = ',slmo(:,1)
!        print *,'  sfem = ',sfem(:,1)
!        print *,'  sfz0 = ',sfz0(:,1)
!        print *,'  ther = ',therin(:,1)
!        print *,'  scfx = ',scfx(:,1)
!        print *,'  sfhc = ',sfhc(:,1)
!        print *
!        print *,'  winter:'
!        print *,'  albd = ',albd(:,2)
!        print *,'  slmo = ',slmo(:,2)
!        print *,'  sfem = ',sfem(:,2)
!        print *,'  sfz0 = ',sfz0(:,2)
!        print *,'  ther = ',therin(:,2)
!        print *,'  scfx = ',scfx(:,2)
!        print *,'  sfhc = ',sfhc(:,2)
      ENDIF

#ifdef MPI
      call MPI_BCAST(albd  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(slmo  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfem  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfz0  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(therin,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(scfx  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfhc  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
#endif

!-----------------------------------------------------------------------

      ! ISN = season:    summer = 1    winter = 2
      ISN = season

      do j=jb,je
      do i=ib,ie
        IS = lu_index(i,j)
        ! SET NO-DATA POINTS (IS=0) TO WATER
        IF(IS.EQ.0)THEN
          IS=ISWATER
        ENDIF
        if( albd(is,isn).le.0.0 )then
          print *,'  category not found '
          call stopcm1
        endif
        ALBEDO(I,J) = ALBD(IS,ISN)/100.
        THC(i,j) = THERIN(IS,ISN)/100.
        EMISS(I,J) = SFEM(IS,ISN)
        ZNT(I,J) = SFZ0(IS,ISN)/100.
        MAVAIL(I,J) = SLMO(IS,ISN)
        IF(IS.NE.ISWATER)THEN
          XLAND(I,J)=1.0
        ELSE
          XLAND(I,J)=2.0
        ENDIF
      enddo
      enddo

!-----------------------------------------------------------------------

      deallocate(   albd )
      deallocate(   slmo )
      deallocate(   sfem )
      deallocate(   sfz0 )
      deallocate( therin )
      deallocate(   scfx )
      deallocate(   sfhc )


      return

!-----------------------------------------------------------------------

888   print *
      print *,'  There was an error opening the LANDUSE.TBL file '
      print *
      print *,'  Please make sure that LANDUSE.TBL is in the same directory '
      print *,'  as cm1.exe ... it is distributed with CM1 in the "run" directory '
      print *
      call stopcm1
      end subroutine getlanduse

init_surface.F  1587424407  1602  20    100644  7952      `

      subroutine init_surface(num_soil_layers,dosfcflx,xh,ruh,xf,yh,rvh,yf,   &
           lu_index,xland,tsk,slab_zs,slab_dzs,tslb, &
           emiss,thc,albd,znt,mavail,dsxy,prs0s,prs0,   &
           tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml)
      use module_sf_oml
      implicit none

      include 'input.incl'
      include 'constants.incl'

      integer, intent(in) :: num_soil_layers
      logical, intent(inout) :: dosfcflx
      real, intent(in), dimension(ib:ie) :: xh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh,rvh
      real, intent(in), dimension(jb:je+1) :: yf
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: lu_index
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,znt,xland
      real, intent(inout), dimension(num_soil_layers) :: slab_zs,slab_dzs
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: emiss,thc,albd,mavail,dsxy
      real, intent(in), dimension(ib:ie,jb:je) :: prs0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: prs0
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml

      integer :: i,j,k,l
      real :: x1,x2

!-----------------------------------------------------------------------
!  BEGIN user settings

    IF( (sfcmodel.ge.1) .or. (bbc.eq.3) )THEN

      ! Initialize the surface:

      ! Key:
      ! tsk      = "skin temperature" (K) of soil/water  (~1 cm deep)
      ! tmn      = deep-layer temperature (K) of soil  (sfcmodel=2,3 only)
      ! xland    = land/water flag:   1 for land,   2 for water
      ! lu_index = land use index   (1-33) (see LANDUSE.TBL file)

!----------
!  Deafult ... fill in arrays with values from Namelist:

      do j=jb,je
      do i=ib,ie
        tsk(i,j)      = tsk0
      enddo
      enddo

      do j=jbl,jel
      do i=ibl,iel
        tmn(i,j)      = tmn0
        xland(i,j)    = xland0
        lu_index(i,j) = lu0
      enddo
      enddo

!----------
!  Initialize the sea breeze test case from WRF:

      IF( initsfc.eq.2 )THEN 

        ! sea breeze test case from WRF:
        ! (modified on 150830 to match WRF3.7 setup)

        x1 = minx + (3.0/8.0)*(maxx-minx)
        x2 = minx + (5.0/8.0)*(maxx-minx)

        do j=jb,je
        do i=ib,ie
          if( xh(i).ge.x1 .and. xh(i).le.x2 )then
            ! land:
            xland(i,j) = 1.0
            lu_index(i,j) = 18
            tsk(i,j) = 280.0
          else
            ! water:
            xland(i,j) = 2.0
            lu_index(i,j) = 16
            tsk(i,j) = 287.0
          endif
          tmn(i,j) = tsk(i,j)-0.5
        enddo
        enddo

!----------
!  if initsfc is not 1,2:

      ELSEIF( initsfc.ne.1 .and. initsfc.ne.2 )THEN

        ! build your own initial conditions here:

!!!        do j=jb,je
!!!        do i=ib,ie
!!!          tsk(i,j)      = ?
!!!          tmn(i,j)      = ?
!!!          xland(i,j)    = ?
!!!          lu_index(i,j) = ?
!!!        enddo
!!!        enddo

!----------

      ENDIF     ! endif for initsfc options

!     END of user settings
!-----------------------------------------------------------------------
!     NO NOT CHANGE ANYTHING BELOW HERE

    IF( sfcmodel.eq.2 .or. sfcmodel.eq.3 .or. sfcmodel.eq.4 )THEN

      IF (num_soil_layers.NE.1)THEN
      slab_dzs(1)=.01
      slab_zs(1)=.5*slab_dzs(1)
      DO l=2,num_soil_layers
         slab_dzs(l)=2*slab_dzs(l-1)
         slab_zs(l)=slab_zs(l-1)+.5*slab_dzs(l-1)+.5*slab_dzs(l)
      ENDDO
      DO l=1,num_soil_layers
         DO j=jb,je
            DO i=ib,ie
              tslb(i,j,l)=( tsk(i,j)*(slab_zs(num_soil_layers)-slab_zs(l))   &
                          + tmn(i,j)*(slab_zs(l)-slab_zs(1)) ) / &
                          ( slab_zs(num_soil_layers)-slab_zs(1) )
            ENDDO
         ENDDO
      ENDDO
      ENDIF

    ENDIF

    IF( sfcmodel.ge.1 )THEN

      IF( axisymm.eq.1 .or. ny.eq.1 )THEN

        do j=jb,je
        do i=ib,ie
          dsxy(i,j) = dx*ruh(i)
        enddo
        enddo

      ELSEIF( nx.eq.1 )THEN

        do j=jb,je
        do i=ib,ie
          dsxy(i,j) = dy*rvh(j)
        enddo
        enddo

      ELSE

        do j=jb,je
        do i=ib,ie
          dsxy(i,j) = sqrt( (dx*ruh(i))**2 + (dy*rvh(j))**2 )
        enddo
        enddo

      ENDIF

    ENDIF

  ENDIF    ! endif for sfcmodel >= 1

!-----------------------------------------------------------------------
! ensure interoperability of surface schemes and turbulence schemes:
!   NOTE:  DO NOT modify anything here unless you really, really
!          know what you are doing

      ! parameters needed in turb subroutines:
      dosfcflx = .false.

      IF(iturb.ge.1)THEN
        if( isfcflx.eq.1 ) dosfcflx = .true.
        if( sfcmodel.eq.2 .or. sfcmodel.eq.3 .or. sfcmodel.eq.4 )then
          dosfcflx = .true.
        endif
      ENDIF
      IF( ipbl.ge.1 )THEN
        ! sfc flux/drag is handled by pbl subroutine:
        dosfcflx = .false.
      ENDIF

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Settings used in this simulation:'
      if(dowr) write(outfile,*) '  isfcflx  = ',isfcflx
      if(dowr) write(outfile,*) '  bbc      = ',bbc
      if(dowr) write(outfile,*) '  dosfcflx = ',dosfcflx
      if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!  Initialize land-surface parameters:

      if( sfcmodel.ge.1 .or. bbc.eq.3 )then
        ! initialize MM5/WRF landuse categories:
        call getlanduse(season,myid,ib,ie,jb,je,ibl,iel,jbl,jel,   &
                        lu_index,xland,emiss,thc,albd,znt,mavail)
      endif

!-----------------------------------------------------------------------
!  reality checks:

      IF( sfcmodel.ge.1 .or. bbc.eq.3 )THEN

        do j=jb,je
        do i=ib,ie
          IF( nint(xland(i,j)).le.0 .or. nint(xland(i,j)).ge.3 )THEN
            print *
            print *,'  Invalid value for xland '
            print *
            print *,'    xland must be 1 (for land) or 2 (for water) '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          if( sfcmodel.eq.2 .or. sfcmodel.eq.3 )then
          IF( lu_index(i,j).le.0 .or. lu_index(i,j).ge.34 )THEN
            print *
            print *,'  Invalid value for lu_index '
            print *
            print *,'    lu_index must be between 1 and 33 '
            print *,'    (see LANDUSE.TBL for more info) '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          endif
          IF( tsk(i,j).lt.100.0 )THEN
            print *
            print *,'  WARNING:  tsk is less than 100 K '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          if( sfcmodel.eq.2 .or. sfcmodel.eq.3 )then
          IF( tmn(i,j).lt.100.0 )THEN
            print *
            print *,'  WARNING:  tmn is less than 100 K '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          endif
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------
!  Initialize the ocean mixed layer model:

      if(oceanmodel.eq.2)then
        call omlinit(outfile,oml_hml0, tsk,                     &
                       tml,t0ml,hml,h0ml,huml,hvml,tmoml,       &
                       .false.,         .true. ,                &
                         1, ni+1,   1, nj+1,   1, nk+1,         &
                        ib, ie,  jb, je,  kb, ke,               &
                         1, ni,   1, nj,   1, nk                )
      endif

!-----------------------------------------------------------------------

      end subroutine init_surface

init_terrain.F  1587424407  1602  20    100644  8952      `

      subroutine init_terrain(xh,uh,xf,uf,yh,vh,yf,vf,rds,sigma,rdsf,sigmaf,  &
                              zh,zf,zs,gz,rgz,gzu,rgzu,gzv,rgzv,         &
                              dzdx,dzdy,gx,gxu,gy,gyv,                   &
                              reqs_u,reqs_v,reqs_s,reqs_p,               &
                              nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,           &
                              sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,   &
                              uw31,uw32,ue31,ue32,us31,us32,un31,un32,   &
                              vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,   &
                              west,newwest,east,neweast,                 &
                              south,newsouth,north,newnorth)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, intent(in), dimension(ib:ie) :: xh,uh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: yh,vh
      real, intent(in), dimension(jb:je+1) :: yf,vf
      real, intent(inout), dimension(kb:ke) :: rds,sigma
      real, intent(inout), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(inout), dimension(ib:ie,jb:je) :: zs
      real, intent(inout), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, intent(inout), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_s,reqs_p
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp) :: west,newwest,east,neweast
      real, intent(inout), dimension(imp,cmp) :: south,newsouth,north,newnorth

      integer :: i,j,k,irec
      real :: hh,aa,xval,xc,yc
      real :: tem1,tem2,rr,angle

#ifdef MPI
      character*50 fname
      integer nabor
#endif

!-----------------------------------------------------------------------
!     SPECIFY TERRAIN HERE
!-----------------------------------------------------------------------

!----------------------------------------------------------
!  itern = 1
!  bell-shaped

        IF(itern.eq.1)THEN

          hh =      400.0              ! max. height (m)
          aa =     1000.0              ! half width (m)
          xc =        0.0 + 0.5*dx     ! x-location (m)

          do j=jb,je
          do i=ib,ie
            zs(i,j)=hh/( 1.0+( (xh(i)-xc)/aa )**2 )
          enddo
          enddo

!---------------
!  itern = 2
!  Schaer case

        ELSEIF(itern.eq.2)THEN

          do j=jb,je
          do i=ib,ie
            xval=dx*(i-ni/2)
            zs(i,j)=250.0*exp(-(xval/5000.0)**2)*(cos(pi*xval/4000.0)**2)
          enddo
          enddo

!---------------

        ELSEIF(itern.eq.3)THEN

          hh =      500.0     ! max. height (m)
          aa =    20000.0     ! half width (m)

          do j=jb,je
          do i=ib,ie
            xval = sqrt( (xh(i)-129000.0)**2   &
                        +(yh(j)-129000.0)**2   &
                                             )
            zs(i,j)=hh*( (1.0+(xval/aa)**2 )**(-1.5) )
          enddo
          enddo

!----------------------------------------------------------
!  itern = 4
!  read from GrADS file "perts.dat"

        ELSEIF(itern.eq.4)THEN

          open(unit=73,file='perts.dat',status='old',   &
               form='unformatted',access='direct',recl=4)

          do j=1,nj
          do i=1,ni
            irec=(myj-1)*nx*nj   &
                +(j-1)*nx        &
                +(myi-1)*ni      &
                +i
            read(73,rec=irec) zs(i,j)
          enddo
          enddo

          close(unit=73)

!----------------------------------------------------------

        ENDIF

!--------------------------------------------------------------
!  DO NOT CHANGE ANYTHING BELOW HERE !
!--------------------------------------------------------------

        call bc2d(zs)
#ifdef MPI
        nf=0
        nu=0
        nv=0
        nw=0
        call comm_2d_start(zs,west,newwest,east,neweast,   &
                              south,newsouth,north,newnorth,reqs_p)
        call comm_2dew_end(zs,west,newwest,east,neweast,reqs_p)
        call comm_2dns_end(zs,south,newsouth,north,newnorth,reqs_p)
        call bcs2_2d(zs)
        call bc2d(zs)
        call getcorner3_2d(zs)
#endif

        zt = maxz
        rzt = 1.0/maxz

        if(dowr) write(outfile,*)
        do k=1,nk+1
          if(dowr) write(outfile,*) '  sigmaf:',k,sigmaf(k)
        enddo
        if(dowr) write(outfile,*)

        do k=1,nk
        do j=jb,je
        do i=ib,ie
          zh(i,j,k)=zs(i,j)+sigma(k)*(zt-zs(i,j))/zt
        enddo
        enddo
        enddo

        do k=kb,ke+1
        do j=jb,je
        do i=ib,ie
          zf(i,j,k)=zs(i,j)+sigmaf(k)*(zt-zs(i,j))/zt
        enddo
        enddo
        enddo

        do j=1,nj
        do i=1,ni
          dzdx(i,j)=( 45.0*( zs(i+1,j)-zs(i-1,j) )                &
                      -9.0*( zs(i+2,j)-zs(i-2,j) )                &
                          +( zs(i+3,j)-zs(i-3,j) ) )*uh(i)/(60.0*dx)
          dzdy(i,j)=( 45.0*( zs(i,j+1)-zs(i,j-1) )                &
                      -9.0*( zs(i,j+2)-zs(i,j-2) )                &
                          +( zs(i,j+3)-zs(i,j-3) ) )*vh(j)/(60.0*dy)
        enddo
        enddo

!--------------------------------
!  set boundary points

        call bc2d(dzdx)
        call bc2d(dzdy)

#ifdef MPI
        call comm_2d_start(dzdx,west,newwest,east,neweast,   &
                                south,newsouth,north,newnorth,reqs_p)
        call comm_2dew_end(dzdx,west,newwest,east,neweast,reqs_p)
        call comm_2dns_end(dzdx,south,newsouth,north,newnorth,reqs_p)
        call bcs2_2d(dzdx)
        call bc2d(dzdx)
        call getcorner3_2d(dzdx)

        call comm_2d_start(dzdy,west,newwest,east,neweast,   &
                                south,newsouth,north,newnorth,reqs_p)
        call comm_2dew_end(dzdy,west,newwest,east,neweast,reqs_p)
        call comm_2dns_end(dzdy,south,newsouth,north,newnorth,reqs_p)
        call bcs2_2d(dzdy)
        call bc2d(dzdy)
        call getcorner3_2d(dzdy)
#endif

!--------------------------------
!  the metric terms:

        do j=jb,je
        do i=ib,ie
           gz(i,j)=zt/(zt-zs(i,j))
          rgz(i,j)=(zt-zs(i,j))/zt
        enddo
        enddo

        call bc2d(rgz)
#ifdef MPI
        call comm_2d_start(rgz,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs_p)
        call comm_2dew_end(rgz,west,newwest,east,neweast,reqs_p)
        call comm_2dns_end(rgz,south,newsouth,north,newnorth,reqs_p)
        call bcs2_2d(rgz)
        call bc2d(rgz)
        call getcorner3_2d(rgz)
#endif

        do j=jb+1,je
        do i=ib+1,ie
           gzu(i,j)=zt/(zt-0.5*(zs(i-1,j)+zs(i,j)))
          rgzu(i,j)=(zt-0.5*(zs(i-1,j)+zs(i,j)))/zt
           gzv(i,j)=zt/(zt-0.5*(zs(i,j-1)+zs(i,j)))
          rgzv(i,j)=(zt-0.5*(zs(i,j-1)+zs(i,j)))/zt
        enddo
        enddo

        do k=1,nk+1
        do j=jb+1,je-1
        do i=ib+1,ie-1
          gx(i,j,k)=(zt-sigmaf(k))*gz(i,j)*(rgzu(i+1,j)-rgzu(i,j))*rdx*uh(i)
          gxu(i,j,k)=(zt-sigmaf(k))*gzu(i,j)*(rgz(i,j)-rgz(i-1,j))*rdx*uf(i)
          gy(i,j,k)=(zt-sigmaf(k))*gz(i,j)*(rgzv(i,j+1)-rgzv(i,j))*rdy*vh(j)
          gyv(i,j,k)=(zt-sigmaf(k))*gzv(i,j)*(rgz(i,j)-rgz(i,j-1))*rdy*vf(j)
        enddo
        enddo
        enddo

!--------------------------------

        do j=jb,je
        do i=ib,ie
          zf(i,j,0)=zf(i,j,1)-(zf(i,j,2)-zf(i,j,1))
          zf(i,j,nk+2)=zf(i,j,nk+1)+(zf(i,j,nk+1)-zf(i,j,nk))
          zh(i,j,0)=0.5*(zf(i,j,0)+zf(i,j,1))
          zh(i,j,nk+1)=0.5*(zf(i,j,nk+1)+zf(i,j,nk+2))
        enddo
        enddo

        if(dowr) write(outfile,*)
        do i=ib,ie
          if(dowr) write(outfile,*) '  zs at nj/2:',i,zs(i,nj/2)
        enddo
        if(dowr) write(outfile,*)

        if(dowr) write(outfile,*)
        do j=jb,je
          if(dowr) write(outfile,*) '  zs at ni/2:',j,zs(ni/2,j)
        enddo
        if(dowr) write(outfile,*)

!---------------------------------------

      do k=2,nk
        rds(k) = 1.0/(sigma(k)-sigma(k-1))
      enddo

      do k=1,nk
        rdsf(k) = 1.0/(sigmaf(k+1)-sigmaf(k))
      enddo

!-----------------------------------------------------------------------

      end subroutine init_terrain

kessler.F       1587424407  1602  20    100644  15604     `


      subroutine kessler(dt,tauto,taccr,tevar,ruh,rvh,rmh,pi0,th0,tmp,   &
                         rho,rr,pp3d,th3d,prs,                        &
                         qv3d,qc3d,qr3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      double precision :: tauto,taccr,tevar
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: tmp,rho,rr,pp3d,    &
                                            th3d,prs,qv3d,qc3d,qr3d

      integer :: i,j,k
      real :: qvnew,qcnew,qrnew
      real :: ar,cr,esl,qvs,er,term1,cpml,cvml,rm,tem
      double precision :: dum
      double precision, dimension(nk) :: bud1,bud2,bud3

!-------------------------------------------------------------------

!$omp parallel do default(shared)              &
!$omp private(i,j,k,qvnew,qcnew,qrnew,ar,cr,esl,qvs,er,term1,cpml,cvml,rm,tem)
      do k=1,nk
      bud1(k)=0.0d0
      bud2(k)=0.0d0
      bud3(k)=0.0d0
      do j=1,nj
      do i=1,ni

        tmp(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))

        qvnew=qv3d(i,j,k)
        qcnew=qc3d(i,j,k)
        qrnew=qr3d(i,j,k)

        ar=0.0
        cr=0.0
        er=0.0

        !! autoconversion of cloud to rain
        if(qcnew.gt.0.0)then
          ar=max(0.001*(qcnew-0.001),0.0)
          ar=ar*dt
        endif

        !! accretion of cloud by rain
        if(qcnew.gt.0.0 .and. qrnew.gt.0.0)then
          cr=2.2*qcnew*(qrnew**0.875)
          cr=cr*dt
        endif

        !! evap of rain to vapor
        if(qrnew.gt.0.0)then
          esl=611.2*exp( 17.67 * ( tmp(i,j,k) - 273.15 ) / ( tmp(i,j,k) - 29.65 ) )
          qvs=eps*esl/(prs(i,j,k)-esl)
          if(qvnew.lt.qvs)then
            er=(1.6+30.3922*((rho(i,j,k)*qrnew)**0.2046))*          &
                (1.0-(qvnew/qvs))*                                  &
                ((rho(i,j,k)*qrnew)**0.525)/                        &
               ( (2.03e4+9.584e6/(qvs*prs(i,j,k))) * rho(i,j,k) )
            er=min(er*dt,qrnew)
            if( (qvnew+er).gt.qvs )then
              er=qvs-qvnew
            endif
          endif
        endif

        if((ar+cr).gt.qcnew)then
          term1=ar+cr
          ar=qcnew*ar/term1
          cr=qcnew*cr/term1
        endif

        qvnew=qvnew+er
        qcnew=qcnew-(ar+cr)
        qrnew=qrnew+(ar+cr-er)

      if(er.gt.1.0e-7)then
        if(eqtset.eq.2)then
          cpml=cp+cpv*qvnew+cpl*(qcnew+qrnew)
          cvml=cv+cvv*qvnew+cpl*(qcnew+qrnew)
          rm=rd+rv*qvnew
          th3d(i,j,k)=th3d(i,j,k)-er*(                                     &
                  (lv1-lv2*tmp(i,j,k))/(cpdcv*cvml*(pi0(i,j,k)+pp3d(i,j,k)))   &
                - (th0(i,j,k)+th3d(i,j,k))*(rv/cvml)*(1.0-rovcp*cpml/rm) )
          pp3d(i,j,k)=((rho(i,j,k)*rm*(th0(i,j,k)+th3d(i,j,k))*rp00)**rddcv)-pi0(i,j,k)
          prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
        else
          th3d(i,j,k)=th3d(i,j,k)-er*( (lv1-lv2*tmp(i,j,k))         &
                                      /(cp*(pi0(i,j,k)+pp3d(i,j,k))) )
          rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qvnew*reps))
        endif
      endif

        tem=ruh(i)*rvh(j)*rmh(i,j,k)

        bud1(k)=bud1(k)+rr(i,j,k)*ar*tem
        bud2(k)=bud2(k)+rr(i,j,k)*cr*tem
        bud3(k)=bud3(k)+rr(i,j,k)*er*tem

        qv3d(i,j,k)=qvnew
        qc3d(i,j,k)=qcnew
        qr3d(i,j,k)=qrnew

      enddo
      enddo
      enddo

      dum=dx*dy*dz

      do k=1,nk
        tauto=tauto+bud1(k)*dum
      enddo

      do k=1,nk
        taccr=taccr+bud2(k)*dum
      enddo

      do k=1,nk
        tevar=tevar+bud3(k)*dum
      enddo

      if(timestats.ge.1) time_microphy=time_microphy+mytime()
 
      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine satadj(nrk,dt,tcond,tevac,ruh,rvh,rmh,pi0,th0,   &
                        rho,rr,pp3d,prs,th3d,q3d)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nrk
      real, intent(in) :: dt
      double precision :: tcond,tevac
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,rr,pp3d,prs,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d

      integer :: i,j,k,n,nmax,omax,iflag
      real :: tnew,pnew
      real :: esl,qvs,qvnew,qcnew,cvml,rm,lhv,tlast,dqv
      real :: converge,t1,d1,tem,ql,qi,rdt
      double precision :: dum
      double precision, dimension(nk) :: bud1,bud2
      logical :: doit

!--------------------------------------------------------------------
!  iterative sat adj.

    nmax=0
    iflag=0

    IF(eqtset.eq.2)THEN

      if(nrk.eq.4)then
!!!        converge=0.0005
        converge=2.0*tsmall
      else
!!!        converge=0.01
        converge=20.0*tsmall
      endif

      rdt = 1.0/dt

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tnew,pnew,esl,qvs,qvnew,qcnew,cvml,rm,lhv,   &
!$omp tlast,dqv,t1,d1,tem,ql,qi,doit)
      do k=1,nk
      bud1(k)=0.0d0
      bud2(k)=0.0d0
      do j=1,nj
      do i=1,ni

        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
        qvs=eps*esl/(prs(i,j,k)-esl)

        IF(q3d(i,j,k,nqc).gt.1.0e-12 .or. q3d(i,j,k,nqv).gt.qvs)THEN

          qvnew=q3d(i,j,k,nqv)
          qcnew=q3d(i,j,k,nqc)
          ql=0.0
          qi=0.0
          do n=nql1,nql2
            ql=ql+q3d(i,j,k,n)
          enddo
          if(iice.eq.1)then
            do n=nqs1,nqs2
              qi=qi+q3d(i,j,k,n)
            enddo
          endif
          ql=max(0.0,ql)
          qi=max(0.0,qi)
          cvml=cv+cvv*qvnew+cpl*ql+cpi*qi
          lhv=lv1-lv2*tnew

          t1=(lhv-rv*tnew)/cvml
          d1=t1*17.67*243.5

          n=0
          tlast=tnew
          doit=.true.

          do while( doit )
            n=n+1
            dqv=(qvs-qvnew)/(1.0+d1*qvs/((tnew-29.65)**2) )
            dqv=min(dqv,qcnew)
            if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew

            qvnew=qvnew+dqv
            qcnew=qcnew-dqv
            tnew=tnew-dqv*t1
            pnew=rho(i,j,k)*(rd+rv*qvnew)*tnew

            doit = .false.
            if( abs(tnew-tlast).gt.converge )then
              tlast=tnew
              esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
              qvs=eps*esl/(pnew-esl)
              doit = .true.
            endif

            if(n.gt.50) print *,'  satadj:',myid,n,tnew,pnew
            if(n.eq.100)then
              print *,'  infinite loop!'
              print *,'  i,j,k=',i,j,k
              iflag=1
              doit=.false.
            endif

          enddo

          tem=ruh(i)*rvh(j)*rmh(i,j,k)

          bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-q3d(i,j,k,nqc),0.0)*tem
          bud2(k)=bud2(k)+rr(i,j,k)*max(qvnew-q3d(i,j,k,nqv),0.0)*tem

          prs(i,j,k) = pnew
          pp3d(i,j,k) = (pnew*rp00)**rovcp - pi0(i,j,k)
          th3d(i,j,k) = tnew/(pi0(i,j,k)+pp3d(i,j,k))-th0(i,j,k)
          q3d(i,j,k,nqc) = qcnew
          q3d(i,j,k,nqv) = qvnew

          nmax=max(n,nmax)

        ENDIF


      enddo
      enddo
      enddo

    ELSE

      nmax=1

!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvnew,qcnew,tnew,esl,qvs,lhv,dqv,tem,rm)
      do k=1,nk
      bud1(k)=0.0d0
      bud2(k)=0.0d0
      do j=1,nj
      do i=1,ni

        qvnew=q3d(i,j,k,nqv)
        qcnew=q3d(i,j,k,nqc)
        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
        qvs=eps*esl/(prs(i,j,k)-esl)
        lhv=lv1-lv2*tnew
!!!        dqv=(qvs-qvnew)/(1.0+lhv*qvs*4097.8531/(cp*((tnew-35.86)**2)))
        dqv=(qvs-qvnew)/(1.0+lhv*qvs*17.67*243.5/(cp*((tnew-29.65)**2)))
        if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
        dqv=min(dqv,max(0.0,qcnew))

        qvnew=qvnew+dqv
        qcnew=qcnew-dqv
        tem=ruh(i)*rvh(j)*rmh(i,j,k)
        bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-q3d(i,j,k,nqc),0.0)*tem
        bud2(k)=bud2(k)+rr(i,j,k)*max(qvnew-q3d(i,j,k,nqv),0.0)*tem

        th3d(i,j,k)=th3d(i,j,k)-dqv*( lhv/(cp*(pi0(i,j,k)+pp3d(i,j,k))) )
        q3d(i,j,k,nqc)=qcnew
        q3d(i,j,k,nqv)=qvnew
        rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qvnew*reps))

      enddo
      enddo
      enddo

    ENDIF

    IF(nrk.ge.3)THEN
      dum=dx*dy*dz
      do k=1,nk
        tcond=tcond+bud1(k)*dum
      enddo

      do k=1,nk
        tevac=tevac+bud2(k)*dum
      enddo
    ENDIF

!!!#ifdef MPI
!!!      omax=0
!!!      call MPI_REDUCE(nmax,omax,1,MPI_INTEGER,MPI_MAX,0,MPI_COMM_WORLD,ierr)
!!!      nmax=omax
!!!#endif
!!!      if(myid.eq.0) print *,'  nmax = ',nmax

      if(iflag.ne.0)then
        print *
        print *,' Convergence cannot be reached in satadj subroutine.'
        print *
        print *,' This may be a problem with the algorithm in satadj.'
        print *,' However, the model may have became unstable somewhere'
        print *,' else and the symptoms first appeared here.'
        print *
        print *,' Try decreasing the timestep (dtl and/or nsound).'
        print *
        print *,'  ... stopping cm1 ... '
        print *
        call stopcm1
      endif

      if(timestats.ge.1) time_satadj=time_satadj+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine k_fallout(rho,qr3d,vr)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,qr3d,vr
 
      integer i,j,k

!--------------------------------------------------------------------
!  Get fall velocities

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          vr(i,j,k)=0.0
          if(qr3d(i,j,k).gt.1.0e-12)then
            vr(i,j,k)=14.34*((rho(i,j,k)*qr3d(i,j,k))**0.1346)    &
                           *sqrt(1.15/rho(i,j,k))
          endif
        enddo
        enddo
        enddo

      if(timestats.ge.1) time_fall=time_fall+mytime()
 
      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine fallout(dt,train,ruh,rvh,zh,mh,mf,rain,rr,rho,   &
                         q3d,vq)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      double precision :: train
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,nrain) :: rain
      real, dimension(ib:ie,jb:je,kb:ke) :: rr,rho,q3d,vq

      integer :: i,j,k,n,nr,nrk
      real, dimension(-1:nk+3):: rq
      real, dimension(0:nk) :: ffk
      real, dimension(nk) :: qtmp

      integer :: nfall
      real :: crmax,dtfall

      double precision :: tem
      double precision, dimension(nj) :: bud

!--------------------------------------------------------------------

!$omp parallel do default(shared)            &
!$omp private(i,j,k,crmax,nfall,rq,n,dtfall,nr)
    do j=1,nj
    bud(j)=0.0d0
    do i=1,ni
      crmax = 0.0
      do k=1,nk
        crmax = max( crmax , vq(i,j,k)*dt*rdz*mh(i,j,k) )
      enddo
      nfall = max( 1 , int(crmax+1.0) )
      ! cm1r17:  following code is needed if nfall is large.
      !  - below edge of falling precip, set fallspeed to
      !    value at gridpoint above:
      do k=(nk-1),1,-1
        if( q3d(i,j,k).lt.1.0e-8 ) vq(i,j,k) = vq(i,j,k+1)
      enddo
      dtfall=dt/nfall
      do n=1,nfall
        do k=1,nk
          rq(k)=rho(i,j,k)*vq(i,j,k)*max(0.0,q3d(i,j,k))
        enddo
        rq(nk+1)=0.0
        do k=1,nk
          q3d(i,j,k)=q3d(i,j,k)+dtfall*(rq(k+1)-rq(k))   &
                                     *rdz*mh(i,j,k)/rho(i,j,k)
        enddo
        do nr=1,nrain
          rain(i,j,nr)=rain(i,j,nr)+0.1*dtfall*rq(1)
        enddo
        bud(j)=bud(j)+dtfall*rr(i,j,1)*vq(i,j,1)*max(0.0,q3d(i,j,1))*ruh(i)*rvh(j)
      enddo
    enddo
    enddo

      tem=dx*dy
      do j=1,nj
        train=train+bud(j)*tem
      enddo

      if(timestats.ge.1) time_fall=time_fall+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getefall(setzero,cpx,mf,t,cvm,tten,q3d,vr)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer, intent(in) :: setzero
      real, intent(in) :: cpx
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: t,cvm
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: q3d,vr

      integer :: i,j,k

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk-1
        if(setzero.eq.1)then
          do j=1,nj
          do i=1,ni
            tten(i,j,k)=0.0
          enddo
          enddo
        endif
        do j=1,nj
        do i=1,ni
          tten(i,j,k)=tten(i,j,k)+q3d(i,j,k)*vr(i,j,k)*(              &
                       cpx*(t(i,j,k+1)-t(i,j,k))*rdz*mf(i,j,k+1) + g  &
                                    )/cvm(i,j,k)
        enddo
        enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_fall=time_fall+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine geterain(dt,cpx,lx1,erain,ruh,rvh,t,rr,q3d,vr)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt,cpx,lx1
      double precision :: erain
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: t,rr
      real, dimension(ib:ie,jb:je,kb:ke) :: q3d,vr

      integer :: i,j
      double precision :: bud(nj)

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      bud(j)=0.0d0
      do i=1,ni
        bud(j)=bud(j)+dt*vr(i,j,1)*rr(i,j,1)*q3d(i,j,1)*(cpx*t(i,j,1)-lx1)*ruh(i)*rvh(j)
      enddo
      enddo

      do j=1,nj
        erain=erain+bud(j)*dx*dy
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_fall=time_fall+mytime()

      RETURN
      END


lfoice.F        1587424407  1602  20    100644  66907     `
!-------------------------------------------------------------------------------
!   lfo_ice_drive
!
!   PURPOSE: To transform the CM1 variables to what 3-ICE expects
!   DATE:   Sept 12, 2006 
!   AUTHOR: Matt Gilmore
!
!-------------------------------------------------------------------------------
!           call lfo_ice_drive(dt, mf, pi0, pp3d, prs, th0, th3d, qv0, rho0, q3d) 

      subroutine lfo_ice_drive(dt, mf, pi0, prs0, pp3d, prs, th0, th3d,    &
                               qv0, rho0, q3d, vq, pn)

      implicit none


! Variable declarations for variables passed from CM1

!(CM1 input.incl common block)
!       ni       # grid points (for tile) in x-direction (east/west)
!       nj       # grid points (for tile) in y-direction (north/south)
!       nk       # grid points (for tile) in vertical
!       dt       model large timestep     (s)
!       rdz      inverse of constant model dz (m^-1)
 
! CM1 INPUT (passed)
!       mf     = 1/[rdz*(zh(k)-zh(k-1)]   (No Dim)    (i,j,k)
!  Note rdz*mf is 1/dzactual for the stretched grid ! zh is scalar ht (m)
!
!       pi0      base state total Exner   (No Dim)    (i,j,k)
!       pp3d     perturbation Exner pressure          (i,j,k)
!       prs      full pressure            (Pascals)   (i,j,k)
!       th0      base state potential temp(K)         (i,j,k)
!       th3d     potential temperature perturb. (K)   (i,j,k)
!       rho0     base state dry air density     (kg/m^3)    (i,j,k)   ! replaced db(kz) in NCOMMAS version
!       qv0      base state vapor mixing ratio        (i,j,k)
!
!       q3d      qv, qc, qr, qi, qs, qh  (kg/kg)      (i,j,k,numq)

      include 'input.incl'     !  dt, ib, ie, jb, je, kb, ke, ibm, ibi, jbm, jbi, kbm, kbi, iem ,iei, jem, jei, kem, kei, ni, nj, nk, numq
!       ni        number of grid pts in the x-direction (east/west)
!       nj        number of grid pts in the y-direction (north/south)
!       nk        number of grid pts in the vertical
!       ib    -2  starting point including 3-point buffer
!       ie  ni+3
!       jb    -2
!       je  nj+3
!       kb     0
!       ke  nk+1

      include 'timestat.incl'   !This will do the timing statistics for the ice micro


      real :: dt
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,pp3d,prs,th3d,th0,   &
                                            rho0,qv0,pn
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d,vq
!
! The following are 3-ICE variables/terminology
! We set the dimensions to that of the tile without buffer (not the full domain)
!
      integer nstep          ! Current Model timestep
      parameter (nstep = 1)  !    for now, set to a constant
      real dzc(nk)           ! 1/dz for the stretched grid 
      real rinit(nk)         ! base state density (kg/m^3)
      real pinit(nk)         ! base state pressure (Pa)
      real sb(nk, numq)        ! base state array of th, qv, qc, etc

!-------------------------------------------------------------------------------
!     misc. local variables
!-------------------------------------------------------------------------------

      integer i,j,k,n

!-------------------------------------------------------------------------------

!
! Set up Conversions between CM1 and SAM
!
      sb(:,:)  = 0.0
      rinit(:) = 0.0
      pinit(:) = 0.0
      dzc(:)   = 0.0

!     Set up 1D vertical arrays.  Use corner of domain for no-terrain case.

      i = 1
      j = 1
      DO k = 1,nk                   !MSG might need to change to nk instead of nk-1
       dzc(k)  =   mf(i,j,k)*rdz
       sb(k,1) =  th0(i,j,k)
       sb(k,2) =  qv0(i,j,k)
       rinit(k)= rho0(i,j,k)
       pinit(k)= prs0(i,j,k)
      ENDDO

!     Copy 3-D arrays from CM1 to 3-ICE.

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      DO k = 1, nk
      DO j = 1, nj
      DO i = 1, ni
       pn(i,j,k)   = prs(i,j,k) - pinit(k)       !perturbation pressure (Pascals)
      ENDDO
      ENDDO
      ENDDO

!     Make sure vq array is zero, by default

      DO n = 1, numq
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k = 1, nk
        DO j = 1, nj
        DO i = 1, ni
          vq(i,j,k,n) = 0.0
        ENDDO
        ENDDO
        ENDDO
      ENDDO

! DO MICROPHYSICS

           CALL LFO_ICE (ni,nj,nk,numq,dt,dzc,sb,th3d,q3d,vq,rinit,pn,pinit,nstep, &
                         ib,ie,jb,je,kb,ke,ibm,iem,jbm,jem,kbm,kem)

!-------------------------------------------------------------------------------

! Uncomment the next lines if micro is allowed to feedback on pressure
!  This could also be put directly into LFO_ICE
!     DO k = 1, nk
!     DO j = 1, nj
!     DO i = 1, ni
!       prs(i,j,k) = pn(i,j,k) + prs0(i,j,k)    !total pressure (Pascals)
!       pp3d(i,j,k) = (prs(i,j,k)*rp00)**rovcp  !total pressure (Ekner)
!     ENDDO
!     ENDDO
!     ENDDO

      if(timestats.ge.1) time_microphy=time_microphy+mytime()


      RETURN
      END
!--------------------------------------------------------------------------
!
!
!  3-ICE MODEL
!
!  VERSION: 1.3 with Rates (2/10/05)
!
!  LIN-FARELY-ORVILLE-like "Simple Ice and Liquid Microphysics Scheme"
!   based on Gilmore et al. (2004) Mon. Wea. Rev.
!
!   Copyright (C) <2004>  <Jerry Straka and Matthew Gilmore>
!
!   This library is free software; you can redistribute it and/or
!   modify it under the terms of the GNU Lesser General Public
!   License as published by the Free Software Foundation; either
!   version 2.1 of the License, or (at your option) any later version.
!
!   This library is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!   Lesser General Public License for more details.
!
!   If you find this code useful and publish results using it, please reference:
!
!     Gilmore M. S., J. M. Straka, and E. N. Rasmussen,
!           Monthly Weather Review: Vol. 132, No. 8, pp. 1897-1916.
!
!--------------------------------------------------------------------------
!          CALL LFO_ICE (ni,nj,nk,numq,dt,dzc,sb,th3d,q3d,rinit,pn,pinit,nstep, &
!                        ib,ie,jb,je,kb,ke,ibm,iem,jbm,jem,kbm,kem)
      SUBROUTINE LFO_ICE(nx,ny,nz,numq,dtp,dzc,ab,th3d,q3d,vq,   db,pn,   pb,nstep, &
                         ib,ie,jb,je,kb,ke,ibm,iem,jbm,jem,kbm,kem)
!--------------------------------------------------------------------------
! RELEASE NOTES
!
! MSG - 2/10/05 Ported the SAM gather-scatter version to NCOMMAS
!       This is most similar to that actually used in the published manuscripts.
!       This version also provides rate output (labels consistent with Gilmore et al) for post-analysis.
!       Known inconsistencies/omissions: 
!          1) min q criteria applied to some (but not all) processes
!          2) internal rate names and signs differ compared to Gilmore et al. (2004),
!               however, rate output is consistent
!          3) time splitting for fallout omitted
!
!
! MSG - 5/5/05  Added time-splitting fallout.
!
! MSG - 9/12/06c Ported code to CM1 with wrapper routine.  Strategy is to *not* use any common blocks
!                or include files.  Thus, slight mismatch between CM1 constants and herein.  
!                Also, here we assume 1-D base state (faster code) but CM1 is really 3-D base state.
!                See the alternate 9/13/06 version if you wish to use the full 3D base state.
!                Note that this code has internal saturation adjustment and fallout.
!
! GHB - 061021: - Now using common block, using include file 'lfoice.incl'
!                 Several constants are now defined in 'lfoice.incl'
!                 Call to "lfoice_init" has been added to "param"
!
!--------------------------------------------------------------------------
!                                
!
!  general declarations
!
!
      implicit none

      include 'lfoice.incl'

!     include 'param.h'
!--------------------------------------------------------------------------

      integer ix,jy,kz,nx,ny,nz

      integer ib, ie, jb, je, kb, ke
      integer ibm,iem,jbm,jem,kbm,kem
      integer numq

      integer nstep
      real dtp
      integer istag,jstag,kstag
      parameter (istag=0, jstag=0, kstag=0)            !MSG Set these to 1 for NCOMMAS; set to 0 for CM1
      integer      lv,  lc,   lr,   li,   ls,   lh
      parameter (  lv=1,lc=2, lr=3, li=4, ls=5, lh=6)  !MSG indicee numbers consistent with CM1

      real dzc(nz)                                     !MSG weren't defined before

!     real  an(nx,ny,nz,numq)                                !MSG scalars (NCOMMAS)
      real, dimension(ib:ie,jb:je,kb:ke) :: th3d             !MSG TH scalar (CM1)
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d   !MSG Q scalars (CM1)
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: vq    !GHB Q fallspeeds (CM1)
      real  ab(nz,numq)                                      !MSG base state for scalars
      real, dimension(ib:ie,jb:je,kb:ke) :: pn               !MSG perturb pressure
      real pb(nz), db(nz)                                    !MSG base state pressure, density
!
!---
! 
!  declarations microphysics and for gather/scatter
!
!   (MSG: In this version, if ngs, the number of gather/scatter points, is smaller than the number of
!         microphysically active gridpoints in an XZ slice, then the code does multiple
!         gather/scatter iterations within a single XZ slice using inumgs and the pointers nxmpb,nzmpb.)
!
      integer jgs,mgs,ngs,numgs,inumgs,nxmpb,nzmpb,nxz      !MSG added innumgs
      parameter ( ngs=500 )
      integer ngscnt,igs(ngs),kgs(ngs)

! Air and particle temperatures (equivalent to each other in LFO version)

      real temp(ngs)
      real temg(ngs),temcg(ngs),theta(ngs),thetap(ngs),theta0(ngs)

! Air pressure, density, & Exner function

      real pbz(ngs),pres(ngs),presp(ngs),pres0(ngs)
      real rho0(ngs),dnz(ngs),pi0n(ngs),piz(ngs)

! Accretions

      real qiacr(ngs)
      real qracw(ngs), qraci(ngs), qracs(ngs)
      real qsacw(ngs), qsaci(ngs),            qsacr(ngs)
      real qhacw(ngs), qhaci(ngs), qhacs(ngs),qhacr(ngs)
      real eri(ngs),erw(ngs),ers(ngs)
      real esw(ngs),esi(ngs)
      real ehw(ngs),ehr(ngs),ehi(ngs),ehs(ngs)

! Biggs Freezing

      real qrfrz(ngs), xrfrz(ngs)

! Bergeron Process

      real qsfw(ngs),qsfi(ngs), eic(ngs)
      real cs9

! Conversions

      real qhcns(ngs), qrcnw(ngs), qscni(ngs), qdiff,argrcnw
      real ehscnv(ngs), esicnv(ngs)

! Evaporation/Deposition/Sublimation

      real qhdsv(ngs),qhdpv(ngs),qhsbv(ngs)
      real qsdsv(ngs),qsdpv(ngs),qssbv(ngs)
      real qrcev(ngs)
      real xav(ngs),xbv,xas(ngs),xbs
      real xrcev2(ngs)
      real xce,xrv,xds
      real xxdsv,xxcev

! Initiation of cloud ice

      real dqisdt(ngs),qiint(ngs),cnnt

! Melting/Wet growth of hail, Melting snow

      real qhmlr(ngs), qsmlr(ngs)
      real xmlt1,xmlt2
      real xhmlt2(ngs), xsmlt2(ngs)
      real xsv, xhv, xhsw

! Wet/dry growth, shedding

      real qhdry(ngs),qhwet(ngs)
      real xhwet1,xhwet2, xcwt,xwt1
      real qhacip(ngs),qhacsp(ngs),qhshr(ngs)

! Water Budgets

      real ptotal(ngs),ptotsat(ngs) 
      real pqcwi(ngs),pqcii(ngs),pqrwi(ngs)
      real pqswi(ngs),pqhwi(ngs),pqwvi(ngs)
      real pqcwd(ngs),pqcid(ngs),pqrwd(ngs)
      real pqswd(ngs),pqhwd(ngs),pqwvd(ngs)
      integer il2(ngs),il3(ngs),il5(ngs)

! Latent Heating Computation

      real psub(ngs),pvap(ngs),pfrz(ngs),ptem(ngs)

! Maximum Depletion Tendencies

      real qc5dt,qi5dt,qr5dt,qs5dt,qh5dt

! Flags
!!!      integer imake                    !prints intercept/density to output file
!!!      save imake
!!!      data imake / 0 /
      integer  ndebug, nrates          !prints debug stuff to output file, prints rates to out file
      integer itfall
      parameter (ndebug = 0, nrates=0) !prints debugging, rate flags
        ! GHB, 061013:  moved fallout to CM1 solve
      parameter (itfall = 0)           !0 no flux fallout, 2: timesplit flux fallout, 1 flux on regular dt

! Fallout, fall velocity parameters/vars

      real dtz1
      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      real cwflx(ngs), cflux(nx,nz)
!!!      real piflx(ngs), pflux(nx,nz)
!!!      real rwflx(ngs), rflux(nx,nz)
!!!      real swflx(ngs), sflux(nx,nz)
!!!      real hwflx(ngs), hflux(nx,nz)

      real maxfall            ! max fallspeed of qg, qh, qf, qr, qd, qm
      real vtrdzmax           ! input courant                         ! MSG
      real dtsplit            ! small timestep for rain sedimentation ! MSG
      integer nrnstp,inrnstp  ! number of small timesteps, counter    ! MSG

 
!  Distribution parameters, Fallout, Mean diameter's, mass, and mixing ratio's
 
!
!
      real qwv(ngs),qcw(ngs),qci(ngs),qrw(ngs),qsw(ngs),qhw(ngs)
      real ccw(ngs),cci(ngs),crw(ngs),csw(ngs),chw(ngs)
!
      real vtwbar(ngs),cwmas(ngs)
      real vtibar(ngs),cimas(ngs)
      real vtrbar(ngs)
      real vtsbar(ngs)
      real vthbar(ngs)
!
      real cwdia(ngs),cwdia2(ngs)
      real cidia(ngs),cidia2(ngs)
      real rwdia(ngs),rwdia2(ngs)
      real swdia(ngs),swdia2(ngs)
      real hwdia(ngs),hwdia2(ngs)

! Saturation Adjustment

      real qvap(ngs)
      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
      real gamss,denom1,denom2
      real gamw(ngs),gams(ngs)
      real qwvp(ngs), qv0n(ngs)
      real fraci(ngs),fracl(ngs)
      real cdw, cdi
      integer itertd
      real qwfzi(ngs),qimlw(ngs)
      real qidep(ngs),qisub(ngs)
      real qcevp(ngs), qccnd(ngs)
      real qcevpcnd(ngs), qisubdep(ngs)

! Saturation lookup table, vapor pressures, ratio's

      integer ltemq
      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
      real tsqr(ngs),ssi(ngs),ssw(ngs)

! Misc Variables

      real advisc,schm,tkarwinv,rhoratio,mlttemp
      real wvdf(ngs),akvisc,ci(ngs),tka(ngs)
      real cc3(ngs),cc4(ngs),cc5(ngs)

!  Rate Output (Domain-total g/m^3)

      real hfrz, hdep, hcnd, cevap, cmelt, csub		!MSG added total cooling/heating vars
      real tqva,  tqia,  tqca
      real tqvb,  tqib,  tqcb
      real tqvap, tqsap, tqiap, tqrap, tqcap, tqhap
      real tqvbp, tqsbp, tqibp, tqrbp, tqcbp, tqhbp
      real tvsum, tssum, tisum, trsum, tcsum, thsum, tqc,tqi,tqv,tsumall 
      real suma,  sumb,  psum 
      real trqsacw, trqhacr, trqhshr, trqhmlr, trqsmlr, tiqiint, tiqidep, trqhacs
      real trqhacw, trqhaci, tvqhsbv, tvqcevp, tvqssbv, tvqrcev, trqrcnw, trqracw
      real tcqcmli, tvqisub, tcqccnd, tiqifzc, thqhacs, thqsacr, thqhaci, thqhacr
      real thqhacw, thqhdpv, thqrfrz, thqiacr, thqracs, thqraci, tsqsacw, tsqsacr
      real tsqscni,  tsqsfi,  tsqsfw, tsqsdpv, thqhcns, tsqsaci, tsqraci, tsqiacr, thqhwet 
!     
!
!  read in constants from 'inmicro.jmslfo'
!  [deleted this part - MSG]

      if ( ndebug .eq. 1 ) print*,'Just entered micro...'

!
!  ZERO
!
!
!  totals for source / sink terms
!
!
!  vapor
!
      tvqrcev = 0.0
      tvqssbv = 0.0
      tvqhsbv = 0.0
      tvqcevp = 0.0
      tvqisub = 0.0
!
!  cloud water
!
      tcqccnd = 0.0 
      tcqcmli = 0.0
!
!  rain
!
      trqrcnw = 0.0
      trqracw = 0.0
      trqhmlr = 0.0
      trqsmlr = 0.0
      trqhshr = 0.0
      trqsacw = 0.0
      trqhacr = 0.0
      trqhacw = 0.0
      trqhaci = 0.0
      trqhacs = 0.0

!
!  cloud ice
!
      tiqiint = 0.0
      tiqidep = 0.0
      tiqifzc = 0.0
!
!  snow
!
      tsqsfi  = 0.0
      tsqsfw  = 0.0
      tsqscni = 0.0
      tsqsacw = 0.0
      tsqsacr = 0.0
      tsqraci = 0.0
      tsqiacr = 0.0
      tsqsaci = 0.0
      tsqsdpv = 0.0
!
!  hail
!
      thqhcns = 0.0
      thqhacr = 0.0
      thqhacw = 0.0
      thqhaci = 0.0
      thqhacs = 0.0
      thqsacr = 0.0
      thqracs = 0.0
      thqraci = 0.0
      thqiacr = 0.0
      thqhdpv = 0.0
      thqrfrz = 0.0
      thqhwet = 0.0
!
!  total heating and cooling rates
!
      hfrz    = 0.0
      hdep    = 0.0
      hcnd    = 0.0
      cevap   = 0.0
      cmelt   = 0.0
      csub    = 0.0
!
!
!  various rate budgets
!
      tqvap     = 0.0
      tqcap     = 0.0
      tqiap     = 0.0
      tqrap     = 0.0
      tqsap     = 0.0
      tqhap     = 0.0
!
      tqvbp     = 0.0
      tqcbp     = 0.0
      tqibp     = 0.0
      tqrbp     = 0.0
      tqsbp     = 0.0
      tqhbp     = 0.0
!
      tqva     = 0.0
      tqca     = 0.0
      tqia     = 0.0
!
      tqvb     = 0.0
      tqcb     = 0.0
      tqib     = 0.0
!
      suma      = 0.0
      psum      = 0.0
!
      sumb      = 0.0
!
      tvsum    = 0.0
      tcsum    = 0.0
      tisum    = 0.0
      trsum    = 0.0
      tssum    = 0.0
      thsum    = 0.0
!
      tsumall   = 0.0
      tqv       = 0.0
      tqc       = 0.0
      tqi       = 0.0
!
!
!  end of totals
!
!
!  other constants
!


!      write(6,*) '-----------------------------------------------------------------------'
!
      if ( ndebug .eq. 1 ) print*,'dbg = 0b'

!
!  MSG: These 3 things a function of base state (eventually will be moved to 3-D base state)
!
      do 10 kz = 1,nz-kstag
       pbz(kz) = pb(kz)
       piz(kz) = (pbz(kz)/poo)**rcp
       temp(kz) = piz(kz)*ab(kz,1)
  10  continue
      
      if (ndebug .eq. 1 ) print*,'dbg = 1'
!
      if (ndebug .eq. 1 ) print*,'dbg = 2'
!
!  start jy loop  (for doing XZ slabs)
!
!
      do 9999 jy = 1,ny-jstag
!
!  VERY IMPORTANT:  SET jgs
!
      jgs = jy
!
!  zero precip flux arrays
!
      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      vtrdzmax = 0.0                     !MSG Courant for the slice
!!!      maxfall = 0.0                      !MSG max fallspeed of any particle for the slice
!!!      if (ndebug .eq. 1 ) print*,'dbg = 3'
!!!      do 95 kz = 1,nz-kstag
!!!      do 96 ix = 1,nx-istag
!!!      hflux(ix,kz) = 0.0
!!!      cflux(ix,kz) = 0.0
!!!      pflux(ix,kz) = 0.0
!!!      rflux(ix,kz) = 0.0
!!!      sflux(ix,kz) = 0.0
!!!  96  continue
!!!  95  continue
!
!..gather microphysics  
!
      if (ndebug .eq. 1 ) print*,'dbg = 4'
      nxmpb = 1
      nzmpb = 1
      nxz = nx*nz
      numgs = nxz/ngs + 1
      do 1000 inumgs = 1,numgs 
      ngscnt = 0
! 061023, GHB:  dunno why the "kstag-1" is here ... removing the -1
!!!      do kz = nzmpb,nz-kstag-1 
      do kz = nzmpb,nz-kstag
      do ix = nxmpb,nx-istag

      theta(kz) = th3d(ix,jy,kz) + ab(kz,1)
      temg(kz) = theta(kz)*( (pn(ix,jy,kz)+pbz(kz)) / poo ) ** rcp
      ltemq = nint((temg(kz)-163.15)/fqsat+1.5)
      ltemq = min(max(ltemq,1),nqsat)         
      pqs(kz) = 380.0/(pn(ix,jy,kz)+pbz(kz))
      qvs(kz) = pqs(kz)*tabqvs(ltemq)        
      qis(kz) = pqs(kz)*tabqis(ltemq)       
      
      if ( temg(kz) .lt. tfr ) then

       qcw(kz) = max(q3d(ix,jy,kz,lc) ,0.0)
       qci(kz) = max(q3d(ix,jy,kz,li) ,0.0)

       if( qcw(kz) .ge. 0.0 .and. qci(kz) .eq. 0.0 ) qss(kz) = qvs(kz)
       if( qcw(kz) .eq. 0.0 .and. qci(kz) .gt. 0.0)  qss(kz) = qis(kz)
       if( qcw(kz) .gt. 0.0 .and. qci(kz) .gt. 0.0)  qss(kz) = (qcw(kz)*qvs(kz) + qci(kz)*qis(kz)) /(qcw(kz) + qci(kz))
      else
       qss(kz) = qvs(kz)
      end if
!
      if ( q3d(ix,jy,kz,lv) .gt. qss(kz) .or.   &
           q3d(ix,jy,kz,lc) .gt. qcmin  .or.    &
           q3d(ix,jy,kz,li) .gt. qimin .or.     &
           q3d(ix,jy,kz,lr) .gt. qrmin .or.     &
           q3d(ix,jy,kz,ls) .gt. qsmin .or.     &
           q3d(ix,jy,kz,lh) .gt. qhmin ) then
      ngscnt = ngscnt + 1
      igs(ngscnt) = ix
      kgs(ngscnt) = kz
      if ( ngscnt .eq. ngs ) goto 1100
      end if
      ENDDO     !MSG - i loop
      nxmpb = 1
      ENDDO     !MSG - k loop
 1100 continue
      if ( ngscnt .eq. 0 ) go to 9998
      if ( ndebug .eq. 1 ) print*,'dbg = 5'
!
!  define temporaries to be used in calculations
!
      do 1010 mgs = 1,ngscnt
      dnz(mgs)   = db(kgs(mgs))
      pres0(mgs) = pbz(kgs(mgs))                    !MSG need to make 3-D base state eventually
      presp(mgs) = pn(igs(mgs),jy,kgs(mgs))
      pres(mgs)  = presp(mgs) + pres0(mgs)
      pi0n(mgs)  = piz(kgs(mgs))                    !MSG need to make 3-D base state eventually
       cc3(mgs)  = cpi*elf/pi0n(mgs)
       cc4(mgs)  = cpi*elv/pi0n(mgs)
       cc5(mgs)  = cpi*els/pi0n(mgs)
      theta0(mgs)= ab(kgs(mgs),1)                   !MSG need to make 3-D base state eventually
      thetap(mgs)= th3d(igs(mgs),jy,kgs(mgs))
      theta(mgs) = thetap(mgs) + theta0(mgs)
      temg(mgs)  = theta(mgs)*( pres(mgs) / poo ) ** rcp      

!      if (IEEE_IS_NAN(temg(mgs))) call stopcm1

      temcg(mgs) = temg(mgs) - tfr
      pqs(mgs)   = 380.0/pres(mgs)
      ltemq      = nint((temg(mgs)-163.15)/fqsat+1.5)
      ltemq      = min(max(ltemq,1),nqsat)
      qvs(mgs)   = pqs(mgs)*tabqvs(ltemq)
      qis(mgs)   = pqs(mgs)*tabqis(ltemq)
      qwv(mgs)   = q3d(igs(mgs),jy,kgs(mgs),lv)
      qv0n(mgs)  = ab(kgs(mgs),2)                   !MSG need to make 3-D base state eventually
      qwvp(mgs)  = qwv(mgs) - qv0n(mgs) 
      qcw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),lc), 0.0) 
      qci(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),li), 0.0) 
      qrw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),lr), 0.0) 
      qsw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),ls), 0.0) 
      qhw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),lh), 0.0) 
      il2(mgs) = 0
      il3(mgs) = 0
      il5(mgs) = 0
      if ( temg(mgs) .lt. tfr ) then 
       il5(mgs) = 1
       if ( qrw(mgs) .lt. 1.0e-04 .and. qsw(mgs) .lt. 1.0e-04 ) il2(mgs) = 1
       if ( qrw(mgs) .lt. 1.0e-04 ) il3(mgs) = 1
      end if
 1010 continue
!
!
! 
!  other constants for paramerization
!
      do mgs = 1,ngscnt
      advisc     = advisc0*(416.16/(temp(kgs(mgs))+120.0))*(temp(kgs(mgs))/296.0)**(1.5)
      akvisc     = advisc/dnz(mgs)
      ci(mgs)    = (2.118636 + 0.007371*(temp(kgs(mgs))-tfr))*(1.0e+03)     !MSG used in qhwet
      tka(mgs)   = tka0*advisc/advisc1
      wvdf(mgs)  = (2.11e-05)*((temp(kgs(mgs))/tfr)**1.94)*(101325.0/(pbz(kgs(mgs))))
      schm       = akvisc/wvdf(mgs)
      tkarwinv   = 1./(tka(mgs)*rw)
      xav(mgs)   = (elv**2)*tkarwinv
      xas(mgs)   = (els**2)*tkarwinv
      rhoratio   = (dnz00/dnz(mgs))**0.25
      mlttemp    = 0.308*(schm**(1./3.))*(akvisc**(-0.5))
      xhmlt2(mgs)= mlttemp*gf2p75
      xsmlt2(mgs)= mlttemp*gf5ds*(cs**(0.5))*rhoratio
      xrcev2(mgs)= mlttemp*gf5br*(ar**(0.5))*rhoratio
      enddo 

!
      if (ndebug .eq. 1 ) print*,'dbg = 6'
!
! cloud water variables
!
      do 4101 mgs = 1,ngscnt
!     ccw(mgs) = 1.e9    !LFO default (Western Plains)
      ccw(mgs) = .6e9    !Central plains CCN value
!     ccw(mgs) = .3e9    !Maritime CCN value
      cwmas(mgs) = min( max(qcw(mgs)*dnz(mgs)/ccw(mgs),cwmasn),cwmasx )
      cwdia(mgs) = (cwmas(mgs)*cwc1)**c1f3 
      cwdia2(mgs) = cwdia(mgs)**2
      vtwbar(mgs) = (ar*(cwdia(mgs)**br))*(rho00/dnz(mgs))**0.5
 4101 continue
!
! cloud ice variables
!
      do 4201 mgs = 1,ngscnt
!
      cimasx     = 3.23e-8
      cci(mgs)   = max(min(cnit*exp(-temcg(mgs)*bta1),1.e+09),1.0)       !Fletcher's formula
      cimas(mgs) = min( max(qci(mgs)*dnz(mgs)/cci(mgs),cimasn),cimasx )
      if ( temcg(mgs) .gt. 0 ) then
        cidia(mgs) = 0.0
      else
        cidia(mgs) = 16.7*(cimas(mgs)**(0.5))
        cidia(mgs) = max(cidia(mgs), 1.e-5)
        cidia(mgs) = min(cidia(mgs), 3.e-3)
      endif
      cidia2(mgs) = cidia(mgs)**2
      vtibar(mgs) = (cs*(cidia(mgs)**ds))*(rho00/dnz(mgs))**0.5
!
 4201 continue
!
!  mp-distribution information for rain, snow agg's, and graupel/hail
!
!
!  definitions for marshall palmer distribution variables
!  (rain, snow, hail) when mixing ratio only is predicted
!
      if (ndebug .eq. 1 ) print*,'dbg = 7a'
!
      do 4301 mgs = 1,ngscnt
!
      rwdia(mgs) = 1.e-20
      swdia(mgs) = 1.e-20
      hwdia(mgs) = 1.e-20
!
      if ( qrw(mgs) .gt. 1.0e-10 ) rwdia(mgs) = xslop*(dnz(mgs)*qrw(mgs)/(rwdn*xcnor))**(0.25) 
      if ( qsw(mgs) .gt. 1.0e-10 ) swdia(mgs) = xslop*(dnz(mgs)*qsw(mgs)/(swdn*xcnos))**(0.25)
      if ( qhw(mgs) .gt. 1.0e-10 ) hwdia(mgs) = xslop*(dnz(mgs)*qhw(mgs)/(hwdn*xcnoh))**(0.25)
!
      rwdia2(mgs) = rwdia(mgs)**2
      swdia2(mgs) = swdia(mgs)**2
      hwdia2(mgs) = hwdia(mgs)**2
!
      vtrbar(mgs) = xvtr*(dnz(mgs)**(-0.5))*(rwdia(mgs)**br)
      vtsbar(mgs) = xvts*(dnz(mgs)**(-0.5))*(swdia(mgs)**ds)
      vthbar(mgs) = xvth1*(dnz(mgs)**(-0.5))*(xvth3**2)*((hwdn*hwdia(mgs))**(0.5))
!     
      crw(mgs) = xcnor*rwdia(mgs)
      csw(mgs) = xcnos*swdia(mgs)
      chw(mgs) = xcnoh*hwdia(mgs)
!
 4301 continue

      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      if (itfall .eq. 2) then
!!!        do mgs = 1,ngscnt                                        !MSG Find max fallspeed for later
!!!         maxfall = max(maxfall,vtrbar(mgs))
!!!         maxfall = max(maxfall,vthbar(mgs))
!!!        enddo
!!!      endif

!
      do 5001 mgs = 1,ngscnt 
!
!  maximum depletion tendency by any one source
!
      qc5dt = 0.20*qcw(mgs)/dtp
      qi5dt = 0.20*qci(mgs)/dtp
      qr5dt = 0.20*qrw(mgs)/dtp
      qs5dt = 0.20*qsw(mgs)/dtp
      qh5dt = 0.20*qhw(mgs)/dtp

!
!  collection efficiencies
!
      eic(mgs) = 1.0
      eri(mgs) = 1.0
      erw(mgs) = 1.0
      esi(mgs) = exp(0.025*min(temcg(mgs),0.0))
      esicnv(mgs) = esi(mgs)
      esw(mgs) = 1.0
      ers(mgs) = 1.0
      ehw(mgs) = 1.0
      ehr(mgs) = 1.0
      ehs(mgs) = exp(0.09*min(temcg(mgs),0.0))
      ehscnv(mgs) = ehs(mgs)
      if ( temcg(mgs) .gt. 0.0 ) ehs(mgs) = 1.0
      ehi(mgs) = 0.1

      if ( qcw(mgs) .lt. qcmin .or. qci(mgs) .lt. qimin ) eic(mgs) = 0.0
      if ( qrw(mgs) .lt. qrmin .or. qci(mgs) .lt. qimin ) eri(mgs) = 0.0
      if ( qrw(mgs) .lt. qrmin .or. qcw(mgs) .lt. qcmin ) erw(mgs) = 0.0
      if ( qsw(mgs) .lt. qsmin .or. qci(mgs) .lt. qimin ) esi(mgs) = 0.0
      if ( qsw(mgs) .lt. qsmin .or. qcw(mgs) .lt. qcmin ) esw(mgs) = 0.0
      if ( qsw(mgs) .lt. qsmin .or. qrw(mgs) .lt. qrmin ) ers(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qcw(mgs) .lt. qcmin ) ehw(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qrw(mgs) .lt. qrmin ) ehr(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qsw(mgs) .lt. qsmin ) ehs(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qci(mgs) .lt. qimin ) ehi(mgs) = 0.0
!
!  accretions:
!    marshall-palmer size distribution collection 
!    of constant size distribution
!      1)  sink for constant size distribution
!      2)  source for marshall-palmer size distribution
!
      qracw(mgs) =  &
         min(erw(mgs)*qcw(mgs)*xacwi*crw(mgs)*abs(vtrbar(mgs)-vtwbar(mgs))  &
        *(  gf3*rwdia2(mgs) + 2.0*gf2*rwdia(mgs)*cwdia(mgs) + gf1*cwdia2(mgs) )      , qc5dt)
      qsacw(mgs) =  &
         min(esw(mgs)*qcw(mgs)*xacwi*csw(mgs)*abs(vtsbar(mgs)-vtwbar(mgs))  &
        *(  gf3*swdia2(mgs) + 2.0*gf2*swdia(mgs)*cwdia(mgs) + gf1*cwdia2(mgs) )      , qc5dt)
      qhacw(mgs) =  &
         min(ehw(mgs)*qcw(mgs)*xacwi*chw(mgs)*abs(vthbar(mgs)-vtwbar(mgs))  &
        *(  gf3*hwdia2(mgs) + 2.0*gf2*hwdia(mgs)*cwdia(mgs) + gf1*cwdia2(mgs) )      , qc5dt)
      qraci(mgs) =  &
         min(eri(mgs)*qci(mgs)*xacwi*crw(mgs)*abs(vtrbar(mgs)-vtibar(mgs))  &
        *(  gf3*rwdia2(mgs) + 2.0*gf2*rwdia(mgs)*cidia(mgs) + gf1*cidia2(mgs) )      , qi5dt)
      qsaci(mgs) =  &
         min(esi(mgs)*qci(mgs)*xacwi*csw(mgs)*abs(vtsbar(mgs)-vtibar(mgs))  &
        *(  gf3*swdia2(mgs) + 2.0*gf2*swdia(mgs)*cidia(mgs) + gf1*cidia2(mgs) )      , qi5dt)
      qhaci(mgs) =  &
        min(ehi(mgs)*qci(mgs)*xacwi*chw(mgs)*abs(vthbar(mgs)-vtibar(mgs))   &
        *(  gf3*hwdia2(mgs) + 2.0*gf2*hwdia(mgs)*cidia(mgs) + gf1*cidia2(mgs) )      , qi5dt)
      qiacr(mgs) =  &
        min(eri(mgs)*qrw(mgs)* xxacx*cci(mgs)*abs(vtrbar(mgs)-vtibar(mgs))   &
        *(  gf6*rwdia2(mgs) + 2.0*gf5*rwdia(mgs)*cidia(mgs) + gf4*cidia2(mgs) )      , qr5dt) 
!
!  accretions:
!    marshall-palmer size distribution collecting marshall-palmer size
!    distribution
!
      qhacs(mgs) =  &
         min( xxacx*abs(vthbar(mgs)-vtsbar(mgs))*ehs(mgs)*qsw(mgs)*chw(mgs)  &
        *(  gf6*gf1*swdia2(mgs) + 2.0*gf5*gf2*swdia(mgs)*hwdia(mgs) + gf4*gf3*hwdia2(mgs) ) , qs5dt)
      qhacr(mgs) =  &
         min( xxacx*abs(vthbar(mgs)-vtrbar(mgs))*ehr(mgs)*qrw(mgs)*chw(mgs)  &
        *(  gf6*gf1*rwdia2(mgs) + 2.0*gf5*gf2*rwdia(mgs)*hwdia(mgs) + gf4*gf3*hwdia2(mgs) ) , qr5dt)
      qracs(mgs) =  &
         min( xxacx*abs(vtrbar(mgs)-vtsbar(mgs))*ers(mgs)*qsw(mgs)*crw(mgs)  &
        *(  gf6*gf1*swdia2(mgs) + 2.0*gf5*gf2*swdia(mgs)*rwdia(mgs) + gf4*gf3*rwdia2(mgs) ) , qs5dt)
      qsacr(mgs) =  &
         min( xxacx*abs(vtrbar(mgs)-vtsbar(mgs))*ers(mgs)*qrw(mgs)*csw(mgs)  &
        *(  gf6*gf1*rwdia2(mgs) + 2.0*gf5*gf2*rwdia(mgs)*swdia(mgs) + gf4*gf3*swdia2(mgs) ) , qr5dt)
! 
!  bergeron process for snow
!
      ibb = min(max(1,int(-temcg(mgs))),32)
        cs9     = bsfw*dnz(mgs)*(0.001) 
      qsfw(mgs) = qci(mgs)*cs11(ibb)*(cs10(ibb) + eic(mgs)*cs9*qcw(mgs))
      qsfw(mgs) = min(qsfw(mgs),qc5dt)
      qsfi(mgs) = qci(mgs)/cbtim(ibb) 
      qsfi(mgs) = min(qsfi(mgs),qi5dt)
!
!  conversions
!
      qscni(mgs) = 0.001*esicnv(mgs)*max((qci(mgs)-qicrit),0.0)
      qscni(mgs) = min(qscni(mgs),qi5dt)
!
      qhcns(mgs) = 0.001*ehscnv(mgs)*max((qsw(mgs)-qscrit),0.0)
      qhcns(mgs) = min(qhcns(mgs),qs5dt)
!
      xrfrz(mgs) = 20.0*(pi**2)*brz*cwdn/dnz(mgs)
      qrfrz(mgs) = min(xrfrz(mgs)*crw(mgs)*(rwdia(mgs)**6)*(exp(max(-arz*temcg(mgs), 0.0))-1.0), qr5dt)

! Berry (1968) Autoconversion == 0 (critical qc) or ==1 (critical diameter from Ferrier 1994)

      IF( autoconversion .eq. 0 ) THEN
       qdiff  = max((qcw(mgs)-qcmincwrn),0.)
      ELSE
       qccrit = (pi/6.)*((ccw(mgs)*cwdiap**3)*cwdn)/dnz(mgs)
       qdiff  = max((qcw(mgs)-qccrit),0.)
      ENDIF

      qrcnw(mgs) =  0.0
      if ( qdiff .gt. 0.0 ) then
       argrcnw = ((1.2e-4)+(1.596e-12)*ccw(mgs)*(1e-6)/(dnz(mgs)*1.e-3*cwdisp*qdiff))
       qrcnw(mgs) = dnz(mgs)*1e-3*(qdiff**2)/argrcnw
       qrcnw(mgs) = (max(qrcnw(mgs),0.0))
      end if
      qrcnw(mgs) = min(qrcnw(mgs),qc5dt)
!
!  constants for hydrometeor-vapor interactions
!
      ssi(mgs) = qwv(mgs)/qis(mgs)
      ssw(mgs) = qwv(mgs)/qvs(mgs)
      tsqr(mgs) = temg(mgs)**2
!
!  melting of snow and hail
!
      xsv   = (xxmlt1*(swdia(mgs)) + xsmlt2(mgs)*(swdia(mgs)**((3.0+ds)/2.0)))
      xhv   = (xxmlt1*(hwdia(mgs)) + (hwdn**(0.25))*xvth3*xhmlt2(mgs)*(hwdia(mgs)**(1.75)))
      xmlt2 = wvdf(mgs)*elv*dnz(mgs)
      xhsw =(tka(mgs)*temcg(mgs) + xmlt2*(qwv(mgs)-pqs(mgs)))
      xmlt1 = -2.0*pi/(elf*dnz(mgs))
      qsmlr(mgs) = min( (xmlt1*csw(mgs)*xsv*xhsw + temcg(mgs)*xmlt3*(qsacr(mgs)+qsacw(mgs)) ) , 0.0 )
      qhmlr(mgs) = min( (xmlt1*chw(mgs)*xhv*xhsw + temcg(mgs)*xmlt3*(qhacr(mgs)+qhacw(mgs)) ) , 0.0 )
      qsmlr(mgs) = max( qsmlr(mgs), -qs5dt ) 
      qhmlr(mgs) = max( qhmlr(mgs), -qh5dt ) 
!
!  deposition/sublimation of snow and hail
!
      xbs   = (1.0/(dnz(mgs)*wvdf(mgs)))
      xxdsv = 2.0*pi/dnz(mgs)
      xds = xxdsv*(ssi(mgs)-1.0)*(1.0/(xas(mgs)/tsqr(mgs)+xbs/qis(mgs)))
      qsdsv(mgs) =   xds*csw(mgs)*xsv
      qhdsv(mgs) =   xds*chw(mgs)*xhv
      qhsbv(mgs) = max( min(qhdsv(mgs), 0.0), -qh5dt )
      qhdpv(mgs) = max( qhdsv(mgs), 0.0 )
      qssbv(mgs) = max( min(qsdsv(mgs), 0.0), -qs5dt )
      qsdpv(mgs) = max( qsdsv(mgs), 0.0 )

!
! SHEDDING CALCULATION
! New version by MSG closer to JMS original  - Last modified 4/6/03
!       
!
!  compute dry growth rate of hail regardless of location
!
      qhdry(mgs) = qhacr(mgs) + qhacw(mgs) + qhaci(mgs) + qhacs(mgs)
!
!  compute wet growth rate of hail regardless of location
!
      qhacip(mgs)= qhaci(mgs)		!ehi=0 case
      qhacsp(mgs)= qhacs(mgs)		!ehs=0 case
      IF ( ehi(mgs) .gt. 0.0 ) qhacip(mgs) = min(qhaci(mgs)/ehi(mgs),qi5dt)
      IF ( ehs(mgs) .gt. 0.0 ) qhacsp(mgs) = min(qhacs(mgs)/ehs(mgs),qs5dt)

      xcwt = 1.0/( elf +cw*temcg(mgs) )

      xhwet1 = 2.0*pi/dnz(mgs)
      xhwet2 = dnz(mgs)*elv*wvdf(mgs)
      xwt1   = xhwet2*(pqs(mgs)-qwv(mgs)) -tka(mgs)*temcg(mgs)

      qhwet(mgs) =  max( 0.0, ( xhv*chw(mgs)*xwt1*xhwet1*xcwt   &
                                + ( 1.0 -ci(mgs)*temcg(mgs)*xcwt )* ( qhacip(mgs)+qhacsp(mgs) )  )  )

!
!  evaluate shedding rate (effective range is 243 < T < 273 due to other "if" checks below)
!
      qhshr(mgs) = 0.0
      if ( qhwet(mgs) .lt. qhdry(mgs) .and. qhwet(mgs) .gt. 0.0 ) then
        qhdry(mgs) = 0.0                                        ! Wet growth
        qhshr(mgs) = qhwet(mgs) -(qhacw(mgs) +qhacr(mgs))
      else					                ! Dry growth (defaults here if qhwet<0)
        qhwet(mgs) = 0.0
        qhshr(mgs) = 0.0
      endif
!
!  Special shedding case when warmer than freezing
!
      if ( temg(mgs) .gt. tfr ) then 
        qhwet(mgs) = 0.0
        qhdry(mgs) = 0.0
        qhshr(mgs) =  -qhacr(mgs) -qhacw(mgs)-qhacip(mgs)-qhacsp(mgs)
      end if
!
!  Special no-shedding (dry) case when T<243....
!
      if ( temg(mgs) .lt. 243.15 ) then
       qhwet(mgs) = 0.0
       qhshr(mgs) = 0.0
      end if
!
!  Reset some vars if wet particle surface due to shedding....
!
      if ( qhshr(mgs) .lt. 0.0 ) then
       qhaci(mgs) = qhacip(mgs)
       qhacs(mgs) = qhacsp(mgs)
       qhdpv(mgs) = 0.0
       qhsbv(mgs) = 0.0
      end if

!
!  evaporation/condensation on wet snow and hail (NOT USED)
! 

!
!  evaporation of rain
!
      xxcev = 2.0*pi/dnz(mgs)
      xbv   = (1.0/(dnz(mgs)*wvdf(mgs)))
      xce = xxcev*(ssw(mgs)-1.0)*(1.0/(xav(mgs)/tsqr(mgs)+xbv/qvs(mgs)))
      xrv = (xrcev1*(rwdia(mgs)) +  xrcev2(mgs)*(rwdia(mgs)**((3.0+br)/2.0)))
      qrcev(mgs) = max(min(xce*crw(mgs)*xrv, 0.0), -qr5dt)
! 
!  vapor to pristine ice crystals 
!
      qiint(mgs) = 0.0
      IF ( ssi(mgs) .gt. 1.0 ) THEN
        dqisdt(mgs)= (qwv(mgs)-qis(mgs))/ (1.0 + xiint*qis(mgs)/tsqr(mgs))
        cnnt       = cci(mgs)
        qiint(mgs) = (1.0/dtp) *min((1.0e-12)*cnnt/dnz(mgs), 0.50*dqisdt(mgs)) 
      ENDIF
!
!  Domain totals for source terms 
!
!
!  vapor
!
      tvqssbv = tvqssbv - il5(mgs)*qssbv(mgs)*dnz(mgs)   
      tvqhsbv = tvqhsbv - il5(mgs)*qhsbv(mgs)*dnz(mgs)     
      tvqrcev = tvqrcev - qrcev(mgs)*dnz(mgs)             
      tvqcevp = tvqcevp + 0.0	
!     tvqisub = tvqisub + 0.0
!
!  cloud water
!
      tcqccnd = tcqccnd	+ 0.0	
      tcqcmli = tcqcmli	+ 0.0		
!
!  rain
!
      trqracw = trqracw + qracw(mgs)*dnz(mgs)           
      trqrcnw = trqrcnw + qrcnw(mgs)*dnz(mgs)            
      trqsacw = trqsacw + (1-il5(mgs))*qsacw(mgs)*dnz(mgs)
      trqsmlr = trqsmlr - (1-il5(mgs))*qsmlr(mgs)*dnz(mgs) 
      trqhmlr = trqhmlr - (1-il5(mgs))*qhmlr(mgs)*dnz(mgs)
      trqhshr = trqhshr - qhshr(mgs)*dnz(mgs)             
!
!  cloud ice
!
      tiqiint = tiqiint + il5(mgs)*qiint(mgs)*dnz(mgs) 	
      tiqidep = tiqidep + 0.0	
      tiqifzc = tiqifzc + 0.0		
!
!  snow
!
      tsqsacw = tsqsacw + il5(mgs)*qsacw(mgs)*dnz(mgs)    
      tsqscni = tsqscni + il5(mgs)*qscni(mgs)*dnz(mgs)     
      tsqsaci = tsqsaci + il5(mgs)*qsaci(mgs)*dnz(mgs)       
      tsqsfi  = tsqsfi  + il5(mgs)*qsfi(mgs) *dnz(mgs)      
      tsqsfw  = tsqsfw  + il5(mgs)*qsfw(mgs) *dnz(mgs)        
      tsqraci = tsqraci + il5(mgs)*il3(mgs)*qraci(mgs)*dnz(mgs)
      tsqiacr = tsqiacr + il5(mgs)*il3(mgs)*qiacr(mgs)*dnz(mgs)
      tsqsacr = tsqsacr + il5(mgs)*il2(mgs)*qsacr(mgs)*dnz(mgs)
      tsqsdpv = tsqsdpv + il5(mgs)*qsdpv(mgs)*dnz(mgs)         
!
!  hail/graupel
!
      thqhcns = thqhcns + qhcns(mgs)*dnz(mgs)			
      thqiacr = thqiacr + il5(mgs)*(1-il3(mgs))*qiacr(mgs)*dnz(mgs) 
      thqraci = thqraci + il5(mgs)*(1-il3(mgs))*qraci(mgs)*dnz(mgs) 
      thqracs = thqracs + il5(mgs)*(1-il2(mgs))*qracs(mgs)*dnz(mgs) 
      thqsacr = thqsacr + il5(mgs)*(1-il2(mgs))*qsacr(mgs)*dnz(mgs) 
      thqhdpv = thqhdpv + il5(mgs)*qhdpv(mgs)*dnz(mgs)             
      thqrfrz = thqrfrz + il5(mgs)*qrfrz(mgs)*dnz(mgs)   
!     thqhacr = thqhacr + qhacr(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04    
!     thqhacw = thqhacw + qhacw(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04   
!     thqhacs = thqhacs + qhacs(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04
!     thqhaci = thqhaci + qhaci(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04

!
!  hail/graupel and rain (based upon wet growth budget)  !MSG added on 2/6/04
!
!--     
      if ( temg(mgs) .ge. 273.15 ) then
       trqhaci = trqhaci + qhaci(mgs)*dnz(mgs)
       trqhacs = trqhacs + qhacs(mgs)*dnz(mgs)
      else
       thqhaci = thqhaci + qhaci(mgs)*dnz(mgs)
       thqhacs = thqhacs + qhacs(mgs)*dnz(mgs)
      endif

      if ((qhwet(mgs) .gt. 0.0).or.( temg(mgs) .ge. 273.15)) then 
       trqhacw = trqhacw + qhacw(mgs)*dnz(mgs)
       trqhacr = trqhacr + qhacr(mgs)*dnz(mgs)
      else
       thqhacw = thqhacw + qhacw(mgs)*dnz(mgs)
       thqhacr = thqhacr + qhacr(mgs)*dnz(mgs)
      endif

      thqhwet  = thqhwet + qhwet(mgs)*dnz(mgs)    !MSG qhwet is positive or zero here

!--     
!  end of totals
!
 5001 continue
!
 5002 continue
!
!
      if (ndebug .eq. 1 ) print*,'dbg = 8'

 
!  rain, snow, hail fluxes due to gravity    !MSG q3d() was ad() in SAM version
!
!  061013: Moved fallout code to CM1 solve.  Store vtbar info in vq array.
!
      do 5020 mgs = 1,ngscnt 
!!!      hwflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),lh)*vthbar(mgs)
!!!      piflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),li)*vtibar(mgs)
!!!      cwflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),lc)*vtwbar(mgs)
!!!      rwflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),lr)*vtrbar(mgs)
!!!      swflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),ls)*vtsbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),lh) = vthbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),li) = vtibar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),lc) = vtwbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),lr) = vtrbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),ls) = vtsbar(mgs)
 5020 continue

!
!  Compute total-domain content (g/m^3) before production rates
!
      do mgs = 1,ngscnt                        !MSG domain total of each species before microphysics
      tqvbp = tqvbp + qwvp(mgs)*dnz(mgs)
      tqcbp = tqcbp + qcw(mgs)*dnz(mgs)
      tqibp = tqibp + qci(mgs)*dnz(mgs)
      tqrbp = tqrbp + qrw(mgs)*dnz(mgs)
      tqsbp = tqsbp + qsw(mgs)*dnz(mgs)
      tqhbp = tqhbp + qhw(mgs)*dnz(mgs)
      sumb = sumb+tqvbp+tqcbp+tqibp+tqrbp+tqsbp+tqhbp
      end do

!
! CALCULATE RATE TOTALS
!
      do 9000 mgs = 1,ngscnt

!
      pqwvi(mgs) =  il5(mgs)*( -qhsbv(mgs) -qssbv(mgs)              )           - qrcev(mgs)
      pqwvd(mgs) =  il5(mgs)*( -qhdpv(mgs) -qsdpv(mgs) - qiint(mgs) ) 
!
      pqcii(mgs) =  il5(mgs)*qiint(mgs) 
      pqcid(mgs) =  il5(mgs)*( -qscni(mgs) -qsaci(mgs) -qraci(mgs) -qsfi(mgs))  - qhaci(mgs)  
!
      pqcwi(mgs) =  0.0
      pqcwd(mgs) =  (-il5(mgs)*qsfw(mgs))  -qracw(mgs) -qsacw(mgs) -qrcnw(mgs) -qhacw(mgs)
!
      pqrwi(mgs) =  qracw(mgs) +qrcnw(mgs) +(1-il5(mgs))*(qsacw(mgs)-qhmlr(mgs) -qsmlr(mgs)) -qhshr(mgs)
      pqrwd(mgs) =  il5(mgs)*(-qiacr(mgs) -qrfrz(mgs)  -qsacr(mgs)) +qrcev(mgs) -qhacr(mgs)
!
      pqswi(mgs) =  il5(mgs)*( qsacw(mgs) +qscni(mgs) +qsaci(mgs) + qsfi(mgs) +qsfw(mgs)    &
                               +il3(mgs)*(qraci(mgs) +qiacr(mgs)) +il2(mgs)*qsacr(mgs) +qsdpv(mgs)     )
      pqswd(mgs) = -qhcns(mgs) -qhacs(mgs) +(1-il5(mgs))*qsmlr(mgs)  +il5(mgs)*(qssbv(mgs) -(1-il2(mgs))*qracs(mgs)) 
!
      pqhwi(mgs) =  qhcns(mgs) +qhacr(mgs) +qhacw(mgs) +qhacs(mgs) +qhaci(mgs)   &
         + il5(mgs)*( (1-il3(mgs))*(qraci(mgs)+qiacr(mgs)) +(1-il2(mgs))*(qsacr(mgs)+qracs(mgs))+qhdpv(mgs)+qrfrz(mgs))
      pqhwd(mgs) =  qhshr(mgs) +(1-il5(mgs))*qhmlr(mgs) + il5(mgs)*qhsbv(mgs)
!
      ptotal(mgs) = pqwvi(mgs) +pqwvd(mgs) + pqcwi(mgs) +pqcwd(mgs) + pqcii(mgs) +pqcid(mgs) +   &
                    pqrwi(mgs) +pqrwd(mgs) + pqswi(mgs) +pqswd(mgs) + pqhwi(mgs) +pqhwd(mgs) 
!
      if (ndebug .eq. 1) then
       if(abs(ptotal(mgs)).gt.1.e-7)then
         print*,'NOTICE:PTOTAL>1e-7 ', mgs, kgs(mgs), ptotal(mgs)
       end if
      endif
!
      psum = psum + ptotal(mgs)
!
 9000 continue
!
!
!  latent heating from phase changes (except qcw, qci cond, and evap)
!   (22 processes involve phase changes, 10 do not)
!
      do 9010 mgs = 1,ngscnt
      pfrz(mgs) = (1.-il5(mgs))*(qhmlr(mgs) + qsmlr(mgs))   &
                + ( il5(mgs)  )*(qiacr(mgs)+qsacr(mgs)+ qsfw(mgs)+qrfrz(mgs)+qsacw(mgs)+qhacw(mgs)+qhacr(mgs)+qhshr(mgs))
      psub(mgs) = ( il5(mgs)  )*(qhdpv(mgs)+qhsbv(mgs)+qiint(mgs)+qsdpv(mgs)+qssbv(mgs))
      pvap(mgs) = qrcev(mgs)
      ptem(mgs) = cc3(mgs)*pfrz(mgs) + cc5(mgs)*psub(mgs) + cc4(mgs)*pvap(mgs)
      thetap(mgs) = thetap(mgs) + dtp*ptem(mgs)

!
!  partitioned domain-total heating and cooling rates 
!  (all are adjusted again later within saturation adjustment)
!

      hfrz  = hfrz  + ( qiacr(mgs)+qsacr(mgs)+qsfw(mgs)+qsacw(mgs)   &
                       +qhacw(mgs)+qhacr(mgs)+qhshr(mgs)+qrfrz(mgs))*il5(mgs)*cc3(mgs)
      hdep  = hdep  + (qiint(mgs)+qhdpv(mgs)+qsdpv(mgs))*il5(mgs)*cc5(mgs)
      hcnd  = hcnd  + 0.0
      cevap = cevap +  qrcev(mgs)                          *cc4(mgs)
      cmelt = cmelt + (qhmlr(mgs)+qsmlr(mgs))*(1.-il5(mgs))*cc3(mgs)
      csub  = csub  + (qhsbv(mgs)+qssbv(mgs))*il5(mgs)     *cc5(mgs)

 9010 continue
 9004 continue
!
!  sum the sources and sinks for qwvp, qcw, qci, qrw, qsw
!
      do 9100 mgs = 1,ngscnt
      qwvp(mgs)= qwvp(mgs) + dtp*(pqwvi(mgs)+pqwvd(mgs))      !initial qwvp is being adjusted by all source/sink
      qcw(mgs) = qcw(mgs) +  dtp*(pqcwi(mgs)+pqcwd(mgs)) 
      qci(mgs) = qci(mgs) +  dtp*(pqcii(mgs)+pqcid(mgs)) 
      qrw(mgs) = qrw(mgs) +  dtp*(pqrwi(mgs)+pqrwd(mgs)) 
      qsw(mgs) = qsw(mgs) +  dtp*(pqswi(mgs)+pqswd(mgs)) 
      qhw(mgs) = qhw(mgs) +  dtp*(pqhwi(mgs)+pqhwd(mgs)) 
      
 9100 continue
!
!  domain-total content (g/m^3) before saturation adjustment
!
      do mgs = 1,ngscnt
      tqvap = tqvap + qwvp(mgs)*dnz(mgs)
      tqcap = tqcap + qcw(mgs)*dnz(mgs)
      tqiap = tqiap + qci(mgs)*dnz(mgs)
      tqrap = tqrap + qrw(mgs)*dnz(mgs)
      tqsap = tqsap + qsw(mgs)*dnz(mgs)
      tqhap = tqhap + qhw(mgs)*dnz(mgs)
      suma = suma+tqvap+tqcap+tqiap+tqrap+tqsap+tqhap
      end do


! 
      if (ndebug .eq. 1 ) print*,'dbg = 10a'
      
!
!  set up temperature and vapor arrays
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.1'
!
      do mgs = 1,ngscnt
       pqs(mgs) = (380.0)/(pres(mgs))
       theta(mgs) = thetap(mgs) + theta0(mgs)
       qvap(mgs) = max( (qwvp(mgs) + qv0n(mgs)), 0.0 )         !MSG Current total qwv
       temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** rcp
      end do
!
!  melting of cloud ice
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.2'
!
      do mgs = 1,ngscnt
      if( temg(mgs) .gt. tfr .and. qci(mgs) .gt. 0.0 ) then
        qimlw(mgs) = - qci(mgs)/dtp                         !MSG Rate of cloudice melting
        tcqcmli = tcqcmli - qimlw(mgs)*dnz(mgs)        !MSG updated 11/22/03 (domain-total rate of qc increase)
        thetap(mgs) = thetap(mgs) - cc3(mgs)*qci(mgs)  !MSG heat decrease
        cmelt   = cmelt   + cc3(mgs)*qimlw(mgs)        !MGS cooling rate
        qcw(mgs) = qcw(mgs) + qci(mgs)
        qci(mgs) = 0.0
      end if
      end do
!
!
!  homogeneous freezing of cloud water
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.3'
!
      do mgs = 1,ngscnt
      if( temg(mgs) .lt. thnuc .and. qcw(mgs) .gt. 0.0 ) then
        qwfzi(mgs)  = -qcw(mgs)/dtp                         ! MSG Rate of clouwater freezing
        tiqifzc = tiqifzc - qwfzi(mgs)*dnz(mgs)        ! MSG updated 11/22/03 (domain-total rate of qi increase)
        thetap(mgs) = thetap(mgs) + cc3(mgs)*qcw(mgs)  ! MSG heat increase
        hfrz    = hfrz    + cc3(mgs)*(-qwfzi(mgs))     ! MSG heating rate
        qci(mgs) = qci(mgs) + qcw(mgs)
        qcw(mgs) = 0.0
      end if
      end do

!
!  Saturation adjustment iteration procedure
!
!  Modified Straka adjustment (nearly identical to Tao et al. 1989 MWR)
!
!

!
!  reset temporaries for cloud particles and vapor
!

      if ( ndebug .eq. 1 ) print*,'dbg = 10.4'
      do mgs = 1,ngscnt
       ptotsat(mgs) = 0.0
       qwv(mgs) = max( 0.0, qvap(mgs) )
       qcw(mgs) = max( 0.0, qcw(mgs) )
       qci(mgs) = max( 0.0, qci(mgs) )
       ptotsat(mgs) = qwv(mgs)+qci(mgs)+qcw(mgs)       !MSG updated just before sat adj. (qwv+qci+qcw)
       qcevpcnd(mgs) = 0.0
       qisubdep(mgs) = 0.0
      end do
!
      tqvb = tqvap              !MSG domain-total vapor perturb. prior to sat adj.
      do mgs = 1,ngscnt         !MSG domain-total qcw and qci prior to sat adj.
       tqcb = tqcb + qcw(mgs)*dnz(mgs)
       tqib = tqib + qci(mgs)*dnz(mgs)
      enddo

      do mgs = 1,ngscnt
       theta(mgs) = thetap(mgs) + theta0(mgs)
       temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** rcp
       temcg(mgs) = temg(mgs) - tfr
       ltemq = nint((temg(mgs)-163.15)/fqsat+1.5)
       ltemq = min(max(ltemq,1),nqsat) 
       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
       qis(mgs) = pqs(mgs)*tabqis(ltemq)
       if ( temg(mgs) .lt. tfr ) then
        if( qcw(mgs) .ge. 0.0 .and. qci(mgs) .eq. 0.0 ) qss(mgs) = qvs(mgs)
        if( qcw(mgs) .eq. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = qis(mgs)
        if( qcw(mgs) .gt. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = (qcw(mgs)*qvs(mgs) + qci(mgs)*qis(mgs))   &	
                                                                 / (qcw(mgs) + qci(mgs))
       else
        qss(mgs) = qvs(mgs)
       end if
      end do
!
!  iterate  adjustment
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.5'
      do itertd = 1,2
!
      do mgs = 1,ngscnt
!
!  calculate super-saturation
!
      dqcw(mgs) = 0.0
      dqci(mgs) = 0.0
      dqwv(mgs) = ( qwv(mgs) - qss(mgs) )
!
!  evaporation and sublimation adjustment
!
      if( dqwv(mgs) .lt. 0. ) then
       if( qcw(mgs) .gt. -dqwv(mgs) ) then		!Evap some of qc
         dqcw(mgs) = dqwv(mgs)
         dqwv(mgs) = 0.
       else						!Evap all of qc
         dqcw(mgs) = -qcw(mgs)
         dqwv(mgs) = dqwv(mgs) + qcw(mgs)
       end if
!
       if( qci(mgs) .gt. -dqwv(mgs) ) then		!Sublimate some of qi
         dqci(mgs) = dqwv(mgs)
         dqwv(mgs) = 0.
       else						!Sublimate all of qi
         dqci(mgs) = -qci(mgs)
         dqwv(mgs) = dqwv(mgs) + qci(mgs)
       end if
!
       qwvp(mgs) = qwvp(mgs) - ( dqcw(mgs) + dqci(mgs) )	!Increase vapor
      
       qcw(mgs) = qcw(mgs) + dqcw(mgs)			!Decrease cloudwater (dqcw<0)
       qci(mgs) = qci(mgs) + dqci(mgs) 			!Decrease cloudice   (dqci<0)
       thetap(mgs) = thetap(mgs) + cpi/pi0n(mgs)*(elv*dqcw(mgs) +els*dqci(mgs))
       qcevpcnd(mgs) = qcevpcnd(mgs) + (dqcw(mgs)/dtp)
       qisubdep(mgs) = qisubdep(mgs) + (dqci(mgs)/dtp)
      end if
!
! condensation/deposition
!
      if( dqwv(mgs) .ge. 0. ) then
!
       fracl(mgs) = 1.0
       fraci(mgs) = 0.0
       if ( temg(mgs) .lt. tfr .and. temg(mgs) .gt. thnuc ) then
        fracl(mgs) = max(min(1.,(temg(mgs)-233.15)/(20.)),0.0)
        fraci(mgs) = 1.0-fracl(mgs)
       end if
       if ( temg(mgs) .le. thnuc ) then
        fraci(mgs) = 1.0
        fracl(mgs) = 0.0
       end if
       fraci(mgs) = 1.0-fracl(mgs)
!
      gamss = (elv*fracl(mgs) + els*fraci(mgs))/ (pi0n(mgs)*cp)
!
      if ( temg(mgs) .lt. tfr ) then
       if (qcw(mgs) .ge. 0.0 .and. qci(mgs) .le. 0.0 ) then
         dqvcnd(mgs) = dqwv(mgs)/(1. + cqv1*qss(mgs)/((temg(mgs)-cbw)**2))
       end if
       if( qcw(mgs) .eq. 0.0 .and. qci(mgs) .gt. 0.0 ) then
         dqvcnd(mgs) = dqwv(mgs)/(1. + cqv2*qss(mgs)/((temg(mgs)-cbi)**2))
       end if
       if ( qcw(mgs) .gt. 0.0 .and. qci(mgs) .gt. 0.0 ) then
        cdw = caw*pi0n(mgs)*tfrcbw/((temg(mgs)-cbw)**2)
        cdi = cai*pi0n(mgs)*tfrcbi/((temg(mgs)-cbi)**2)
        denom1 = qcw(mgs) + qci(mgs)
        denom2 = 1.0 + gamss*(qcw(mgs)*qvs(mgs)*cdw + qci(mgs)*qis(mgs)*cdi) / denom1
        dqvcnd(mgs) =  dqwv(mgs) / denom2
       end if
      end if

      if ( temg(mgs) .ge. tfr ) then
        dqvcnd(mgs) = dqwv(mgs)/(1. + cqv1*qss(mgs)/ ((temg(mgs)-cbw)**2))
      end if
!
      dqcw(mgs) = dqvcnd(mgs)*fracl(mgs)
      dqci(mgs) = dqvcnd(mgs)*fraci(mgs)
!
      thetap(mgs) = thetap(mgs) + (elv*dqcw(mgs) + els*dqci(mgs))/ (pi0n(mgs)*cp)
      qwvp(mgs) = qwvp(mgs) - ( dqvcnd(mgs) )		!Decrease vapor
      qcw(mgs) = qcw(mgs) + dqcw(mgs)			!Increase cloudwater (dqcw>0)
      qci(mgs) = qci(mgs) + dqci(mgs)			!Increase cloudice   (dqci>0)

      qcevpcnd(mgs) = qcevpcnd(mgs) + (dqcw(mgs)/dtp)
      qisubdep(mgs) = qisubdep(mgs) + (dqci(mgs)/dtp)
      
!
      end if
      end do
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.51'
      do mgs = 1,ngscnt
       theta(mgs) = thetap(mgs) + theta0(mgs)
       temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** rcp
       qvap(mgs) =max((qwvp(mgs) + qv0n(mgs)), 0.0)
       temcg(mgs) = temg(mgs) - tfr

       ltemq = nint((temg(mgs)-163.15)/fqsat+1.5)
       ltemq = min(max(ltemq,1),nqsat)
       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
       qis(mgs) = pqs(mgs)*tabqis(ltemq)
       qcw(mgs) = max( 0.0, qcw(mgs) )
       qwv(mgs) = max( 0.0, qvap(mgs))
       qci(mgs) = max( 0.0, qci(mgs) )      !MSG 
      
       if ( temg(mgs) .lt. tfr ) then
        if( qcw(mgs) .ge. 0.0 .and. qci(mgs) .eq. 0.0 ) qss(mgs) = qvs(mgs)
        if( qcw(mgs) .eq. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = qis(mgs)
        if( qcw(mgs) .gt. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = (qcw(mgs)*qvs(mgs) + qci(mgs)*qis(mgs))   &
                                                               / (qcw(mgs) + qci(mgs))
       else
        qss(mgs) = qvs(mgs)
       end if
      end do
      if ( ndebug .eq. 1 ) print*,'dbg = 10.52'
!
!  end the saturation adjustment iteration loop
!
      end do
      if ( ndebug .eq. 1 ) print*,'dbg = 10.6'

      do mgs = 1,ngscnt                     !MSG net at each gpt after all sat adj. iterations are finished
       qcevp(mgs) = min(qcevpcnd(mgs),0.)  ! qcevp <=0
       qisub(mgs) = min(qisubdep(mgs),0.)  ! qisub <=0
       qccnd(mgs) = max(qcevpcnd(mgs),0.)  ! qccnd >=0
       qidep(mgs) = max(qisubdep(mgs),0.)  ! qidep >=0
      end do

      do mgs = 1,ngscnt
       tcqccnd = tcqccnd + qccnd(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total condensation
       tvqcevp = tvqcevp - qcevp(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total qc evaporation
       tvqisub = tvqisub - qisub(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total sublimation
       tiqidep = tiqidep + qidep(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total deposition

          hcnd = hcnd    + qccnd(mgs)*cc4(mgs)    ! MSG Update domain-total heating rate via qc condensation
         cevap = cevap   + qcevp(mgs)*cc4(mgs)    ! MSG Update domain-total cooling rate via qc evap
          csub = csub    + qisub(mgs)*cc5(mgs)    ! MSG Update domain-total cooling rate via qi sublim
          hdep = hdep    + qidep(mgs)*cc5(mgs)    ! MSG Update domain-total heating rate via qi deposition
      end do

!
!  Compute vapor, ice, and cloud totals after saturation adjustment.  
!            
      if (ndebug .eq. 1 ) then
       do mgs = 1,ngscnt
        if(abs(ptotsat(mgs)-qwv(mgs)-qci(mgs)-qcw(mgs)).gt.1.e-7)then
         print*,'NOTICE:PTOTSAT>1e-7 ', mgs, kgs(mgs), ptotsat(mgs),qwv(mgs),qci(mgs),qcw(mgs)
        end if
       end do
      end if

      if (ndebug .eq. 1 ) print*,'dbg = 10b'
! 
      do mgs = 1,ngscnt
        tqva = tqva + qwvp(mgs)*dnz(mgs)
        tqca = tqca +  qcw(mgs)*dnz(mgs)
        tqia = tqia +  qci(mgs)*dnz(mgs)
      end do

      tqv=tqva-tqvb          ! Change in vapor due to sat adj. (Should equal +tvqcevp+tvqisub-tiqidep-tcqccnd  )
      tqc=tqca-tqcb          ! Change in cloud due to sat adj. (Should equal +tcqccnd+tcqcmli-tvqcevp-tiqifzc  )
      tqi=tqia-tqib          ! Change in ice due to sat adj.   (Should equal +tiqidep+tiqifzc-tvqisub-tcqcmli  )
!
!
!
!  end of saturation adjustment
!
!  scatter precipitation fluxes, and thetap, and hydrometeors
!
!DIR$ IVDEP
      do 4001 mgs = 1,ngscnt
      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      pflux(igs(mgs),kgs(mgs)) = piflx(mgs)
!!!      cflux(igs(mgs),kgs(mgs)) = cwflx(mgs)
!!!      rflux(igs(mgs),kgs(mgs)) = rwflx(mgs)
!!!      sflux(igs(mgs),kgs(mgs)) = swflx(mgs)
!!!      hflux(igs(mgs),kgs(mgs)) = hwflx(mgs)
      th3d(igs(mgs),jy,kgs(mgs))  =  thetap(mgs) 
      q3d(igs(mgs),jy,kgs(mgs),lv) = ab(kgs(mgs),2) +   qwvp(mgs) 
      q3d(igs(mgs),jy,kgs(mgs),lc) = qcw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),lc), 0.0 ) !MSG putting any neg Gibbs values back
      q3d(igs(mgs),jy,kgs(mgs),li) = qci(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),li), 0.0 )  
      q3d(igs(mgs),jy,kgs(mgs),lr) = qrw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),lr), 0.0 )  
      q3d(igs(mgs),jy,kgs(mgs),ls) = qsw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),ls), 0.0 )  
      q3d(igs(mgs),jy,kgs(mgs),lh) = qhw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),lh), 0.0 )  
 4001 continue
!
!
 9998 continue
!
!---------------------------------
! new, 071008, GHB (from MSG):
      if ( (ix+1 .gt. nx-istag) .and. &   ! x&z at end. Exit.       !MSG Corrected logic on 5 Oct 2007
           (kz+1 .gt. nz-kstag-1) ) then
        go to 1200
      else if (ix+1 .gt. nx-istag ) then  ! x at end. Reset x & inc z
        nzmpb = kz+1 
        nxmpb = 1
      else                                ! none at the end.  Inc x.
        nzmpb = kz 
        nxmpb = ix+1
      end if
!---------------------------------
! 061023, GHB:  dunno why the "kstag-1" is here ... removing the -1
!!!      if ( kz .gt. nz-kstag-1 .and. ix .gt. nx-istag ) then
!  old code:
!      if ( kz .gt. nz-kstag .and. ix .gt. nx-istag ) then
!        go to 1200
!      else
!        nzmpb = kz 
!      end if
!      
!      if ( ix+1 .gt. nx ) then
!        nxmpb = 1
!      else
!        nxmpb = ix+1
!      end if
!---------------------------------
      
 1000 continue      !MSG  end of numgs loop
 1200 continue
!
!  end of gather scatter
!
!  precipitation fallout contributions 
!  MSG Technically we probably should really be re-computing the fluxes based upon new mixing ratio's but we don't.
!
      ! GHB, 061013:  fallout is now computed in CM1 solve.

!      if (itfall .gt. 0) then
!       dtsplit = dtp
!       nrnstp  = 1
!
!       if (itfall .eq. 2) then  ! COMPUTE SPLIT-EXPLICIT TIME STEP USING MAX FALLSPEED OF ANY SPECIES IN THE SLICE
!        vtrdzmax = dtp*dzc(kz)*maxfall   ! Courant Number
!        nrnstp = 1 + aint(2.*vtrdzmax)   ! MSG Define number of small steps based upon
!                                         ! fastest falling particles (rain or hail/graupel)
!                                         ! nrnstp for 1 + aint(2*0.45) = 1 (use original timestep)
!                                         ! whereas 1+aint(2*0.55) = 2 (requiring dtp be split into
!                                         ! two smaller timesteps.) Thus if courant number, vtrdzmax>=0.5,
!                                         ! then automatically uses 2 small steps (0.25 courant each).
!                                         ! If vtrdzmax=1.0, then uses 3 small steps (0.33 courant each).
!                                         ! If vtrdzmax=1.5, then uses 4 small steps (0.25 courant, Etc.)
!                                         ! Thus the actual fallout courant ranges 0.25 to 0.5
!        dtsplit = dtp / float( nrnstp )  ! MSG Define small timestep (sec)
!       endif
!
!       DO inrnstp = 1,nrnstp            ! MSG BEGIN OF TIMESPLITTING
!        if (ndebug .eq. 1 ) print*,'dbg = 10g'
! 061023, GHB:  dunno why the "kstag-1" is here ... removing the -1
!!!!        do kz = 1,nz-kstag-1 
!        do kz = 1,nz-kstag
!        do ix = 1,nx-istag
!!         dtz1 = dzc(kz)*dtp/1.0        !MSG old version before timesplitting
!          dtz1 = dzc(kz)*dtsplit
!          q3d(ix,jy,kz,li) = q3d(ix,jy,kz,li) + dtz1*(pflux(ix,kz+1)-pflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,lc) = q3d(ix,jy,kz,lc) + dtz1*(cflux(ix,kz+1)-cflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,lr) = q3d(ix,jy,kz,lr) + dtz1*(rflux(ix,kz+1)-rflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,ls) = q3d(ix,jy,kz,ls) + dtz1*(sflux(ix,kz+1)-sflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,lh) = q3d(ix,jy,kz,lh) + dtz1*(hflux(ix,kz+1)-hflux(ix,kz))/db(kz)
!        enddo
!        enddo
!       ENDDO      !MSG End of timesplitting on fallout
!
!      endif     !end of itfall check


!
!
!  end of jy loop
!
 9999 continue
!
!
      if (ndebug .eq. 1 ) print*,'dbg = 10h'
!
!
!  WRITE totals for source / sink terms
      if (nrates .eq. 1 ) then
!
        tvsum  = tvqrcev -tiqiint -thqhdpv -tsqsdpv +tvqhsbv +tvqssbv
        tcsum  = -tsqsfw -thqhacw -trqrcnw -trqracw -tsqsacw -trqsacw
        trsum  = -tvqrcev -thqhacr +trqrcnw -thqrfrz +trqhshr +trqhmlr +trqsmlr -tsqiacr -thqiacr -tsqsacr -thqsacr   &
                 +trqracw +trqsacw
        tisum  = -tsqsfi -thqhaci -tsqscni +tiqiint -tsqraci -thqraci  -tsqsaci
        tssum  = tsqsfw +tsqsfi -thqhacs +tsqscni -thqhcns -trqsmlr +tsqiacr +tsqraci +tsqsacr +tsqsdpv -tvqssbv      &
                +tsqsaci +tsqsacw -thqracs
        thsum  = thqhacw +thqhacr +thqhacs +thqhaci +thqhcns +thqrfrz -trqhshr -trqhmlr +thqiacr +thqraci +thqsacr +thqhdpv   &
                 +thqracs -tvqhsbv
        tsumall =  tvsum + tcsum + tisum + trsum + tssum + thsum        !MSG gives ~1e-9 (machine precision)
!
        if (ndebug .eq. 1) then    ! MSG only print details if debugging on
!
        write(6,*) 'Sum species source/sink domain totals for all but Sat. Adj. (kg s^-1 m^-3)'
        write(6,*) 'qv', tvsum            ! Total rate for qv (not including sat adj.)
        write(6,*) 'qc', tcsum
        write(6,*) 'qi', tisum
        write(6,*) 'qr', trsum
        write(6,*) 'qs', tssum
        write(6,*) 'qh', thsum
!
        write(6,*) 'Sum only for saturation adjustment (kg s^-1 m^-3)'
        write(6,*) 'qv', tqv              !MSG total change in vapor only due to sat adj.
        write(6,*) 'qc', tqc              !MSG change in cloud only due to sat adj.
        write(6,*) 'qi', tqi              !MSG change in ice only due to sat adj.
!
        write(6,*) 'Sum all species but not sat. adj. (kg s^-1 m^-3)'
        write(6,*) 'sum', tsumall         !MSG - all sources/sink rates except for sat adj.(comes from tsum rates)
!       write(6,*) 'psum', psum           !MSG - all sources/sink rates except for sat adj.(comes from model rates)
!       write(6,*) 'sumchange', suma-sumb !MSG - change in content (g/m^3) over timestep (not incl. sat adj.)
!
        write(6,*) 'Sum of all rates (kg s^-1 m^-3)'
        write(6,*) 'tsa', tsumall+tqv+tqc+tqi  !MSG all source/sink rates including sat adj.
!       write(6,*) 'psa', psum+tqv+tqc+tqi     !MSG all source/sink rates including sat adj.
!
!       write(6,*) 'tqvp',tqvap-tqvbp          !Changes due to all (except sat adj or fallout)
!       write(6,*) 'tqcp',tqcap-tqcbp
!       write(6,*) 'tqip',tqiap-tqibp
!       write(6,*) 'tqrp',tqrap-tqrbp
!       write(6,*) 'tqsp',tqsap-tqsbp
!       write(6,*) 'tqhp',tqhap-tqhbp
!
        endif
!
!
        write(6,*) 'Individual domain total rates (kg s^-1 m^-3)'
        write(6,*) 'Using Gilmore et al. (2004b) terminology'
        write(6,*) 'vapor sources'
!
        write(6,*) 'qvevr ' , tvqrcev 
        write(6,*) 'qvevw ' , tvqcevp 
        write(6,*) 'qvsbi ' , tvqisub 
        write(6,*) 'qvsbs ' , tvqssbv 
        write(6,*) 'qvsbh ' , tvqhsbv 
!
        write(6,*) 'cloud water sources'
!
        write(6,*) 'qwcdv ' , tcqccnd 
        write(6,*) 'qwmli ' , tcqcmli 
!
        write(6,*) 'rain sources'
!
        write(6,*) 'qrhacr' , trqhacr     !Added 2/6/04  (rain accreted and shed during same timestep)
        write(6,*) 'qrmlh ' , trqhmlr 
        write(6,*) 'qracw ' , trqracw 
        write(6,*) 'qrcnw ' , trqrcnw 
!       write(6,*) 'qrshh ' , trqhshr      !MSG ambiguous since sign can switch. Instead, use 4 individual terms (2/6/04)
        write(6,*) 'qrhacw' , trqhacw     !Added 2/6/04  (from shedding)
        write(6,*) 'qrhacs' , trqhacs     !Added 2/6/04  (from shedding)
        write(6,*) 'qrmls ' , trqsmlr 
        write(6,*) 'qrsacw' , trqsacw
        write(6,*) 'qrhaci' , trqhaci     !Added 2/6/04  (from shedding)
!
        write(6,*) 'cloud ice sources'
!
        write(6,*) 'qidpv ' , tiqidep
        write(6,*) 'qiint ' , tiqiint 
        write(6,*) 'qifzw ' , tiqifzc 
!
        write(6,*) 'snow sources'
!
        write(6,*) 'qsfi  ' , tsqsfi 
        write(6,*) 'qsacw ' , tsqsacw
        write(6,*) 'qsaci ' , tsqsaci
        write(6,*) 'qsdpv ' , tsqsdpv
        write(6,*) 'qsiacr' , tsqiacr
        write(6,*) 'qsacr ' , tsqsacr
        write(6,*) 'qsfw  ' , tsqsfw 
        write(6,*) 'qsraci' , tsqraci
        write(6,*) 'qscni ' , tsqscni
!
        write(6,*) 'hail sources'
!
        write(6,*) 'qhacw ' , thqhacw   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhacr ' , thqhacr   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhdpv ' , thqhdpv
        write(6,*) 'qhsacr' , thqsacr
        write(6,*) 'qhwtr ' , thqhwet   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhacs ' , thqhacs   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhfzr ' , thqrfrz
        write(6,*) 'qhaci ' , thqhaci   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhracs' , thqracs
        write(6,*) 'qhcns ' , thqhcns
        write(6,*) 'qhiacr' , thqiacr
        write(6,*) 'qhraci' , thqraci
!
        write(6,*) 'total heating and cooling rates'
!
        write(6,*) 'hfrz'    , hfrz
        write(6,*) 'hdep'    , hdep
        write(6,*) 'hcnd'    , hcnd
        write(6,*) 'cmelt'   , cmelt
        write(6,*) 'cevap'   , cevap
        write(6,*) 'csub'    , csub
      endif
! 
!
!
      if (ndebug .eq. 1 ) print*,'dbg = 11a'

      return
      end
!
!  end of subroutine
!
!--------------------------------------------------------------------------
!
!--------------------------------------------------------------------------
! Routine from Numerical Recipes to replace other gamma function
!  using 32-bit reals, this is accurate to 6th decimal place.

!     REAL FUNCTION GAMMA(xx)

!     implicit none
!     real xx
!     integer j

! Double precision ser,stp,tmp,x,y,cof(6)

!     real*8 ser,stp,tmp,x,y,cof(6)
!     SAVE cof,stp
!     DATA cof,stp/76.18009172947146d+0,
!    $            -86.50532032941677d0,
!    $             24.01409824083091d0,
!    $             -1.231739572450155d0,
!    $              0.1208650973866179d-2,
!    $             -0.5395239384953d-5,
!    $              2.5066282746310005d0/

!     x = xx
!     y = x
!     tmp = x + 5.5d0
!     tmp = (x + 0.5d0)*Log(tmp) - tmp
!     ser = 1.000000000190015d0
!     DO j=1,6
!       y = y + 1.0d0
!       ser = ser + cof(j)/y
!     END DO
!     gamma = Exp(tmp + log(stp*ser/x))

!     RETURN
!     END

!--------------------------------------------------------------------------

      subroutine lfoice_init(dtp)
      implicit none

      include 'lfoice.incl'

      real, intent(in) :: dtp

      outfile=6
#ifdef MPI
      outfile=10
#endif

!
!  constants
!
      poo = 1.0e+05
      ar = 841.99666  
      br = 0.8
      bta1 = 0.6
      cnit = 1.0e-02
      dnz00 = 1.225
      rho00 = 1.225
      cs = 4.83607122
      ds = 0.25
      pi = 4.0*atan(1.0)
      pid4 = pi/4.0 
      qccrit = 2.0e-03
      qscrit = 6.0e-04
      qicrit = 1.0e-03
!      
! Define gamma functions
!
      gf1 = 1.0      !gamma(1.0)
      gf2 = 1.0      !gamma(2.0)
      gf3 = 2.0      !gamma(3.0)
      gf4 = 6.0      !gamma(4.0)
      gf5 = 24.0     !gamma(5.0)
      gf6 = 120.0    !gamma(6.0)
      gf4br = 17.837862  !gamma(4.0+br)
      gf4ds = 8.2850851  !gamma(4.0+ds)
      gf5br = 1.8273551  !gamma((5.0+br)/2.)
      gf5ds = 1.4569332  !gamma((5.0+ds)/2.)
      gf2p75= 1.6083594  !gamma(2.75)
      gf4p5 = 11.631728  !gamma(4.0+0.5)
      
      if ( hwdn .lt. 600.0 ) then
      dragh = 1.00
      else
      dragh = 0.60
      end if

      xcnor = cnor
      xcnos = cnos
      xcnoh = cnoh

       write(outfile,*) '-----------------------------------------------------------------------'
       write(outfile,*)
       write(outfile,*) '2004 STRAKA(GILMORE) SAM microphysics'
       write(outfile,*)
       write(outfile,*) '3-ICE MICROPHYSICAL CONSTANTS'
101    Format(1x,a,6(g12.5,2x))
       write(outfile,101) 'CNOR/DENR:        ',cnor, rwdn
       write(outfile,101) 'CNOS/DENS:        ',cnos, swdn
       write(outfile,101) 'CNOH/DENH/DRAGH:  ',cnoh, hwdn,dragh
       write(outfile,*)   'TIME STEP:        ', dtp
         IF( autoconversion .eq. 0 ) THEN
        write(outfile,*) 'Berry (1968) Critical qc g/g for autoconversion= ',qcmincwrn
         ELSE
        write(outfile,*) 'Berry (1968) Critical qc diam for autoconversion= ',cwdiap*1e6,' microns'
         ENDIF
       write(outfile,*) '-----------------------------------------------------------------------'
       write(outfile,*)

!  constants
!
      c1f3 = 1.0/3.0
!
!  general constants for microphysics
!
      brz = 100.0
      arz = 0.66
      cai = 21.87455
      caw = 17.2693882
      cbi = 7.66
      cbw = 35.86
      qcmin = 1.0e-09
      qimin = 1.0e-12
      qrmin = 1.0e-07
      qsmin = 1.0e-07
      qhmin = 1.0e-07

      tfr = 273.15
      thnuc = 233.15
      advisc0 = 1.832e-05
      advisc1 = 1.718e-05
      tka0 = 2.43e-02
      cpi = 1.0/cp
      tfrcbw = tfr - cbw
      tfrcbi = tfr - cbi

      elv = 2500300. 
      elf = 335717. 
      els = elv + elf
      cw = 4218.0   
      xmlt3 = -cw/elf
      xiint = (elv**2)/(cp*rw)

      xacwi = pid4          
      xxacx = pid4/gf4
      xvth1 = gf4p5/(6.0)
      xxmlt1 = 0.78*gf2
      xrcev1 = 0.78*gf2
      xvth3 = (4.0*g/(3.0*dragh))**(0.25)
      xslop = (1./pi)**(0.25)
      xvtr  = ar*gf4br*(dnz00**0.5)/6.0
      xvts  = cs*gf4ds*(dnz00**0.5)/6.0

      cqv1 = 4097.8531*elv*cpi
      cqv2 = 5807.4743*els*cpi
!
!
!  Saturation Vapor Pressure Lookup Table
!
      do lll = 1,nqsat
      temq = 163.15 + (lll-1)*fqsat
      tabqvs(lll) = exp(caw*(temq-273.15)/(temq-cbw))
      tabqis(lll) = exp(cai*(temq-273.15)/(temq-cbi))
      end do
!
!  cw constants in mks units
!
      cwmasn = 4.25e-15
      cwmasx = 5.25e-10
      cwdn = 1000.0
      cwc1 = 6.0/(pi*cwdn)
!
!  ci constants in mks units
!
      cimasx = 3.23e-8
      cimasn = 4.25e-15
!
!  constants for bergeron process, note in cgs units
!
      cmn = 1.05e-15
      cmi40 = 2.4546e-07
      cmi50 = 4.8e-07
      ri50 = 5.0e-03
      vti50 = 100.0
      bsfw = (ri50**2)*vti50*pi
      cbtim(1) = 1.0e+30
      cs10(1)  = 0.0
      cs11(1)  = 0.0
      do ibb = 2,32
        cm50a = cmi50**bfa2(ibb)
        atemp = 1.0-bfa2(ibb)
        cm40b = cmi40**atemp
        cm50b = cmi50**atemp
        cbtim(ibb) = (cm50b-cm40b)/(bfa1(ibb)*atemp)
        cs10(ibb) = bfa1(ibb)*cm50a
        cs11(ibb) = dtp/(cbtim(ibb)*cmi50)
!       write(6,*) 'ibb, cbtim(ibb)=',ibb, cbtim(ibb)
      ENDDO

      return
      end subroutine lfoice_init

!--------------------------------------------------------------------------

maxmin.F        1587424407  1602  20    100644  6009      `
MODULE maxminmod

CONTAINS

      subroutine maxmin(izz,jzz,kzz,f,nstat,rstat,amax,amin)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      integer :: izz,jzz,kzz,nstat
      real, dimension(stat_out) :: rstat
      real, dimension(1-ngxy:izz+ngxy,1-ngxy:jzz+ngxy,1-ngz:kzz+ngz) :: f
      character*6 :: amax,amin

!-----------------------------------------------------------------------

      integer :: i,j,k
      integer :: imax,jmax,kmax,imin,jmin,kmin
      integer, dimension(nk+1) :: imaxt,jmaxt,kmaxt,imint,jmint,kmint
      real, dimension(nk+1) :: tmax,tmin
      real :: fmax,fmin,rmax,rmin
      integer :: loc
      real, dimension(2) :: mmax,nmax,mmin,nmin

!-----------------------------------------------------------------------

      imin = 1
      jmin = 1
      kmin = 1
      imax = 1
      jmax = 1
      kmax = 1

!$omp parallel do default(shared)    &
!$omp private(i,j,k)
      do k=1,kzz
        tmax(k)= -1.e30
        tmin(k)=  1.e30
        do j=1,jzz
        do i=1,izz
          if(f(i,j,k).gt.tmax(k))then
            tmax(k)=f(i,j,k)
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
          if(f(i,j,k).lt.tmin(k))then
            tmin(k)=f(i,j,k)
            imint(k)=i
            jmint(k)=j
            kmint(k)=k
          endif
        enddo
        enddo
      enddo

      fmax= -1.e30
      fmin=  1.e30
      do k=1,kzz
        if(tmax(k).gt.fmax)then
          fmax=tmax(k)
          imax=imaxt(k)
          jmax=jmaxt(k)
          kmax=kmaxt(k)
        endif
        if(tmin(k).lt.fmin)then
          fmin=tmin(k)
          imin=imint(k)
          jmin=jmint(k)
          kmin=kmint(k)
        endif 
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
      call MPI_BCAST(imax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      mmin(1)=fmin
      mmin(2)=myid
      call MPI_ALLREDUCE(mmin,nmin,1,MPI_2REAL,MPI_MINLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmin(2))
      imin=imin+(myi-1)*ni
      jmin=jmin+(myj-1)*nj
      call MPI_BCAST(imin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      fmax=nmax(1)
      fmin=nmin(1)

    if(myid.eq.0)then
#endif
      write(6,100) amax,fmax,imax,jmax,kmax,    &
                   amin,fmin,imin,jmin,kmin
100   format(2x,a6,':',1x,g13.6,i5,i5,i5,    &
             4x,a6,':',1x,g13.6,i5,i5,i5)

      nstat = nstat + 1
      rstat(nstat) = fmax
      nstat = nstat + 1
      rstat(nstat) = fmin
#ifdef MPI
    endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      end subroutine maxmin


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine maxmin2d(izz,jzz,f,nstat,rstat,amax,amin)
#ifdef MPI
      use mpi
#endif
      implicit none
        
      include 'input.incl'
      include 'timestat.incl'

      integer :: izz,jzz,nstat
      real, dimension(stat_out) :: rstat
      real, dimension(1-ngxy:izz+ngxy,1-ngxy:jzz+ngxy) :: f
      character*6 :: amax,amin
        
!-----------------------------------------------------------------------
          
      integer :: i,j
      integer :: imax,jmax,imin,jmin
      integer, dimension(jzz) :: imaxt,jmaxt,imint,jmint
      real, dimension(jzz) :: tmax,tmin
      real :: fmax,fmin,rmax,rmin
      integer :: loc
      real, dimension(2) :: mmax,nmax,mmin,nmin
          
!-----------------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j)
      do j=1,jzz
        tmax(j)= -1.e30
        tmin(j)=  1.e30
        do i=1,izz
          if(f(i,j).gt.tmax(j))then
            tmax(j)=f(i,j)
            imaxt(j)=i
            jmaxt(j)=j
          endif
          if(f(i,j).lt.tmin(j))then
            tmin(j)=f(i,j)
            imint(j)=i
            jmint(j)=j
          endif
        enddo
      enddo

      fmax= -1.e30
      fmin=  1.e30
      do j=1,jzz
        if(tmax(j).gt.fmax)then
          fmax=tmax(j)
          imax=imaxt(j)
          jmax=jmaxt(j)
        endif
        if(tmin(j).lt.fmin)then
          fmin=tmin(j)
          imin=imint(j)
          jmin=jmint(j)
        endif
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
      call MPI_BCAST(imax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      mmin(1)=fmin
      mmin(2)=myid
      call MPI_ALLREDUCE(mmin,nmin,1,MPI_2REAL,MPI_MINLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmin(2))
      imin=imin+(myi-1)*ni
      jmin=jmin+(myj-1)*nj
      call MPI_BCAST(imin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      fmax=nmax(1)
      fmin=nmin(1)

    if(myid.eq.0)then
#endif
      write(6,100) amax,fmax,imax,jmax,1,    &
                   amin,fmin,imin,jmin,1
100   format(2x,a6,':',1x,g13.6,i5,i5,i5,    &
             4x,a6,':',1x,g13.6,i5,i5,i5)

      nstat = nstat + 1
      rstat(nstat) = fmax
      nstat = nstat + 1
      rstat(nstat) = fmin
#ifdef MPI
    endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      end subroutine maxmin2d

END MODULE maxminmod

misclibs.F      1587424407  1602  20    100644  112091    `


      subroutine dtsmall(dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      ! cm1r18:  moved this section of code from solve.F to misclibs.F

      real, intent(inout) :: dt

      real :: dtsm

        ! Algorithm to determine number of small steps:
        IF( psolver.eq.2 )THEN
          ! check dx,dy,dz:
          IF( ny.eq.1 )THEN
            ! 2D sims (x-z):
            dtsm = 0.60*min( min_dx , min_dz )/360.0
          ELSEIF( nx.eq.1 )THEN
            ! 2D sims (y-z):
            dtsm = 0.60*min( min_dy , min_dz )/360.0
          ELSE
            ! 3D sims:
            dtsm = 0.50*min( min_dx , min_dy , min_dz )/360.0
          ENDIF
        ELSEIF( psolver.eq.3 )THEN
          ! check dx,dy:
          IF( ny.eq.1 )THEN
            ! 2D sims (x-z):
            dtsm = 0.60*min_dx/360.0
          ELSEIF( nx.eq.1 )THEN
            ! 2D sims (y-z):
            dtsm = 0.60*min_dy/360.0
          ELSE
            ! 3D sims:
            dtsm = 0.60*min( min_dx , min_dy )/360.0
          ENDIF
        ELSEIF( psolver.eq.6 )THEN
          ! check dx,dy,dz:
          IF( ny.eq.1 )THEN
            ! 2D sims (x-z):
            dtsm = 0.60*min( min_dx , min_dz )/csound
          ELSEIF( nx.eq.1 )THEN
            ! 2D sims (y-z):
            dtsm = 0.60*min( min_dy , min_dz )/csound
          ELSE
            ! 3D sims:
            dtsm = 0.50*min( min_dx , min_dy , min_dz )/csound
          ENDIF
        ENDIF

        nsound = max( nint( dt/dtsm ) , 4 )
        if( mod(nsound,2).ne.0 ) nsound = nsound + 1
        if( dt/float(nsound).gt.dtsm ) nsound = nsound + 2

        if( nsound.gt.48 )then
          nsound = 48
          dt = 48*dtsm
        endif

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getqli(q,ql,qi)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q
      real, dimension(ib:ie,jb:je,kb:ke) :: ql,qi

      integer :: i,j,k,n

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
    DO k=1,nk

      do j=1,nj
      do i=1,ni
        ql(i,j,k)=0.0
        qi(i,j,k)=0.0
      enddo
      enddo

      do n=nql1,nql2
        do j=1,nj
        do i=1,ni
          ql(i,j,k)=ql(i,j,k)+q(i,j,k,n)
        enddo
        enddo
      enddo

      IF(iice.eq.1)THEN
        do n=nqs1,nqs2
          do j=1,nj
          do i=1,ni
            qi(i,j,k)=qi(i,j,k)+q(i,j,k,n)
          enddo
          enddo
        enddo
      ENDIF

    ENDDO

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcvm(cvm,q)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: cvm
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q

      integer :: i,j,k,n

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
    DO k=1,nk

      IF( eqtset.le.1 .or. imoist.eq.0 )THEN

        do j=1,nj
        do i=1,ni
          cvm(i,j,k) = cv
        enddo
        enddo

      ELSE

        do j=1,nj
        do i=1,ni
          cvm(i,j,k) = cv+cvv*q(i,j,k,nqv)
        enddo
        enddo
        do n=nql1,nql2
          do j=1,nj
          do i=1,ni
            cvm(i,j,k)=cvm(i,j,k)+cpl*q(i,j,k,n)
          enddo
          enddo
        enddo
        IF(iice.eq.1)THEN
          do n=nqs1,nqs2
          do j=1,nj
          do i=1,ni
            cvm(i,j,k)=cvm(i,j,k)+cpi*q(i,j,k,n)
          enddo
          enddo
          enddo
        ENDIF

      ENDIF

    ENDDO

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefq(rmax,asq,ruh,rvh,rmh,rho,q3d)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real rmax
      double precision :: asq
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,q3d

      integer i,j,k
      double precision :: t1,t2,t3
      double precision :: a1,a2,tem
      double precision, dimension(nj) :: budj
      double precision, dimension(nk) :: budk

!----------------------------------------------------------------------

      tem = dx*dy*dz

      IF(pdscheme.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,t1,t2,t3,a1,a2)
        do j=1,nj
        budj(j)=0.0d0
        do i=1,ni
          t1=0.0d0
          t2=0.0d0
          a1=0.0d0
          a2=0.0d0
          do k=1,nk
            t1=t1+rho(i,j,k)*q3d(i,j,k)
            a1=a1+rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
!!!            q3d(i,j,k)=max(0.0,q3d(i,j,k))
            if(q3d(i,j,k).lt.rmax) q3d(i,j,k)=0.0
            t2=t2+rho(i,j,k)*q3d(i,j,k)
          enddo
          t3=(t1+1.0d-20)/(t2+1.0d-20)
          if(t3.lt.0.0) t3=1.0d0
          do k=1,nk
            q3d(i,j,k)=t3*q3d(i,j,k)
            a2=a2+rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
          enddo
          budj(j)=budj(j)+a2-a1
        enddo
        enddo

        do j=1,nj
          asq=asq+budj(j)*tem
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k,a1,a2)
        do k=1,nk
        budk(k)=0.0d0
        do j=1,nj
        do i=1,ni
          a1=rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
!!!          q3d(i,j,k)=max(0.0,q3d(i,j,k))
          if(q3d(i,j,k).lt.rmax) q3d(i,j,k)=0.0
          a2=rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
          budk(k)=budk(k)+a2-a1
        enddo
        enddo
        enddo

        do k=1,nk
          asq=asq+budk(k)*tem
        enddo

      ENDIF

!----------------------------------------------------------------------

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine calcprs(pi0,prs,pp3d)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0
      real, dimension(ib:ie,jb:je,kb:ke) :: prs,pp3d
 
      integer i,j,k
 
!----------------------------------------------------------------------
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
      enddo
      enddo
      enddo
 
!----------------------------------------------------------------------
 
      if(timestats.ge.1) time_prsrho=time_prsrho+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcrho(pi0,th0,rho,prs,pp3d,th3d,q3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,prs,pp3d,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d

      integer i,j,k

!----------------------------------------------------------------------

      IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          rho(i,j,k)=prs(i,j,k)                         &
             /( rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))     &
                  *(1.0+max(0.0,q3d(i,j,k,nqv))*reps) )
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k)))
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------------

      if(timestats.ge.1) time_prsrho=time_prsrho+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcdbz(rho,qr,qs,qg,dbz)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: rho,qr,qs,qg,dbz

      integer :: i,j,k
      real :: n0r,n0g,n0s,rhor,rhog,rhos,gamma,zer,zeg,zes
      real, parameter :: epp = 1.0e-8

  IF(ptype.eq.2)THEN

    rhor = 1000.0 * ROQR
    rhog = 1000.0 * ROQG
    rhos = 1000.0 * ROQS

    n0r = 1.0e8 * TNW
    n0g = 1.0e8 * TNG
    n0s = 1.0e8 * TNSS

!!!    print *,'  rhor,rhog,rhos = ',rhor,rhog,rhos
!!!    print *,'  n0r,n0g,n0s    = ',n0r,n0g,n0s

!$omp parallel do default(shared)  &
!$omp private(i,j,k,gamma,zer,zeg,zes)
    do k=1,nk
    do j=1,nj
    do i=1,ni

    if(qr(i,j,k).ge.epp)then
      !--- rain ---
      gamma=(3.14159*n0r*rhor/(rho(i,j,k)*qr(i,j,k)))**0.25
      zer=720.0*n0r*(gamma**(-7))
    else
      zer=0.0
    endif

    if(qg(i,j,k).ge.epp)then
      !--- graupel/hail ---
      gamma=(3.14159*n0g*rhog/(rho(i,j,k)*qg(i,j,k)))**0.25
      zeg=720.0*n0g*(gamma**(-7))*((rhog/rhor)**2)*0.224
    else
      zeg=0.0
    endif

    if(qs(i,j,k).ge.epp)then
      !--- snow ---
      gamma=(3.14159*n0s*rhos/(rho(i,j,k)*qs(i,j,k)))**0.25
      zes=720.0*n0s*(gamma**(-7))*((rhos/rhor)**2)*0.224
    else
      zes=0.0
    endif

      !--- dbz ---

    if( (zer+zeg+zes).gt.1.0e-18 )then
      dbz(i,j,k)=10.0*log10((zer+zeg+zes)*1.0e18)
    else
      dbz(i,j,k)=0.0
    endif

    enddo
    enddo
    enddo

  ELSE

    if(dowr) write(outfile,*)
    if(dowr) write(outfile,*) ' ptype = ',ptype
    if(dowr) write(outfile,*)
    if(dowr) write(outfile,*) ' calcdbz is not valid for this value of ptype'
    if(dowr) write(outfile,*)
    call stopcm1

  ENDIF

      if(timestats.ge.1) time_write=time_write+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine impldiffu(uf,vh,arh1,arh2,arf1,arf2,mh,rdsf,gzu,rho0,rr0,dum1,dum2,dum3,rru,rrv,rrw,u3d,uten)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(ib:ie+1) :: uf
      real, intent(in),    dimension(jb:je) :: vh
      real, intent(in),    dimension(ib:ie) :: arh1,arh2
      real, intent(in),    dimension(ib:ie+1) :: arf1,arf2
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in),    dimension(kb:ke+1) :: rdsf
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gzu
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: uten

      integer :: i,j,k,i2
      real :: ubar,vbar,wbar

      uten = 0.0
      dum1 = 0.0
      dum2 = 0.0
      dum3 = 0.0

      !---

    hadvu:  IF(hadvordrv.eq.5)THEN

      IF(axisymm.eq.0)THEN

        ! Cartesian grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k,ubar,vbar)
        do k=1,nk
          do j=1,nj
          do i=0,ni+1
            ubar = 0.5*(rru(i,j,k)+rru(i+1,j,k))
            dum1(i,j,k) = ubar*( -sign(1.0,ubar)                   &
                             *( 10.0*(u3d(i+1,j,k)-u3d(i  ,j,k))   &
                                -5.0*(u3d(i+2,j,k)-u3d(i-1,j,k))   &
                                    +(u3d(i+3,j,k)-u3d(i-2,j,k)) ) )*onedsixty
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni+1
            vbar = 0.5*(rrv(i,j,k)+rrv(i-1,j,k))
            dum2(i,j,k) = vbar*( -sign(1.0,vbar)                   &
                             *( 10.0*(u3d(i,j  ,k)-u3d(i,j-1,k))   &
                                -5.0*(u3d(i,j+1,k)-u3d(i,j-2,k))   &
                                    +(u3d(i,j+2,k)-u3d(i,j-3,k)) ) )*onedsixty
          enddo
          enddo
        enddo

      ELSE

        ! axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k,ubar,vbar)
        do k=1,nk
          do j=1,nj
            do i=2,ni+1
              ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                   &
                               *( 10.0*(u3d(i+1,j,k)-u3d(i  ,j,k))   &
                                  -5.0*(u3d(i+2,j,k)-u3d(i-1,j,k))   &
                                      +(u3d(i+3,j,k)-u3d(i-2,j,k)) ) )*onedsixty
            enddo
            i = 2
            ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
            if(ubar.gt.0.0)then
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                &
                             *( 3.0*(u3d(i+1,j,k)-u3d(i  ,j,k))   &
                                   -(u3d(i+2,j,k)-u3d(i-1,j,k)) ) )*onedtwelve
            endif
            i = 1
            ubar = 0.5*(arh1(i)*rru(i,j,k)+arh2(i)*rru(i+1,j,k))
            if(ubar.lt.0.0)then
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                &
                             *( 3.0*(u3d(i+1,j,k)-u3d(i  ,j,k))   &
                                   -(u3d(i+2,j,k)-u3d(i-1,j,k)) ) )*onedtwelve
            endif
          enddo
        enddo

      ENDIF

    ENDIF  hadvu

      !---

    vadvu:  IF(vadvordrv.eq.5)THEN

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wbar)
        do j=1,nj
          do k=3,nk-1
          do i=1,ni+1
            wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
            dum3(i,j,k) = wbar*( -sign(1.0,wbar)                   &
                             *( 10.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                -5.0*(u3d(i,j,k+1)-u3d(i,j,k-2))   &
                                    +(u3d(i,j,k+2)-u3d(i,j,k-3)) ) )*onedsixty
          enddo
          enddo
          k = 3
          do i=1,ni+1
            wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = nk-1
          do i=1,ni+1
            wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = 2
          do i=1,ni+1
            wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = nk
          do i=1,ni+1
            wbar = 0.5*(rrw(i,j,k)+rrw(i-1,j,k))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
        enddo

      ELSE

        if(ibe.eq.1)then
          i2=ni+1-1
        else
          i2=ni+1
        endif
        IF(ebc.eq.3.or.ebc.eq.4) i2 = ni

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wbar)
        do j=1,nj
          do k=3,nk-1
          do i=2,i2
            wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
            dum3(i,j,k) = wbar*( -sign(1.0,wbar)                   &
                             *( 10.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                -5.0*(u3d(i,j,k+1)-u3d(i,j,k-2))   &
                                    +(u3d(i,j,k+2)-u3d(i,j,k-3)) ) )*onedsixty
          enddo
          enddo
          k = 3
          do i=2,i2
            wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = nk-1
          do i=2,i2
            wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = 2
          do i=2,i2
            wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = nk
          do i=2,i2
            wbar = 0.5*(arf2(i)*rrw(i,j,k)+arf1(i)*rrw(i-1,j,k))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))   &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
        enddo

      ENDIF

    ENDIF  vadvu

      !---

      IF(.not.terrain_flag)THEN

        IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni+1
            uten(i,j,k) = ( -(dum1(i,j,k)-dum1(i-1,j,k))*rdx*uf(i)      &
                            -(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)      &
                            -(dum3(i,j,k+1)-dum3(i,j,k))*rdz*mh(1,1,k)  &
                          )*rr0(1,1,k)
          enddo
          enddo
          enddo

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=2,ni+1
            uten(i,j,k) = ( -(arf2(i)*dum1(i,j,k)-arf1(i)*dum1(i-1,j,k))*rdx*uf(i)  &
                            -(dum3(i,j,k+1)-dum3(i,j,k))*rdz*mh(1,1,k)  &
                          )*rr0(1,1,k)
          enddo
          IF(ebc.eq.3.or.ebc.eq.4)THEN
            uten(ni+1,j,k)=0.0
          ENDIF
          enddo
          enddo

        ENDIF

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten(i,j,k) = ( -(dum1(i,j,k)-dum1(i-1,j,k))*rdx*uf(i)      &
                          -(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)      &
                          -(dum3(i,j,k+1)-dum3(i,j,k))*rdsf(k)        &
                        )*gzu(i,j)/(0.5*(rho0(i-1,j,k)+rho0(i,j,k)))
        enddo
        enddo
        enddo

      ENDIF

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine impldiffv(uh,vf,arh1,arh2,mh,rdsf,gzv,rho0,rr0,dum1,dum2,dum3,rru,rrv,rrw,v3d,vten)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(ib:ie) :: uh
      real, intent(in),    dimension(jb:je+1) :: vf
      real, intent(in),    dimension(ib:ie) :: arh1,arh2
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in),    dimension(kb:ke+1) :: rdsf
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gzv
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: vten

      integer :: i,j,k
      real :: ubar,vbar,wbar

      vten = 0.0
      dum1 = 0.0
      dum2 = 0.0
      dum3 = 0.0

      !---

    hadvv:  IF(hadvordrv.eq.5)THEN

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,ubar,vbar)
        do k=1,nk
          do j=1,nj+1
          do i=1,ni+1
            ubar = 0.5*(rru(i,j,k)+rru(i,j-1,k))
            dum1(i,j,k) = ubar*( -sign(1.0,ubar)                   &
                             *( 10.0*(v3d(i  ,j,k)-v3d(i-1,j,k))   &
                                -5.0*(v3d(i+1,j,k)-v3d(i-2,j,k))   &
                                    +(v3d(i+2,j,k)-v3d(i-3,j,k)) ) )*onedsixty
          enddo
          enddo
          do j=0,nj+1
          do i=1,ni
            vbar = 0.5*(rrv(i,j,k)+rrv(i,j+1,k))
            dum2(i,j,k) = vbar*( -sign(1.0,vbar)                   &
                             *( 10.0*(v3d(i,j+1,k)-v3d(i,j  ,k))   &
                                -5.0*(v3d(i,j+2,k)-v3d(i,j-1,k))   &
                                    +(v3d(i,j+3,k)-v3d(i,j-2,k)) ) )*onedsixty
          enddo
          enddo
        enddo

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k,ubar,vbar)
        do k=1,nk
          do j=1,nj
            do i=3,ni+1
              ubar = rru(i,j,k)
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                   &
                               *( 10.0*(v3d(i  ,j,k)-v3d(i-1,j,k))   &
                                  -5.0*(v3d(i+1,j,k)-v3d(i-2,j,k))   &
                                      +(v3d(i+2,j,k)-v3d(i-3,j,k)) ) )*onedsixty
            enddo
            i = 3
            ubar = rru(i,j,k)
            if(ubar.gt.0.0)then
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                &
                             *( 3.0*(v3d(i  ,j,k)-v3d(i-1,j,k))   &
                                   -(v3d(i+1,j,k)-v3d(i-2,j,k)) ) )*onedtwelve
            endif
            i = 2
            ubar = rru(i,j,k)
            if(ubar.lt.0.0)then
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                &
                             *( 3.0*(v3d(i  ,j,k)-v3d(i-1,j,k))   &
                                   -(v3d(i+1,j,k)-v3d(i-2,j,k)) ) )*onedtwelve
            endif
          enddo
        enddo

      ENDIF

    ENDIF  hadvv

      !---

    vadvv:  IF(vadvordrv.eq.5)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wbar)
        do j=1,nj+1
          do k=3,nk-1
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
            dum3(i,j,k) = wbar*( -sign(1.0,wbar)                   &
                             *( 10.0*(v3d(i,j,k  )-v3d(i,j,k-1))   &
                                -5.0*(v3d(i,j,k+1)-v3d(i,j,k-2))   &
                                    +(v3d(i,j,k+2)-v3d(i,j,k-3)) ) )*onedsixty
          enddo
          enddo
          k = 3
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(v3d(i,j,k  )-v3d(i,j,k-1))   &
                                   -(v3d(i,j,k+1)-v3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = nk-1
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(v3d(i,j,k  )-v3d(i,j,k-1))   &
                                   -(v3d(i,j,k+1)-v3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = 2
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(v3d(i,j,k  )-v3d(i,j,k-1))   &
                                   -(v3d(i,j,k+1)-v3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
          k = nk
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j-1,k))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(v3d(i,j,k  )-v3d(i,j,k-1))   &
                                   -(v3d(i,j,k+1)-v3d(i,j,k-2)) ) )*onedtwelve
            endif
          enddo
        enddo

    ENDIF  vadvv

      !---

      IF(.not.terrain_flag)THEN

        IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            vten(i,j,k) = ( -(dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)      &
                            -(dum2(i,j,k)-dum2(i,j-1,k))*rdy*vf(j)      &
                            -(dum3(i,j,k+1)-dum3(i,j,k))*rdz*mh(1,1,k)  &
                          )*rr0(1,1,k)
          enddo
          enddo
          enddo

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            vten(i,j,k) = ( -(arh2(i)*dum1(i+1,j,k)-arh1(i)*dum1(i,j,k))*rdx*uh(i)  &
                            -(dum3(i,j,k+1)-dum3(i,j,k))*rdz*mh(1,1,k)  &
                          )*rr0(1,1,k)
          enddo
          enddo
          enddo

        ENDIF

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten(i,j,k) = ( -(dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)      &
                          -(dum2(i,j,k)-dum2(i,j-1,k))*rdy*vf(j)      &
                          -(dum3(i,j,k+1)-dum3(i,j,k))*rdsf(k)        &
                        )*gzv(i,j)/(0.5*(rho0(i,j-1,k)+rho0(i,j,k)))
        enddo
        enddo
        enddo

      ENDIF

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine impldiffw(uh,vh,arh1,arh2,mf,gz,rds,rrf0,dum1,dum2,dum3,rru,rrv,rrw,w3d,wten,c1,c2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in),    dimension(ib:ie) :: uh
      real, intent(in),    dimension(jb:je) :: vh
      real, intent(in),    dimension(ib:ie) :: arh1,arh2
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in),    dimension(kb:ke) :: rds
      real, intent(in),    dimension(itb:ite,jtb:jte) :: gz
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: rrf0
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: w3d
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: wten
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: c1,c2

      integer :: i,j,k
      real :: ubar,vbar,wbar,cc1,cc2

      wten = 0.0
      dum1 = 0.0
      dum2 = 0.0
      dum3 = 0.0

      !---

    hadvw:  IF(hadvordrv.eq.5)THEN

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,cc1,cc2,ubar,vbar)
        do k=1,nk
          do j=1,nj+1
          do i=1,ni+1
            cc2 = 0.5*(c2(i-1,j,k)+c2(i,j,k))
            cc1 = 1.0-cc2
            ubar = cc2*rru(i,j,k)+cc1*rru(i,j,k-1)
            dum1(i,j,k) = ubar*( -sign(1.0,ubar)                   &
                             *( 10.0*(w3d(i  ,j,k)-w3d(i-1,j,k))   &
                                -5.0*(w3d(i+1,j,k)-w3d(i-2,j,k))   &
                                    +(w3d(i+2,j,k)-w3d(i-3,j,k)) ) )*onedsixty
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni+1
            cc2 = 0.5*(c2(i,j-1,k)+c2(i,j,k))
            cc1 = 1.0-cc2
            vbar = cc2*rrv(i,j,k)+cc1*rrv(i,j,k-1)
            dum2(i,j,k) = vbar*( -sign(1.0,vbar)                   &
                             *( 10.0*(w3d(i,j  ,k)-w3d(i,j-1,k))   &
                                -5.0*(w3d(i,j+1,k)-w3d(i,j-2,k))   &
                                    +(w3d(i,j+2,k)-w3d(i,j-3,k)) ) )*onedsixty
          enddo
          enddo
        enddo

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k,ubar,vbar)
        do k=1,nk
          do j=1,nj
            do i=3,ni+1
              ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                   &
                               *( 10.0*(w3d(i  ,j,k)-w3d(i-1,j,k))   &
                                  -5.0*(w3d(i+1,j,k)-w3d(i-2,j,k))   &
                                      +(w3d(i+2,j,k)-w3d(i-3,j,k)) ) )*onedsixty
            enddo
            i = 3
            ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
            if(ubar.gt.0.0)then
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                &
                             *( 3.0*(w3d(i  ,j,k)-w3d(i-1,j,k))   &
                                   -(w3d(i+1,j,k)-w3d(i-2,j,k)) ) )*onedtwelve
            endif
            i = 2
            ubar = c2(1,1,k)*rru(i,j,k)+c1(1,1,k)*rru(i,j,k-1)
            if(ubar.lt.0.0)then
              dum1(i,j,k) = ubar*( -sign(1.0,ubar)                &
                             *( 3.0*(w3d(i  ,j,k)-w3d(i-1,j,k))   &
                                   -(w3d(i+1,j,k)-w3d(i-2,j,k)) ) )*onedtwelve
            endif
          enddo
        enddo

      ENDIF

    ENDIF  hadvw

      !---

    vadvw:  IF(vadvordrv.eq.5)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wbar)
        do j=1,nj+1
          do k=2,nk-1
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
            dum3(i,j,k) = wbar*( -sign(1.0,wbar)                   &
                             *( 10.0*(w3d(i,j,k+1)-w3d(i,j,k  ))   &
                                -5.0*(w3d(i,j,k+2)-w3d(i,j,k-1))   &
                                    +(w3d(i,j,k+3)-w3d(i,j,k-2)) ) )*onedsixty
          enddo
          enddo
          k = 2
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(w3d(i,j,k+1)-w3d(i,j,k  ))   &
                                   -(w3d(i,j,k+2)-w3d(i,j,k-1)) ) )*onedtwelve
            endif
          enddo
          k = nk-1
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(w3d(i,j,k+1)-w3d(i,j,k  ))   &
                                   -(w3d(i,j,k+2)-w3d(i,j,k-1)) ) )*onedtwelve
            endif
          enddo
          k = 1
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
            if(wbar.lt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(w3d(i,j,k+1)-w3d(i,j,k  ))   &
                                   -(w3d(i,j,k+2)-w3d(i,j,k-1)) ) )*onedtwelve
            endif
          enddo
          k = nk
          do i=1,ni
            wbar = 0.5*(rrw(i,j,k)+rrw(i,j,k+1))
            if(wbar.gt.0.0)then
              dum3(i,j,k) = wbar*( -sign(1.0,wbar)                &
                             *( 3.0*(w3d(i,j,k+1)-w3d(i,j,k  ))   &
                                   -(w3d(i,j,k+2)-w3d(i,j,k-1)) ) )*onedtwelve
            endif
          enddo
        enddo

    ENDIF  vadvw

      !---

      IF(.not.terrain_flag)THEN

        IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            wten(i,j,k) = ( -(dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)      &
                            -(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)      &
                            -(dum3(i,j,k)-dum3(i,j,k-1))*rdz*mf(1,1,k)  &
                          )*rrf0(1,1,k)
          enddo
          enddo
          enddo

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            wten(i,j,k) = ( -(arh2(i)*dum1(i+1,j,k)-arh1(i)*dum1(i,j,k))*rdx*uh(i)  &
                            -(dum3(i,j,k)-dum3(i,j,k-1))*rdz*mf(1,1,k)  &
                          )*rrf0(1,1,k)
          enddo
          enddo
          enddo

        ENDIF

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          wten(i,j,k) = ( -(dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)      &
                          -(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)      &
                          -(dum3(i,j,k)-dum3(i,j,k-1))*rds(k)         &
                        )*rrf0(i,j,k)*gz(i,j)
        enddo
        enddo
        enddo

      ENDIF

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcuh(uf,vf,zh,zf,ua,va,wa,uh,zeta,dum1,dum2, &
                        zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf)
      implicit none

      ! Subroutine to calculate vertically integrated updraft helicity
      ! Reference:  Kain et al, 2008, WAF, p 931

      include 'input.incl'
      include 'timestat.incl'

      ! note:  need zh,zf Above Ground Level

      real, intent(in), dimension(ib:ie+1) :: uf
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je) :: uh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: zeta,dum1,dum2
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: rgzu,rgzv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf

      real, parameter :: zz0 = 2000.0     ! bottom of integration layer (m AGL)
      real, parameter :: zzt = 5000.0     ! top of integration layer (m AGL)

      integer :: i,j,k
      real :: r1,r2
      real :: wbar,zbar

  IF(.not.terrain_flag)THEN

    ! Cartesian grid, without terrain:

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    DO k=1,nk
    DO j=1,nj+1
    DO i=1,ni+1
      zeta(i,j,k) = (va(i,j,k)-va(i-1,j,k))*rdx*uf(i)   &
                   -(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
    ENDDO
    ENDDO
    ENDDO

  ELSE

    ! Cartesian grid, with terrain:

        ! dum1 stores u at w-pts:
        ! dum2 stores v at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+2
          ! lowest model level:
          do i=0,ni+2
            dum1(i,j,1) = cgs1*ua(i,j,1)+cgs2*ua(i,j,2)+cgs3*ua(i,j,3)
            dum2(i,j,1) = cgs1*va(i,j,1)+cgs2*va(i,j,2)+cgs3*va(i,j,3)
          enddo

          ! upper-most model level:
          do i=0,ni+2
            dum1(i,j,nk+1) = cgt1*ua(i,j,nk)+cgt2*ua(i,j,nk-1)+cgt3*ua(i,j,nk-2)
            dum2(i,j,nk+1) = cgt1*va(i,j,nk)+cgt2*va(i,j,nk-1)+cgt3*va(i,j,nk-2)
          enddo

          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+2
            dum1(i,j,k) = r1*ua(i,j,k-1)+r2*ua(i,j,k)
            dum2(i,j,k) = r1*va(i,j,k-1)+r2*va(i,j,k)
          enddo
          enddo
        enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k,r1)
        do k=1,nk
          do j=1,nj+1
          do i=1,ni+1
            r1 = zt/(zt-0.25*((zs(i-1,j-1)+zs(i,j))+(zs(i-1,j)+zs(i,j-1))))
            zeta(i,j,k)=( r1*(va(i,j,k)*rgzv(i,j)-va(i-1,j,k)*rgzv(i-1,j))*rdx*uf(i)  &
                         +0.5*( (zt-sigmaf(k+1))*(dum2(i-1,j,k+1)+dum2(i,j,k+1))      &
                               -(zt-sigmaf(k  ))*(dum2(i-1,j,k  )+dum2(i,j,k  ))      &
                              )*rdsf(k)*r1*(rgzv(i,j)-rgzv(i-1,j))*rdx*uf(i) )        &
                       -( r1*(ua(i,j,k)*rgzu(i,j)-ua(i,j-1,k)*rgzu(i,j-1))*rdy*vf(j)  &
                         +0.5*( (zt-sigmaf(k+1))*(dum1(i,j-1,k+1)+dum1(i,j,k+1))      &
                               -(zt-sigmaf(k  ))*(dum1(i,j-1,k  )+dum1(i,j,k  ))      &
                              )*rdsf(k)*r1*(rgzu(i,j)-rgzu(i,j-1))*rdy*vf(j) )
          enddo
          enddo
        enddo

  ENDIF

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wbar,zbar)
    DO j=1,nj
    DO i=1,ni
      uh(i,j) = 0.0
      DO k=1,nk
        IF( zh(i,j,k).ge.zz0 .and. zh(i,j,k).le.zzt )THEN
          ! note:  only consider cyclonically rotating updrafts
          !        (so, w and zeta must both be positive)
          wbar = max( 0.0 , 0.5*(wa(i,j,k)+wa(i,j,k+1)) )
          zbar = max( 0.0 , 0.25*(zeta(i,j,k)+zeta(i+1,j,k)   &
                                 +zeta(i,j+1,k)+zeta(i+1,j+1,k)) )
          uh(i,j) = uh(i,j) + (min(zf(i,j,k+1),zzt)-max(zf(i,j,k),zz0))*wbar*zbar
        ENDIF
      ENDDO
    ENDDO
    ENDDO

      return
      end subroutine calcuh


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcvort(xh,xf,uf,vf,zh,mh,zf,mf,zs,gz,gzu,gzv,rgz,rgzu,rgzv,gxu,gyv,rds,sigma,rdsf,sigmaf,  &
                          ua,va,wa,xvort,yvort,zvort,tem ,dum1,dum2,pv  ,th  ,th0,tha,rr,  &
                          ust,znt,u1,v1,s1)
      implicit none

      ! Subroutine to calculate 3 components of vorticity
      ! at scalar points.

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,mh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,gzu,gzv,rgz,rgzu,rgzv
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gxu,gyv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: xvort,yvort,zvort,tem,dum1,dum2,pv,th
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: th0,tha,rr
      real, intent(in), dimension(ib:ie,jb:je) :: ust,znt,u1,v1,s1

      integer :: i,j,k
      real :: r1,r2

!-----------------------------------------------------------------------

      IF( output_pv.eq.1 )THEN
        do k=1,nk
        do j=1,nj
        do i=1,ni
          pv(i,j,k)=0.0
        enddo
        enddo
        enddo
      ENDIF

    IF( terrain_flag )THEN
      ! dum1 stores w at scalar pts
      ! dum2 stores theta at w pts
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do j=0,nj+1
        do k=1,nk
        do i=0,ni+1
          dum1(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
          th(i,j,k)=th0(i,j,k)+tha(i,j,k)
        enddo
        enddo
        ! lowest model level:
        do i=0,ni+1
          dum2(i,j,1) = cgs1*th(i,j,1)+cgs2*th(i,j,2)+cgs3*th(i,j,3)
        enddo
        ! upper-most model level:
        do i=0,ni+1
          dum2(i,j,nk+1) = cgt1*th(i,j,nk)+cgt2*th(i,j,nk-1)+cgt3*th(i,j,nk-2)
        enddo
        ! interior:
        do k=2,nk
        r2 = (sigmaf(k)-sigma(k-1))*rds(k)
        r1 = 1.0-r2
        do i=0,ni+1
          dum2(i,j,k) = r1*th(i,j,k-1)+r2*th(i,j,k)
        enddo
        enddo
      enddo
    ENDIF

!-----------------------------------------------------------------------
! x-vort:

  tem=0.0
  if(axisymm.eq.0)then
    IF(.not.terrain_flag)THEN
      !cccccccccccccccccccccccccccccccccccccc
      ! Cartesian grid, without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj+1
      do i=1,ni
        tem(i,j,k) = (wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j)   &
                    -(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))
      enddo
      enddo
      enddo
      IF( bbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,1)=tem(i,j,2)
        enddo
        enddo
      ELSEIF( bbc.eq.2 )THEN
      if( imove.eq.0 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,1)=-2.0*va(i,j,1)*rdz*0.5*(mf(i,j-1,1)+mf(i,j,1))
        enddo
        enddo
      else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,1)=-2.0*(va(i,j,1)+vmove)*rdz*0.5*(mf(i,j-1,1)+mf(i,j,1))
        enddo
        enddo
      endif
      ENDIF
      IF( tbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,nk+1)=tem(i,j,nk)
        enddo
        enddo
      ELSEIF( tbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,nk+1)=2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
        enddo
        enddo
      ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        xvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i,j+1,k)+tem(i,j,k+1)+tem(i,j+1,k+1))
      enddo
      enddo
      enddo
      !cccccccccccccccccccccccccccccccccccccc
    getpv11: IF( output_pv.eq.1 )THEN
      ! here, zvort array stores d(th)/dx
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        zvort(i,j,k) = (th(i,j,k)-th(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo
      ! pv1:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pv(i,j,k)=pv(i,j,k)+xvort(i,j,k)*0.5*( zvort(i,j,k)+zvort(i+1,j,k) )
      enddo
      enddo
      enddo
    ENDIF  getpv11
      !cccccccccccccccccccccccccccccccccccccc
    ELSE
      !cccccccccccccccccccccccccccccccccccccc
      ! Cartesian grid, with terrain:
      !   (dum1 stores w at scalar-pts:)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj+1
      do i=1,ni
        tem(i,j,k)=(-(va(i,j,k)-va(i,j,k-1))*rds(k)                                  &
                    +(wa(i,j,k)*rgz(i,j)-wa(i,j-1,k)*rgz(i,j-1))*rdy*vf(j)           &
                    +0.5*rds(k)*( (zt-sigma(k  ))*(dum1(i,j,k  )+dum1(i,j-1,k  ))    &
                                 -(zt-sigma(k-1))*(dum1(i,j,k-1)+dum1(i,j-1,k-1)) )  &
                               *(rgz(i,j)-rgz(i,j-1))*rdy*vf(j)                      &
                   )*0.5*( gz(i,j)+gz(i,j-1) )
      enddo
      enddo
      enddo
      IF( bbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,1)=tem(i,j,2)
        enddo
        enddo
      ELSEIF( bbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,1)=-2.0*va(i,j,1)*rds(2)*0.5*( gz(i,j-1)+gz(i,j) )
        enddo
        enddo
      ENDIF
      IF( tbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,nk+1)=tem(i,j,nk)
        enddo
        enddo
      ELSEIF( tbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni
          tem(i,j,nk+1)=2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
        enddo
        enddo
      ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        xvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i,j+1,k)+tem(i,j,k+1)+tem(i,j+1,k+1))
      enddo
      enddo
      enddo
    getpv1: IF( output_pv.eq.1 )THEN
      !cccccccccccccccccccccccccccccccccccccc
      ! here, zvort array stores d(th)/dx
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        zvort(i,j,k) = gzu(i,j)*(th(i,j,k)*rgz(i,j)-th(i-1,j,k)*rgz(i-1,j))*rdx*uf(i)  &
               +0.5*( gxu(i,j,k+1)*(dum2(i,j,k+1)+dum2(i-1,j,k+1))                     &
                     -gxu(i,j,k  )*(dum2(i,j,k  )+dum2(i-1,j,k  )) )*rdsf(k)
      enddo
      enddo
      enddo
      ! pv1:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pv(i,j,k)=pv(i,j,k)+xvort(i,j,k)*0.5*( zvort(i,j,k)+zvort(i+1,j,k) )
      enddo
      enddo
      enddo
      !cccccccccccccccccccccccccccccccccccccc
    ENDIF  getpv1
    ENDIF
  else
      !cccccccccccccccccccccccccccccccccccccc
      ! Axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        tem(i,j,k) = -(va(i,j,k)-va(i,j,k-1))*rdz*mf(1,1,k)
      enddo
      enddo
      enddo
      IF( bbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          tem(i,j,1)=tem(i,j,2)
        enddo
        enddo
      ELSEIF( bbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          tem(i,j,1)=-2.0*va(i,j,1)*rdz*mf(1,1,1)
        enddo
        enddo
      ENDIF
      IF( tbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          tem(i,j,nk+1)=tem(i,j,nk)
        enddo
        enddo
      ELSEIF( tbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          tem(i,j,nk+1)=2.0*va(i,j,nk)*rdz*mf(1,1,nk+1)
        enddo
        enddo
      ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        xvort(i,j,k) = 0.5*(tem(i,j,k)+tem(i,j,k+1))
      enddo
      enddo
      enddo
      !cccccccccccccccccccccccccccccccccccccc
  endif

!-----------------------------------------------------------------------
! y-vort:

    tem=0.0
    IF(.not.terrain_flag)THEN
      !cccccccccccccccccccccccccccccccccccccc
      ! Cartesian grid, without terrain:
      ! and axisymmetric grid:

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni+1
        tem(i,j,k) = (ua(i,j,k)-ua(i,j,k-1))*rdz*0.5*(mf(i-1,j,k)+mf(i,j,k))   &
                    -(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo
      IF( bbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,1)=tem(i,j,2)
        enddo
        enddo
      ELSEIF( bbc.eq.2 )THEN
      if( imove.eq.0 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,1)=2.0*ua(i,j,1)*rdz*0.5*(mf(i-1,j,1)+mf(i,j,1))
        enddo
        enddo
      else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,1)=2.0*(ua(i,j,1)+umove)*rdz*0.5*(mf(i-1,j,1)+mf(i,j,1))
        enddo
        enddo
      endif
      ENDIF
      IF( tbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,nk+1)=tem(i,j,nk)
        enddo
        enddo
      ELSEIF( tbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,nk+1)=-2.0*ua(i,j,nk)*rdz*0.5*(mf(i-1,j,nk+1)+mf(i,j,nk+1))
        enddo
        enddo
      ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        yvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i+1,j,k)+tem(i,j,k+1)+tem(i+1,j,k+1))
      enddo
      enddo
      enddo
      !cccccccccccccccccccccccccccccccccccccc
    getpv12:  IF( output_pv.eq.1 )THEN
      ! here, zvort array stores d(th)/dy
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        zvort(i,j,k) = (th(i,j,k)-th(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo
      ! pv1:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pv(i,j,k)=pv(i,j,k)+yvort(i,j,k)*0.5*( zvort(i,j,k)+zvort(i,j+1,k) )
      enddo
      enddo
      enddo
    ENDIF  getpv12
      !cccccccccccccccccccccccccccccccccccccc
    ELSE
      !cccccccccccccccccccccccccccccccccccccc
      ! Cartesian grid, with terrain:
      !   (dum1 stores w at scalar-pts:)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni+1
        tem(i,j,k)=( (ua(i,j,k)-ua(i,j,k-1))*rds(k)                                  &
                    -(wa(i,j,k)*rgz(i,j)-wa(i-1,j,k)*rgz(i-1,j))*rdx*uf(i)           &
                    -0.5*rds(k)*( (zt-sigma(k  ))*(dum1(i,j,k  )+dum1(i-1,j,k  ))    &
                                 -(zt-sigma(k-1))*(dum1(i,j,k-1)+dum1(i-1,j,k-1)) )  &
                               *(rgz(i,j)-rgz(i-1,j))*rdx*uf(i)                      &
                   )*0.5*( gz(i,j)+gz(i-1,j) )
      enddo
      enddo
      enddo
      IF( bbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,1)=tem(i,j,2)
        enddo
        enddo
      ELSEIF( bbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,1)=2.0*ua(i,j,1)*rds(2)*0.5*( gz(i-1,j)+gz(i,j) )
        enddo
        enddo
      ENDIF
      IF( tbc.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,nk+1)=tem(i,j,nk)
        enddo
        enddo
      ELSEIF( tbc.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni+1
          tem(i,j,nk+1)=-2.0*ua(i,j,nk)*rds(nk)*0.5*( gz(i-1,j)+gz(i,j) )
        enddo
        enddo
      ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        yvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i+1,j,k)+tem(i,j,k+1)+tem(i+1,j,k+1))
      enddo
      enddo
      enddo
    getpv2:  IF( output_pv.eq.1 )THEN
      !cccccccccccccccccccccccccccccccccccccc
      ! here, zvort array stores d(th)/dy
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        zvort(i,j,k) = gzv(i,j)*(th(i,j,k)*rgz(i,j)-th(i,j-1,k)*rgz(i,j-1))*rdy*vf(j)  &
               +0.5*( gyv(i,j,k+1)*(dum2(i,j,k+1)+dum2(i,j-1,k+1))                     &
                     -gyv(i,j,k  )*(dum2(i,j,k  )+dum2(i,j-1,k  )) )*rdsf(k)
      enddo
      enddo
      enddo
      ! pv1:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pv(i,j,k)=pv(i,j,k)+yvort(i,j,k)*0.5*( zvort(i,j,k)+zvort(i,j+1,k) )
      enddo
      enddo
      enddo
    ENDIF  getpv2
      !cccccccccccccccccccccccccccccccccccccc
    ENDIF

!-----------------------------------------------------------------------
! z-vort:

    tem=0.0
    if(axisymm.eq.0)then
      IF(.not.terrain_flag)THEN
        !cccccccccccccccccccccccccccccccccccccc
        ! Cartesian grid, without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj+1
          do i=1,ni+1
            tem(i,j,k) = (va(i,j,k)-va(i-1,j,k))*rdx*uf(i)   &
                        -(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            zvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i+1,j,k)+tem(i,j+1,k)+tem(i+1,j+1,k))
          enddo
          enddo
        enddo
        !cccccccccccccccccccccccccccccccccccccc
      ELSE
        !cccccccccccccccccccccccccccccccccccccc
        ! Cartesian grid, with terrain:
        ! dum1 stores u at w-pts:
        ! dum2 stores v at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+2
          ! lowest model level:
          do i=0,ni+2
            dum1(i,j,1) = cgs1*ua(i,j,1)+cgs2*ua(i,j,2)+cgs3*ua(i,j,3)
            dum2(i,j,1) = cgs1*va(i,j,1)+cgs2*va(i,j,2)+cgs3*va(i,j,3)
          enddo
          ! upper-most model level:
          do i=0,ni+2
            dum1(i,j,nk+1) = cgt1*ua(i,j,nk)+cgt2*ua(i,j,nk-1)+cgt3*ua(i,j,nk-2)
            dum2(i,j,nk+1) = cgt1*va(i,j,nk)+cgt2*va(i,j,nk-1)+cgt3*va(i,j,nk-2)
          enddo
          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+2
            dum1(i,j,k) = r1*ua(i,j,k-1)+r2*ua(i,j,k)
            dum2(i,j,k) = r1*va(i,j,k-1)+r2*va(i,j,k)
          enddo
          enddo
        enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k,r1)
        do k=1,nk
          do j=1,nj+1
          do i=1,ni+1
            r1 = zt/(zt-0.25*((zs(i-1,j-1)+zs(i,j))+(zs(i-1,j)+zs(i,j-1))))
            tem(i,j,k)=r1*( (va(i,j,k)*rgzv(i,j)-va(i-1,j,k)*rgzv(i-1,j))*rdx*uf(i)  &
                           +0.5*( (zt-sigmaf(k+1))*(dum2(i-1,j,k+1)+dum2(i,j,k+1))   &
                                 -(zt-sigmaf(k  ))*(dum2(i-1,j,k  )+dum2(i,j,k  ))   &
                                )*rdsf(k)*(rgzv(i,j)-rgzv(i-1,j))*rdx*uf(i) )        &
                      -r1*( (ua(i,j,k)*rgzu(i,j)-ua(i,j-1,k)*rgzu(i,j-1))*rdy*vf(j)  &
                           +0.5*( (zt-sigmaf(k+1))*(dum1(i,j-1,k+1)+dum1(i,j,k+1))   &
                                 -(zt-sigmaf(k  ))*(dum1(i,j-1,k  )+dum1(i,j,k  ))   &
                                )*rdsf(k)*(rgzu(i,j)-rgzu(i,j-1))*rdy*vf(j) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni
            zvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i+1,j,k)+tem(i,j+1,k)+tem(i+1,j+1,k))
          enddo
          enddo
        enddo
        !cccccccccccccccccccccccccccccccccccccc
      ENDIF
    else
      !cccccccccccccccccccccccccccccccccccccc
      ! Axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        tem(1,j,k) = 0.0
        do i=2,ni+1
          tem(i,j,k) = (va(i,j,k)*xh(i)-va(i-1,j,k)*xh(i-1))*rdx*uf(i)/xf(i)
        enddo
        enddo
        do j=1,nj
        do i=1,ni
          zvort(i,j,k) = 0.5*(tem(i,j,k)+tem(i+1,j,k))
        enddo
        enddo
      enddo
      !cccccccccccccccccccccccccccccccccccccc
    endif


    getpv3:  IF( output_pv.eq.1 )THEN
      ! now, dum1 stores dt/dz:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do j=1,nj
        do k=2,nk
        do i=1,ni
          dum1(i,j,k) = (th(i,j,k)-th(i,j,k-1))*rdz*mf(i,j,k)
        enddo
        enddo
        do i=1,ni
          dum1(i,j,1) = (dgs3*th(i,j,3)+dgs2*th(i,j,2)+dgs1*th(i,j,1))*rdz*mh(i,j,1)
        enddo
        do i=1,ni
          dum1(i,j,nk+1) = (dgt3*th(i,j,nk-2)+dgt2*th(i,j,nk-1)+dgt1*th(i,j,nk))*rdz*mh(i,j,nk)
        enddo
        ! pv:
        do k=1,nk
        do i=1,ni
          pv(i,j,k)=pv(i,j,k)+zvort(i,j,k)*0.5*(dum1(i,j,k)+dum1(i,j,k+1))
          pv(i,j,k)=pv(i,j,k)*rr(i,j,k)
        enddo
        enddo
      enddo
    ENDIF  getpv3

!-----------------------------------------------------------------------

      IF( bbc.eq.3 )THEN
        ! cm1r18:  use log-layer equation below
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          xvort(i,j,1) = -(ust(i,j)/(karman*(zh(i,j,1)+znt(i,j))))*(v1(i,j)/max(s1(i,j),0.01))
          yvort(i,j,1) =  (ust(i,j)/(karman*(zh(i,j,1)+znt(i,j))))*(u1(i,j)/max(s1(i,j),0.01))
        enddo
        enddo
      ENDIF

!-----------------------------------------------------------------------

      return
      end subroutine calcvort


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calccpch(zh,zf,th0,qv0,cpc,cph,tha,qa)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: th0,qv0
      real, intent(inout), dimension(ib:ie,jb:je) :: cpc,cph
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: tha
      real, intent(in),    dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa

      integer :: i,j,k,n
      real :: ql
      real, dimension(nk) :: bb

      ! defines top of cold pool / location to stop calculation of C
      real, parameter :: bcrit = -0.01

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,ql,bb)
    DO j=1,nj
    DO i=1,ni
      cpc(i,j) = 0.0
      cph(i,j) = 0.0
      bb = 0.0
      do k=1,nk
        bb(k) = g*tha(i,j,k)/th0(i,j,k)
      enddo
      if(imoist.eq.1)then
        do k=1,nk
          ql = 0.0
          do n=nql1,nql2
            ql=ql+qa(i,j,k,n)
          enddo
          if(iice.eq.1)then
            do n=nqs1,nqs2
              ql=ql+qa(i,j,k,n)
            enddo
          endif
          bb(k) = bb(k) + g*( repsm1*(qa(i,j,k,nqv)-qv0(i,j,k)) - ql )
        enddo
      endif
    ! only calculate cpc/cph if surface B is less than bcrit
    IF( bb(1).lt.bcrit .and. tha(i,j,1).le.-1.0 )THEN
      cpc(i,j) = - 2.0*bb(1)*(zf(i,j,2)-zf(i,j,1))
      k = 2
      do while( bb(k).lt.bcrit .and. k.lt.nk )
        if( cpc(i,j).lt.0.0 ) cpc(i,j) = 0.0
        cpc(i,j) = cpc(i,j) - 2.0*bb(k)*(zf(i,j,k+1)-zf(i,j,k))
        k = k + 1
      enddo
      if( cpc(i,j).gt.0.0 )then
        cpc(i,j) = sqrt(cpc(i,j))
        if(k.eq.nk)then
          cph(i,j) = zf(i,j,nk+1)
        else
          cph(i,j) = zh(i,j,k-1) + (zh(i,j,k)-zh(i,j,k-1))*(bcrit-bb(k-1))   &
                                                          /(bb(k)-bb(k-1))
        endif
        ! account for terrain:
        cph(i,j) = cph(i,j) - zf(i,j,1)
      endif
    ENDIF
    ENDDO
    ENDDO

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calccref(cref,dbz)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je) :: cref
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: dbz

      integer :: i,j,k

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do j=1,nj
      do i=1,ni
        cref(i,j)=0.0
        do k=1,nk
          cref(i,j)=max(cref(i,j),dbz(i,j,k))
        enddo
      enddo
      enddo


      if(timestats.ge.1) time_write=time_write+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcthe(zh,pi0,th0,the,rh,prs,ppi,tha,qa)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: zh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: the,rh,prs,ppi,tha
      real, dimension(ib:ie,jb:je,kb:ke,numq) :: qa

      integer i,j,k,n
      real tx,cpm
      real rslf
      real, parameter :: l0 = 2.555e6

! Reference:  Bryan, 2008, MWR, p. 5239

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tx,cpm)
      do j=1,nj
      do k=1,nk
      do i=1,ni
        if(zh(i,j,k).le.10000.)then
          tx=(th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k))
          cpm=cp
          the(i,j,k)=tx                                              &
            *((p00*(1.0+qa(i,j,k,nqv)*reps)/prs(i,j,k))**(rd/cpm))   &
            *(rh(i,j,k)**(-qa(i,j,k,nqv)*rv/cpm))                    &
            *exp(l0*qa(i,j,k,nqv)/(cpm*tx))
        else
          the(i,j,k)=the(i,j,k-1)
        endif
      enddo
      enddo
      enddo

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine cloud(nstat,rstat,zh,qci)
#ifdef MPI
      use mpi
#endif
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie,jb:je,kb:ke) :: zh
      real, dimension(ib:ie,jb:je,kb:ke) :: qci

      integer i,j,k
      real qcbot(nk),qctop(nk),bot,top,var

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        qcbot(k)=maxz
        qctop(k)=0.0
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          if(qci(i,j,k).ge.clwsat)then
            qctop(k)=max(qctop(k),zh(i,j,k))
            qcbot(k)=min(qcbot(k),zh(i,j,k))
          endif
        enddo
        enddo
      enddo

      top=0.0
      do k=1,nk
        top=max(top,qctop(k))
      enddo

      bot=maxz
      do k=1,nk
        bot=min(bot,qcbot(k))
      enddo

#ifdef MPI
      call MPI_REDUCE(bot,var,1,MPI_REAL,MPI_MIN,0,MPI_COMM_WORLD,ierr)
      bot=var
      call MPI_REDUCE(top,var,1,MPI_REAL,MPI_MAX,0,MPI_COMM_WORLD,ierr)
      top=var
      if(myid.eq.0)then
#endif

      if(bot.eq.maxz) bot=0.0

      write(6,100) 'QCTOP ',top,1,1,1,   &
                   'QCBOT ',bot,1,1,1
100   format(2x,a6,':',1x,f13.6,i5,i5,i5,   &
             4x,a6,':',1x,f13.6,i5,i5,i5)
 
      nstat = nstat + 1
      rstat(nstat) = top
      nstat = nstat + 1
      rstat(nstat) = bot

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine vertvort(nstat,rstat,xh,xf,uf,vf,zh,zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf,dum1,dum2,ua,va)
#ifdef MPI
      use mpi
#endif
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: xh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: rgzu,rgzv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer i,j,k,n,n1km,n2km,n3km,n4km,n5km
      real vort,vmax,var
      real :: r1,r2
      character*6 text

!-----
!  note:  does not account for terrain

      n1km=nk+1
      n2km=nk+1
      n3km=nk+1
      n4km=nk+1
      n5km=nk+1

      do k=nk,1,-1
        if(zh(1,1,k).ge.1000.0) n1km=k
        if(zh(1,1,k).ge.2000.0) n2km=k
        if(zh(1,1,k).ge.3000.0) n3km=k
        if(zh(1,1,k).ge.4000.0) n4km=k
        if(zh(1,1,k).ge.5000.0) n5km=k
      enddo

      IF(terrain_flag)THEN
        ! dum1 stores u at w-pts:
        ! dum2 stores v at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+2
          ! lowest model level:
          do i=0,ni+2
            dum1(i,j,1) = cgs1*ua(i,j,1)+cgs2*ua(i,j,2)+cgs3*ua(i,j,3)
            dum2(i,j,1) = cgs1*va(i,j,1)+cgs2*va(i,j,2)+cgs3*va(i,j,3)
          enddo

          ! upper-most model level:
          do i=0,ni+2
            dum1(i,j,nk+1) = cgt1*ua(i,j,nk)+cgt2*ua(i,j,nk-1)+cgt3*ua(i,j,nk-2)
            dum2(i,j,nk+1) = cgt1*va(i,j,nk)+cgt2*va(i,j,nk-1)+cgt3*va(i,j,nk-2)
          enddo

          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+2
            dum1(i,j,k) = r1*ua(i,j,k-1)+r2*ua(i,j,k)
            dum2(i,j,k) = r1*va(i,j,k-1)+r2*va(i,j,k)
          enddo
          enddo
        enddo
      ENDIF

      do n=1,6
        vmax = 0.0
        if(n.eq.1)then
          k=1
          text='VORSFC'
        elseif(n.eq.2)then
          k=n1km
          text='VOR1KM'
        elseif(n.eq.3)then
          k=n2km
          text='VOR2KM'
        elseif(n.eq.4)then
          k=n3km
          text='VOR3KM'
        elseif(n.eq.5)then
          k=n4km
          text='VOR4KM'
        elseif(n.eq.6)then
          k=n5km
          text='VOR5KM'
        endif
    kcheck:  IF( k.le.nk )THEN
        vmax=-9999999.
    IF( axisymm.eq.0 )THEN
      IF(.not.terrain_flag)THEN
        ! Cartesian grid, without terrain:
        do j=1+ibs,nj+1-ibn
        do i=1+ibw,ni+1-ibe
          vort=(va(i,j,k)-va(i-1,j,k))*rdx*uf(i)   &
              -(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
          vmax=max(vmax,vort)
        enddo
        enddo
      ELSE
        ! Cartesian grid, with terrain:
        do j=1+ibs,nj+1-ibn
        do i=1+ibw,ni+1-ibe
          r1 = zt/(zt-0.25*((zs(i-1,j-1)+zs(i,j))+(zs(i-1,j)+zs(i,j-1))))
          vort=( r1*(va(i,j,k)*rgzv(i,j)-va(i-1,j,k)*rgzv(i-1,j))*rdx*uf(i)  &
                +0.5*( (zt-sigmaf(k+1))*(dum2(i-1,j,k+1)+dum2(i,j,k+1))      &
                      -(zt-sigmaf(k  ))*(dum2(i-1,j,k  )+dum2(i,j,k  ))      &
                     )*rdsf(k)*r1*(rgzv(i,j)-rgzv(i-1,j))*rdx*uf(i) )        &
              -( r1*(ua(i,j,k)*rgzu(i,j)-ua(i,j-1,k)*rgzu(i,j-1))*rdy*vf(j)  &
                +0.5*( (zt-sigmaf(k+1))*(dum1(i,j-1,k+1)+dum1(i,j,k+1))      &
                      -(zt-sigmaf(k  ))*(dum1(i,j-1,k  )+dum1(i,j,k  ))      &
                     )*rdsf(k)*r1*(rgzu(i,j)-rgzu(i,j-1))*rdy*vf(j) )
          vmax=max(vmax,vort)
        enddo
        enddo
      ENDIF
    ELSE
        ! axisymmetric grid
        do j=1,nj+1
        do i=2,ni+1
          vort=(xh(i)*va(i,j,k)-xh(i-1)*va(i-1,j,k))*rdx*uf(i)/xf(i)
          vmax=max(vmax,vort)
        enddo
        enddo
    ENDIF
    ENDIF  kcheck
#ifdef MPI
        call MPI_REDUCE(vmax,var,1,MPI_REAL,MPI_MAX,0,   &
                        MPI_COMM_WORLD,ierr)
        vmax=var
        if(myid.eq.0)then
#endif
        write(6,100) text,vmax
        nstat = nstat + 1
        rstat(nstat) = vmax
#ifdef MPI
        endif
#endif
      ENDDO

100   format(2x,a6,':',1x,e13.6)

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

 
      subroutine calccfl(nstat,rstat,dt,acfl,uh,vh,mh,ua,va,wa,writeit)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real :: dt
      double precision :: acfl
      real, intent(in), dimension(ib:ie) :: uh
      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      integer :: writeit
 
      integer i,j,k
      integer imax,jmax,kmax
      integer imaxt(nk),jmaxt(nk),kmaxt(nk)
      real dtdx,dtdy,dtdz,cfl(nk),fmax
      real :: wsp
      integer :: loc
      real, dimension(2) :: mmax,nmax
 
      dtdx=0.5*dt*rdx
      dtdy=0.5*dt*rdy
      dtdz=0.5*dt*rdz

      cfl = -1.0
      imaxt = 0
      jmaxt = 0
      kmaxt = 0

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wsp)
      do k=1,nk
      if(nx.gt.1.and.ny.gt.1)then
        do j=1,nj
        do i=1,ni
          wsp = sqrt( ( ((ua(i,j,k)+ua(i+1,j,k))*dtdx*uh(i))**2     &
                       +((va(i,j,k)+va(i,j+1,k))*dtdy*vh(j))**2 )   &
                       +((wa(i,j,k)+wa(i,j,k+1))*dtdz*mh(i,j,k))**2 )
          if( wsp.gt.cfl(k) )then
            cfl(k) = wsp
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
        enddo
        enddo
      elseif(nx.gt.1)then
        do j=1,nj
        do i=1,ni
          wsp = sqrt( ((ua(i,j,k)+ua(i+1,j,k))*dtdx*uh(i))**2     &
                     +((wa(i,j,k)+wa(i,j,k+1))*dtdz*mh(i,j,k))**2 )
          if( wsp.gt.cfl(k) )then
            cfl(k) = wsp
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
        enddo
        enddo
      elseif(axisymm.eq.0.and.ny.gt.1)then
        do j=1,nj
        do i=1,ni
          wsp = sqrt( ((va(i,j,k)+va(i,j+1,k))*dtdy*vh(j))**2     &
                     +((wa(i,j,k)+wa(i,j,k+1))*dtdz*mh(i,j,k))**2 )
          if( wsp.gt.cfl(k) )then
            cfl(k) = wsp
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
        enddo
        enddo
      endif
      enddo

      fmax=-99999999.
      imax=1
      jmax=1
      kmax=1
      do k=1,nk
        if(cfl(k).gt.fmax)then
          fmax=cfl(k)
          imax=imaxt(k)
          jmax=jmaxt(k)
          kmax=kmaxt(k)
        endif
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
      call MPI_BCAST(imax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      fmax=nmax(1)

      if(myid.eq.0)then
#endif

    IF(writeit.eq.1)THEN
      nstat = nstat + 1
      IF( adapt_dt.eq.1 )THEN
        write(6,100) 'CFLMAX',sngl(acfl),imax,jmax,kmax
        rstat(nstat) = sngl(acfl)
      ELSE
        write(6,100) 'CFLMAX',fmax,imax,jmax,kmax
        rstat(nstat) = fmax
      ENDIF
100   format(2x,a6,':',1x,f13.6,i5,i5,i5)
    ENDIF

#ifdef MPI
      endif
#endif

!!!      cflmax = fmax

      if(fmax.ge.1.50) stopit=.true.
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calccflquick(dt,uh,vh,mh,ua,va,wa)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: uh
      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
 
      integer :: i,j,k
      real :: dtdx,dtdy,dtdz,fmax,gmax,wsp,tem
      real, dimension(nk) :: cfl
 
      dtdx=0.5*dt*rdx
      dtdy=0.5*dt*rdy
      dtdz=0.5*dt*rdz

      cfl = 0.0

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wsp,tem)
      do k=1,nk
      if(nx.gt.1.and.ny.gt.1)then
        do j=1,nj
        do i=1,ni
          wsp = sqrt( ( ((ua(i,j,k)+ua(i+1,j,k))*dtdx*uh(i))**2     &
                       +((va(i,j,k)+va(i,j+1,k))*dtdy*vh(j))**2 )   &
                       +((wa(i,j,k)+wa(i,j,k+1))*dtdz*mh(i,j,k))**2 )
          cfl(k) = max( cfl(k) , wsp )
          if( wsp.ge.1.30 ) print *,'  cfl,myid,i,j,k = ',wsp,myid,i,j,k
        enddo
        enddo
      elseif(nx.gt.1)then
        do j=1,nj
        do i=1,ni
          wsp = sqrt( ((ua(i,j,k)+ua(i+1,j,k))*dtdx*uh(i))**2     &
                     +((wa(i,j,k)+wa(i,j,k+1))*dtdz*mh(i,j,k))**2 )
          cfl(k) = max( cfl(k) , wsp )
          if( wsp.ge.1.30 ) print *,'  cfl,myid,i,j,k = ',wsp,myid,i,j,k
        enddo
        enddo
      elseif(axisymm.eq.0.and.ny.gt.1)then
        do j=1,nj
        do i=1,ni
          wsp = sqrt( ((va(i,j,k)+va(i,j+1,k))*dtdy*vh(j))**2     &
                     +((wa(i,j,k)+wa(i,j,k+1))*dtdz*mh(i,j,k))**2 )
          cfl(k) = max( cfl(k) , wsp )
          if( wsp.ge.1.30 ) print *,'  cfl,myid,i,j,k = ',wsp,myid,i,j,k
        enddo
        enddo
      endif
      enddo

      fmax=-99999999.
      do k=1,nk
        fmax = max( fmax , cfl(k) )
      enddo

#ifdef MPI
      gmax = 0.0
      call MPI_ALLREDUCE(fmax,gmax,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      fmax = gmax
#endif

      if(fmax.ge.1.50) stopit=.true.

      cflmax = fmax

      if(timestats.ge.1) time_cflq=time_cflq+mytime()
 
      end subroutine calccflquick


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcksmax(nstat,rstat,dt,uh,vh,mf,kmh,kmv,khh,khv)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nstat
      real, dimension(stat_out) :: rstat
      real :: dt
      real, dimension(ib:ie) :: uh
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv

      integer i,j,k
      integer imaxh,jmaxh,kmaxh
      integer imaxv,jmaxv,kmaxv
      integer imaxth(nk),jmaxth(nk),kmaxth(nk)
      integer imaxtv(nk),jmaxtv(nk),kmaxtv(nk)
      real dtdx,dtdy,dtdz,tem,ksh(nk),ksv(nk),fhmax,fvmax
      integer :: loc
      real, dimension(2) :: mmax,nmax

    IF(iturb.ge.1)THEN

      dtdx=dt*rdx*rdx
      dtdy=dt*rdy*rdy
      dtdz=dt*rdz*rdz

!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
      do k=2,nk
        ksh(k)=-99999.0
        ksv(k)=-99999.0
        do j=1,nj
        do i=1,ni
!!!          tem = max( abs(kmh(i,j,k))*dtdx*uh(i)*uh(i) ,   &
!!!                     abs(khh(i,j,k))*dtdx*uh(i)*uh(i) )
          tem = khh(i,j,k)*dtdx*uh(i)*uh(i)
          if( tem.gt.ksh(k) )then
            ksh(k)=tem
            imaxth(k)=i
            jmaxth(k)=j
            kmaxth(k)=k
          endif
!!!          tem = max( abs(kmh(i,j,k))*dtdy*vh(j)*vh(j) ,   &
!!!                     abs(khh(i,j,k))*dtdy*vh(j)*vh(j) )
          tem = khh(i,j,k)*dtdy*vh(j)*vh(j)
          if( tem.gt.ksh(k) )then
            ksh(k)=tem
            imaxth(k)=i
            jmaxth(k)=j
            kmaxth(k)=k
          endif
!!!          tem = max( abs(kmv(i,j,k))*dtdz*mf(i,j,k)*mf(i,j,k) ,   &
!!!                     abs(khv(i,j,k))*dtdz*mf(i,j,k)*mf(i,j,k) )
          tem = khv(i,j,k)*dtdz*mf(i,j,k)*mf(i,j,k)
          if( tem.gt.ksv(k) )then
            ksv(k)=tem
            imaxtv(k)=i
            jmaxtv(k)=j
            kmaxtv(k)=k
          endif
        enddo
        enddo
      enddo

      fhmax=-99999999.
      fvmax=-99999999.
      imaxh=1
      jmaxh=1
      kmaxh=1
      imaxv=1
      jmaxv=1
      kmaxv=1
      do k=2,nk
        if(ksh(k).gt.fhmax)then
          fhmax=ksh(k)
          imaxh=imaxth(k)
          jmaxh=jmaxth(k)
          kmaxh=kmaxth(k)
        endif
        if(ksv(k).gt.fvmax)then
          fvmax=ksv(k)
          imaxv=imaxtv(k)
          jmaxv=jmaxtv(k)
          kmaxv=kmaxtv(k)
        endif
      enddo

    ELSE

      fhmax = 0.0
      fvmax = 0.0
      imaxh = 0
      jmaxh = 0
      kmaxh = 0
      imaxv = 0
      jmaxv = 0
      kmaxv = 0

    ENDIF

#ifdef MPI
      mmax(1)=fhmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imaxh=imaxh+(myi-1)*ni
      jmaxh=jmaxh+(myj-1)*nj
      call MPI_BCAST(imaxh,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmaxh,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmaxh,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      fhmax=nmax(1)

      mmax(1)=fvmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imaxv=imaxv+(myi-1)*ni
      jmaxv=jmaxv+(myj-1)*nj
      call MPI_BCAST(imaxv,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmaxv,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmaxv,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      fvmax=nmax(1)

      if(myid.eq.0)then
#endif

      write(6,100) 'KSHMAX',fhmax,imaxh,jmaxh,kmaxh

      nstat = nstat + 1
      rstat(nstat) = fhmax

      write(6,100) 'KSVMAX',fvmax,imaxv,jmaxv,kmaxv

      nstat = nstat + 1
      rstat(nstat) = fvmax

100   format(2x,a6,':',1x,g13.6,i5,i5,i5)

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getrmw(nstat,rstat,xh,zh,ua,va)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      integer, intent(inout) :: nstat
      real, intent(inout), dimension(stat_out) :: rstat
      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer :: i,k,imax,jmax,kmax
      real :: wspd
      real :: rmax,zmax,vmax

      integer, dimension(nk) :: imaxt,kmaxt
      real, dimension(nk) :: rmaxt,zmaxt,vmaxt

      ! Note:  only called from axisymmetric simulation

!$omp parallel do default(shared)  &
!$omp private(i,k,wspd)
      do k=1,nk
        vmaxt(k) = 0.0
        do i=1,ni
          wspd = sqrt( (0.5*(ua(i,1,k)+ua(i+1,1,k)))**2 + va(i,1,k)**2 )
          IF( wspd.ge.vmaxt(k) )THEN
            vmaxt(k) = wspd
            rmaxt(k) = xh(i)
            zmaxt(k) = zh(i,1,k)
            imaxt(k) = i
            kmaxt(k) = k
          ENDIF
        enddo
      enddo

      vmax = 0.0
      do k=1,nk
        IF( vmaxt(k).ge.vmax )THEN
          vmax = vmaxt(k)
          rmax = rmaxt(k)
          zmax = zmaxt(k)
          imax = imaxt(k)
          kmax = kmaxt(k)
        ENDIF
      enddo

      jmax = 1

      write(6,131) 'RMW   ',rmax,imax,jmax,kmax
      write(6,131) 'ZMW   ',zmax,imax,jmax,kmax
131   format(2x,a6,':',1x,f13.6,i5,i5,i5)

      nstat = nstat + 1
      rstat(nstat) = rmax
      nstat = nstat + 1
      rstat(nstat) = zmax

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcmass(nstat,rstat,ruh,rvh,rmh,rho)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
 
      integer i,j,k
      double precision :: tmass,var
      double precision, dimension(nk) :: foo
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        foo(k)=0.0d0
        do j=1,nj
        do i=1,ni
          foo(k)=foo(k)+rho(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
        enddo
        enddo
      enddo
 
      tmass=0.0d0
      do k=1,nk
        tmass=tmass+foo(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmass,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      tmass=var
      if(myid.eq.0)then
#endif

      tmass=tmass*(dx*dy*dz)
 
      write(6,100) 'TMASS ',tmass
100   format(2x,a6,':',1x,e13.6)
 
      nstat = nstat + 1
      rstat(nstat) = tmass

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine totmois(nstat,rstat,train,ruh,rvh,rmh,qv,ql,qi,rho)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nstat
      real, dimension(stat_out) :: rstat
      double precision :: train
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: qv,ql,qi,rho
 
      integer i,j,k
      double precision :: tmass,var
      double precision, dimension(nk) :: foo

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        foo(k)=0.0d0
      enddo
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          foo(k)=foo(k)+rho(i,j,k)*(qv(i,j,k)+ql(i,j,k)+qi(i,j,k))*ruh(i)*rvh(j)*rmh(i,j,k)
        enddo
        enddo
      enddo
 
      tmass=0.0d0
      do k=1,nk
        tmass=tmass+foo(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmass,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      tmass=var
      if(myid.eq.0)then
#endif

!!!      tmass=tmass*(dx*dy*dz)+train
      ! cm1r18:  do not include rain:
      tmass=tmass*(dx*dy*dz)

      write(6,100) 'TMOIS ',tmass
100   format(2x,a6,':',1x,e13.6)
 
      nstat = nstat + 1
      rstat(nstat) = tmass

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine totq(nstat,rstat,ruh,rvh,rmh,q,rho,aname)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: q,rho
      character*6 aname

      integer i,j,k
      double precision :: tmass,var
      double precision, dimension(nk) :: foo

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        foo(k)=0.0d0
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        foo(k)=foo(k)+rho(i,j,k)*q(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
      enddo
      enddo
      enddo

      tmass=0.0d0
      do k=1,nk
        tmass=tmass+foo(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmass,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      tmass=var
      if(myid.eq.0)then
#endif

      tmass=tmass*(dx*dy*dz)

      write(6,100) aname,tmass
100   format(2x,a6,':',1x,e13.6)

      nstat = nstat + 1
      rstat(nstat) = tmass

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine calcener(nstat,rstat,ruh,rvh,zh,rmh,pi0,th0,rho,ua,va,wa,ppi,tha,   &
                          qv,ql,qi,vr)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha,qv,ql,qi,vr
 
      integer i,j,k
      double precision :: u,v,w,tmp,qtot,ek,ei,ep,et,le,var,tem
      double precision, dimension(nk) :: foo1,foo2,foo3,foo4

!$omp parallel do default(shared)  &
!$omp private(i,j,k,u,v,w,tmp,qtot,tem)
      do k=1,nk
        foo1(k)=0.0d0      ! = ek
        foo2(k)=0.0d0      ! = ei
        foo3(k)=0.0d0      ! = ep
        foo4(k)=0.0d0      ! = le
        do j=1,nj
        do i=1,ni
          tem=ruh(i)*rvh(j)*rmh(i,j,k)
          u=umove+0.5*(ua(i,j,k)+ua(i+1,j,k))
          v=vmove+0.5*(va(i,j,k)+va(i,j+1,k))
          w=0.5*(wa(i,j,k)+wa(i,j,k+1))
          qtot=qv(i,j,k)+ql(i,j,k)+qi(i,j,k)
          foo1(k)=foo1(k)+rho(i,j,k)*tem*(1.0+qtot)*0.5*(        &
                         0.5*( ua(i,j,k)**2 + ua(i+1,j,k)**2 )   &
                        +0.5*( va(i,j,k)**2 + va(i,j+1,k)**2 )   &
                        +0.5*( wa(i,j,k)**2 + wa(i,j,k+1)**2 ) ) &
               +ql(i,j,k)*rho(i,j,k)*tem*0.5*(vr(i,j,k)**2-2.0*w*vr(i,j,k))
          tmp=(th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k))
          foo2(k)=foo2(k)+rho(i,j,k)*tem*(cv+cvv*qv(i,j,k))*tmp
          foo3(k)=foo3(k)+rho(i,j,k)*tem*(1.0+qtot)*g*zh(i,j,k)
          foo4(k)=foo4(k)+rho(i,j,k)*tem*ql(i,j,k)*(cpl*tmp-lv1)   &
                         +rho(i,j,k)*tem*qi(i,j,k)*(cpi*tmp-ls1)
        enddo
        enddo
      enddo

      ek=0.0d0
      ei=0.0d0
      ep=0.0d0
      le=0.0d0
 
      do k=1,nk
        ek=ek+foo1(k)
        ei=ei+foo2(k)
        ep=ep+foo3(k)
        le=le+foo4(k)
      enddo

      ek=ek*(dx*dy*dz)
      ei=ei*(dx*dy*dz)
      ep=ep*(dx*dy*dz)
      le=le*(dx*dy*dz)

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(ek,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      ek=var
      var=0.0d0
      call MPI_REDUCE(ei,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      ei=var
      var=0.0d0
      call MPI_REDUCE(ep,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      ep=var
      var=0.0d0
      call MPI_REDUCE(le,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      le=var
      if(myid.eq.0)then
#endif

      et=ek+ei+ep+le
 
      write(6,100) 'TENERG',et
100   format(2x,a6,':',1x,e13.6)

      nstat = nstat + 1
      rstat(nstat) = ek
      nstat = nstat + 1
      rstat(nstat) = ei
      nstat = nstat + 1
      rstat(nstat) = ep
      nstat = nstat + 1
      rstat(nstat) = le
      nstat = nstat + 1
      rstat(nstat) = et

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine calcmoe(nstat,rstat,ruh,rvh,rmh,rho,ua,va,wa,qv,ql,qi,vr)
#ifdef MPI
      use mpi
#endif
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: qv,ql,qi,vr
 
      integer i,j,k
      double precision :: tmu,tmv,tmw,qtot,var,tem
      double precision, dimension(nk) :: foo1,foo2,foo3

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        foo1(k)=0.0d0
        foo2(k)=0.0d0
        foo3(k)=0.0d0
      enddo
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k,qtot,tem)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          qtot=qv(i,j,k)+ql(i,j,k)+qi(i,j,k)
          tem=ruh(i)*rvh(j)*rmh(i,j,k)
          foo1(k)=foo1(k)   &
                +rho(i,j,k)*tem*(1.0+qtot)*( umove+0.5*(ua(i,j,k)+ua(i+1,j,k)) )
          foo2(k)=foo2(k)   &
                +rho(i,j,k)*tem*(1.0+qtot)*( vmove+0.5*(va(i,j,k)+va(i,j+1,k)) )
          foo3(k)=foo3(k)                                                &
                +rho(i,j,k)*tem*(1.0+qtot)*( 0.5*(wa(i,j,k)+wa(i,j,k+1)) )   &
                -rho(i,j,k)*tem*ql(i,j,k)*vr(i,j,k)
        enddo
        enddo
      enddo

      tmu=0.0d0
      tmv=0.0d0
      tmw=0.0d0
      do k=1,nk
        tmu=tmu+foo1(k)
        tmv=tmv+foo2(k)
        tmw=tmw+foo3(k)
      enddo

      tmu=tmu*(dx*dy*dz)
      tmv=tmv*(dx*dy*dz)
      tmw=tmw*(dx*dy*dz)

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmu,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmu=var
      var=0.0d0
      call MPI_REDUCE(tmv,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmv=var
      var=0.0d0
      call MPI_REDUCE(tmw,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmw=var
      if(myid.eq.0)then
#endif
 
      write(6,100) 'TMU   ',tmu
      write(6,100) 'TMV   ',tmv
      write(6,100) 'TMW   ',tmw
100   format(2x,a6,':',1x,e13.6)
 
      nstat = nstat + 1
      rstat(nstat) = tmu
      nstat = nstat + 1
      rstat(nstat) = tmv
      nstat = nstat + 1
      rstat(nstat) = tmw

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine tmf(nstat,rstat,ruh,rvh,rho,wa)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa

      integer i,j,k
      double precision :: tmfu,tmfd,mf,var
      double precision, dimension(nk) :: foo1,foo2

!$omp parallel do default(shared)  &
!$omp private(i,j,k,mf)
      do k=1,nk
        foo1(k)=0.0d0
        foo2(k)=0.0d0
        do j=1,nj
        do i=1,ni
          mf=rho(i,j,k)*0.5*(wa(i,j,k)+wa(i,j,k+1))*ruh(i)*rvh(j)
          foo1(k)=foo1(k)+max(mf,0.0d0)
          foo2(k)=foo2(k)+min(mf,0.0d0)
        enddo
        enddo
      enddo

      tmfu=0.0d0
      tmfd=0.0d0
      do k=1,nk
        tmfu=tmfu+foo1(k)
        tmfd=tmfd+foo2(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmfu,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmfu=var
      var=0.0d0
      call MPI_REDUCE(tmfd,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmfd=var
      if(myid.eq.0)then
#endif

      tmfu=tmfu*dx*dy
      tmfd=tmfd*dx*dy

      write(6,100) 'TMFU  ',tmfu
      write(6,100) 'TMFD  ',tmfd
100   format(2x,a6,':',1x,e13.6)

      nstat = nstat + 1
      rstat(nstat) = tmfu
      nstat = nstat + 1
      rstat(nstat) = tmfd

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine zinterp(sigma,zs,zh,dum1,dum2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(kb:ke) :: sigma
      real, dimension(ib:ie,jb:je) :: zs
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,dum1,dum2

      integer i,j,k,kk,kup,kdn
      real, dimension(nk) :: zref

      do k=1,nk
!!!        zref(k)=(k*dz-0.5*dz)
        zref(k)=sigma(k)
      enddo

      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum2(i,j,k)=dum1(i,j,k)
      enddo
      enddo
      enddo

      do k=1,nk
      do j=1,nj
      do i=1,ni
        if( (zref(k).lt.zh(i,j,1)).or.(zref(k).gt.zh(i,j,nk)) )then
          if( zref(k).gt.0.5*zh(i,j,1) .and. zref(k).gt.zs(i,j) )then
            ! 2nd-order extrapolation:
            dum1(i,j,k)=dum2(i,j,1)-(zh(i,j,1)-zref(k))                             &
                                   *(-3.0*dum2(i,j,1)+4.0*dum2(i,j,2)-dum2(i,j,3))  &
                                   *0.25/(zh(i,j,1)-zs(i,j))
          else
            dum1(i,j,k)=-99999999.
          endif
        elseif(zs(i,j).lt.0.1 .or. zref(k).eq.zh(i,j,1))then
          dum1(i,j,k)=dum2(i,j,k)
        else
          kup=0
          kdn=0
          do kk=1,nk
            if(zref(k).gt.zh(i,j,kk)) kdn=kk
          enddo
          kup=kdn+1
          if(kup.le.0.or.kdn.le.0.or.kup.ge.nk+1.or.kdn.ge.nk+1)then
            print *,kdn,kup
            print *,zs(i,j),zh(i,j,kdn),zref(k),zh(i,j,kup)
            print *,i,j,k
            call stopcm1
          endif
          dum1(i,j,k)=dum2(i,j,kdn)+(dum2(i,j,kup)-dum2(i,j,kdn))   &
                                   *(  zref(k  )  -zh(i,j,kdn))     &
                                   /(  zh(i,j,kup)-zh(i,j,kdn))
        endif
      enddo
      enddo
      enddo

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!
! ---------------------------------------------------------------------
! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS
! A FUNCTION OF TEMPERATURE AND PRESSURE
!
      FUNCTION RSLF(P,T)

      IMPLICIT NONE
      include 'input.incl'
      include 'constants.incl'
      REAL ESL,RSLF,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8
      PARAMETER (C0= .611583699E03)
      PARAMETER (C1= .444606896E02)
      PARAMETER (C2= .143177157E01)
      PARAMETER (C3= .264224321E-1)
      PARAMETER (C4= .299291081E-3)
      PARAMETER (C5= .203154182E-5)
      PARAMETER (C6= .702620698E-8)
      PARAMETER (C7= .379534310E-11)
      PARAMETER (C8=-.321582393E-13)

!  Note to self ... this should be changed, somehow, in the future.
!  GHB 060806

    if(ptype.eq.1.or.ptype.eq.2.or.ptype.eq.3.or.ptype.eq.5.or.ptype.eq.6)then

      ! from Bolton (1980, MWR)
      esl=611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
      rslf= eps * ESL /(P-ESL)

    elseif(ptype.eq.4)then

      rslf=380.00*exp(17.2693882-4097.8531/(t-35.86))/p

!    elseif(ptype.eq.3)then
!
!      X=MAX(-80.,T-273.16)
!      ESL=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSLF=eps*ESL/(P-ESL)

    else

      esl=611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
      rslf= eps * ESL /(P-ESL)

    endif

      RETURN
      END

!
! ---------------------------------------------------------------------
! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A
! FUNCTION OF TEMPERATURE AND PRESSURE
!
      FUNCTION RSIF(P,T)

      IMPLICIT NONE
      include 'input.incl'
      include 'constants.incl'
      REAL ESI,RSIF,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8
      PARAMETER (C0= .609868993E03)
      PARAMETER (C1= .499320233E02)
      PARAMETER (C2= .184672631E01)
      PARAMETER (C3= .402737184E-1)
      PARAMETER (C4= .565392987E-3)
      PARAMETER (C5= .521693933E-5)
      PARAMETER (C6= .307839583E-7)
      PARAMETER (C7= .105785160E-9)
      PARAMETER (C8= .161444444E-12)

!  Note to self ... this should be changed, somehow, in the future.
!  GHB 060806

    if(ptype.eq.1.or.ptype.eq.2.or.ptype.eq.3.or.ptype.eq.5.or.ptype.eq.6)then

      ! from Tao et al (1989, MWR)
      esi=611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
      rsif= eps * ESI /(P-ESI)

    elseif(ptype.eq.4)then

      rsif=380.00*exp(21.87455-5807.4743/(t-7.66))/p

!    elseif(ptype.eq.3)then
!
!      X=MAX(-80.,T-273.16)
!      ESI=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSIF=eps*ESI/(P-ESI)

    else

      esi=611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
      rsif= eps * ESI /(P-ESI)

    endif

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


! REV PROCESSED 213 LINES OF CODE. PROGRAM DONE.
      REAL FUNCTION GAMMA(X)
      implicit none
!D    DOUBLE PRECISION FUNCTION DGAMMA(X)
!----------------------------------------------------------------------
!
! THIS ROUTINE CALCULATES THE GAMMA FUNCTION FOR A REAL ARGUMENT X.
!   COMPUTATION IS BASED ON AN ALGORITHM OUTLINED IN REFERENCE 1.
!   THE PROGRAM USES RATIONAL FUNCTIONS THAT APPROXIMATE THE GAMMA
!   FUNCTION TO AT LEAST 20 SIGNIFICANT DECIMAL DIGITS.  COEFFICIENTS
!   FOR THE APPROXIMATION OVER THE INTERVAL (1,2) ARE UNPUBLISHED.
!   THOSE FOR THE APPROXIMATION FOR X .GE. 12 ARE FROM REFERENCE 2.
!   THE ACCURACY ACHIEVED DEPENDS ON THE ARITHMETIC SYSTEM, THE
!   COMPILER, THE INTRINSIC FUNCTIONS, AND PROPER SELECTION OF THE
!   MACHINE-DEPENDENT CONSTANTS.
!
!
!*******************************************************************
!*******************************************************************
!
! EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
!
! BETA   - RADIX FOR THE FLOATING-POINT REPRESENTATION
! MAXEXP - THE SMALLEST POSITIVE POWER OF BETA THAT OVERFLOWS
! XBIG   - THE LARGEST ARGUMENT FOR WHICH GAMMA(X) IS REPRESENTABLE
!          IN THE MACHINE, I.E., THE SOLUTION TO THE EQUATION
!                  GAMMA(XBIG) = BETA**MAXEXP
! XINF   - THE LARGEST MACHINE REPRESENTABLE FLOATING-POINT NUMBER;
!          APPROXIMATELY BETA**MAXEXP
! EPS    - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1.0+EPS .GT. 1.0
! XMININ - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1/XMININ IS MACHINE REPRESENTABLE
!
!     APPROXIMATE VALUES FOR SOME IMPORTANT MACHINES ARE:
!
!                            BETA       MAXEXP        XBIG
!
! CRAY-1         (S.P.)        2         8191        966.961
! CYBER 180/855
!   UNDER NOS    (S.P.)        2         1070        177.803
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)        2          128        35.040
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)        2         1024        171.624
! IBM 3033       (D.P.)       16           63        57.574
! VAX D-FORMAT   (D.P.)        2          127        34.844
! VAX G-FORMAT   (D.P.)        2         1023        171.489
!
!                            XINF         EPS        XMININ
!
! CRAY-1         (S.P.)   5.45E+2465   7.11E-15    1.84E-2466
! CYBER 180/855
!   UNDER NOS    (S.P.)   1.26E+322    3.55E-15    3.14E-294
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)   3.40E+38     1.19E-7     1.18E-38
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)   1.79D+308    2.22D-16    2.23D-308
! IBM 3033       (D.P.)   7.23D+75     2.22D-16    1.39D-76
! VAX D-FORMAT   (D.P.)   1.70D+38     1.39D-17    5.88D-39
! VAX G-FORMAT   (D.P.)   8.98D+307    1.11D-16    1.12D-308
!
!*******************************************************************
!*******************************************************************
!
! ERROR RETURNS
!
!  THE PROGRAM RETURNS THE VALUE XINF FOR SINGULARITIES OR
!     WHEN OVERFLOW WOULD OCCUR.  THE COMPUTATION IS BELIEVED
!     TO BE FREE OF UNDERFLOW AND OVERFLOW.
!
!
!  INTRINSIC FUNCTIONS REQUIRED ARE:
!
!     INT, DBLE, EXP, LOG, REAL, SIN
!
!
! REFERENCES:  AN OVERVIEW OF SOFTWARE DEVELOPMENT FOR SPECIAL
!              FUNCTIONS   W. J. CODY, LECTURE NOTES IN MATHEMATICS,
!              506, NUMERICAL ANALYSIS DUNDEE, 1975, G. A. WATSON
!              (ED.), SPRINGER VERLAG, BERLIN, 1976.
!
!              COMPUTER APPROXIMATIONS, HART, ET. AL., WILEY AND
!              SONS, NEW YORK, 1968.
!
!  LATEST MODIFICATION: OCTOBER 12, 1989
!
!  AUTHORS: W. J. CODY AND L. STOLTZ
!           APPLIED MATHEMATICS DIVISION
!           ARGONNE NATIONAL LABORATORY
!           ARGONNE, IL 60439
!
!----------------------------------------------------------------------
      INTEGER I,N
      LOGICAL PARITY
      REAL               &
!D    DOUBLE PRECISION   &
          C,CONV,EPS,FACT,HALF,ONE,P,PI,Q,RES,SQRTPI,SUM,TWELVE,   &
          TWO,X,XBIG,XDEN,XINF,XMININ,XNUM,Y,Y1,YSQ,Z,ZERO
      DIMENSION C(7),P(8),Q(8)
!----------------------------------------------------------------------
!  MATHEMATICAL CONSTANTS
!----------------------------------------------------------------------
      DATA ONE,HALF,TWELVE,TWO,ZERO/1.0E0,0.5E0,12.0E0,2.0E0,0.0E0/,   &
           SQRTPI/0.9189385332046727417803297E0/,                      &
           PI/3.1415926535897932384626434E0/
!D    DATA ONE,HALF,TWELVE,TWO,ZERO/1.0D0,0.5D0,12.0D0,2.0D0,0.0D0/,
!D   1     SQRTPI/0.9189385332046727417803297D0/,
!D   2     PI/3.1415926535897932384626434D0/
!----------------------------------------------------------------------
!  MACHINE DEPENDENT PARAMETERS
!----------------------------------------------------------------------
      DATA XBIG,XMININ,EPS/35.040E0,1.18E-38,1.19E-7/,   &
           XINF/3.4E38/
!D    DATA XBIG,XMININ,EPS/171.624D0,2.23D-308,2.22D-16/,
!D   1     XINF/1.79D308/
!----------------------------------------------------------------------
!  NUMERATOR AND DENOMINATOR COEFFICIENTS FOR RATIONAL MINIMAX
!     APPROXIMATION OVER (1,2).
!----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811E+0,2.47656508055759199108314E+1,   &
             -3.79804256470945635097577E+2,6.29331155312818442661052E+2,   &
             8.66966202790413211295064E+2,-3.14512729688483675254357E+4,   &
             -3.61444134186911729807069E+4,6.64561438202405440627855E+4/
      DATA Q/-3.08402300119738975254353E+1,3.15350626979604161529144E+2,   &
            -1.01515636749021914166146E+3,-3.10777167157231109440444E+3,   &
              2.25381184209801510330112E+4,4.75584627752788110767815E+3,   &
            -1.34659959864969306392456E+5,-1.15132259675553483497211E+5/
!D    DATA P/-1.71618513886549492533811D+0,2.47656508055759199108314D+1,
!D   1       -3.79804256470945635097577D+2,6.29331155312818442661052D+2,
!D   2       8.66966202790413211295064D+2,-3.14512729688483675254357D+4,
!D   3       -3.61444134186911729807069D+4,6.64561438202405440627855D+4/
!D    DATA Q/-3.08402300119738975254353D+1,3.15350626979604161529144D+2,
!D   1      -1.01515636749021914166146D+3,-3.10777167157231109440444D+3,
!D   2        2.25381184209801510330112D+4,4.75584627752788110767815D+3,
!D   3      -1.34659959864969306392456D+5,-1.15132259675553483497211D+5/
!----------------------------------------------------------------------
!  COEFFICIENTS FOR MINIMAX APPROXIMATION OVER (12, INF).
!----------------------------------------------------------------------
      DATA C/-1.910444077728E-03,8.4171387781295E-04,                     &
           -5.952379913043012E-04,7.93650793500350248E-04,                &
           -2.777777777777681622553E-03,8.333333333333333331554247E-02,   &
            5.7083835261E-03/
!D    DATA C/-1.910444077728D-03,8.4171387781295D-04,
!D   1     -5.952379913043012D-04,7.93650793500350248D-04,
!D   2     -2.777777777777681622553D-03,8.333333333333333331554247D-02,
!D   3      5.7083835261D-03/
!----------------------------------------------------------------------
!  STATEMENT FUNCTIONS FOR CONVERSION BETWEEN INTEGER AND FLOAT
!----------------------------------------------------------------------
      CONV(I) = REAL(I)
!D    CONV(I) = DBLE(I)
      PARITY=.FALSE.
      FACT=ONE
      N=0
      Y=X
      IF(Y.LE.ZERO)THEN
!----------------------------------------------------------------------
!  ARGUMENT IS NEGATIVE
!----------------------------------------------------------------------
        Y=-X
        Y1=AINT(Y)
        RES=Y-Y1
        IF(RES.NE.ZERO)THEN
          IF(Y1.NE.AINT(Y1*HALF)*TWO)PARITY=.TRUE.
          FACT=-PI/SIN(PI*RES)
          Y=Y+ONE
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  ARGUMENT IS POSITIVE
!----------------------------------------------------------------------
      IF(Y.LT.EPS)THEN
!----------------------------------------------------------------------
!  ARGUMENT .LT. EPS
!----------------------------------------------------------------------
        IF(Y.GE.XMININ)THEN
          RES=ONE/Y
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ELSEIF(Y.LT.TWELVE)THEN
        Y1=Y
        IF(Y.LT.ONE)THEN
!----------------------------------------------------------------------
!  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          Z=Y
          Y=Y+ONE
        ELSE
!----------------------------------------------------------------------
!  1.0 .LT. ARGUMENT .LT. 12.0, REDUCE ARGUMENT IF NECESSARY
!----------------------------------------------------------------------
          N=INT(Y)-1
          Y=Y-CONV(N)
          Z=Y-ONE
        ENDIF
!----------------------------------------------------------------------
!  EVALUATE APPROXIMATION FOR 1.0 .LT. ARGUMENT .LT. 2.0
!----------------------------------------------------------------------
        XNUM=ZERO
        XDEN=ONE
        DO 260 I=1,8
          XNUM=(XNUM+P(I))*Z
          XDEN=XDEN*Z+Q(I)
  260   CONTINUE
        RES=XNUM/XDEN+ONE
        IF(Y1.LT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          RES=RES/Y1
        ELSEIF(Y1.GT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  2.0 .LT. ARGUMENT .LT. 12.0
!----------------------------------------------------------------------
          DO 290 I=1,N
            RES=RES*Y
            Y=Y+ONE
  290     CONTINUE
        ENDIF
      ELSE
!----------------------------------------------------------------------
!  EVALUATE FOR ARGUMENT .GE. 12.0,
!----------------------------------------------------------------------
        IF(Y.LE.XBIG)THEN
          YSQ=Y*Y
          SUM=C(7)
          DO 350 I=1,6
            SUM=SUM/YSQ+C(I)
  350     CONTINUE
          SUM=SUM/Y-Y+SQRTPI
          SUM=SUM+(Y-HALF)*LOG(Y)
          RES=EXP(SUM)
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  FINAL ADJUSTMENTS AND RETURN
!----------------------------------------------------------------------
      IF(PARITY)RES=-RES
      IF(FACT.NE.ONE)RES=FACT/RES
  900 GAMMA=RES
!D900 DGAMMA = RES
      RETURN
! ---------- LAST LINE OF GAMMA ----------
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      function mytime()
      implicit none

      include 'timestat.incl'

      integer count,rate,max
      real time_current,rcount

!----------------------------------------------------------
!  Platform-independent timer

      call system_clock(count,rate,max)
      if( count.lt.count_last )then
        ! simple kludge ... do nothing
        ! fix some other day   (GHB, 101018)
!!!        rcount = float(count+max)
!!!        time_current=rcount*clock_rate
!!!        mytime=time_current-time_last
!!!        rcount = float(count)
!!!        time_current=rcount*clock_rate
        rcount = float(count)
        time_current=rcount*clock_rate
        mytime=0.0
      else
        rcount = float(count)
        time_current=rcount*clock_rate
        mytime=time_current-time_last
      endif
      time_last=time_current
      count_last=count

!----------------------------------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine stopcm1()
#ifdef MPI
      use mpi
#endif
      implicit none

#ifdef MPI
      integer :: errcode,ierr

      call mpi_abort( mpi_comm_world, errcode , ierr )
#endif

      stop

      end subroutine stopcm1



morrison.F      1587424407  1602  20    100644  213658    `
!WRF:MODEL_LAYER:PHYSICS
!
! Current version is tagged as V3.5
! Reference is Morrison et al. (2005), JAS, Morrison et al. (2009), MWR

! changes with respect to V1.4

! V1.5
! 1) more pathways to allow hail to form (only affects IHAIL=1 option), from collisions of snow/cloud water
! 2) bug fix to PGAM calculation (multiplication instead of division by air density)

! V1.6
! 1) added parameter TMELT for all calculations involving melting point
! 2) replaced hard-wired gas constant for air with parameter value 'R'

! V1.7
! 1) modification to minimum mixing ratio in dry conditions, change from 10^-6 to 10^-8 kg/kg
!   to improve reflectivity at low mixing ratio amounts
! 2) bug fix to prevent possible division by zero error involving LAMI
! 3) change for liquid saturation vapor pressure, replace old formula with Flatau et al. 1992

! V2
! 1) bug fix to maximum-allowed particle fallspeeds (air density correction factor considered)
! 2) change to comments

! V2.1
! 1) addition of rain drop breakup following Verlinde and Cotton (1993)
! 2) change to minimum allowed lambda (slope parameter) for rain
! 3) addition of accelerated melting of graupel/hail/snow due to collision with rain

! V3
! minor revisions by Andy Ackerman
! 1) replaced kinematic with dynamic viscosity 
! 2) replaced scaling by air density for cloud droplet sedimentation
!    with viscosity-dependent Stokes expression
! 3) use Ikawa and Saito (1991) air-density scaling for cloud ice
! 4) corrected typo in 2nd digit of ventilation constant F2R

! Additional fixes
! 5) TEMPERATURE FOR ACCELERATED MELTING DUE TO COLLIIONS OF SNOW AND GRAUPEL
!    WITH RAIN SHOULD USE CELSIUS, NOT KELVIN (BUG REPORTED BY K. VAN WEVERBERG)
! 6) NPRACS IS NO SUBTRACTED SUBTRACTED FROM SNOW NUMBER CONCENTRATION, SIN
!    DECREASE IN SNOW NUMBER IS ALREADY ACCOUNTED FOR BY NSMLTS 
! 7) MODIFY FALLSPEED BELOW THE LOWEST LEVEL OF PRECIPITATION, WHICH PREVENTS
!      POTENTIAL FOR SPURIOUS ACCUMULATION OF PRECIPITATION DURING SUB-STEPPING FOR SEDIMENTATION
! 8) BUG FIX TO LATENT HEAT RELEASE DUE TO COLLISIONS OF CLOUD ICE WITH RAIN
! 9) BUG FIX TO IGRAUP SWITCH FOR NO GRAUPEL/HAIL

! hm bug fix 3/16/12

! 1) very minor change to limits on autoconversion source of rain number when cloud water is depleted

! hm, changes 3/4/13 for V3.3

! 1) removed second initialization of evpms (non-answer-changing)
! 2) for accelerated melting from collisions, should use rain mass collected by snow, not snow mass 
!    collected by rain
! 3) reduction of maximum-allowed ice concentration from 10 cm-3 to 0.3
!    cm-3. This was done to address the problem of excessive and persistent
!    anvil cirrus produced by the scheme, and was found to greatly improve forecasts over
!    at convection-permitting scales over the central U.S. in summertime.

! hm, changes 7/25/13 for V3.4

! 1) bug fix to option w/o graupel/hail (IGRAUP = 1), include PRACI, PGSACW,
!    and PGRACS as sources for snow instead of graupel/hail, bug reported by
!    Hailong Wang (PNNL)
! 2) very minor fix to immersion freezing rate formulation (negligible impact)
! 3) clarifications to code comments
! 4) minor change to shedding of rain, remove limit so that the number of
!    collected drops can smaller than number of shed drops
! 5) change of specific heat of liquid water from 4218 to 4187 J/kg/K

! hm, changes 1/20/15 for version 3.5

! 1) minor bug fix to diagnostic steady-state supersaturation equation for droplet activation in
!    cloud interior for option IBASE=1, minus sign is missing from the pressure term in this equation,
!    note this only has ~10% effect relative to the DQSDT term so the impact of the fix is small.
!    Bug reported by Xiaowen Li (NASA Goddard).
! 2) minor bug fix to melting of snow and graupel, an extra factor of air density (RHO) was removed
!    from the calculation of PSMLT and PGMLT
! 3) redundant initialization of PSMLT (non answer-changing)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

MODULE module_mp_GRAUPEL
!!!   USE     module_wrf_error
!!!      USE module_utility, ONLY: WRFU_Clock, WRFU_Alarm  ! GT
!!!      USE module_domain, ONLY : HISTORY_ALARM, Is_alarm_tstep  ! GT

!  USE module_state_description

   IMPLICIT NONE

   REAL, PARAMETER :: PI = 3.1415926535897932384626434
   REAL, PARAMETER :: SQRTPI = 0.9189385332046727417803297

   PUBLIC  ::  MP_GRAUPEL
!!!   PUBLIC  ::  POLYSVP

   PRIVATE :: GAMMA, DERF1
   PRIVATE :: PI, SQRTPI
   PRIVATE :: M2005MICRO_GRAUPEL

! SWITCHES FOR MICROPHYSICS SCHEME
! IACT = 1, USE POWER-LAW CCN SPECTRA, NCCN = CS^K
! IACT = 2, USE LOGNORMAL AEROSOL SIZE DIST TO DERIVE CCN SPECTRA

     INTEGER, PRIVATE ::  IACT

! INUM = 0, PREDICT DROPLET CONCENTRATION
! INUM = 1, ASSUME CONSTANT DROPLET CONCENTRATION   

     INTEGER, PRIVATE ::  INUM

! FOR INUM = 1, SET CONSTANT DROPLET CONCENTRATION (CM-3)
     REAL, PRIVATE ::      NDCNST

! SWITCH FOR LIQUID-ONLY RUN
! ILIQ = 0, INCLUDE ICE
! ILIQ = 1, LIQUID ONLY, NO ICE

     INTEGER, PRIVATE ::  ILIQ

! SWITCH FOR ICE NUCLEATION
! INUC = 0, USE FORMULA FROM RASMUSSEN ET AL. 2002 (MID-LATITUDE)
!      = 1, USE MPACE OBSERVATIONS

     INTEGER, PRIVATE ::  INUC

! IBASE = 1, NEGLECT DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING, ACTIVATE
!             AT CLOUD BASE OR IN REGION WITH LITTLE CLOUD WATER USING 
!             NON-EQULIBRIUM SUPERSATURATION, 
!             IN CLOUD INTERIOR ACTIVATE USING EQUILIBRIUM SUPERSATURATION
! IBASE = 2, ASSUME DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING DOMINATES,
!             ACTIVATE DROPLETS EVERYWHERE IN THE CLOUD USING NON-EQUILIBRIUM
!             SUPERSATURATION, BASED ON THE 
!             LOCAL SUB-GRID AND/OR GRID-SCALE VERTICAL VELOCITY 
!             AT THE GRID POINT

! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

     INTEGER, PRIVATE ::  IBASE

! INCLUDE SUB-GRID VERTICAL VELOCITY IN DROPLET ACTIVATION
! ISUB = 0, INCLUDE SUB-GRID W (RECOMMENDED FOR LOWER RESOLUTION)
! ISUB = 1, EXCLUDE SUB-GRID W, ONLY USE GRID-SCALE W

     INTEGER, PRIVATE ::  ISUB      

! SWITCH FOR GRAUPEL/NO GRAUPEL
! IGRAUP = 0, INCLUDE GRAUPEL
! IGRAUP = 1, NO GRAUPEL

     INTEGER, PRIVATE ::  IGRAUP

! HM ADDED NEW OPTION FOR HAIL V1.3
! SWITCH FOR HAIL/GRAUPEL
! IHAIL = 0, DENSE PRECIPITATING ICE IS GRAUPEL
! IHAIL = 1, DENSE PRECIPITATING GICE IS HAIL

     INTEGER, PRIVATE ::  IHAIL

! HM ADDED 8/1/08, v1.4
! SWITCH FOR WARM RAIN SCHEME
! IRAIN = 0, WARM RAIN (AUTO, ACC, SELF-COLL) FROM KHAIROUTIDNOV AND KOGAN (2000)
! IRAIN = 1, WARM RAIN (AUTO, ACC, SELF-COLL) FROM SEIFERT AND BEHENG (2001)

     INTEGER, PRIVATE ::  IRAIN      

! CLOUD MICROPHYSICS CONSTANTS

     REAL, PRIVATE ::      AI,AC,AS,AR,AG ! 'A' PARAMETER IN FALLSPEED-DIAM RELATIONSHIP
     REAL, PRIVATE ::      BI,BC,BS,BR,BG ! 'B' PARAMETER IN FALLSPEED-DIAM RELATIONSHIP
     REAL, PRIVATE ::      R           ! GAS CONSTANT FOR AIR
     REAL, PRIVATE ::      RV          ! GAS CONSTANT FOR WATER VAPOR
     REAL, PRIVATE ::      CP          ! SPECIFIC HEAT AT CONSTANT PRESSURE FOR DRY AIR
     REAL, PRIVATE ::      EP_2
     ! GHB: Needed for eqtset=2 in CM1
     REAL, PRIVATE ::      cv
     REAL, PRIVATE ::      cvv
     REAL, PRIVATE ::      cpv
     REAL, PRIVATE ::      cpl
     REAL, PRIVATE ::      cpi
     REAL, PRIVATE ::      xlv0
     REAL, PRIVATE ::      xls0
     REAL, PRIVATE ::      lv1
     REAL, PRIVATE ::      lv2
     REAL, PRIVATE ::      ls1
     REAL, PRIVATE ::      ls2
     ! GHB
     REAL, PRIVATE ::      RHOSU       ! STANDARD AIR DENSITY AT 850 MB
     REAL, PRIVATE ::      RHOW        ! DENSITY OF LIQUID WATER
     REAL, PRIVATE ::      RHOI        ! BULK DENSITY OF CLOUD ICE
     REAL, PRIVATE ::      RHOSN       ! BULK DENSITY OF SNOW
     REAL, PRIVATE ::      RHOG        ! BULK DENSITY OF GRAUPEL
     REAL, PRIVATE ::      AIMM        ! PARAMETER IN BIGG IMMERSION FREEZING
     REAL, PRIVATE ::      BIMM        ! PARAMETER IN BIGG IMMERSION FREEZING
     REAL, PRIVATE ::      ECR         ! COLLECTION EFFICIENCY BETWEEN DROPLETS/RAIN AND SNOW/RAIN
     REAL, PRIVATE ::      DCS         ! THRESHOLD SIZE FOR CLOUD ICE AUTOCONVERSION
     REAL, PRIVATE ::      MI0         ! INITIAL SIZE OF NUCLEATED CRYSTAL
     REAL, PRIVATE ::      MG0         ! MASS OF EMBRYO GRAUPEL
     REAL, PRIVATE ::      F1S         ! VENTILATION PARAMETER FOR SNOW
     REAL, PRIVATE ::      F2S         ! VENTILATION PARAMETER FOR SNOW
     REAL, PRIVATE ::      F1R         ! VENTILATION PARAMETER FOR RAIN
     REAL, PRIVATE ::      F2R         ! VENTILATION PARAMETER FOR RAIN
     REAL, PRIVATE ::      G           ! GRAVITATIONAL ACCELERATION
     REAL, PRIVATE ::      QSMALL      ! SMALLEST ALLOWED HYDROMETEOR MIXING RATIO
     REAL, PRIVATE ::      CI,DI,CS,DS,CG,DG ! SIZE DISTRIBUTION PARAMETERS FOR CLOUD ICE, SNOW, GRAUPEL
     REAL, PRIVATE ::      EII         ! COLLECTION EFFICIENCY, ICE-ICE COLLISIONS
     REAL, PRIVATE ::      ECI         ! COLLECTION EFFICIENCY, ICE-DROPLET COLLISIONS
     REAL, PRIVATE ::      RIN     ! RADIUS OF CONTACT NUCLEI (M)
! V1.6
     REAL, PRIVATE ::      TMELT     ! melting temp (K)
! hm, add for V2.1
     REAL, PRIVATE ::      CPW     ! SPECIFIC HEAT OF LIQUID WATER

! CCN SPECTRA FOR IACT = 1

     REAL, PRIVATE ::      C1     ! 'C' IN NCCN = CS^K (CM-3)
     REAL, PRIVATE ::      K1     ! 'K' IN NCCN = CS^K

! AEROSOL PARAMETERS FOR IACT = 2

     REAL, PRIVATE ::      MW      ! MOLECULAR WEIGHT WATER (KG/MOL)
     REAL, PRIVATE ::      OSM     ! OSMOTIC COEFFICIENT
     REAL, PRIVATE ::      VI      ! NUMBER OF ION DISSOCIATED IN SOLUTION
     REAL, PRIVATE ::      EPSM    ! AEROSOL SOLUBLE FRACTION
     REAL, PRIVATE ::      RHOA    ! AEROSOL BULK DENSITY (KG/M3)
     REAL, PRIVATE ::      MAP     ! MOLECULAR WEIGHT AEROSOL (KG/MOL)
     REAL, PRIVATE ::      MA      ! MOLECULAR WEIGHT OF 'AIR' (KG/MOL)
     REAL, PRIVATE ::      RR      ! UNIVERSAL GAS CONSTANT
     REAL, PRIVATE ::      BACT    ! ACTIVATION PARAMETER
     REAL, PRIVATE ::      RM1     ! GEOMETRIC MEAN RADIUS, MODE 1 (M)
     REAL, PRIVATE ::      RM2     ! GEOMETRIC MEAN RADIUS, MODE 2 (M)
     REAL, PRIVATE ::      NANEW1  ! TOTAL AEROSOL CONCENTRATION, MODE 1 (M^-3)
     REAL, PRIVATE ::      NANEW2  ! TOTAL AEROSOL CONCENTRATION, MODE 2 (M^-3)
     REAL, PRIVATE ::      SIG1    ! STANDARD DEVIATION OF AEROSOL S.D., MODE 1
     REAL, PRIVATE ::      SIG2    ! STANDARD DEVIATION OF AEROSOL S.D., MODE 2
     REAL, PRIVATE ::      F11     ! CORRECTION FACTOR FOR ACTIVATION, MODE 1
     REAL, PRIVATE ::      F12     ! CORRECTION FACTOR FOR ACTIVATION, MODE 1
     REAL, PRIVATE ::      F21     ! CORRECTION FACTOR FOR ACTIVATION, MODE 2
     REAL, PRIVATE ::      F22     ! CORRECTION FACTOR FOR ACTIVATION, MODE 2     
     REAL, PRIVATE ::      MMULT   ! MASS OF SPLINTERED ICE PARTICLE
     REAL, PRIVATE ::      LAMMAXI,LAMMINI,LAMMAXR,LAMMINR,LAMMAXS,LAMMINS,LAMMAXG,LAMMING
     REAL, PRIVATE ::      D_b     ! cutoff diameter for breakup

! CONSTANTS TO IMPROVE EFFICIENCY

     REAL, PRIVATE :: CONS1,CONS2,CONS3,CONS4,CONS5,CONS6,CONS7,CONS8,CONS9,CONS10
     REAL, PRIVATE :: CONS11,CONS12,CONS13,CONS14,CONS15,CONS16,CONS17,CONS18,CONS19,CONS20
     REAL, PRIVATE :: CONS21,CONS22,CONS23,CONS24,CONS25,CONS26,CONS27,CONS28,CONS29,CONS30
     REAL, PRIVATE :: CONS31,CONS32,CONS33,CONS34,CONS35,CONS36,CONS37,CONS38,CONS39,CONS40
     REAL, PRIVATE :: CONS41

! v1.4
     REAL, PRIVATE :: dnu(16)

!..Various radar related variables, from GT

!..Lookup table dimensions
      INTEGER, PARAMETER, PRIVATE:: nbins = 100
      INTEGER, PARAMETER, PRIVATE:: nbr = nbins
      INTEGER, PARAMETER, PRIVATE:: nbs = nbins
      INTEGER, PARAMETER, PRIVATE:: nbg = nbins
      DOUBLE PRECISION, DIMENSION(nbins+1):: ddx
      DOUBLE PRECISION, DIMENSION(nbr):: Dr, dtr
      DOUBLE PRECISION, DIMENSION(nbs):: Dds, dts
      DOUBLE PRECISION, DIMENSION(nbg):: Ddg, dtg

      DOUBLE PRECISION, PARAMETER, PRIVATE:: lamda_radar = 0.10         ! in meters
      DOUBLE PRECISION, PRIVATE:: K_w, PI5, lamda4
      COMPLEX*16, PRIVATE:: m_w_0, m_i_0
      DOUBLE PRECISION, DIMENSION(nbins+1), PRIVATE:: simpson
      DOUBLE PRECISION, DIMENSION(3), PARAMETER, PRIVATE:: basis =      &
                           (/1.d0/3.d0, 4.d0/3.d0, 1.d0/3.d0/)

      INTEGER, PARAMETER, PRIVATE:: slen = 20
      CHARACTER(len=slen), PRIVATE::                                    &
              mixingrulestring_s, matrixstring_s, inclusionstring_s,    &
              hoststring_s, hostmatrixstring_s, hostinclusionstring_s,  &
              mixingrulestring_g, matrixstring_g, inclusionstring_g,    &
              hoststring_g, hostmatrixstring_g, hostinclusionstring_g

      REAL, PARAMETER, PRIVATE:: D0r = 50.E-6
      REAL, PARAMETER, PRIVATE:: D0s = 100.E-6
      REAL, PARAMETER, PRIVATE:: D0g = 100.E-6
      CHARACTER*256:: mp_debug

CONTAINS

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE GRAUPEL_INIT(cm1hail,cm1inum,cm1ndcnst)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! THIS SUBROUTINE INITIALIZES ALL PHYSICAL CONSTANTS AMND PARAMETERS 
! NEEDED BY THE MICROPHYSICS SCHEME.
! NEEDS TO BE CALLED AT FIRST TIME STEP, PRIOR TO CALL TO MAIN MICROPHYSICS INTERFACE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      IMPLICIT NONE

      integer, intent(in) :: cm1hail
      integer, intent(inout) :: cm1inum
      real,    intent(in) :: cm1ndcnst
      integer n,i

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! THE FOLLOWING PARAMETERS ARE USER-DEFINED SWITCHES AND NEED TO BE
! SET PRIOR TO CODE COMPILATION

! INUM = 0, PREDICT DROPLET CONCENTRATION
! INUM = 1, ASSUME CONSTANT DROPLET CONCENTRATION   

      INUM = 1

! FOR INUM = 1, SET CONSTANT DROPLET CONCENTRATION (UNITS OF CM-3)

      NDCNST = cm1ndcnst

! IACT = 1, USE POWER-LAW CCN SPECTRA, NCCN = CS^K
! IACT = 2, USE LOGNORMAL AEROSOL SIZE DIST TO DERIVE CCN SPECTRA
! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

      IACT = 2

! IBASE = 1, NEGLECT DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING, ACTIVATE
!             AT CLOUD BASE OR IN REGION WITH LITTLE CLOUD WATER USING 
!             NON-EQULIBRIUM SUPERSATURATION ASSUMING NO INITIAL CLOUD WATER, 
!             IN CLOUD INTERIOR ACTIVATE USING EQUILIBRIUM SUPERSATURATION
! IBASE = 2, ASSUME DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING DOMINATES,
!             ACTIVATE DROPLETS EVERYWHERE IN THE CLOUD USING NON-EQUILIBRIUM
!             SUPERSATURATION ASSUMING NO INITIAL CLOUD WATER, BASED ON THE 
!             LOCAL SUB-GRID AND/OR GRID-SCALE VERTICAL VELOCITY 
!             AT THE GRID POINT

! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

      IBASE = 1

! INCLUDE SUB-GRID VERTICAL VELOCITY IN DROPLET ACTIVATION
! ISUB = 0, INCLUDE SUB-GRID W (RECOMMENDED FOR LOWER RESOLUTION)
! ISUB = 1, EXCLUDE SUB-GRID W, ONLY USE GRID-SCALE W

! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

      ISUB = 1      

! SWITCH FOR LIQUID-ONLY RUN
! ILIQ = 0, INCLUDE ICE
! ILIQ = 1, LIQUID ONLY, NO ICE

      ILIQ = 0

! SWITCH FOR ICE NUCLEATION
! INUC = 0, USE FORMULA FROM RASMUSSEN ET AL. 2002 (MID-LATITUDE)
!      = 1, USE MPACE OBSERVATIONS (ARCTIC ONLY)

      INUC = 0

! SWITCH FOR GRAUPEL/NO GRAUPEL
! IGRAUP = 0, INCLUDE GRAUPEL
! IGRAUP = 1, NO GRAUPEL

      IGRAUP = 0

! HM ADDED 11/7/07, V1.3
! SWITCH FOR HAIL/GRAUPEL
! IHAIL = 0, DENSE PRECIPITATING ICE IS GRAUPEL
! IHAIL = 1, DENSE PRECIPITATING ICE IS HAIL

      IHAIL = cm1hail
 
! HM ADDED 8/1/08, v1.4
! SWITCH FOR WARM RAIN SCHEME
! IRAIN = 0, WARM RAIN (AUTO, ACC, SELF-COLL) FROM KHAIROUTIDNOV AND KOGAN (2000)
! IRAIN = 1, WARM RAIN (AUTO, ACC, SELF-COLL) FROM SEIFERT AND BEHENG (2001)

      IRAIN = 0

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! SET PHYSICAL CONSTANTS

! FALLSPEED PARAMETERS (V=AD^B)
         AI = 700.
         AC = 3.E7
         AS = 11.72
         AR = 841.99667
         BI = 1.
         BC = 2.
         BS = 0.41
         BR = 0.8
! V1.3
         IF (IHAIL.EQ.0) THEN
	 AG = 19.3
	 BG = 0.37
         ELSE ! (MATSUN AND HUGGINS 1980)
         AG = 114.5 
         BG = 0.5
         END IF

! CONSTANTS AND PARAMETERS
         R = 287.04
         RV = 461.5
         CP = 1005.7
         EP_2 = R/RV
         ! GHB: Needed for eqtset=2 in CM1
         cv = CP - R
         cvv = 1408.5
         cpv = 1870.0
         cpl = 4190.0
         cpi = 2106.0
         xlv0 = 2501000.0
         xls0 = 2834000.0
         lv1 = xlv0+(cpl-cpv)*273.15
         lv2 = cpl-cpv
         ls1 = xls0+(cpi-cpv)*273.15
         ls2 = cpi-cpv
         ! GHB
! V1.6
         TMELT = 273.15
! V1.6
         RHOSU = 85000./(R*TMELT)
         RHOW = 997.
         RHOI = 500.
         RHOSN = 100.
! V1.3
         IF (IHAIL.EQ.0) THEN
	 RHOG = 400.
         ELSE
         RHOG = 900.
         END IF
         AIMM = 0.66
         BIMM = 100.
         ECR = 1.
         DCS = 125.E-6
         MI0 = 4./3.*PI*RHOI*(10.E-6)**3
	 MG0 = 1.6E-10
         F1S = 0.86
         F2S = 0.28
         F1R = 0.78
! V3 5/27/11
!         F2R = 0.32
! AA revision 4/1/11
         F2R = 0.308
         G = 9.81
         QSMALL = 1.E-14
         EII = 0.1
         ECI = 0.7
! HM, ADD FOR V3.2
         CPW = cpl

! SIZE DISTRIBUTION PARAMETERS

         CI = RHOI*PI/6.
         DI = 3.
         CS = RHOSN*PI/6.
         DS = 3.
         CG = RHOG*PI/6.
         DG = 3.

! RADIUS OF CONTACT NUCLEI
         RIN = 0.1E-6

         MMULT = 4./3.*PI*RHOI*(5.E-6)**3

! SIZE LIMITS FOR LAMBDA

         LAMMAXI = 1./1.E-6
         LAMMINI = 1./(2.*DCS+100.E-6)
         LAMMAXR = 1./20.E-6
!         LAMMINR = 1./500.E-6
! V2.1
         LAMMINR = 1./2800.E-6

         D_b = 300.e-6  ! cutoff diameter for breakup

         LAMMAXS = 1./10.E-6
         LAMMINS = 1./2000.E-6
         LAMMAXG = 1./20.E-6
         LAMMING = 1./2000.E-6

! CCN SPECTRA FOR IACT = 1

! MARITIME
! MODIFIED FROM RASMUSSEN ET AL. 2002
! NCCN = C*S^K, NCCN IS IN CM-3, S IS SUPERSATURATION RATIO IN %

              K1 = 0.4
              C1 = 120. 

! CONTINENTAL

!              K1 = 0.5
!              C1 = 1000. 

! AEROSOL ACTIVATION PARAMETERS FOR IACT = 2
! PARAMETERS CURRENTLY SET FOR AMMONIUM SULFATE

         MW = 0.018
         OSM = 1.
         VI = 3.
         EPSM = 0.7
         RHOA = 1777.
         MAP = 0.132
         MA = 0.0284
         RR = 8.3187
         BACT = VI*OSM*EPSM*MW*RHOA/(MAP*RHOW)

! AEROSOL SIZE DISTRIBUTION PARAMETERS CURRENTLY SET FOR MPACE
! MODE 1

         RM1 = 0.052E-6
         SIG1 = 2.04
         NANEW1 = 72.2E6
         F11 = 0.5*EXP(2.5*(LOG(SIG1))**2)
         F21 = 1.+0.25*LOG(SIG1)

! MODE 2

         RM2 = 1.3E-6
         SIG2 = 2.5
         NANEW2 = 1.8E6
         F12 = 0.5*EXP(2.5*(LOG(SIG2))**2)
         F22 = 1.+0.25*LOG(SIG2)

! CONSTANTS FOR EFFICIENCY

         CONS1=GAMMA(1.+DS)*CS
         CONS2=GAMMA(1.+DG)*CG
         CONS3=GAMMA(4.+BS)/6.
         CONS4=GAMMA(4.+BR)/6.
         CONS5=GAMMA(1.+BS)
         CONS6=GAMMA(1.+BR)
         CONS7=GAMMA(4.+BG)/6.
         CONS8=GAMMA(1.+BG)
         CONS9=GAMMA(5./2.+BR/2.)
         CONS10=GAMMA(5./2.+BS/2.)
         CONS11=GAMMA(5./2.+BG/2.)
         CONS12=GAMMA(1.+DI)*CI
         CONS13=GAMMA(BS+3.)*PI/4.*ECI
         CONS14=GAMMA(BG+3.)*PI/4.*ECI
         CONS15=-1108.*EII*PI**((1.-BS)/3.)*RHOSN**((-2.-BS)/3.)/(4.*720.)
         CONS16=GAMMA(BI+3.)*PI/4.*ECI
         CONS17=4.*2.*3.*RHOSU*PI*ECI*ECI*GAMMA(2.*BS+2.)/(8.*(RHOG-RHOSN))
         CONS18=RHOSN*RHOSN
         CONS19=RHOW*RHOW
         CONS20=20.*PI*PI*RHOW*BIMM
         CONS21=4./(DCS*RHOI)
         CONS22=PI*RHOI*DCS**3/6.
         CONS23=PI/4.*EII*GAMMA(BS+3.)
         CONS24=PI/4.*ECR*GAMMA(BR+3.)
         CONS25=PI*PI/24.*RHOW*ECR*GAMMA(BR+6.)
         CONS26=PI/6.*RHOW
         CONS27=GAMMA(1.+BI)
         CONS28=GAMMA(4.+BI)/6.
         CONS29=4./3.*PI*RHOW*(25.E-6)**3
         CONS30=4./3.*PI*RHOW
         CONS31=PI*PI*ECR*RHOSN
         CONS32=PI/2.*ECR
         CONS33=PI*PI*ECR*RHOG
         CONS34=5./2.+BR/2.
         CONS35=5./2.+BS/2.
         CONS36=5./2.+BG/2.
         CONS37=4.*PI*1.38E-23/(6.*PI*RIN)
         CONS38=PI*PI/3.*RHOW
         CONS39=PI*PI/36.*RHOW*BIMM
         CONS40=PI/6.*BIMM
         CONS41=PI*PI*ECR*RHOW

! v1.4
         dnu(1) = -0.557
         dnu(2) = -0.557
         dnu(3) = -0.430
         dnu(4) = -0.307
         dnu(5) = -0.186
         dnu(6) = -0.067
         dnu(7) = 0.050
         dnu(8) = 0.167
         dnu(9) = 0.282
         dnu(10) = 0.397
         dnu(11) = 0.512
         dnu(12) = 0.626
         dnu(13) = 0.739
         dnu(14) = 0.853
         dnu(15) = 0.966
         dnu(16) = 0.966

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! variables for radar reflecitivity calculations
!..Create bins of rain (from min diameter up to 5 mm).
      ddx(1) = D0r*1.0d0
      ddx(nbr+1) = 0.005d0
      do n = 2, nbr
         ddx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbr) &
                  *DLOG(ddx(nbr+1)/ddx(1)) +DLOG(ddx(1)))
      enddo
      do n = 1, nbr
         Dr(n) = DSQRT(ddx(n)*ddx(n+1))
         dtr(n) = ddx(n+1) - ddx(n)
      enddo

!..Create bins of snow (from min diameter up to 2 cm).
      Ddx(1) = D0s*1.0d0
      Ddx(nbs+1) = 0.02d0
      do n = 2, nbs
         Ddx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbs) &
                  *DLOG(Ddx(nbs+1)/Ddx(1)) +DLOG(Ddx(1)))
      enddo
      do n = 1, nbs
         Dds(n) = DSQRT(Ddx(n)*Ddx(n+1))
         dts(n) = Ddx(n+1) - Ddx(n)
      enddo

!..Create bins of graupel (from min diameter up to 5 cm).
      Ddx(1) = D0g*1.0d0
      Ddx(nbg+1) = 0.05d0
      do n = 2, nbg
         Ddx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbg) &
                  *DLOG(Ddx(nbg+1)/Ddx(1)) +DLOG(Ddx(1)))
      enddo   
      do n = 1, nbg
         Ddg(n) = DSQRT(Ddx(n)*Ddx(n+1))
         dtg(n) = Ddx(n+1) - Ddx(n)
      enddo

      do i = 1, 256
         mp_debug(i:i) = char(0)
      enddo

      call radar_init

      cm1inum   = inum

END SUBROUTINE GRAUPEL_INIT

!interface copied from new thompson interface
!and added NC, NS, NR, and NG variables.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! THIS SUBROUTINE IS MAIN INTERFACE WITH THE TWO-MOMENT MICROPHYSICS SCHEME
! THIS INTERFACE TAKES IN 3D VARIABLES FROM DRIVER MODEL, CONVERTS TO 1D FOR
! CALL TO THE MAIN MICROPHYSICS SUBROUTINE (SUBROUTINE M2005MICRO_GRAUPEL) 
! WHICH OPERATES ON 1D VERTICAL COLUMNS.
! 1D VARIABLES FROM THE MAIN MICROPHYSICS SUBROUTINE ARE THEN REASSIGNED BACK TO 3D FOR OUTPUT
! BACK TO DRIVER MODEL USING THIS INTERFACE

! ******IMPORTANT******
! THIS CODE ASSUMES THE DRIVER MODEL USES PROCESS-SPLITTING FOR SOLVING THE TIME-DEPENDENT EQS.
! THUS, MODEL VARIABLES ARE UPDATED WITH MICROPHYSICS TENDENCIES INSIDE OF THE MICROPHYSICS
! SCHEME. THESE UPDATED VARIABLES ARE PASSED BACK TO DRIVER MODEL. THIS IS WHY THERE
! ARE NO TENDENCIES PASSED BACK AND FORTH BETWEEN DRIVER AND THE INTERFACE SUBROUTINE

! AN EXCEPTION IS THE TURBULENT MIXING TENDENCIES FOR DROPLET AND CLOUD ICE NUMBER CONCENTRATIONS
! (NCTEND, NITEND BELOW). FOR APPLICATION IN MODELS OTHER THAN WRF, TURBULENT MIXING TENDENCIES
! CAN BE ADDED TO THE VARIABLES ELSEWHERE (IN DRIVER OR PBL ROUTINE), AND THEN DON'T
! NEED TO BE PASSED INTO THE SUBROUTINE HERE.....

! FOR QUESTIONS, CONTACT: HUGH MORRISON, E-MAIL: MORRISON@UCAR.EDU, PHONE:303-497-8916

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE MP_GRAUPEL(ITIMESTEP,                       &
                T3D, QV, QC, QR, QI, QS, QG, NNI, NS, NR, NG, NC,   &
                     P, RHO, DT_IN, DDZ, W, RAINNC,                     &
                effc,effi,effs,effr,effg,effis,                    &
                tcond,tevac,tevar,train,                           &
                ruh,rvh,rmh,rr,dbz3d,getdbz,                       &
                vtc,vtr,vti,vts,vtg,getvt)
 
! QV - water vapor mixing ratio (kg/kg)
! QC - cloud water mixing ratio (kg/kg)
! QR - rain water mixing ratio (kg/kg)
! QI - cloud ice mixing ratio (kg/kg)
! QS - snow mixing ratio (kg/kg)
! QG - graupel mixing ratio (KG/KG)
! NI - cloud ice number concentration (1/kg)
! NC - Droplet Number concentration (1/kg)
! NS - Snow Number concentration (1/kg)
! NR - Rain Number concentration (1/kg)
! NG - Graupel number concentration (1/kg)
! NOTE: RHO AND HT NOT USED BY THIS SCHEME AND DO NOT NEED TO BE PASSED INTO SCHEME!!!!
! P - AIR PRESSURE (PA)
! W - VERTICAL AIR VELOCITY (M/S)
! TH - POTENTIAL TEMPERATURE (K)
! PII - exner function - used to convert potential temp to temp
! DZ - difference in height over interface (m)
! DT_IN - model time step (sec)
! ITIMESTEP - time step counter
! RAINNC - accumulated grid-scale precipitation (mm)
! RAINNCV - one time step grid scale precipitation (mm/time step)
! SR - one time step mass ratio of snow to total precip
! TKE - turbulence kinetic energy (m^2 s-2), NEEDED FOR DROPLET ACTIVATION (SEE CODE BELOW)
! NCTEND - droplet concentration tendency from pbl (kg-1 s-1)
! NCTEND - CLOUD ICE concentration tendency from pbl (kg-1 s-1)
! KZH - heat eddy diffusion coefficient from YSU scheme (M^2 S-1), NEEDED FOR DROPLET ACTIVATION (SEE CODE BELOW)
! EFFCS - CLOUD DROPLET EFFECTIVE RADIUS OUTPUT TO RADIATION CODE (micron)
! EFFIS - CLOUD DROPLET EFFECTIVE RADIUS OUTPUT TO RADIATION CODE (micron)
! REFL_10CM - CALCULATED RADAR REFLECTIVITY AT 10 CM (DBZ)
!................................
! GRID_CLOCK, GRID_ALARMS - parameters to limit radar reflectivity calculation only when needed
! otherwise radar reflectivity calculation every time step is too slow
! only needed for coupling with WRF, see code below for details

! EFFC - DROPLET EFFECTIVE RADIUS (MICRON)
! EFFR - RAIN EFFECTIVE RADIUS (MICRON)
! EFFS - SNOW EFFECTIVE RADIUS (MICRON)
! EFFI - CLOUD ICE EFFECTIVE RADIUS (MICRON)

! ADDITIONAL OUTPUT FROM MICRO - SEDIMENTATION TENDENCIES, NEEDED FOR LIQUID-ICE STATIC ENERGY

! QGSTEN - GRAUPEL SEDIMENTATION TEND (KG/KG/S)
! QRSTEN - RAIN SEDIMENTATION TEND (KG/KG/S)
! QISTEN - CLOUD ICE SEDIMENTATION TEND (KG/KG/S)
! QNISTEN - SNOW SEDIMENTATION TEND (KG/KG/S)
! QCSTEN - CLOUD WATER SEDIMENTATION TEND (KG/KG/S)

! ADDITIONAL INPUT NEEDED BY MICRO
! ********NOTE: WVAR IS SHOULD BE USED IN DROPLET ACTIVATION
! FOR CASES WHEN UPDRAFT IS NOT RESOLVED, EITHER BECAUSE OF
! LOW MODEL RESOLUTION OR CLOUD TYPE
! WVAR - STANDARD DEVIATION OF SUB-GRID VERTICAL VELOCITY (M/S)

   IMPLICIT NONE

   include 'input.incl'

!!!   INTEGER,      INTENT(IN   )    ::   ids, ide, jds, jde, kds, kde , &
!!!                                       ims, ime, jms, jme, kms, kme , &
!!!                                       its, ite, jts, jte, kts, kte
! Temporary changed from INOUT to IN

!!!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT):: &
!!!                          qv, qc, qr, qi, qs, qg, ni, ns, nr, TH, NG
!, effcs, effis

!!!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN):: &
!!!                          pii, p, dz, rho, w !, tke, nctend, nitend,kzh
   REAL, DIMENSION(ib:ie,jb:je,kb:ke), INTENT(INOUT):: &
                          qv, qc, qr, qi, qs, qg, nni, nc, ns, nr, T3D, NG,   &
                          dbz3d,vtc,vtr,vti,vts,vtg
   real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: effc,effi,effs,effr,effg,effis

   REAL, DIMENSION(ib:ie,jb:je,kb:ke), INTENT(IN):: &
                          rmh, rr,      p, rho, ddz
   REAL, DIMENSION(ib:ie,jb:je,kb:ke+1), INTENT(IN):: &
                          w
   REAL, INTENT(IN):: dt_in
   INTEGER, INTENT(IN):: ITIMESTEP

   real, dimension(ib:ie,jb:je,nrain), INTENT(INOUT) :: rainnc
   double precision :: tcond,tevac,tevar,train
   real, dimension(ib:ie) :: ruh
   real, dimension(jb:je) :: rvh
   logical, intent(in) :: getdbz,getvt

!!!   REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT):: &
!!!                          RAINNC, RAINNCV, SR

!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT)::       &  ! GT
!                          refl_10cm

!!!   REAL , DIMENSION( ims:ime , jms:jme ) , INTENT(IN) ::       ht

!      TYPE (WRFU_Clock):: grid_clock                  ! GT
!      TYPE (WRFU_Alarm), POINTER:: grid_alarms(:)     ! GT

   ! LOCAL VARIABLES

!!!   REAL, DIMENSION(its:ite, kts:kte, jts:jte)::                     &
!!!                      effi, effs, effr, EFFG

!!!   REAL, DIMENSION(its:ite, kts:kte, jts:jte)::                     &
!!!                      T, WVAR, EFFC

   REAL, DIMENSION(nk) ::                                                                & 
                            QC_TEND1D, QI_TEND1D, QNI_TEND1D, QR_TEND1D, NC_TEND1D,           &
                            NI_TEND1D, NS_TEND1D, NR_TEND1D,                                  &
                            QC1D, QI1D, QR1D, NC1D,NI1D, NS1D, NR1D, QS1D,                    &
                            T_TEND1D,QV_TEND1D, T1D, QV1D, P1D, RHO1D, W1D, WVAR1D,         &
                            EFFC1D, EFFI1D, EFFS1D, EFFR1D,DZ1D,   &
   ! HM ADD GRAUPEL
                            QG_TEND1D, NG_TEND1D, QG1D, NG1D, EFFG1D, &

! ADD SEDIMENTATION TENDENCIES (UNITS OF KG/KG/S)
                            QGSTEN,QRSTEN, QISTEN, QNISTEN, QCSTEN, &

! HM add reflectivity      
                            dbz,effis1d  ! hm 8/20/12
                          
   REAL PRECPRT1D, SNOWRT1D

   INTEGER I,K,J,n

   REAL DT,rdt

   real, dimension(nk) :: PRE,EVPMS,EVPMG,PCC,FR,FI,FC,FS,FG
   real :: tem1,tem2
   double precision, dimension(nj) :: bud1,bud2,bud3,bud4

   LOGICAL:: dBZ_tstep ! GT

   ! Initialize tendencies (all set to 0) and transfer
   ! array to local variables
   DT = DT_IN   
   rdt = 1.0/dt

      dBZ_tstep = getdbz

    tem1 = dx*dy*dz

!   DO I=ITS,ITE
!   DO J=JTS,JTE
!   DO K=KTS,KTE
!       T(I,K,J)        = TH(i,k,j)*PII(i,k,j)
!
!! wvar is the ST. DEV. OF sub-grid vertical velocity, used for calculating droplet 
!! activation rates.
!! WVAR CAN BE DERIVED EITHER FROM PREDICTED TKE (AS IN MYJ PBL SCHEME),
!! OR FROM EDDY DIFFUSION COEFFICIENT KZH (AS IN YSU PBL SCHEME),
!! DEPENDING ON THE PARTICULAR pbl SCHEME DRIVER MODEL IS COUPLED WITH
!! NOTE: IF MODEL HAS HIGH ENOUGH RESOLUTION TO RESOLVE UPDRAFTS, WVAR MAY 
!! NOT BE NEEDED 
!
!! currently assign wvar to 0.5 m/s (not coupled with PBL scheme)
!
!       WVAR(I,K,J)     = 0.5
!
!! currently mixing of number concentrations also is neglected (not coupled with PBL schemes)
!
!   END DO
!   END DO
!   END DO

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,QC_TEND1D,QI_TEND1D,QNI_TEND1D,QR_TEND1D,NC_TEND1D,     &
!$omp NI_TEND1D,NS_TEND1D,NR_TEND1D,T_TEND1D,QV_TEND1D,QC1D,QI1D,QS1D,QR1D,   &
!$omp NC1D,NI1D,NS1D,NR1D,QG1D,NG1D,QG_TEND1D,NG_TEND1D,T1D,QV1D,P1D,RHO1D,DZ1D, &
!$omp W1D,WVAR1D,PRE,EVPMS,EVPMG,PCC,dBZ,PRECPRT1D,SNOWRT1D,EFFC1D,EFFI1D,EFFS1D,EFFR1D,  &
!$omp EFFG1D,QGSTEN,QRSTEN,QISTEN,QNISTEN,QCSTEN,FR,FI,FC,FS,FG,tem2,effis1d)
   do j=1,nj         ! j loop (north-south)
   bud1(j)=0.0d0
   bud2(j)=0.0d0
   bud3(j)=0.0d0
   bud4(j)=0.0d0
   do i=1,ni         ! i loop (east-west)
   !
   ! Transfer 3D arrays into 1D for microphysical calculations
   !

! hm , initialize 1d tendency arrays to zero

          QC_TEND1D  = 0.
          QI_TEND1D  = 0.
          QNI_TEND1D = 0.
          QR_TEND1D  = 0.
          NC_TEND1D  = 0.
          NI_TEND1D  = 0.
          NS_TEND1D  = 0.
          NR_TEND1D  = 0.
          T_TEND1D   = 0.
          QV_TEND1D  = 0.

          QG_TEND1D  = 0.
          NG_TEND1D  = 0.

          QGSTEN     = 0.
          QRSTEN     = 0.
          QISTEN     = 0.
          QNISTEN    = 0.
          QCSTEN     = 0.

          ! wvar is neglected in cm1
          WVAR1D     = 0.0

          NC1D = 0.0

      IF(inum.eq.0)THEN
        do k=1,nk
          NC1D(k)       = NC(i,j,k)
        enddo
      ENDIF

      do k=1,nk      ! k loop (vertical)

          QC1D(k)       = QC(i,j,k)
          QI1D(k)       = QI(i,j,k)
          QS1D(k)       = QS(i,j,k)
          QR1D(k)       = QR(i,j,k)

          NI1D(k)       = NNI(i,j,k)

          NS1D(k)       = NS(i,j,k)
          NR1D(k)       = NR(i,j,k)
! HM ADD GRAUPEL
          QG1D(K)       = QG(i,j,k)
          NG1D(K)       = NG(i,j,k)

!!!          T1D(k)        = T(i,k,j)
!!!          T1D(k)        = TH(i,j,k)*PII(i,j,k)
          T1D(k)        = T3D(i,j,k)
          QV1D(k)       = QV(i,j,k)
          P1D(k)        = P(i,j,k)
          RHO1D(k)      = RHO(i,j,k)
          DZ1D(k)       = DDZ(i,j,k)
!!!          W1D(k)        = W(i,k,j)
          W1D(k)        = 0.5*( w(i,j,k) + w(i,j,k+1) )
      end do

      PRE = 0.0
      EVPMS = 0.0
      EVPMG = 0.0
      PCC = 0.0
      FR = 0.0
      FI = 0.0
      FC = 0.0
      FS = 0.0
      FG = 0.0

      IF(radopt.ge.1)THEN
      EFFC1D = 0.0
      EFFI1D = 0.0
      EFFS1D = 0.0
      EFFR1D = 0.0
      EFFG1D = 0.0
      effis1d = 0.0
      ENDIF

      call m2005micro_graupel(QC_TEND1D, QI_TEND1D, QNI_TEND1D, QR_TEND1D, NC_TEND1D,            &
       NI_TEND1D, NS_TEND1D, NR_TEND1D,                                                  &
       QC1D, QI1D, QS1D, QR1D, NC1D,NI1D, NS1D, NR1D,                                    &
       T_TEND1D,QV_TEND1D, T1D, QV1D, P1D, RHO1D, DZ1D, W1D, WVAR1D,                   &
       PRECPRT1D,SNOWRT1D,                                                               &
       EFFC1D,EFFI1D,EFFS1D,EFFR1D,DT,RDT,                                               &
                                              1,ni ,   1,nj ,   1,nk ,                   &
                                              1,ni ,   1,nj ,   1,nk ,                   &
                                    QG_TEND1D,NG_TEND1D,QG1D,NG1D,EFFG1D, &
! ADD SEDIMENTATION TENDENCIES
                                  QGSTEN,QRSTEN,QISTEN,QNISTEN,QCSTEN,   &
                                  PRE,EVPMS,EVPMG,PCC,FR,FI,FC,FS,FG,eqtset,radopt,tsmall,effis1d)


   !
   ! Transfer 1D arrays back into 3D arrays
   !
      do k=1,nk

! hm, add tendencies to update global variables 
! HM, TENDENCIES FOR Q AND N NOW ADDED IN M2005MICRO, SO WE
! ONLY NEED TO TRANSFER 1D VARIABLES BACK TO 3D

          QC(i,j,k)        = QC1D(k)
          QI(i,j,k)        = QI1D(k)
          QS(i,j,k)        = QS1D(k)
          QR(i,j,k)        = QR1D(k)
          NNI(i,j,k)        = NI1D(k)
          NS(i,j,k)        = NS1D(k)          
          NR(i,j,k)        = NR1D(k)
	  QG(i,j,k)        = QG1D(K)
          NG(i,j,k)        = NG1D(K)

!!!          T(i,k,j)         = T1D(k)
!!!          TH(I,K,J)        = T(i,k,j)/PII(i,k,j) ! CONVERT TEMP BACK TO POTENTIAL TEMP
!!!          TH(i,j,k)        = T1D(k)/PII(i,j,k) ! CONVERT TEMP BACK TO POTENTIAL TEMP
          T3D(i,j,k)        = T1D(k)
          QV(i,j,k)        = QV1D(k)

      end do

      IF(radopt.ge.1)THEN
      do k=1,nk
! hm 8/20/12
          EFFC(i,j,k)      = EFFC1D(k)
          EFFI(i,j,k)      = EFFI1D(k)
          EFFS(i,j,k)      = EFFS1D(k)
          EFFR(i,j,k)      = EFFR1D(k)
	  EFFG(i,j,k)      = EFFG1D(K)
	  effis(i,j,k)      = effis1D(K)  ! combined cloud ice plus snow, with correct weighting

! EFFECTIVE RADIUS FOR RADIATION CODE
! HM, ADD LIMIT TO PREVENT BLOWING UP OPTICAL PROPERTIES, 8/18/07
! hm 8/20/12 note: no limits needed here, limits are applied inside Goddard radiation code in CM1
!          EFFCS(I,K,J)     = MIN(EFFC(I,K,J),50.)
!          EFFCS(I,K,J)     = MAX(EFFCS(I,K,J),1.)
!          EFFIS(I,K,J)     = MIN(EFFI(I,K,J),130.)
!          EFFIS(I,K,J)     = MAX(EFFIS(I,K,J),13.)
        ! GHB, 130904: still seeing blowups in goddard code, so add an upper limit:
        EFFI(i,j,k) = min( EFFI(i,j,k) , 400.0 )
        EFFS(i,j,k) = min( EFFS(i,j,k) , 400.0 )
        effis(i,j,k) = min( effis(i,j,k) , 400.0 )
      end do
      ENDIF

      IF(inum.eq.0)THEN
        do k=1,nk
          NC(i,j,k)        = NC1D(k)
        enddo
      ENDIF

      IF( getvt )THEN
        do k=1,nk
          vtc(i,j,k) = fc(k)
          vtr(i,j,k) = fr(k)
          vti(i,j,k) = fi(k)
          vts(i,j,k) = fs(k)
          vtg(i,j,k) = fg(k)
        enddo
      ENDIF

! hm modified so that m2005 precip variables correctly match wrf precip variables
!!!      RAINNC(i,j) = RAINNC(I,J)+PRECPRT1D
!!!      RAINNCV(i,j) = PRECPRT1D
!!!      SR(i,j) = SNOWRT1D/(PRECPRT1D+1.E-12)


         do n = 1,nrain
           RAINNC(i,j,n) = RAINNC(i,j,n) + 0.1*PRECPRT1D
         enddo
         bud1(j) = bud1(j) + PRECPRT1D*ruh(i)*rvh(j)*dx*dy

         do k=1,nk
           tem2 = dt*rr(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*tem1
           bud2(j) = bud2(j) - tem2*( PRE(K)+EVPMS(K)+EVPMG(K) )
           bud3(j) = bud3(j) + tem2*max(PCC(K),0.0)
           bud4(j) = bud4(j) - tem2*min(PCC(K),0.0)
         enddo

! add reflectivity calculations
! only calculate if logical parameter dbz_tstep = .true.

         if (dBZ_tstep) then
          call calc_refl10cm (qv1d, qr1d, qs1d, qg1d, t1d, p1d, dBZ,    &
                      1, nk, i, j, nr1d, ns1d, ng1d, rho1d)
          do k = 1, nk
             dbz3d(i,j,k) = dBZ(k)
          enddo
         endif

   end do
   end do   

   do j=1,nj
     train=train+bud1(j)
     tevar=tevar+bud2(j)
     tcond=tcond+bud3(j)
     tevac=tevac+bud4(j)
   enddo

END SUBROUTINE MP_GRAUPEL

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE M2005MICRO_GRAUPEL(QC3DTEN,QI3DTEN,QNI3DTEN,QR3DTEN,NC3DTEN,    &
       NI3DTEN,NS3DTEN,NR3DTEN,QC3D,QI3D,QNI3D,QR3D,NC3D,NI3D,NS3D,NR3D,         &
       T3DTEN,QV3DTEN,T3D,QV3D,PRES,RHO3D,DZQ,W3D,WVAR,PRECRT,SNOWRT,            &
       EFFC,EFFI,EFFS,EFFR,DT,RDT,                                               &
                                            IMS,IME, JMS,JME, KMS,KME,           &
                                            ITS,ITE, JTS,JTE, KTS,KTE,           & ! ADD GRAUPEL
                        QG3DTEN,NG3DTEN,QG3D,NG3D,EFFG,QGSTEN,QRSTEN,QISTEN,QNISTEN,QCSTEN,   &
                        PRE,EVPMS,EVPMG,PCC,FR,FI,FC,FS,FG,eqtset,radopt,tsmall,effis)

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! THIS PROGRAM IS THE MAIN TWO-MOMENT MICROPHYSICS SUBROUTINE DESCRIBED BY
! MORRISON ET AL. 2005 JAS; MORRISON AND PINTO 2005 JAS.
! ADDITIONAL CHANGE IS ADDITION OF GRAUPEL MICROPHYSICS.
! SCHEME IS DESCRIBED IN DETAIL BY MORRISON ET AL. (MONTHLY WEATHER REVIEW, IN PREP.)

! THIS SCHEME IS A BULK DOUBLE-MOMENT SCHEME THAT PREDICTS MIXING
! RATIOS AND NUMBER CONCENTRATIONS OF FIVE HYDROMETEOR SPECIES:
! CLOUD DROPLETS, CLOUD (SMALL) ICE, RAIN, SNOW, AND GRAUPEL.

! CODE STRUCTURE: MAIN SUBROUTINE IS 'M2005MICRO_GRAUPEL'. ALSO INCLUDED IN THIS FILE IS
! 'FUNCTION POLYSVP', 'FUNCTION DERF1', AND
! 'FUNCTION GAMMA'.

! NOTE: THIS SUBROUTINE USES 1D ARRAY IN VERTICAL (COLUMN), EVEN THOUGH VARIABLES ARE CALLED '3D'......

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! DECLARATIONS

      IMPLICIT NONE

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! THESE VARIABLES BELOW MUST BE LINKED WITH THE MAIN MODEL.
! DEFINE ARRAY SIZES

! INPUT NUMBER OF GRID CELLS

! INPUT/OUTPUT PARAMETERS                                 ! DESCRIPTION (UNITS)
      INTEGER, INTENT( IN)  :: IMS,IME, JMS,JME, KMS,KME,          &
                               ITS,ITE, JTS,JTE, KTS,KTE

      REAL, DIMENSION(KMS:KME) ::  QC3DTEN            ! CLOUD WATER MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QI3DTEN            ! CLOUD ICE MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QNI3DTEN           ! SNOW MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QR3DTEN            ! RAIN MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  NC3DTEN            ! CLOUD DROPLET NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KMS:KME) ::  NI3DTEN            ! CLOUD ICE NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KMS:KME) ::  NS3DTEN            ! SNOW NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KMS:KME) ::  NR3DTEN            ! RAIN NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QC3D               ! CLOUD WATER MIXING RATIO (KG/KG)
      REAL, DIMENSION(KMS:KME) ::  QI3D               ! CLOUD ICE MIXING RATIO (KG/KG)
      REAL, DIMENSION(KMS:KME) ::  QNI3D              ! SNOW MIXING RATIO (KG/KG)
      REAL, DIMENSION(KMS:KME) ::  QR3D               ! RAIN MIXING RATIO (KG/KG)
      REAL, DIMENSION(KMS:KME) ::  NC3D               ! CLOUD DROPLET NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KMS:KME) ::  NI3D               ! CLOUD ICE NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KMS:KME) ::  NS3D               ! SNOW NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KMS:KME) ::  NR3D               ! RAIN NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KMS:KME) ::  T3DTEN             ! TEMPERATURE TENDENCY (K/S)
      REAL, DIMENSION(KMS:KME) ::  QV3DTEN            ! WATER VAPOR MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  T3D                ! TEMPERATURE (K)
      REAL, DIMENSION(KMS:KME) ::  QV3D               ! WATER VAPOR MIXING RATIO (KG/KG)
      REAL, DIMENSION(KMS:KME) ::  PRES               ! ATMOSPHERIC PRESSURE (PA)
      REAL, DIMENSION(KMS:KME) ::  RHO3D              ! DENSITY (KG/M^3)
      REAL, DIMENSION(KMS:KME) ::  DZQ                ! DIFFERENCE IN HEIGHT ACROSS LEVEL (m)
      REAL, DIMENSION(KMS:KME) ::  W3D                ! GRID-SCALE VERTICAL VELOCITY (M/S)
      REAL, DIMENSION(KMS:KME) ::  WVAR               ! SUB-GRID VERTICAL VELOCITY (M/S)

! HM ADDED GRAUPEL VARIABLES
      REAL, DIMENSION(KMS:KME) ::  QG3DTEN            ! GRAUPEL MIX RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  NG3DTEN            ! GRAUPEL NUMB CONC TENDENCY (1/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QG3D            ! GRAUPEL MIX RATIO (KG/KG)
      REAL, DIMENSION(KMS:KME) ::  NG3D            ! GRAUPEL NUMBER CONC (1/KG)

! HM, ADD 1/16/07, SEDIMENTATION TENDENCIES FOR MIXING RATIO

      REAL, DIMENSION(KMS:KME) ::  QGSTEN            ! GRAUPEL SED TEND (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QRSTEN            ! RAIN SED TEND (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QISTEN            ! CLOUD ICE SED TEND (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QNISTEN           ! SNOW SED TEND (KG/KG/S)
      REAL, DIMENSION(KMS:KME) ::  QCSTEN            ! CLOUD WAT SED TEND (KG/KG/S)      

      integer, intent(in) :: eqtset,radopt
      real, intent(in) :: tsmall

! OUTPUT VARIABLES

        REAL PRECRT                ! TOTAL PRECIP PER TIME STEP (mm)
        REAL SNOWRT                ! SNOW PER TIME STEP (mm)

        REAL, DIMENSION(KMS:KME) ::   EFFC            ! DROPLET EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KMS:KME) ::   EFFI            ! CLOUD ICE EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KMS:KME) ::   EFFS            ! SNOW EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KMS:KME) ::   EFFR            ! RAIN EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KMS:KME) ::   EFFG            ! GRAUPEL EFFECTIVE RADIUS (MICRON)
! hm 8/20/12
        REAL, DIMENSION(KMS:KME) ::   effis           ! GRAUPEL EFFECTIVE RADIUS (MICRON)

! MODEL INPUT PARAMETERS (FORMERLY IN COMMON BLOCKS)

        REAL, intent(in) :: DT,RDT         ! MODEL TIME STEP (SEC)

!.....................................................................................................
! LOCAL VARIABLES: ALL PARAMETERS BELOW ARE LOCAL TO SCHEME AND DON'T NEED TO COMMUNICATE WITH THE
! REST OF THE MODEL.

! SIZE PARAMETER VARIABLES

     REAL, DIMENSION(KMS:KME) :: LAMC          ! SLOPE PARAMETER FOR DROPLETS (M-1)
     REAL, DIMENSION(KMS:KME) :: LAMI          ! SLOPE PARAMETER FOR CLOUD ICE (M-1)
     REAL, DIMENSION(KMS:KME) :: LAMS          ! SLOPE PARAMETER FOR SNOW (M-1)
     REAL, DIMENSION(KMS:KME) :: LAMR          ! SLOPE PARAMETER FOR RAIN (M-1)
     REAL, DIMENSION(KMS:KME) :: LAMG          ! SLOPE PARAMETER FOR GRAUPEL (M-1)
     REAL, DIMENSION(KMS:KME) :: CDIST1        ! PSD PARAMETER FOR DROPLETS
     REAL, DIMENSION(KMS:KME) :: N0I           ! INTERCEPT PARAMETER FOR CLOUD ICE (KG-1 M-1)
     REAL, DIMENSION(KMS:KME) :: N0S           ! INTERCEPT PARAMETER FOR SNOW (KG-1 M-1)
     REAL, DIMENSION(KMS:KME) :: N0RR          ! INTERCEPT PARAMETER FOR RAIN (KG-1 M-1)
     REAL, DIMENSION(KMS:KME) :: N0G           ! INTERCEPT PARAMETER FOR GRAUPEL (KG-1 M-1)
     REAL, DIMENSION(KMS:KME) :: PGAM          ! SPECTRAL SHAPE PARAMETER FOR DROPLETS

! MICROPHYSICAL PROCESSES

     REAL, DIMENSION(KMS:KME) ::  NSUBC     ! LOSS OF NC DURING EVAP
     REAL, DIMENSION(KMS:KME) ::  NSUBI     ! LOSS OF NI DURING SUB.
     REAL, DIMENSION(KMS:KME) ::  NSUBS     ! LOSS OF NS DURING SUB.
     REAL, DIMENSION(KMS:KME) ::  NSUBR     ! LOSS OF NR DURING EVAP
     REAL, DIMENSION(KMS:KME) ::  PRD       ! DEP CLOUD ICE
     REAL, DIMENSION(KMS:KME), intent(inout) ::  PRE       ! EVAP OF RAIN
     REAL, DIMENSION(KMS:KME) ::  PRDS      ! DEP SNOW
     REAL, DIMENSION(KMS:KME) ::  NNUCCC    ! CHANGE N DUE TO CONTACT FREEZ DROPLETS
     REAL, DIMENSION(KMS:KME) ::  MNUCCC    ! CHANGE Q DUE TO CONTACT FREEZ DROPLETS
     REAL, DIMENSION(KMS:KME) ::  PRA       ! ACCRETION DROPLETS BY RAIN
     REAL, DIMENSION(KMS:KME) ::  PRC       ! AUTOCONVERSION DROPLETS
     REAL, INTENT(INOUT), DIMENSION(KMS:KME) ::  PCC       ! COND/EVAP DROPLETS
     REAL, DIMENSION(KMS:KME) ::  NNUCCD    ! CHANGE N FREEZING AEROSOL (PRIM ICE NUCLEATION)
     REAL, DIMENSION(KMS:KME) ::  MNUCCD    ! CHANGE Q FREEZING AEROSOL (PRIM ICE NUCLEATION)
     REAL, DIMENSION(KMS:KME) ::  MNUCCR    ! CHANGE Q DUE TO CONTACT FREEZ RAIN
     REAL, DIMENSION(KMS:KME) ::  NNUCCR    ! CHANGE N DUE TO CONTACT FREEZ RAIN
     REAL, DIMENSION(KMS:KME) ::  NPRA      ! CHANGE IN N DUE TO DROPLET ACC BY RAIN
     REAL, DIMENSION(KMS:KME) ::  NRAGG     ! SELF-COLLECTION/BREAKUP OF RAIN
     REAL, DIMENSION(KMS:KME) ::  NSAGG     ! SELF-COLLECTION OF SNOW
     REAL, DIMENSION(KMS:KME) ::  NPRC      ! CHANGE NC AUTOCONVERSION DROPLETS
     REAL, DIMENSION(KMS:KME) ::  NPRC1      ! CHANGE NR AUTOCONVERSION DROPLETS
     REAL, DIMENSION(KMS:KME) ::  PRAI      ! CHANGE Q ACCRETION CLOUD ICE
     REAL, DIMENSION(KMS:KME) ::  PRCI      ! CHANGE Q AUTOCONVERSION CLOUD ICE BY SNOW
     REAL, DIMENSION(KMS:KME) ::  PSACWS    ! CHANGE Q DROPLET ACCRETION BY SNOW
     REAL, DIMENSION(KMS:KME) ::  NPSACWS   ! CHANGE N DROPLET ACCRETION BY SNOW
     REAL, DIMENSION(KMS:KME) ::  PSACWI    ! CHANGE Q DROPLET ACCRETION BY CLOUD ICE
     REAL, DIMENSION(KMS:KME) ::  NPSACWI   ! CHANGE N DROPLET ACCRETION BY CLOUD ICE
     REAL, DIMENSION(KMS:KME) ::  NPRCI     ! CHANGE N AUTOCONVERSION CLOUD ICE BY SNOW
     REAL, DIMENSION(KMS:KME) ::  NPRAI     ! CHANGE N ACCRETION CLOUD ICE
     REAL, DIMENSION(KMS:KME) ::  NMULTS    ! ICE MULT DUE TO RIMING DROPLETS BY SNOW
     REAL, DIMENSION(KMS:KME) ::  NMULTR    ! ICE MULT DUE TO RIMING RAIN BY SNOW
     REAL, DIMENSION(KMS:KME) ::  QMULTS    ! CHANGE Q DUE TO ICE MULT DROPLETS/SNOW
     REAL, DIMENSION(KMS:KME) ::  QMULTR    ! CHANGE Q DUE TO ICE RAIN/SNOW
     REAL, DIMENSION(KMS:KME) ::  PRACS     ! CHANGE Q RAIN-SNOW COLLECTION
     REAL, DIMENSION(KMS:KME) ::  NPRACS    ! CHANGE N RAIN-SNOW COLLECTION
     REAL, DIMENSION(KMS:KME) ::  PCCN      ! CHANGE Q DROPLET ACTIVATION
     REAL, DIMENSION(KMS:KME) ::  PSMLT     ! CHANGE Q MELTING SNOW TO RAIN
     REAL, DIMENSION(KMS:KME), intent(inout) ::  EVPMS     ! CHNAGE Q MELTING SNOW EVAPORATING
     REAL, DIMENSION(KMS:KME) ::  NSMLTS    ! CHANGE N MELTING SNOW
     REAL, DIMENSION(KMS:KME) ::  NSMLTR    ! CHANGE N MELTING SNOW TO RAIN
! HM ADDED 12/13/06
     REAL, DIMENSION(KMS:KME) ::  PIACR     ! CHANGE QR, ICE-RAIN COLLECTION
     REAL, DIMENSION(KMS:KME) ::  NIACR     ! CHANGE N, ICE-RAIN COLLECTION
     REAL, DIMENSION(KMS:KME) ::  PRACI     ! CHANGE QI, ICE-RAIN COLLECTION
     REAL, DIMENSION(KMS:KME) ::  PIACRS     ! CHANGE QR, ICE RAIN COLLISION, ADDED TO SNOW
     REAL, DIMENSION(KMS:KME) ::  NIACRS     ! CHANGE N, ICE RAIN COLLISION, ADDED TO SNOW
     REAL, DIMENSION(KMS:KME) ::  PRACIS     ! CHANGE QI, ICE RAIN COLLISION, ADDED TO SNOW
     REAL, DIMENSION(KMS:KME) ::  EPRD      ! SUBLIMATION CLOUD ICE
     REAL, DIMENSION(KMS:KME) ::  EPRDS     ! SUBLIMATION SNOW
! HM ADDED GRAUPEL PROCESSES
     REAL, DIMENSION(KMS:KME) ::  PRACG    ! CHANGE IN Q COLLECTION RAIN BY GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  PSACWG    ! CHANGE IN Q COLLECTION DROPLETS BY GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  PGSACW    ! CONVERSION Q TO GRAUPEL DUE TO COLLECTION DROPLETS BY SNOW
     REAL, DIMENSION(KMS:KME) ::  PGRACS    ! CONVERSION Q TO GRAUPEL DUE TO COLLECTION RAIN BY SNOW
     REAL, DIMENSION(KMS:KME) ::  PRDG    ! DEP OF GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  EPRDG    ! SUB OF GRAUPEL
     REAL, DIMENSION(KMS:KME), intent(inout) ::  EVPMG    ! CHANGE Q MELTING OF GRAUPEL AND EVAPORATION
     REAL, DIMENSION(KMS:KME) ::  PGMLT    ! CHANGE Q MELTING OF GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  NPRACG    ! CHANGE N COLLECTION RAIN BY GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  NPSACWG    ! CHANGE N COLLECTION DROPLETS BY GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  NSCNG    ! CHANGE N CONVERSION TO GRAUPEL DUE TO COLLECTION DROPLETS BY SNOW
     REAL, DIMENSION(KMS:KME) ::  NGRACS    ! CHANGE N CONVERSION TO GRAUPEL DUE TO COLLECTION RAIN BY SNOW
     REAL, DIMENSION(KMS:KME) ::  NGMLTG    ! CHANGE N MELTING GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  NGMLTR    ! CHANGE N MELTING GRAUPEL TO RAIN
     REAL, DIMENSION(KMS:KME) ::  NSUBG    ! CHANGE N SUB/DEP OF GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  PSACR    ! CONVERSION DUE TO COLL OF SNOW BY RAIN
     REAL, DIMENSION(KMS:KME) ::  NMULTG    ! ICE MULT DUE TO ACC DROPLETS BY GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  NMULTRG    ! ICE MULT DUE TO ACC RAIN BY GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  QMULTG    ! CHANGE Q DUE TO ICE MULT DROPLETS/GRAUPEL
     REAL, DIMENSION(KMS:KME) ::  QMULTRG    ! CHANGE Q DUE TO ICE MULT RAIN/GRAUPEL

! TIME-VARYING ATMOSPHERIC PARAMETERS

     REAL, DIMENSION(KMS:KME) ::   KAP   ! THERMAL CONDUCTIVITY OF AIR
     REAL, DIMENSION(KMS:KME) ::   EVS   ! SATURATION VAPOR PRESSURE
     REAL, DIMENSION(KMS:KME) ::   EIS   ! ICE SATURATION VAPOR PRESSURE
     REAL, DIMENSION(KMS:KME) ::   QVS   ! SATURATION MIXING RATIO
     REAL, DIMENSION(KMS:KME) ::   QVI   ! ICE SATURATION MIXING RATIO
     REAL, DIMENSION(KMS:KME) ::   QVQVS ! SAUTRATION RATIO
     REAL, DIMENSION(KMS:KME) ::   QVQVSI! ICE SATURAION RATIO
     REAL, DIMENSION(KMS:KME) ::   DV    ! DIFFUSIVITY OF WATER VAPOR IN AIR
     REAL, DIMENSION(KMS:KME) ::   XXLS  ! LATENT HEAT OF SUBLIMATION
     REAL, DIMENSION(KMS:KME) ::   XXLV  ! LATENT HEAT OF VAPORIZATION
     REAL, DIMENSION(KMS:KME) ::   CPM   ! SPECIFIC HEAT AT CONST PRESSURE FOR MOIST AIR
     ! GHB
     REAL :: cvm
     REAL, DIMENSION(KMS:KME) ::   ecnd,edep,efrz
     ! GHB
     REAL, DIMENSION(KMS:KME) ::   MU    ! VISCOCITY OF AIR
     REAL, DIMENSION(KMS:KME) ::   SC    ! SCHMIDT NUMBER
     REAL, DIMENSION(KMS:KME) ::   XLF   ! LATENT HEAT OF FREEZING
     REAL, DIMENSION(KMS:KME) ::   RHO   ! AIR DENSITY
     REAL, DIMENSION(KMS:KME) ::   AB    ! CORRECTION TO CONDENSATION RATE DUE TO LATENT HEATING
     REAL, DIMENSION(KMS:KME) ::   ABI    ! CORRECTION TO DEPOSITION RATE DUE TO LATENT HEATING

! TIME-VARYING MICROPHYSICS PARAMETERS

     REAL, DIMENSION(KMS:KME) ::   DAP    ! DIFFUSIVITY OF AEROSOL
     REAL    NACNT                    ! NUMBER OF CONTACT IN
     REAL    FMULT                    ! TEMP.-DEP. PARAMETER FOR RIME-SPLINTERING
     REAL    COFFI                    ! ICE AUTOCONVERSION PARAMETER

! FALL SPEED WORKING VARIABLES (DEFINED IN CODE)

      REAL, DIMENSION(KMS:KME), intent(inout) :: FR,FI,FC,FS,FG
      REAL, DIMENSION(KMS:KME) ::    DUMI,DUMR,DUMFNI,DUMG,DUMFNG
      REAL UNI, UMI,UMR
      REAL, DIMENSION(KMS:KME) ::    FNI,FNG
      REAL RGVM
      REAL, DIMENSION(KMS:KME) ::   FALOUTR,FALOUTI,FALOUTNI
      REAL FALTNDR,FALTNDI,FALTNDNI,RHO2
      REAL, DIMENSION(KMS:KME) ::   DUMQS,DUMFNS
      REAL UMS,UNS
      REAL, DIMENSION(KMS:KME) ::   FNS, FALOUTS,FALOUTNS,FALOUTG,FALOUTNG
      REAL FALTNDS,FALTNDNS,UNR,FALTNDG,FALTNDNG
      REAL, DIMENSION(KMS:KME) ::    DUMC,DUMFNC
      REAL UNC,UMC,UNG,UMG
      REAL, DIMENSION(KMS:KME) ::   FALOUTC,FALOUTNC
      REAL FALTNDC,FALTNDNC
      REAL, DIMENSION(KMS:KME) ::   FNC,DUMFNR,FALOUTNR
      REAL FALTNDNR
      REAL, DIMENSION(KMS:KME) ::   FNR(KMS:KME)

! FALL-SPEED PARAMETER 'A' WITH AIR DENSITY CORRECTION

      REAL, DIMENSION(KMS:KME) ::    AIN,ARN,ASN,ACN,AGN

! EXTERNAL FUNCTION CALL RETURN VARIABLES

!      REAL GAMMA,      ! EULER GAMMA FUNCTION
!      REAL POLYSVP,    ! SAT. PRESSURE FUNCTION
!      REAL DERF1        ! ERROR FUNCTION

! DUMMY VARIABLES

     REAL DUM,DUM1,DUM2,DUMT,DUMQV,DUMQSS,DUMQSI,DUMS
     REAL DUMMQS,DUMQG,SAVEQC,SAVET

! PROGNOSTIC SUPERSATURATION

     REAL DQSDT    ! CHANGE OF SAT. MIX. RAT. WITH TEMPERATURE
     REAL DQSIDT   ! CHANGE IN ICE SAT. MIXING RAT. WITH T
     REAL EPSI     ! 1/PHASE REL. TIME (SEE M2005), ICE
     REAL EPSS     ! 1/PHASE REL. TIME (SEE M2005), SNOW
     REAL EPSR     ! 1/PHASE REL. TIME (SEE M2005), RAIN
     REAL EPSG     ! 1/PHASE REL. TIME (SEE M2005), GRAUPEL

! NEW DROPLET ACTIVATION VARIABLES
     REAL TAUC     ! PHASE REL. TIME (SEE M2005), DROPLETS
     REAL TAUR     ! PHASE REL. TIME (SEE M2005), RAIN
     REAL TAUI     ! PHASE REL. TIME (SEE M2005), CLOUD ICE
     REAL TAUS     ! PHASE REL. TIME (SEE M2005), SNOW
     REAL TAUG     ! PHASE REL. TIME (SEE M2005), GRAUPEL
     REAL DUMACT,DUM3

! COUNTING/INDEX VARIABLES

! V1.3 DIFFERENT NSTEP FOR EACH SPECIES
     INTEGER K,N,NSTEPR,NSTEPI,NSTEPS,NSTEPC,NSTEPG ! ,I

! LTRUE, SWITCH = 0, NO HYDROMETEORS IN COLUMN, 
!               = 1, HYDROMETEORS IN COLUMN

      INTEGER LTRUE

! DROPLET ACTIVATION/FREEZING AEROSOL


     REAL    CT      ! DROPLET ACTIVATION PARAMETER
     REAL    TEMP1   ! DUMMY TEMPERATURE
     REAL    SAT1    ! DUMMY SATURATION
     REAL    SIGVL   ! SURFACE TENSION LIQ/VAPOR
     REAL    KEL     ! KELVIN PARAMETER
     REAL    KC2     ! TOTAL ICE NUCLEATION RATE

       REAL CRY,KRY   ! AEROSOL ACTIVATION PARAMETERS

! MORE WORKING/DUMMY VARIABLES

     REAL DUMQI,DUMNI,DC0,DS0,DG0
     REAL DUMQC,DUMQR,RATIO,SUM_DEP,FUDGEF

! EFFECTIVE VERTICAL VELOCITY  (M/S)
     REAL WEF

! WORKING PARAMETERS FOR ICE NUCLEATION

      REAL ANUC,BNUC

! WORKING PARAMETERS FOR AEROSOL ACTIVATION

        REAL AACT,GAMM,GG,PSI,ETA1,ETA2,SM1,SM2,SMAX,UU1,UU2,ALPHA

! DUMMY SIZE DISTRIBUTION PARAMETERS

        REAL DLAMS,DLAMR,DLAMI,DLAMC,DLAMG,LAMMAX,LAMMIN

        INTEGER IDROP

! v1.4
! new variables for seifert and beheng warm rain scheme
      REAL, DIMENSION(KMS:KME) :: nu
      integer dumii

      real :: dttmp
      REAL, DIMENSION(KMS:KME) :: temr,temz

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! SET LTRUE INITIALLY TO 0

         LTRUE = 0

      IF(radopt.ge.1)THEN
! V.13 initialize effective radii to default values (from P. Blossey)
! hm 8/20/12
         effc(kts:kte) = 25.         
         effi(kts:kte) = 25.         
         effs(kts:kte) = 25.         
         effr(kts:kte) = 25.         
         effg(kts:kte) = 25.         
	 effis(kts:kte) = 25.
      ENDIF
!---------------------------------!

! ATMOSPHERIC PARAMETERS THAT VARY IN TIME AND HEIGHT
         DO K = KTS,KTE

! LATENT HEAT OF VAPORATION

!!!            XXLV(K) = 3.1484E6-2370.*T3D(K)
            ! GHB, 130722:
            XXLV(K) = lv1-lv2*T3D(K)

! LATENT HEAT OF SUBLIMATION

!!!            XXLS(K) = 3.15E6-2370.*T3D(K)+0.3337E6
            ! GHB, 130722:
            XXLS(K) = ls1-ls2*T3D(K)

            CPM(K) = CP*(1.+0.887*QV3D(K))

            ! GHB
            if(eqtset.eq.2)then
              cvm = 1.0/( cv+cvv*qv3d(k)+cpl*(qc3d(k)+qr3d(k))   &
                                        +cpi*(qi3d(k)+qni3d(k)+qg3d(k)) )
              ecnd(k) = (XXLV(K)-RV*T3D(K))*cvm
              edep(k) = (XXLS(K)-RV*T3D(K))*cvm
              efrz(k) = (XXLS(K)-XXLV(K))*cvm
            else
              ecnd(k) = XXLV(K)/CPM(K)
              edep(k) = XXLS(K)/CPM(K)
              efrz(k) = (XXLS(K)-XXLV(K))/CPM(K)
            endif
            ! GHB

! SATURATION VAPOR PRESSURE AND MIXING RATIO

!!!            EVS(K) = POLYSVP(T3D(K),0)   ! PA
!!!            EIS(K) = POLYSVP(T3D(K),1)   ! PA
            EVS(K) = 611.2 * EXP( 17.67 * ( T3D(K) - 273.15 ) / ( T3D(K) - 29.65 ) )
            EIS(K) = 611.2 * EXP( 21.8745584 * ( T3D(K) - 273.15 ) / ( T3D(K) - 7.66 ) )

! MAKE SURE ICE SATURATION DOESN'T EXCEED WATER SAT. NEAR FREEZING

            IF (EIS(K).GT.EVS(K)) EIS(K) = EVS(K)

            QVS(K) = EP_2*EVS(K)/(PRES(K)-EVS(K))
            QVI(K) = EP_2*EIS(K)/(PRES(K)-EIS(K))

            QVQVS(K) = QV3D(K)/QVS(K)
            QVQVSI(K) = QV3D(K)/QVI(K)

! AIR DENSITY

!!!            RHO(K) = PRES(K)/(R*T3D(K))
            RHO(K) = RHO3D(K)

! AT SUBSATURATION, REMOVE SMALL AMOUNTS OF CLOUD/PRECIP WATER
! V1.3, change limit from 10^-7 to 10^-6
! V1.7 7/9/09 change limit from 10^-6 to 10^-8
! this improves reflectivity at low mixing ratios

             IF (QVQVS(K).LT.0.9) THEN
               IF (QR3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QR3D(K)
!!!                  T3D(K)=T3D(K)-QR3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QR3D(K)*ecnd(k)
                  QR3D(K)=0.
               END IF
               IF (QC3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QC3D(K)
!!!                  T3D(K)=T3D(K)-QC3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QC3D(K)*ecnd(k)
                  QC3D(K)=0.
               END IF
             END IF

             IF (QVQVSI(K).LT.0.9) THEN
               IF (QI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QI3D(K)
!!!                  T3D(K)=T3D(K)-QI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QI3D(K)*edep(k)
                  QI3D(K)=0.
               END IF
               IF (QNI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QNI3D(K)
!!!                  T3D(K)=T3D(K)-QNI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QNI3D(K)*edep(k)
                  QNI3D(K)=0.
               END IF
               IF (QG3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QG3D(K)
!!!                  T3D(K)=T3D(K)-QG3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QG3D(K)*edep(k)
                  QG3D(K)=0.
               END IF
             END IF

! HEAT OF FUSION

            XLF(K) = XXLS(K)-XXLV(K)

!..................................................................
! IF MIXING RATIO < QSMALL SET MIXING RATIO AND NUMBER CONC TO ZERO

       IF (QC3D(K).LT.QSMALL) THEN
         QC3D(K) = 0.
         NC3D(K) = 0.
       END IF
       IF (QR3D(K).LT.QSMALL) THEN
         QR3D(K) = 0.
         NR3D(K) = 0.
       END IF
       IF (QI3D(K).LT.QSMALL) THEN
         QI3D(K) = 0.
         NI3D(K) = 0.
       END IF
       IF (QNI3D(K).LT.QSMALL) THEN
         QNI3D(K) = 0.
         NS3D(K) = 0.
       END IF
       IF (QG3D(K).LT.QSMALL) THEN
         QG3D(K) = 0.
         NG3D(K) = 0.
       END IF

! INITIALIZE SEDIMENTATION TENDENCIES FOR MIXING RATIO

      QRSTEN(K) = 0.
      QISTEN(K) = 0.
      QNISTEN(K) = 0.
      QCSTEN(K) = 0.
      QGSTEN(K) = 0.

!..................................................................
! MICROPHYSICS PARAMETERS VARYING IN TIME/HEIGHT

! DYNAMIC VISCOSITY OF AIR

            MU(K) = 1.496E-6*T3D(K)**1.5/(T3D(K)+120.)

! FALL SPEED WITH DENSITY CORRECTION (HEYMSFIELD AND BENSSEMER 2006)

            DUM = (RHOSU/RHO(K))**0.54

! v3 5/27/11
!            AIN(K) = DUM*AI
! AA revision 4/1/11: Ikawa and Saito 1991 air-density correction 
! hm fix 11/18/11
            AIN(K) = (RHOSU/RHO(K))**0.35*AI
            ARN(K) = DUM*AR
            ASN(K) = DUM*AS
!            ACN(K) = DUM*AC
! AA revision 4/1/11: temperature-dependent Stokes fall speed
            ACN(K) = G*RHOW/(18.*MU(K))
! HM ADD GRAUPEL 8/28/06
            AGN(K) = DUM*AG

! V1.7
! bug fix 7/10/09 
!hm 4/15/09 bug fix, initialize lami to prevent later division by zero
            LAMI(K)=0.

!..................................
! IF THERE IS NO CLOUD/PRECIP WATER, AND IF SUBSATURATED, THEN SKIP MICROPHYSICS
! FOR THIS LEVEL

            IF (QC3D(K).LT.QSMALL.AND.QI3D(K).LT.QSMALL.AND.QNI3D(K).LT.QSMALL &
                 .AND.QR3D(K).LT.QSMALL.AND.QG3D(K).LT.QSMALL) THEN
                 IF (T3D(K).LT.TMELT.AND.QVQVSI(K).LT.0.999) GOTO 200
                 IF (T3D(K).GE.TMELT.AND.QVQVS(K).LT.0.999) GOTO 200
            END IF

! THERMAL CONDUCTIVITY FOR AIR

! v3 5/27/11
            KAP(K) = 1.414E3*MU(K)

! DIFFUSIVITY OF WATER VAPOR

            DV(K) = 8.794E-5*T3D(K)**1.81/PRES(K)

! SCHMIT NUMBER

! v3 5/27/11
            SC(K) = MU(K)/(RHO(K)*DV(K))

! PSYCHOMETIC CORRECTIONS

! RATE OF CHANGE SAT. MIX. RATIO WITH TEMPERATURE

            DUM = (RV*T3D(K)**2)

            DQSDT = XXLV(K)*QVS(K)/DUM
            DQSIDT =  XXLS(K)*QVI(K)/DUM

            ABI(K) = 1.+DQSIDT*XXLS(K)/CPM(K)
            AB(K) = 1.+DQSDT*XXLV(K)/CPM(K)

! 
!.....................................................................
!.....................................................................
! CASE FOR TEMPERATURE ABOVE FREEZING

            IF (T3D(K).GE.TMELT) THEN

!......................................................................
!HM ADD, ALLOW FOR CONSTANT DROPLET NUMBER
! INUM = 0, PREDICT DROPLET NUMBER
! INUM = 1, SET CONSTANT DROPLET NUMBER

         IF (INUM.EQ.1) THEN
! CONVERT NDCNST FROM CM-3 TO KG-1
            NC3D(K)=NDCNST*1.E6/RHO(K)
         END IF

! GET SIZE DISTRIBUTION PARAMETERS

! MELT VERY SMALL SNOW AND GRAUPEL MIXING RATIOS, ADD TO RAIN
       IF (QNI3D(K).LT.1.E-6) THEN
          QR3D(K)=QR3D(K)+QNI3D(K)
          NR3D(K)=NR3D(K)+NS3D(K)
!!!          T3D(K)=T3D(K)-QNI3D(K)*XLF(K)/CPM(K)
          T3D(K)=T3D(K)-QNI3D(K)*efrz(k)
          QNI3D(K) = 0.
          NS3D(K) = 0.
       END IF
       IF (QG3D(K).LT.1.E-6) THEN
          QR3D(K)=QR3D(K)+QG3D(K)
          NR3D(K)=NR3D(K)+NG3D(K)
!!!          T3D(K)=T3D(K)-QG3D(K)*XLF(K)/CPM(K)
          T3D(K)=T3D(K)-QG3D(K)*efrz(k)
          QG3D(K) = 0.
          NG3D(K) = 0.
       END IF

       IF (QC3D(K).LT.QSMALL.AND.QNI3D(K).LT.1.E-8.AND.QR3D(K).LT.QSMALL.AND.QG3D(K).LT.1.E-8) GOTO 300

! MAKE SURE NUMBER CONCENTRATIONS AREN'T NEGATIVE

      NS3D(K) = MAX(0.,NS3D(K))
      IF(INUM.EQ.0)  &
      NC3D(K) = MAX(0.,NC3D(K))
      NR3D(K) = MAX(0.,NR3D(K))
      NG3D(K) = MAX(0.,NG3D(K))

!......................................................................
! RAIN

      IF (QR3D(K).GE.QSMALL) THEN
      LAMR(K) = (PI*RHOW*NR3D(K)/QR3D(K))**(1./3.)
      N0RR(K) = NR3D(K)*LAMR(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMR(K).LT.LAMMINR) THEN

      LAMR(K) = LAMMINR

      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      ELSE IF (LAMR(K).GT.LAMMAXR) THEN
      LAMR(K) = LAMMAXR
      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      END IF
      END IF

!......................................................................
! CLOUD DROPLETS

! MARTIN ET AL. (1994) FORMULA FOR PGAM

      IF (QC3D(K).GE.QSMALL) THEN

!         DUM = PRES(K)/(R*T3D(K))
! V1.5
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*RHO(K))+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)
! v1.4
! interpolate
         dumii=int(pgam(k))
         nu(k)=dnu(dumii)+(dnu(dumii+1)-dnu(dumii))* &
               (pgam(k)-real(dumii))

! CALCULATE LAMC

      LAMC(K) = (CONS26*NC3D(K)*GAMMA(PGAM(K)+4.)/   &
                 (QC3D(K)*GAMMA(PGAM(K)+1.)))**(1./3.)

! LAMMIN, 60 MICRON DIAMETER
! LAMMAX, 1 MICRON

      LAMMIN = (PGAM(K)+1.)/60.E-6
      LAMMAX = (PGAM(K)+1.)/1.E-6

      IF (LAMC(K).LT.LAMMIN) THEN
      LAMC(K) = LAMMIN

      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26
      ELSE IF (LAMC(K).GT.LAMMAX) THEN
      LAMC(K) = LAMMAX

      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      END IF

      END IF

!......................................................................
! SNOW

      IF (QNI3D(K).GE.QSMALL) THEN
      LAMS(K) = (CONS1*NS3D(K)/QNI3D(K))**(1./DS)
      N0S(K) = NS3D(K)*LAMS(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMS(K).LT.LAMMINS) THEN
      LAMS(K) = LAMMINS
      N0S(K) = LAMS(K)**(DS+1.)*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)

      ELSE IF (LAMS(K).GT.LAMMAXS) THEN

      LAMS(K) = LAMMAXS
      N0S(K) = LAMS(K)**(DS+1.)*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)
      END IF
      END IF

!......................................................................
! GRAUPEL

      IF (QG3D(K).GE.QSMALL) THEN
      LAMG(K) = (CONS2*NG3D(K)/QG3D(K))**(1./DG)
      N0G(K) = NG3D(K)*LAMG(K)

! ADJUST VARS

      IF (LAMG(K).LT.LAMMING) THEN
      LAMG(K) = LAMMING
      N0G(K) = LAMG(K)**(DG+1.)*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)

      ELSE IF (LAMG(K).GT.LAMMAXG) THEN

      LAMG(K) = LAMMAXG
      N0G(K) = LAMG(K)**(DG+1.)*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)
      END IF
      END IF

!.....................................................................
! ZERO OUT PROCESS RATES

            PRC(K) = 0.
            NPRC(K) = 0.
            NPRC1(K) = 0.
            PRA(K) = 0.
            NPRA(K) = 0.
            NRAGG(K) = 0.
            NSMLTS(K) = 0.
            NSMLTR(K) = 0.
            EVPMS(K) = 0.
            PCC(K) = 0.
            PRE(K) = 0.
            NSUBC(K) = 0.
            NSUBR(K) = 0.
            PRACG(K) = 0.
            NPRACG(K) = 0.
            PSMLT(K) = 0.
            PGMLT(K) = 0.
            EVPMG(K) = 0.
            PRACS(K) = 0.
            NPRACS(K) = 0.
            NGMLTG(K) = 0.
            NGMLTR(K) = 0.

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATION OF MICROPHYSICAL PROCESS RATES, T > 273.15 K

!.................................................................
!.......................................................................
! AUTOCONVERSION OF CLOUD LIQUID WATER TO RAIN
! FORMULA FROM BEHENG (1994)
! USING NUMERICAL SIMULATION OF STOCHASTIC COLLECTION EQUATION
! AND INITIAL CLOUD DROPLET SIZE DISTRIBUTION SPECIFIED
! AS A GAMMA DISTRIBUTION

! USE MINIMUM VALUE OF 1.E-6 TO PREVENT FLOATING POINT ERROR

         IF (QC3D(K).GE.1.E-6) THEN

! HM ADD 12/13/06, REPLACE WITH NEWER FORMULA
! FROM KHAIROUTDINOV AND KOGAN 2000, MWR

            IF (IRAIN.EQ.0) THEN

                PRC(K)=1350.*QC3D(K)**2.47*  &
           (NC3D(K)/1.e6*RHO(K))**(-1.79)

! note: nprc1 is change in Nr,
! nprc is change in Nc

        NPRC1(K) = PRC(K)/CONS29
        NPRC(K) = PRC(K)/(QC3D(k)/NC3D(K))

! hm bug fix 3/20/12
                NPRC(K) = MIN(NPRC(K),NC3D(K)/DT)
                NPRC1(K) = MIN(NPRC1(K),NPRC(K))

            ELSE IF (IRAIN.EQ.1) THEN

! v1.4
! replace with seifert and beheng

        dum = 1.-qc3d(k)/(qc3d(k)+qr3d(k))
        dum1 = 600.*dum**0.68*(1.-dum**0.68)**3

        prc(k) = 9.44e9/(20.*2.6e-7)* &
        (nu(k)+2.)*(nu(k)+4.)/(nu(k)+1.)**2* &
        (rho(k)*qc3d(k)/1000.)**4/(rho(k)*nc3d(k)/1.e6)**2* &
        (1.+dum1/(1.-dum)**2)*1000./rho(k)

        nprc(k) = prc(k)*2./2.6e-7*1000.
        nprc1(k) = 0.5*nprc(k)

        END IF
         END IF

!.......................................................................
! HM ADD 12/13/06, COLLECTION OF SNOW BY RAIN ABOVE FREEZING

         IF (QR3D(K).GE.1.E-8.AND.QNI3D(K).GE.1.E-8) THEN

            UMS = ASN(K)*CONS3/(LAMS(K)**BS)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNS = ASN(K)*CONS5/LAMS(K)**BS
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS
! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMS=MIN(UMS,1.2*dum)
            UNS=MIN(UNS,1.2*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

! hm fix, 3/4/13
! for above freezing conditions to get accelerated melting of snow,
! we need collection of rain by snow (following Lin et al. 1983)
!            PRACS(K) = CONS31*(((1.2*UMR-0.95*UMS)**2+              &
!                  0.08*UMS*UMR)**0.5*RHO(K)*                     &
!                 N0RR(K)*N0S(K)/LAMS(K)**3*                    &
!                  (5./(LAMS(K)**3*LAMR(K))+                    &
!                  2./(LAMS(K)**2*LAMR(K)**2)+                  &
!                  0.5/(LAMS(K)*LAMR(K)**3)))

            PRACS(K) = CONS41*(((1.2*UMR-0.95*UMS)**2+                   &
                  0.08*UMS*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0S(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMS(K))+                    &
                  2./(LAMR(K)**2*LAMS(K)**2)+                  &				 
                  0.5/(LAMR(k)*LAMS(k)**3)))

! v3 5/27/11 npracs no longer used
!            NPRACS(K) = CONS32*RHO(K)*(1.7*(UNR-UNS)**2+            &
!                0.3*UNR*UNS)**0.5*N0RR(K)*N0S(K)*              &
!                (1./(LAMR(K)**3*LAMS(K))+                      &
!                 1./(LAMR(K)**2*LAMS(K)**2)+                   &
!                 1./(LAMR(K)*LAMS(K)**3))

         END IF

! ADD COLLECTION OF GRAUPEL BY RAIN ABOVE FREEZING
! ASSUME ALL RAIN COLLECTION BY GRAUPEL ABOVE FREEZING IS SHED
! ASSUME SHED DROPS ARE 1 MM IN SIZE

         IF (QR3D(K).GE.1.E-8.AND.QG3D(K).GE.1.E-8) THEN

            UMG = AGN(K)*CONS7/(LAMG(K)**BG)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNG = AGN(K)*CONS8/LAMG(K)**BG
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS
! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMG=MIN(UMG,20.*dum)
            UNG=MIN(UNG,20.*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

! PRACG IS MIXING RATIO OF RAIN PER SEC COLLECTED BY GRAUPEL/HAIL
            PRACG(K) = CONS41*(((1.2*UMR-0.95*UMG)**2+                   &
                  0.08*UMG*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0G(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMG(K))+                    &
                  2./(LAMR(K)**2*LAMG(K)**2)+				   &
				  0.5/(LAMR(k)*LAMG(k)**3)))

! ASSUME 1 MM DROPS ARE SHED, GET NUMBER CONC (KG-1) SHED PER SEC

            DUM = PRACG(K)/5.2E-7

! GET NUMBER CONC OF RAIN DROPS COLLECTED

            NPRACG(K) = CONS32*RHO(K)*(1.7*(UNR-UNG)**2+            &
                0.3*UNR*UNG)**0.5*N0RR(K)*N0G(K)*              &
                (1./(LAMR(K)**3*LAMG(K))+                      &
                 1./(LAMR(K)**2*LAMG(K)**2)+                   &
                 1./(LAMR(K)*LAMG(K)**3))

! hm 7/15/13, remove limit so that the number of collected drops can smaller than
! number of shed drops
!            NPRACG(K)=MAX(NPRACG(K)-DUM,0.)
            NPRACG(K)=NPRACG(K)-DUM

	    END IF

!.......................................................................
! ACCRETION OF CLOUD LIQUID WATER BY RAIN
! CONTINUOUS COLLECTION EQUATION WITH
! GRAVITATIONAL COLLECTION KERNEL, DROPLET FALL SPEED NEGLECTED

         IF (QR3D(K).GE.1.E-8 .AND. QC3D(K).GE.1.E-8) THEN

! 12/13/06 HM ADD, REPLACE WITH NEWER FORMULA FROM
! KHAIROUTDINOV AND KOGAN 2000, MWR

            IF (IRAIN.EQ.0) THEN

           DUM=(QC3D(K)*QR3D(K))
           PRA(K) = 67.*(DUM)**1.15
           NPRA(K) = PRA(K)/(QC3D(K)/NC3D(K))

           ELSE IF (IRAIN.EQ.1) THEN

! v1.4
! seifert and beheng (2001) formulation

           dum = 1.-qc3d(k)/(qc3d(k)+qr3d(k))
           dum1 = (dum/(dum+5.e-4))**4
           pra(k) = 5.78e3*rho(k)/1000.*qc3d(k)*qr3d(k)*dum1
           npra(k) = pra(k)*rho(k)/1000.*(nc3d(k)*rho(k)/1.e6)/ &
           (qc3d(k)*rho(k)/1000.)*1.e6/rho(k)

         END IF
         END IF
!.......................................................................
! SELF-COLLECTION OF RAIN DROPS
! FROM BEHENG(1994)
! FROM NUMERICAL SIMULATION OF THE STOCHASTIC COLLECTION EQUATION
! AS DESCRINED ABOVE FOR AUTOCONVERSION

! v1.4, replace with seifert and beheng (2001)

         IF (QR3D(K).GE.1.E-8) THEN
! v1.4
! seifert and beheng
! include breakup, V2.1
            dum1=D_b
            if (1./lamr(k).lt.dum1) then
            dum=1.
            else if (1./lamr(k).ge.dum1) then
            dum=2.-exp(2300.*(1./lamr(k)-dum1))
            end if
            nragg(k) = -5.78*dum*qr3d(k)*nr3d(k)*rho(k)

         END IF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATE EVAP OF RAIN

      IF (QR3D(K).GE.QSMALL) THEN
        EPSR = 2.*PI*N0RR(K)*RHO(K)*DV(K)*                           &
                   (F1R/(LAMR(K)*LAMR(K))+                       &
                    F2R*(ARN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS9/                   &
                (LAMR(K)**CONS34))
      ELSE
      EPSR = 0.
      END IF

! NO CONDENSATION ONTO RAIN, ONLY EVAP

           IF (QV3D(K).LT.QVS(K)) THEN
              PRE(K) = EPSR*(QV3D(K)-QVS(K))/AB(K)
              PRE(K) = MIN(PRE(K),0.)
              ! dont allow evap to exceed saturation:  GHB, 130712:
              dum = QV3D(K)-PRE(K)*DT
              if( dum.gt.QVS(K) )then
                PRE(K)=(QV3D(K)-QVS(K))/DT
              endif
           ELSE
              PRE(K) = 0.
           END IF

!.......................................................................
! MELTING OF SNOW

! SNOW MAY PERSITS ABOVE FREEZING, FORMULA FROM RUTLEDGE AND HOBBS, 1984
! IF WATER SUPERSATURATION, SNOW MELTS TO FORM RAIN

          IF (QNI3D(K).GE.1.E-8) THEN

! v3 5/27/11 bug fix
!             DUM = -CPW/XLF(K)*T3D(K)*PRACS(K)
             DUM = -CPW/XLF(K)*(T3D(K)-273.15)*PRACS(K)

! hm fix 1/20/15
!             PSMLT(K)=2.*PI*N0S(K)*KAP(K)*(TMELT-T3D(K))/       &
!                    XLF(K)*RHO(K)*(F1S/(LAMS(K)*LAMS(K))+        &
!                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
!                    SC(K)**(1./3.)*CONS10/                   &
!                   (LAMS(K)**CONS35))+DUM
             PSMLT(K)=2.*PI*N0S(K)*KAP(K)*(TMELT-T3D(K))/       &
                    XLF(K)*(F1S/(LAMS(K)*LAMS(K))+        &
                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS10/                   &
                   (LAMS(K)**CONS35))+DUM

! IN WATER SUBSATURATION, SNOW MELTS AND EVAPORATES

      IF (QVQVS(K).LT.1.) THEN
        EPSS = 2.*PI*N0S(K)*RHO(K)*DV(K)*                            &
                   (F1S/(LAMS(K)*LAMS(K))+                       &
                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS10/                   &
               (LAMS(K)**CONS35))
! bug fix V1.4
        EVPMS(K) = (QV3D(K)-QVS(K))*EPSS/AB(K)    
        EVPMS(K) = MAX(EVPMS(K),PSMLT(K))
        PSMLT(K) = PSMLT(K)-EVPMS(K)
      END IF
      END IF

!.......................................................................
! MELTING OF GRAUPEL

! GRAUPEL MAY PERSITS ABOVE FREEZING, FORMULA FROM RUTLEDGE AND HOBBS, 1984
! IF WATER SUPERSATURATION, GRAUPEL MELTS TO FORM RAIN

          IF (QG3D(K).GE.1.E-8) THEN

! v3 5/27/11 bug fix
!             DUM = -CPW/XLF(K)*T3D(K)*PRACG(K)
             DUM = -CPW/XLF(K)*(T3D(K)-273.15)*PRACG(K)

! hm fix 1/20/15
!             PGMLT(K)=2.*PI*N0G(K)*KAP(K)*(TMELT-T3D(K))/ 		 &
!                    XLF(K)*RHO(K)*(F1S/(LAMG(K)*LAMG(K))+                &
!                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
!                    SC(K)**(1./3.)*CONS11/                   &
!                   (LAMG(K)**CONS36))+DUM
             PGMLT(K)=2.*PI*N0G(K)*KAP(K)*(TMELT-T3D(K))/ 		 &
                    XLF(K)*(F1S/(LAMG(K)*LAMG(K))+                &
                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS11/                   &
                   (LAMG(K)**CONS36))+DUM

! IN WATER SUBSATURATION, GRAUPEL MELTS AND EVAPORATES

      IF (QVQVS(K).LT.1.) THEN
        EPSG = 2.*PI*N0G(K)*RHO(K)*DV(K)*                                &
                   (F1S/(LAMG(K)*LAMG(K))+                               &
                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS11/                   &
               (LAMG(K)**CONS36))
! bug fix V1.4
        EVPMG(K) = (QV3D(K)-QVS(K))*EPSG/AB(K)
        EVPMG(K) = MAX(EVPMG(K),PGMLT(K))
        PGMLT(K) = PGMLT(K)-EVPMG(K)
      END IF
      END IF

! HM, V2.1
! RESET PRACG AND PRACS TO ZERO, THIS IS DONE BECAUSE THERE IS NO
! TRANSFER OF MASS FROM SNOW AND GRAUPEL TO RAIN DIRECTLY FROM COLLECTION
! ABOVE FREEZING, IT IS ONLY USED FOR ENHANCEMENT OF MELTING AND SHEDDING

      PRACG(K) = 0.
      PRACS(K) = 0.

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! FOR CLOUD ICE, ONLY PROCESSES OPERATING AT T > 273.15 IS
! MELTING, WHICH IS ALREADY CONSERVED DURING PROCESS
! CALCULATION

! CONSERVATION OF QC

      DUM = (PRC(K)+PRA(K))*DT

      IF (DUM.GT.QC3D(K).AND.QC3D(K).GE.QSMALL) THEN

        RATIO = QC3D(K)/DUM

        PRC(K) = PRC(K)*RATIO
        PRA(K) = PRA(K)*RATIO

        END IF

! CONSERVATION OF SNOW

        DUM = (-PSMLT(K)-EVPMS(K)+PRACS(K))*DT

        IF (DUM.GT.QNI3D(K).AND.QNI3D(K).GE.QSMALL) THEN

! NO SOURCE TERMS FOR SNOW AT T > FREEZING
        RATIO = QNI3D(K)/DUM

        PSMLT(K) = PSMLT(K)*RATIO
        EVPMS(K) = EVPMS(K)*RATIO
        PRACS(K) = PRACS(K)*RATIO

        END IF

! CONSERVATION OF GRAUPEL

        DUM = (-PGMLT(K)-EVPMG(K)+PRACG(K))*DT

        IF (DUM.GT.QG3D(K).AND.QG3D(K).GE.QSMALL) THEN

! NO SOURCE TERM FOR GRAUPEL ABOVE FREEZING
        RATIO = QG3D(K)/DUM

        PGMLT(K) = PGMLT(K)*RATIO
        EVPMG(K) = EVPMG(K)*RATIO
        PRACG(K) = PRACG(K)*RATIO

        END IF

! CONSERVATION OF QR
! HM 12/13/06, ADDED CONSERVATION OF RAIN SINCE PRE IS NEGATIVE

        DUM = (-PRACS(K)-PRACG(K)-PRE(K)-PRA(K)-PRC(K)+PSMLT(K)+PGMLT(K))*DT

        IF (DUM.GT.QR3D(K).AND.QR3D(K).GE.QSMALL) THEN

        RATIO = (QR3D(K)/DT+PRACS(K)+PRACG(K)+PRA(K)+PRC(K)-PSMLT(K)-PGMLT(K))/ &
                        (-PRE(K))
        PRE(K) = PRE(K)*RATIO
        
        END IF

!....................................

      QV3DTEN(K) = QV3DTEN(K)+(-PRE(K)-EVPMS(K)-EVPMG(K))

!!!      T3DTEN(K) = T3DTEN(K)+(PRE(K)*XXLV(K)+(EVPMS(K)+EVPMG(K))*XXLS(K)+&
!!!                    (PSMLT(K)+PGMLT(K)-PRACS(K)-PRACG(K))*XLF(K))/CPM(K)
      T3DTEN(K) = T3DTEN(K)+(PRE(K)*ecnd(k)+(EVPMS(K)+EVPMG(K))*edep(k)+&
                    (PSMLT(K)+PGMLT(K)-PRACS(K)-PRACG(K))*efrz(k))

      QC3DTEN(K) = QC3DTEN(K)+(-PRA(K)-PRC(K))
      QR3DTEN(K) = QR3DTEN(K)+(PRE(K)+PRA(K)+PRC(K)-PSMLT(K)-PGMLT(K)+PRACS(K)+PRACG(K))
      QNI3DTEN(K) = QNI3DTEN(K)+(PSMLT(K)+EVPMS(K)-PRACS(K))
      QG3DTEN(K) = QG3DTEN(K)+(PGMLT(K)+EVPMG(K)-PRACG(K))
! v3 5/27/11
!      NS3DTEN(K) = NS3DTEN(K)-NPRACS(K)
!      NG3DTEN(K) = NG3DTEN(K)
      NC3DTEN(K) = NC3DTEN(K)+ (-NPRA(K)-NPRC(K))
      NR3DTEN(K) = NR3DTEN(K)+ (NPRC1(K)+NRAGG(K)-NPRACG(K))

      IF (PRE(K).LT.0.) THEN
         DUM = PRE(K)*DT/QR3D(K)
           DUM = MAX(-1.,DUM)
         NSUBR(K) = DUM*NR3D(K)/DT
      END IF

! V1.3 move code below to before saturation adjustment
        IF (EVPMS(K)+PSMLT(K).LT.0.) THEN
         DUM = (EVPMS(K)+PSMLT(K))*DT/QNI3D(K)
           DUM = MAX(-1.,DUM)
         NSMLTS(K) = DUM*NS3D(K)/DT
        END IF
        IF (PSMLT(K).LT.0.) THEN
          DUM = PSMLT(K)*DT/QNI3D(K)
          DUM = MAX(-1.0,DUM)
          NSMLTR(K) = DUM*NS3D(K)/DT
        END IF
        IF (EVPMG(K)+PGMLT(K).LT.0.) THEN
         DUM = (EVPMG(K)+PGMLT(K))*DT/QG3D(K)
           DUM = MAX(-1.,DUM)
         NGMLTG(K) = DUM*NG3D(K)/DT
        END IF
        IF (PGMLT(K).LT.0.) THEN
          DUM = PGMLT(K)*DT/QG3D(K)
          DUM = MAX(-1.0,DUM)
          NGMLTR(K) = DUM*NG3D(K)/DT
        END IF

!        nsubr(k)=0.
!        nsubs(k)=0.
!        nsubg(k)=0.

         NS3DTEN(K) = NS3DTEN(K)+(NSMLTS(K))
         NG3DTEN(K) = NG3DTEN(K)+(NGMLTG(K))
         NR3DTEN(K) = NR3DTEN(K)+(NSUBR(K)-NSMLTR(K)-NGMLTR(K))

 300  CONTINUE

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! NOW CALCULATE SATURATION ADJUSTMENT TO CONDENSE EXTRA VAPOR ABOVE
! WATER SATURATION

      DUMT = T3D(K)+DT*T3DTEN(K)
      DUMQV = QV3D(K)+DT*QV3DTEN(K)
      DUMQC = QC3D(K)+DT*QC3DTEN(K)
      DUMQR = QR3D(K)+DT*QR3DTEN(K)
      DUMMQS = QNI3D(K)+DT*QNI3DTEN(K)
      DUMQG = QG3D(K)+DT*QG3DTEN(K)
      DUMQI = 0.0
      if(eqtset.eq.2) PRES(K) = RHO(K)*DUMT*(R+RV*DUMQV)
      SAVEQC = DUMQC
      SAVET = DUMT
      call satadj2(DUMT,PRES(K),DUMQV,DUMQC,DUMQR,DUMQI,DUMMQS,DUMQG,RHO(K),eqtset,tsmall)

!!!      DUMQSS = EP_2*POLYSVP(DUMT,0)/ (PRES(K)-POLYSVP(DUMT,0))
!!!      DUMQC = MAX(DUMQC,0.)
!!!
!!!! SATURATION ADJUSTMENT FOR LIQUID
!!!
!!!      DUMS = DUMQV-DUMQSS
!!!      PCC(K) = DUMS/(1.+XXLV(K)**2*DUMQSS/(CPM(K)*RV*DUMT**2))/DT
!!!      IF (PCC(K)*DT+DUMQC.LT.0.) THEN
!!!           PCC(K) = -DUMQC/DT
!!!      END IF
!!!
!!!      QV3DTEN(K) = QV3DTEN(K)-PCC(K)
!!!      T3DTEN(K) = T3DTEN(K)+PCC(K)*XXLV(K)/CPM(K)
!!!      QC3DTEN(K) = QC3DTEN(K)+PCC(K)
      ! GHB2

      IF( abs(DUMT-SAVET).ge.0.0001 )THEN
        PCC(K) = (DUMQC-SAVEQC)*RDT
        QV3DTEN(K) = QV3DTEN(K)-PCC(K)
        QC3DTEN(K) = QC3DTEN(K)+PCC(K)
        T3DTEN(K) = T3DTEN(K)+(DUMT-SAVET)*RDT
      ENDIF

!.......................................................................
! ACTIVATION OF CLOUD DROPLETS

    ! GHB, 120124:
    IF(INUM.EQ.0)THEN
      IF (QC3D(K)+QC3DTEN(K)*DT.GE.QSMALL) THEN

! EFFECTIVE VERTICAL VELOCITY (M/S)

      IF (ISUB.EQ.0) THEN
! ADD SUB-GRID VERTICAL VELOCITY
         DUM = W3D(K)+WVAR(K)

! ASSUME MINIMUM EFF. SUB-GRID VELOCITY 0.10 M/S
         DUM = MAX(DUM,0.10)

      ELSE IF (ISUB.EQ.1) THEN
         DUM=W3D(K)
      END IF

! ONLY ACTIVATE IN REGIONS OF UPWARD MOTION
      IF (DUM.GE.0.001) THEN

      IF (IBASE.EQ.1) THEN

! ACTIVATE ONLY IF THERE IS LITTLE CLOUD WATER
! OR IF AT CLOUD BASE, OR AT LOWEST MODEL LEVEL (K=1)

         IDROP=0

! V1.3 USE CURRENT VALUE OF QC FOR IDROP
         IF (QC3D(K).LE.0.05E-3/RHO(K)) THEN
            IDROP=1
         END IF
         IF (K.EQ.1) THEN
            IDROP=1
         ELSE IF (K.GE.2) THEN
            IF (QC3D(K).GT.0.05E-3/RHO(K).AND. &
             QC3D(K-1).LE.0.05E-3/RHO(K-1)) THEN
            IDROP=1
            END IF
         END IF

         IF (IDROP.EQ.1) THEN
! ACTIVATE AT CLOUD BASE OR REGIONS WITH VERY LITTLE LIQ WATER

           IF (IACT.EQ.1) THEN
! USE ROGERS AND YAU (1989) TO RELATE NUMBER ACTIVATED TO W
! BASED ON TWOMEY 1959

            DUM=DUM*100.  ! CONVERT FROM M/S TO CM/S
            DUM2 = 0.88*C1**(2./(K1+2.))*(7.E-2*DUM**1.5)**(K1/(K1+2.))
            DUM2=DUM2*1.E6 ! CONVERT FROM CM-3 TO M-3
            DUM2=DUM2/RHO(K)  ! CONVERT FROM M-3 TO KG-1
            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           ELSE IF (IACT.EQ.2) THEN
! DROPLET ACTIVATION FROM ABDUL-RAZZAK AND GHAN (2000)

           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)
           ALPHA = G*MW*XXLV(K)/(CPM(K)*RR*T3D(K)**2)-G*MA/(RR*T3D(K))
           GAMM = RR*T3D(K)/(EVS(K)*MW)+MW*XXLV(K)**2/(CPM(K)*PRES(K)*MA*T3D(K))

           GG = 1./(RHOW*RR*T3D(K)/(EVS(K)*DV(K)*MW)+ XXLV(K)*RHOW/(KAP(K)*T3D(K))*(XXLV(K)*MW/ &
              (T3D(K)*RR)-1.))

           PSI = 2./3.*(ALPHA*DUM/GG)**0.5*AACT

           ETA1 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW1)
           ETA2 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW2)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

           DUM1 = 1./SM1**2*(F11*(PSI/ETA1)**1.5+F21*(SM1**2/(ETA1+3.*PSI))**0.75)
           DUM2 = 1./SM2**2*(F12*(PSI/ETA2)**1.5+F22*(SM2**2/(ETA2+3.*PSI))**0.75)

           SMAX = 1./(DUM1+DUM2)**0.5

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

            DUM2 = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2
           END IF  ! IACT

!.............................................................................
        ELSE IF (IDROP.EQ.0) THEN
! ACTIVATE IN CLOUD INTERIOR
! FIND EQUILIBRIUM SUPERSATURATION

           TAUC=1./(2.*PI*RHO(k)*DV(K)*NC3D(K)*(PGAM(K)+1.)/LAMC(K))
           IF (EPSR.GT.1.E-8) THEN
             TAUR=1./EPSR
           ELSE
             TAUR=1.E8
           END IF

! hm fix 1/20/15
!           DUM3=(QVS(K)*RHO(K)/(PRES(K)-EVS(K))+DQSDT/CP)*G*DUM
           DUM3=(-QVS(K)*RHO(K)/(PRES(K)-EVS(K))+DQSDT/CP)*G*DUM
           DUM3=DUM3*TAUC*TAUR/(TAUC+TAUR)

           IF (DUM3/QVS(K).GE.1.E-6) THEN
           IF (IACT.EQ.1) THEN

! FIND MAXIMUM ALLOWED ACTIVATION WITH NON-EQULIBRIUM SS

            DUM=DUM*100.  ! CONVERT FROM M/S TO CM/S
            DUMACT = 0.88*C1**(2./(K1+2.))*(7.E-2*DUM**1.5)**(K1/(K1+2.))

! USE POWER LAW CCN SPECTRA

! CONVERT FROM ABSOLUTE SUPERSATURATION TO SUPERSATURATION RATIO IN %
            DUM3=DUM3/QVS(K)*100.

            DUM2=C1*DUM3**K1
! MAKE SURE VALUE DOESN'T EXCEED THAT FOR NON-EQUILIBRIUM SS
            DUM2=MIN(DUM2,DUMACT)
            DUM2=DUM2*1.E6 ! CONVERT FROM CM-3 TO M-3
            DUM2=DUM2/RHO(K)  ! CONVERT FROM M-3 TO KG-1
            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           ELSE IF (IACT.EQ.2) THEN

! FIND MAXIMUM ALLOWED ACTIVATION WITH NON-EQULIBRIUM SS

           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)
           ALPHA = G*MW*XXLV(K)/(CPM(K)*RR*T3D(K)**2)-G*MA/(RR*T3D(K))
           GAMM = RR*T3D(K)/(EVS(K)*MW)+MW*XXLV(K)**2/(CPM(K)*PRES(K)*MA*T3D(K))

           GG = 1./(RHOW*RR*T3D(K)/(EVS(K)*DV(K)*MW)+ XXLV(K)*RHOW/(KAP(K)*T3D(K))*(XXLV(K)*MW/ &
              (T3D(K)*RR)-1.))

           PSI = 2./3.*(ALPHA*DUM/GG)**0.5*AACT

           ETA1 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW1)
           ETA2 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW2)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

           DUM1 = 1./SM1**2*(F11*(PSI/ETA1)**1.5+F21*(SM1**2/(ETA1+3.*PSI))**0.75)
           DUM2 = 1./SM2**2*(F12*(PSI/ETA2)**1.5+F22*(SM2**2/(ETA2+3.*PSI))**0.75)

           SMAX = 1./(DUM1+DUM2)**0.5

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

           DUMACT = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

! USE LOGNORMAL AEROSOL
           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

! GET SUPERSATURATION RATIO FROM ABSOLUTE SUPERSATURATION
           SMAX = DUM3/QVS(K)

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

            DUM2 = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

! MAKE SURE ISN'T GREATER THAN NON-EQUIL. SS
            DUM2=MIN(DUM2,DUMACT)

            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           END IF ! IACT
           END IF ! DUM3/QVS > 1.E-6
        END IF  ! IDROP = 1

!.......................................................................
      ELSE IF (IBASE.EQ.2) THEN

           IF (IACT.EQ.1) THEN
! USE ROGERS AND YAU (1989) TO RELATE NUMBER ACTIVATED TO W
! BASED ON TWOMEY 1959

            DUM=DUM*100.  ! CONVERT FROM M/S TO CM/S
            DUM2 = 0.88*C1**(2./(K1+2.))*(7.E-2*DUM**1.5)**(K1/(K1+2.))
            DUM2=DUM2*1.E6 ! CONVERT FROM CM-3 TO M-3
            DUM2=DUM2/RHO(K)  ! CONVERT FROM M-3 TO KG-1
            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           ELSE IF (IACT.EQ.2) THEN

           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)
           ALPHA = G*MW*XXLV(K)/(CPM(K)*RR*T3D(K)**2)-G*MA/(RR*T3D(K))
           GAMM = RR*T3D(K)/(EVS(K)*MW)+MW*XXLV(K)**2/(CPM(K)*PRES(K)*MA*T3D(K))

           GG = 1./(RHOW*RR*T3D(K)/(EVS(K)*DV(K)*MW)+ XXLV(K)*RHOW/(KAP(K)*T3D(K))*(XXLV(K)*MW/ &
              (T3D(K)*RR)-1.))

           PSI = 2./3.*(ALPHA*DUM/GG)**0.5*AACT

           ETA1 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW1)
           ETA2 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW2)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

           DUM1 = 1./SM1**2*(F11*(PSI/ETA1)**1.5+F21*(SM1**2/(ETA1+3.*PSI))**0.75)
           DUM2 = 1./SM2**2*(F12*(PSI/ETA2)**1.5+F22*(SM2**2/(ETA2+3.*PSI))**0.75)

           SMAX = 1./(DUM1+DUM2)**0.5

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

            DUM2 = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2
           END IF  ! IACT
        END IF  ! IBASE
        END IF  ! W > 0.001
        END IF  ! QC3D > QSMALL
    ! GHB, 120124:
    ENDIF     ! INUM=0

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! SUBLIMATE, MELT, OR EVAPORATE NUMBER CONCENTRATION
! THIS FORMULATION ASSUMES 1:1 RATIO BETWEEN MASS LOSS AND
! LOSS OF NUMBER CONCENTRATION

!     IF (PCC(K).LT.0.) THEN
!        DUM = PCC(K)*DT/QC3D(K)
!           DUM = MAX(-1.,DUM)
!        NSUBC(K) = DUM*NC3D(K)/DT
!     END IF

! UPDATE TENDENCIES

!        NC3DTEN(K) = NC3DTEN(K)+NSUBC(K)

!.....................................................................
!.....................................................................
         ELSE  ! TEMPERATURE < 273.15

!......................................................................
!HM ADD, ALLOW FOR CONSTANT DROPLET NUMBER
! INUM = 0, PREDICT DROPLET NUMBER
! INUM = 1, SET CONSTANT DROPLET NUMBER

         IF (INUM.EQ.1) THEN
! CONVERT NDCNST FROM CM-3 TO KG-1
            NC3D(K)=NDCNST*1.E6/RHO(K)
         END IF

! MAKE SURE NUMBER CONCENTRATIONS AREN'T NEGATIVE

      NI3D(K) = MAX(0.,NI3D(K))
      NS3D(K) = MAX(0.,NS3D(K))
      IF(INUM.EQ.0)  &
      NC3D(K) = MAX(0.,NC3D(K))
      NR3D(K) = MAX(0.,NR3D(K))
      NG3D(K) = MAX(0.,NG3D(K))

!......................................................................
! CLOUD ICE

      IF (QI3D(K).GE.QSMALL) THEN
         LAMI(K) = (CONS12*                 &
              NI3D(K)/QI3D(K))**(1./DI)
         N0I(K) = NI3D(K)*LAMI(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMI(K).LT.LAMMINI) THEN

      LAMI(K) = LAMMINI

      N0I(K) = LAMI(K)**(DI+1.)*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      ELSE IF (LAMI(K).GT.LAMMAXI) THEN
      LAMI(K) = LAMMAXI
      N0I(K) = LAMI(K)**(DI+1.)*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      END IF
      END IF

!......................................................................
! RAIN

      IF (QR3D(K).GE.QSMALL) THEN
      LAMR(K) = (PI*RHOW*NR3D(K)/QR3D(K))**(1./3.)
      N0RR(K) = NR3D(K)*LAMR(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMR(K).LT.LAMMINR) THEN

      LAMR(K) = LAMMINR

      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      ELSE IF (LAMR(K).GT.LAMMAXR) THEN
      LAMR(K) = LAMMAXR
      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      END IF
      END IF

!......................................................................
! CLOUD DROPLETS

! MARTIN ET AL. (1994) FORMULA FOR PGAM

      IF (QC3D(K).GE.QSMALL) THEN

!         DUM = PRES(K)/(R*T3D(K))
! V1.5
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*RHO(K))+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

! v1.4
! interpolate
         dumii=int(pgam(k))
         nu(k)=dnu(dumii)+(dnu(dumii+1)-dnu(dumii))* &
               (pgam(k)-real(dumii))

! CALCULATE LAMC

      LAMC(K) = (CONS26*NC3D(K)*GAMMA(PGAM(K)+4.)/   &
                 (QC3D(K)*GAMMA(PGAM(K)+1.)))**(1./3.)

! LAMMIN, 60 MICRON DIAMETER
! LAMMAX, 1 MICRON

      LAMMIN = (PGAM(K)+1.)/60.E-6
      LAMMAX = (PGAM(K)+1.)/1.E-6

      IF (LAMC(K).LT.LAMMIN) THEN
      LAMC(K) = LAMMIN

      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26
      ELSE IF (LAMC(K).GT.LAMMAX) THEN
      LAMC(K) = LAMMAX
      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      END IF

! TO CALCULATE DROPLET FREEZING

        CDIST1(K) = NC3D(K)/GAMMA(PGAM(K)+1.)

      END IF

!......................................................................
! SNOW

      IF (QNI3D(K).GE.QSMALL) THEN
      LAMS(K) = (CONS1*NS3D(K)/QNI3D(K))**(1./DS)
      N0S(K) = NS3D(K)*LAMS(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMS(K).LT.LAMMINS) THEN
      LAMS(K) = LAMMINS
      N0S(K) = LAMS(K)**(DS+1.)*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)

      ELSE IF (LAMS(K).GT.LAMMAXS) THEN

      LAMS(K) = LAMMAXS
      N0S(K) = LAMS(K)**(DS+1.)*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)
      END IF
      END IF

!......................................................................
! GRAUPEL

      IF (QG3D(K).GE.QSMALL) THEN
      LAMG(K) = (CONS2*NG3D(K)/QG3D(K))**(1./DG)
      N0G(K) = NG3D(K)*LAMG(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMG(K).LT.LAMMING) THEN
      LAMG(K) = LAMMING
      N0G(K) = LAMG(K)**(DG+1.)*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)

      ELSE IF (LAMG(K).GT.LAMMAXG) THEN

      LAMG(K) = LAMMAXG
      N0G(K) = LAMG(K)**(DG+1.)*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)
      END IF
      END IF

!.....................................................................
! ZERO OUT PROCESS RATES

            MNUCCC(K) = 0.
            NNUCCC(K) = 0.
            PRC(K) = 0.
            NPRC(K) = 0.
            NPRC1(K) = 0.
            NSAGG(K) = 0.
            PSACWS(K) = 0.
            NPSACWS(K) = 0.
            PSACWI(K) = 0.
            NPSACWI(K) = 0.
            PRACS(K) = 0.
            NPRACS(K) = 0.
            NMULTS(K) = 0.
            QMULTS(K) = 0.
            NMULTR(K) = 0.
            QMULTR(K) = 0.
            NMULTG(K) = 0.
            QMULTG(K) = 0.
            NMULTRG(K) = 0.
            QMULTRG(K) = 0.
            MNUCCR(K) = 0.
            NNUCCR(K) = 0.
            PRA(K) = 0.
            NPRA(K) = 0.
            NRAGG(K) = 0.
            PRCI(K) = 0.
            NPRCI(K) = 0.
            PRAI(K) = 0.
            NPRAI(K) = 0.
            NNUCCD(K) = 0.
            MNUCCD(K) = 0.
            PCC(K) = 0.
            PRE(K) = 0.
            PRD(K) = 0.
            PRDS(K) = 0.
            EPRD(K) = 0.
            EPRDS(K) = 0.
            NSUBC(K) = 0.
            NSUBI(K) = 0.
            NSUBS(K) = 0.
            NSUBR(K) = 0.
            PIACR(K) = 0.
            NIACR(K) = 0.
            PRACI(K) = 0.
            PIACRS(K) = 0.
            NIACRS(K) = 0.
            PRACIS(K) = 0.
! HM: ADD GRAUPEL PROCESSES
            PRACG(K) = 0.
            PSACR(K) = 0.
	    PSACWG(K) = 0.
	    PGSACW(K) = 0.
            PGRACS(K) = 0.
	    PRDG(K) = 0.
	    EPRDG(K) = 0.
	    NPRACG(K) = 0.
	    NPSACWG(K) = 0.
	    NSCNG(K) = 0.
 	    NGRACS(K) = 0.
	    NSUBG(K) = 0.

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATION OF MICROPHYSICAL PROCESS RATES
! ACCRETION/AUTOCONVERSION/FREEZING/MELTING/COAG.
!.......................................................................
! FREEZING OF CLOUD DROPLETS
! ONLY ALLOWED BELOW -4 C
        IF (QC3D(K).GE.QSMALL .AND. T3D(K).LT.269.15) THEN

! NUMBER OF CONTACT NUCLEI (M^-3) FROM MEYERS ET AL., 1992
! FACTOR OF 1000 IS TO CONVERT FROM L^-1 TO M^-3

! MEYERS CURVE

           NACNT = EXP(-2.80+0.262*(TMELT-T3D(K)))*1000.

! COOPER CURVE
!        NACNT =  5.*EXP(0.304*(TMELT-T3D(K)))

! FLECTHER
!     NACNT = 0.01*EXP(0.6*(TMELT-T3D(K)))

! CONTACT FREEZING

! MEAN FREE PATH

            DUM = 7.37*T3D(K)/(288.*10.*PRES(K))/100.

! EFFECTIVE DIFFUSIVITY OF CONTACT NUCLEI
! BASED ON BROWNIAN DIFFUSION

            DAP(K) = CONS37*T3D(K)*(1.+DUM/RIN)/MU(K)
 
           MNUCCC(K) = CONS38*DAP(K)*NACNT*EXP(LOG(CDIST1(K))+   &
                   LOG(GAMMA(PGAM(K)+5.))-4.*LOG(LAMC(K)))
           NNUCCC(K) = 2.*PI*DAP(K)*NACNT*CDIST1(K)*           &
                    GAMMA(PGAM(K)+2.)/                         &
                    LAMC(K)

! IMMERSION FREEZING (BIGG 1953)

!           MNUCCC(K) = MNUCCC(K)+CONS39*                   &
!                  EXP(LOG(CDIST1(K))+LOG(GAMMA(7.+PGAM(K)))-6.*LOG(LAMC(K)))*             &
!                   EXP(AIMM*(273.15-T3D(K)))

!           NNUCCC(K) = NNUCCC(K)+                                  &
!            CONS40*EXP(LOG(CDIST1(K))+LOG(GAMMA(PGAM(K)+4.))-3.*LOG(LAMC(K)))              &
!                *EXP(AIMM*(273.15-T3D(K)))

! hm 7/15/13 fix for consistency w/ original formula
           MNUCCC(K) = MNUCCC(K)+CONS39*                   &
                  EXP(LOG(CDIST1(K))+LOG(GAMMA(7.+PGAM(K)))-6.*LOG(LAMC(K)))*             &
                   (EXP(AIMM*(273.15-T3D(K)))-1.)

           NNUCCC(K) = NNUCCC(K)+                                  &
            CONS40*EXP(LOG(CDIST1(K))+LOG(GAMMA(PGAM(K)+4.))-3.*LOG(LAMC(K)))              &
                *(EXP(AIMM*(273.15-T3D(K)))-1.)

! PUT IN A CATCH HERE TO PREVENT DIVERGENCE BETWEEN NUMBER CONC. AND
! MIXING RATIO, SINCE CONSERVATION NOT APPLIED TO NUMBER CONC

           NNUCCC(K) = MIN(NNUCCC(K),NC3D(K)/DT)

        END IF

!.................................................................
!.......................................................................
! AUTOCONVERSION OF CLOUD LIQUID WATER TO RAIN
! FORMULA FROM BEHENG (1994)
! USING NUMERICAL SIMULATION OF STOCHASTIC COLLECTION EQUATION
! AND INITIAL CLOUD DROPLET SIZE DISTRIBUTION SPECIFIED
! AS A GAMMA DISTRIBUTION

! USE MINIMUM VALUE OF 1.E-6 TO PREVENT FLOATING POINT ERROR

         IF (QC3D(K).GE.1.E-6) THEN

! HM ADD 12/13/06, REPLACE WITH NEWER FORMULA
! FROM KHAIROUTDINOV AND KOGAN 2000, MWR

            IF (IRAIN.EQ.0) THEN

                PRC(K)=1350.*QC3D(K)**2.47*  &
           (NC3D(K)/1.e6*RHO(K))**(-1.79)

! note: nprc1 is change in Nr,
! nprc is change in Nc

        NPRC1(K) = PRC(K)/CONS29
        NPRC(K) = PRC(K)/(QC3D(K)/NC3D(K))

! hm bug fix 3/20/12
                NPRC(K) = MIN(NPRC(K),NC3D(K)/DT)
                NPRC1(K) = MIN(NPRC1(K),NPRC(K))

             ELSE IF (IRAIN.EQ.1) THEN

! v1.4
! replace with seifert and beheng

        dum = 1.-qc3d(k)/(qc3d(k)+qr3d(k))
        dum1 = 600.*dum**0.68*(1.-dum**0.68)**3

        prc(k) = 9.44e9/(20.*2.6e-7)* &
        (nu(k)+2.)*(nu(k)+4.)/(nu(k)+1.)**2* &
        (rho(k)*qc3d(k)/1000.)**4/(rho(k)*nc3d(k)/1.e6)**2* &
        (1.+dum1/(1.-dum)**2)*1000./rho(k)

        nprc(k) = prc(k)*2./2.6e-7*1000.
        nprc1(k) = 0.5*nprc(k)

         END IF
         END IF

!.......................................................................
! SELF-COLLECTION OF DROPLET NOT INCLUDED IN KK2000 SCHEME

! SNOW AGGREGATION FROM PASSARELLI, 1978, USED BY REISNER, 1998
! THIS IS HARD-WIRED FOR BS = 0.4 FOR NOW

         IF (QNI3D(K).GE.1.E-8) THEN
             NSAGG(K) = CONS15*ASN(K)*RHO(K)**            &
            ((2.+BS)/3.)*QNI3D(K)**((2.+BS)/3.)*                  &
            (NS3D(K)*RHO(K))**((4.-BS)/3.)/                       &
            (RHO(K))
         END IF

!.......................................................................
! ACCRETION OF CLOUD DROPLETS ONTO SNOW/GRAUPEL
! HERE USE CONTINUOUS COLLECTION EQUATION WITH
! SIMPLE GRAVITATIONAL COLLECTION KERNEL IGNORING

! SNOW

         IF (QNI3D(K).GE.1.E-8 .AND. QC3D(K).GE.QSMALL) THEN

           PSACWS(K) = CONS13*ASN(K)*QC3D(K)*RHO(K)*               &
                  N0S(K)/                        &
                  LAMS(K)**(BS+3.)
           NPSACWS(K) = CONS13*ASN(K)*NC3D(K)*RHO(K)*              &
                  N0S(K)/                        &
                  LAMS(K)**(BS+3.)

         END IF

!............................................................................
! COLLECTION OF CLOUD WATER BY GRAUPEL

         IF (QG3D(K).GE.1.E-8 .AND. QC3D(K).GE.QSMALL) THEN

           PSACWG(K) = CONS14*AGN(K)*QC3D(K)*RHO(K)*               &
                  N0G(K)/                        &
                  LAMG(K)**(BG+3.)
           NPSACWG(K) = CONS14*AGN(K)*NC3D(K)*RHO(K)*              &
                  N0G(K)/                        &
                  LAMG(K)**(BG+3.)
	    END IF

!.......................................................................
! HM, ADD 12/13/06
! CLOUD ICE COLLECTING DROPLETS, ASSUME THAT CLOUD ICE MEAN DIAM > 100 MICRON
! BEFORE RIMING CAN OCCUR
! ASSUME THAT RIME COLLECTED ON CLOUD ICE DOES NOT LEAD
! TO HALLET-MOSSOP SPLINTERING

         IF (QI3D(K).GE.1.E-8 .AND. QC3D(K).GE.QSMALL) THEN

! PUT IN SIZE DEPENDENT COLLECTION EFFICIENCY BASED ON STOKES LAW
! FROM THOMPSON ET AL. 2004, MWR

            IF (1./LAMI(K).GE.100.E-6) THEN

           PSACWI(K) = CONS16*AIN(K)*QC3D(K)*RHO(K)*               &
                  N0I(K)/                        &
                  LAMI(K)**(BI+3.)
           NPSACWI(K) = CONS16*AIN(K)*NC3D(K)*RHO(K)*              &
                  N0I(K)/                        &
                  LAMI(K)**(BI+3.)
           END IF
         END IF

!.......................................................................
! ACCRETION OF RAIN WATER BY SNOW
! FORMULA FROM IKAWA AND SAITO, 1991, USED BY REISNER ET AL, 1998

         IF (QR3D(K).GE.1.E-8.AND.QNI3D(K).GE.1.E-8) THEN

            UMS = ASN(K)*CONS3/(LAMS(K)**BS)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNS = ASN(K)*CONS5/LAMS(K)**BS
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS
! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMS=MIN(UMS,1.2*dum)
            UNS=MIN(UNS,1.2*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

            PRACS(K) = CONS41*(((1.2*UMR-0.95*UMS)**2+                   &
                  0.08*UMS*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0S(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMS(K))+                    &
                  2./(LAMR(K)**2*LAMS(K)**2)+                  &				 
                  0.5/(LAMR(k)*LAMS(k)**3)))

            NPRACS(K) = CONS32*RHO(K)*(1.7*(UNR-UNS)**2+            &
                0.3*UNR*UNS)**0.5*N0RR(K)*N0S(K)*              &
                (1./(LAMR(K)**3*LAMS(K))+                      &
                 1./(LAMR(K)**2*LAMS(K)**2)+                   &
                 1./(LAMR(K)*LAMS(K)**3))

! MAKE SURE PRACS DOESN'T EXCEED TOTAL RAIN MIXING RATIO
! AS THIS MAY OTHERWISE RESULT IN TOO MUCH TRANSFER OF WATER DURING
! RIME-SPLINTERING

            PRACS(K) = MIN(PRACS(K),QR3D(K)/DT)

! COLLECTION OF SNOW BY RAIN - NEEDED FOR GRAUPEL CONVERSION CALCULATIONS
! ONLY CALCULATE IF SNOW AND RAIN MIXING RATIOS EXCEED 0.1 G/KG

! V1.3
! V1.5
!            IF (IHAIL.EQ.0) THEN
            IF (QNI3D(K).GE.0.1E-3.AND.QR3D(K).GE.0.1E-3) THEN
            PSACR(K) = CONS31*(((1.2*UMR-0.95*UMS)**2+              &
                  0.08*UMS*UMR)**0.5*RHO(K)*                     &
                 N0RR(K)*N0S(K)/LAMS(K)**3*                               &
                  (5./(LAMS(K)**3*LAMR(K))+                    &
                  2./(LAMS(K)**2*LAMR(K)**2)+                  &
                  0.5/(LAMS(K)*LAMR(K)**3)))            
            END IF
!            END IF

         END IF

!.......................................................................

! COLLECTION OF RAINWATER BY GRAUPEL, FROM IKAWA AND SAITO 1990, 
! USED BY REISNER ET AL 1998
         IF (QR3D(K).GE.1.E-8.AND.QG3D(K).GE.1.E-8) THEN

            UMG = AGN(K)*CONS7/(LAMG(K)**BG)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNG = AGN(K)*CONS8/LAMG(K)**BG
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS
! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMG=MIN(UMG,20.*dum)
            UNG=MIN(UNG,20.*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

            PRACG(K) = CONS41*(((1.2*UMR-0.95*UMG)**2+                   &
                  0.08*UMG*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0G(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMG(K))+                    &
                  2./(LAMR(K)**2*LAMG(K)**2)+				   &
				  0.5/(LAMR(k)*LAMG(k)**3)))

            NPRACG(K) = CONS32*RHO(K)*(1.7*(UNR-UNG)**2+            &
                0.3*UNR*UNG)**0.5*N0RR(K)*N0G(K)*              &
                (1./(LAMR(K)**3*LAMG(K))+                      &
                 1./(LAMR(K)**2*LAMG(K)**2)+                   &
                 1./(LAMR(K)*LAMG(K)**3))

! MAKE SURE PRACG DOESN'T EXCEED TOTAL RAIN MIXING RATIO
! AS THIS MAY OTHERWISE RESULT IN TOO MUCH TRANSFER OF WATER DURING
! RIME-SPLINTERING

            PRACG(K) = MIN(PRACG(K),QR3D(K)/DT)

	    END IF

!.......................................................................
! RIME-SPLINTERING - SNOW
! HALLET-MOSSOP (1974)
! NUMBER OF SPLINTERS FORMED IS BASED ON MASS OF RIMED WATER

! DUM1 = MASS OF INDIVIDUAL SPLINTERS

! HM ADD THRESHOLD SNOW AND DROPLET MIXING RATIO FOR RIME-SPLINTERING
! TO LIMIT RIME-SPLINTERING IN STRATIFORM CLOUDS
! THESE THRESHOLDS CORRESPOND WITH GRAUPEL THRESHOLDS IN RH 1984

!v1.4
         IF (QNI3D(K).GE.0.1E-3) THEN
         IF (QC3D(K).GE.0.5E-3.OR.QR3D(K).GE.0.1E-3) THEN
         IF (PSACWS(K).GT.0..OR.PRACS(K).GT.0.) THEN
            IF (T3D(K).LT.270.16 .AND. T3D(K).GT.265.16) THEN

               IF (T3D(K).GT.270.16) THEN
                  FMULT = 0.
               ELSE IF (T3D(K).LE.270.16.AND.T3D(K).GT.268.16)  THEN
                  FMULT = (270.16-T3D(K))/2.
               ELSE IF (T3D(K).GE.265.16.AND.T3D(K).LE.268.16)   THEN
                  FMULT = (T3D(K)-265.16)/3.
               ELSE IF (T3D(K).LT.265.16) THEN
                  FMULT = 0.
               END IF

! 1000 IS TO CONVERT FROM KG TO G

! SPLINTERING FROM DROPLETS ACCRETED ONTO SNOW

               IF (PSACWS(K).GT.0.) THEN
                  NMULTS(K) = 35.E4*PSACWS(K)*FMULT*1000.
                  QMULTS(K) = NMULTS(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM SNOW TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO SNOW

                  QMULTS(K) = MIN(QMULTS(K),PSACWS(K))
                  PSACWS(K) = PSACWS(K)-QMULTS(K)

               END IF

! RIMING AND SPLINTERING FROM ACCRETED RAINDROPS

               IF (PRACS(K).GT.0.) THEN
                   NMULTR(K) = 35.E4*PRACS(K)*FMULT*1000.
                   QMULTR(K) = NMULTR(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM SNOW TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO SNOW

                   QMULTR(K) = MIN(QMULTR(K),PRACS(K))

                   PRACS(K) = PRACS(K)-QMULTR(K)

               END IF

            END IF
            END IF
         END IF
         END IF

!.......................................................................
! RIME-SPLINTERING - GRAUPEL 
! HALLET-MOSSOP (1974)
! NUMBER OF SPLINTERS FORMED IS BASED ON MASS OF RIMED WATER

! DUM1 = MASS OF INDIVIDUAL SPLINTERS

! HM ADD THRESHOLD SNOW MIXING RATIO FOR RIME-SPLINTERING
! TO LIMIT RIME-SPLINTERING IN STRATIFORM CLOUDS

! V1.3
! V1.5
!         IF (IHAIL.EQ.0) THEN
! v1.4
         IF (QG3D(K).GE.0.1E-3) THEN
         IF (QC3D(K).GE.0.5E-3.OR.QR3D(K).GE.0.1E-3) THEN
         IF (PSACWG(K).GT.0..OR.PRACG(K).GT.0.) THEN
            IF (T3D(K).LT.270.16 .AND. T3D(K).GT.265.16) THEN

               IF (T3D(K).GT.270.16) THEN
                  FMULT = 0.
               ELSE IF (T3D(K).LE.270.16.AND.T3D(K).GT.268.16)  THEN
                  FMULT = (270.16-T3D(K))/2.
               ELSE IF (T3D(K).GE.265.16.AND.T3D(K).LE.268.16)   THEN
                  FMULT = (T3D(K)-265.16)/3.
               ELSE IF (T3D(K).LT.265.16) THEN
                  FMULT = 0.
               END IF

! 1000 IS TO CONVERT FROM KG TO G

! SPLINTERING FROM DROPLETS ACCRETED ONTO GRAUPEL

               IF (PSACWG(K).GT.0.) THEN
                  NMULTG(K) = 35.E4*PSACWG(K)*FMULT*1000.
                  QMULTG(K) = NMULTG(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM GRAUPEL TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO GRAUPEL

                  QMULTG(K) = MIN(QMULTG(K),PSACWG(K))
                  PSACWG(K) = PSACWG(K)-QMULTG(K)

               END IF

! RIMING AND SPLINTERING FROM ACCRETED RAINDROPS

               IF (PRACG(K).GT.0.) THEN
                   NMULTRG(K) = 35.E4*PRACG(K)*FMULT*1000.
                   QMULTRG(K) = NMULTRG(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM GRAUPEL TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO GRAUPEL

                   QMULTRG(K) = MIN(QMULTRG(K),PRACG(K))
                   PRACG(K) = PRACG(K)-QMULTRG(K)

               END IF

            END IF
            END IF
            END IF
            END IF
!         END IF

!........................................................................
! CONVERSION OF RIMED CLOUD WATER ONTO SNOW TO GRAUPEL/HAIL

! V1.3
! V1.5
!           IF (IHAIL.EQ.0) THEN
	   IF (PSACWS(K).GT.0.) THEN
! ONLY ALLOW CONVERSION IF QNI > 0.1 AND QC > 0.5 G/KG FOLLOWING RUTLEDGE AND HOBBS (1984)
              IF (QNI3D(K).GE.0.1E-3.AND.QC3D(K).GE.0.5E-3) THEN

! PORTION OF RIMING CONVERTED TO GRAUPEL (REISNER ET AL. 1998, ORIGINALLY IS1991)
	     PGSACW(K) = MIN(PSACWS(K),CONS17*DT*N0S(K)*QC3D(K)*QC3D(K)* &
                          ASN(K)*ASN(K)/ &
                           (RHO(K)*LAMS(K)**(2.*BS+2.))) 

! MIX RAT CONVERTED INTO GRAUPEL AS EMBRYO (REISNER ET AL. 1998, ORIG M1990)
	     DUM = MAX(RHOSN/(RHOG-RHOSN)*PGSACW(K),0.) 

! NUMBER CONCENTRAITON OF EMBRYO GRAUPEL FROM RIMING OF SNOW
	     NSCNG(K) = DUM/MG0*RHO(K)
! LIMIT MAX NUMBER CONVERTED TO SNOW NUMBER
             NSCNG(K) = MIN(NSCNG(K),NS3D(K)/DT)

! PORTION OF RIMING LEFT FOR SNOW
             PSACWS(K) = PSACWS(K) - PGSACW(K)
             END IF
	   END IF

! CONVERSION OF RIMED RAINWATER ONTO SNOW CONVERTED TO GRAUPEL

	   IF (PRACS(K).GT.0.) THEN
! ONLY ALLOW CONVERSION IF QNI > 0.1 AND QR > 0.1 G/KG FOLLOWING RUTLEDGE AND HOBBS (1984)
              IF (QNI3D(K).GE.0.1E-3.AND.QR3D(K).GE.0.1E-3) THEN
! PORTION OF COLLECTED RAINWATER CONVERTED TO GRAUPEL (REISNER ET AL. 1998)
	      DUM = CONS18*(4./LAMS(K))**3*(4./LAMS(K))**3 &    
                   /(CONS18*(4./LAMS(K))**3*(4./LAMS(K))**3+ &  
                   CONS19*(4./LAMR(K))**3*(4./LAMR(K))**3)
              DUM=MIN(DUM,1.)
              DUM=MAX(DUM,0.)
	      PGRACS(K) = (1.-DUM)*PRACS(K)
            NGRACS(K) = (1.-DUM)*NPRACS(K)
! LIMIT MAX NUMBER CONVERTED TO MIN OF EITHER RAIN OR SNOW NUMBER CONCENTRATION
            NGRACS(K) = MIN(NGRACS(K),NR3D(K)/DT)
            NGRACS(K) = MIN(NGRACS(K),NS3D(K)/DT)

! AMOUNT LEFT FOR SNOW PRODUCTION
            PRACS(K) = PRACS(K) - PGRACS(K)
            NPRACS(K) = NPRACS(K) - NGRACS(K)
! CONVERSION TO GRAUPEL DUE TO COLLECTION OF SNOW BY RAIN
            PSACR(K)=PSACR(K)*(1.-DUM)
            END IF
	   END IF
!           END IF

!.......................................................................
! FREEZING OF RAIN DROPS
! FREEZING ALLOWED BELOW -4 C

         IF (T3D(K).LT.269.15.AND.QR3D(K).GE.QSMALL) THEN

! IMMERSION FREEZING (BIGG 1953)
!            MNUCCR(K) = CONS20*NR3D(K)*EXP(AIMM*(273.15-T3D(K)))/LAMR(K)**3 &
!                 /LAMR(K)**3

!            NNUCCR(K) = PI*NR3D(K)*BIMM*EXP(AIMM*(273.15-T3D(K)))/LAMR(K)**3

! hm fix 7/15/13 for consistency w/ original formula
            MNUCCR(K) = CONS20*NR3D(K)*((EXP(AIMM*(273.15-T3D(K)))-1.)/LAMR(K)**3 &
                 /LAMR(K)**3)

            NNUCCR(K) = PI*NR3D(K)*BIMM*(EXP(AIMM*(273.15-T3D(K)))-1.)/LAMR(K)**3

! PREVENT DIVERGENCE BETWEEN MIXING RATIO AND NUMBER CONC
            NNUCCR(K) = MIN(NNUCCR(K),NR3D(K)/DT)

         END IF

!.......................................................................
! ACCRETION OF CLOUD LIQUID WATER BY RAIN
! CONTINUOUS COLLECTION EQUATION WITH
! GRAVITATIONAL COLLECTION KERNEL, DROPLET FALL SPEED NEGLECTED

         IF (QR3D(K).GE.1.E-8 .AND. QC3D(K).GE.1.E-8) THEN

! 12/13/06 HM ADD, REPLACE WITH NEWER FORMULA FROM
! KHAIROUTDINOV AND KOGAN 2000, MWR

            IF (IRAIN.EQ.0) THEN

           DUM=(QC3D(K)*QR3D(K))
           PRA(K) = 67.*(DUM)**1.15
           NPRA(K) = PRA(K)/(QC3D(K)/NC3D(K))

           ELSE IF (IRAIN.EQ.1) THEN

! v1.4
! seifert and beheng (2001) formulation

           dum = 1.-qc3d(k)/(qc3d(k)+qr3d(k))
           dum1 = (dum/(dum+5.e-4))**4
           pra(k) = 5.78e3*rho(k)/1000.*qc3d(k)*qr3d(k)*dum1
           npra(k) = pra(k)*rho(k)/1000.*(nc3d(k)*rho(k)/1.e6)/ &
           (qc3d(k)*rho(k)/1000.)*1.e6/rho(k)

         END IF
         END IF
!.......................................................................
! SELF-COLLECTION OF RAIN DROPS
! FROM BEHENG(1994)
! FROM NUMERICAL SIMULATION OF THE STOCHASTIC COLLECTION EQUATION
! AS DESCRINED ABOVE FOR AUTOCONVERSION

! v1.4 replace with seifert and beheng (2001)

         IF (QR3D(K).GE.1.E-8) THEN
! v1.4
! seifert and beheng
! include breakup, V2.1
            dum1=D_b
            if (1./lamr(k).lt.dum1) then
            dum=1.
            else if (1./lamr(k).ge.dum1) then
            dum=2.-exp(2300.*(1./lamr(k)-dum1))
            end if
            nragg(k) = -5.78*dum*qr3d(k)*nr3d(k)*rho(k)

         END IF

!.......................................................................
! AUTOCONVERSION OF CLOUD ICE TO SNOW
! FOLLOWING HARRINGTON ET AL. (1995) WITH MODIFICATION
! HERE IT IS ASSUMED THAT AUTOCONVERSION CAN ONLY OCCUR WHEN THE
! ICE IS GROWING, I.E. IN CONDITIONS OF ICE SUPERSATURATION

         IF (QI3D(K).GE.1.E-8 .AND.QVQVSI(K).GE.1.) THEN

!           COFFI = 2./LAMI(K)
!           IF (COFFI.GE.DCS) THEN
              NPRCI(K) = CONS21*(QV3D(K)-QVI(K))*RHO(K)                         &
                *N0I(K)*EXP(-LAMI(K)*DCS)*DV(K)/ABI(K)
              PRCI(K) = CONS22*NPRCI(K)
              NPRCI(K) = MIN(NPRCI(K),NI3D(K)/DT)

!           END IF
         END IF

!.......................................................................
! ACCRETION OF CLOUD ICE BY SNOW
! FOR THIS CALCULATION, IT IS ASSUMED THAT THE VS >> VI
! AND DS >> DI FOR CONTINUOUS COLLECTION

         IF (QNI3D(K).GE.1.E-8 .AND. QI3D(K).GE.QSMALL) THEN
            PRAI(K) = CONS23*ASN(K)*QI3D(K)*RHO(K)*N0S(K)/     &
                     LAMS(K)**(BS+3.)
            NPRAI(K) = CONS23*ASN(K)*NI3D(K)*                                       &
                  RHO(K)*N0S(K)/                                 &
                  LAMS(K)**(BS+3.)
            NPRAI(K)=MIN(NPRAI(K),NI3D(K)/DT)
         END IF

!.......................................................................
! HM, ADD 12/13/06, COLLISION OF RAIN AND ICE TO PRODUCE SNOW OR GRAUPEL
! FOLLOWS REISNER ET AL. 1998
! ASSUMED FALLSPEED AND SIZE OF ICE CRYSTAL << THAN FOR RAIN

         IF (QR3D(K).GE.1.E-8.AND.QI3D(K).GE.1.E-8.AND.T3D(K).LE.TMELT) THEN

! ALLOW GRAUPEL FORMATION FROM RAIN-ICE COLLISIONS ONLY IF RAIN MIXING RATIO > 0.1 G/KG,
! OTHERWISE ADD TO SNOW

            IF (QR3D(K).GE.0.1E-3) THEN
            NIACR(K)=CONS24*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)*RHO(K)
            PIACR(K)=CONS25*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)/LAMR(K)**3*RHO(K)
            PRACI(K)=CONS24*QI3D(K)*N0RR(K)*ARN(K)/ &
                LAMR(K)**(BR+3.)*RHO(K)
            NIACR(K)=MIN(NIACR(K),NR3D(K)/DT)
            NIACR(K)=MIN(NIACR(K),NI3D(K)/DT)
            ELSE 
            NIACRS(K)=CONS24*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)*RHO(K)
            PIACRS(K)=CONS25*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)/LAMR(K)**3*RHO(K)
            PRACIS(K)=CONS24*QI3D(K)*N0RR(K)*ARN(K)/ &
                LAMR(K)**(BR+3.)*RHO(K)
            NIACRS(K)=MIN(NIACRS(K),NR3D(K)/DT)
            NIACRS(K)=MIN(NIACRS(K),NI3D(K)/DT)
            END IF
         END IF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! NUCLEATION OF CLOUD ICE FROM HOMOGENEOUS AND HETEROGENEOUS FREEZING ON AEROSOL

         IF (INUC.EQ.0) THEN

! FREEZING OF AEROSOL ONLY ALLOWED BELOW -5 C
! AND ABOVE DELIQUESCENCE THRESHOLD OF 80%
! AND ABOVE ICE SATURATION

! add threshold according to Greg Thomspon

         if ((QVQVS(K).GE.0.999.and.T3D(K).le.265.15).or. &
              QVQVSI(K).ge.1.08) then

! hm, modify dec. 5, 2006, replace with cooper curve
      kc2 = 0.005*exp(0.304*(TMELT-T3D(K)))*1000. ! convert from L-1 to m-3
! limit to 500 L-1
      kc2 = min(kc2,500.e3)
      kc2=MAX(kc2/rho(k),0.)  ! convert to kg-1

          IF (KC2.GT.NI3D(K)+NS3D(K)+NG3D(K)) THEN
             NNUCCD(K) = (KC2-NI3D(K)-NS3D(K)-NG3D(K))/DT
             MNUCCD(K) = NNUCCD(K)*MI0
          END IF

          END IF

          ELSE IF (INUC.EQ.1) THEN

          IF (T3D(K).LT.TMELT.AND.QVQVSI(K).GT.1.) THEN

             KC2 = 0.16*1000./RHO(K)  ! CONVERT FROM L-1 TO KG-1
          IF (KC2.GT.NI3D(K)+NS3D(K)+NG3D(K)) THEN
             NNUCCD(K) = (KC2-NI3D(K)-NS3D(K)-NG3D(K))/DT
             MNUCCD(K) = NNUCCD(K)*MI0
          END IF
          END IF

         END IF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

 101      CONTINUE

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATE EVAP/SUB/DEP TERMS FOR QI,QNI,QR

! NO VENTILATION FOR CLOUD ICE

        IF (QI3D(K).GE.QSMALL) THEN

         EPSI = 2.*PI*N0I(K)*RHO(K)*DV(K)/(LAMI(K)*LAMI(K))

      ELSE
         EPSI = 0.
      END IF

      IF (QNI3D(K).GE.QSMALL) THEN
        EPSS = 2.*PI*N0S(K)*RHO(K)*DV(K)*                            &
                   (F1S/(LAMS(K)*LAMS(K))+                       &
                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS10/                   &
               (LAMS(K)**CONS35))
      ELSE
      EPSS = 0.
      END IF

      IF (QG3D(K).GE.QSMALL) THEN
        EPSG = 2.*PI*N0G(K)*RHO(K)*DV(K)*                                &
                   (F1S/(LAMG(K)*LAMG(K))+                               &
                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS11/                   &
               (LAMG(K)**CONS36))


      ELSE
      EPSG = 0.
      END IF

      IF (QR3D(K).GE.QSMALL) THEN
        EPSR = 2.*PI*N0RR(K)*RHO(K)*DV(K)*                           &
                   (F1R/(LAMR(K)*LAMR(K))+                       &
                    F2R*(ARN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS9/                   &
                (LAMR(K)**CONS34))
      ELSE
      EPSR = 0.
      END IF

! ONLY INCLUDE REGION OF ICE SIZE DIST < DCS
! DUM IS FRACTION OF D*N(D) < DCS

              IF (QI3D(K).GE.QSMALL) THEN              
              DUM=(1.-EXP(-LAMI(K)*DCS)*(1.+LAMI(K)*DCS))
              PRD(K) = EPSI*(QV3D(K)-QVI(K))/ABI(K)*DUM
              ELSE
              DUM=0.
              END IF
! ADD DEPOSITION IN TAIL OF ICE SIZE DIST TO SNOW IF SNOW IS PRESENT
              IF (QNI3D(K).GE.QSMALL) THEN
              PRDS(K) = EPSS*(QV3D(K)-QVI(K))/ABI(K)+ &
                EPSI*(QV3D(K)-QVI(K))/ABI(K)*(1.-DUM)
! OTHERWISE ADD TO CLOUD ICE
              ELSE
              PRD(K) = PRD(K)+EPSI*(QV3D(K)-QVI(K))/ABI(K)*(1.-DUM)
              END IF
! VAPOR DPEOSITION ON GRAUPEL
              PRDG(K) = EPSG*(QV3D(K)-QVI(K))/ABI(K)

! NO CONDENSATION ONTO RAIN, ONLY EVAP

           IF (QV3D(K).LT.QVS(K)) THEN
              PRE(K) = EPSR*(QV3D(K)-QVS(K))/AB(K)
              PRE(K) = MIN(PRE(K),0.)
              ! dont allow evap to exceed saturation:  GHB, 130712:
              dum = QV3D(K)-PRE(K)*DT
              if( dum.gt.QVS(K) )then
                PRE(K)=(QV3D(K)-QVS(K))/DT
              endif
           ELSE
              PRE(K) = 0.
           END IF

! MAKE SURE NOT PUSHED INTO ICE SUPERSAT/SUBSAT
! FORMULA FROM REISNER 2 SCHEME

           DUM = (QV3D(K)-QVI(K))/DT

           FUDGEF = 0.9999
           SUM_DEP = PRD(K)+PRDS(K)+MNUCCD(K)+PRDG(K)

           IF( (DUM.GT.0. .AND. SUM_DEP.GT.DUM*FUDGEF) .OR.                      &
               (DUM.LT.0. .AND. SUM_DEP.LT.DUM*FUDGEF) ) THEN
               MNUCCD(K) = FUDGEF*MNUCCD(K)*DUM/SUM_DEP
               PRD(K) = FUDGEF*PRD(K)*DUM/SUM_DEP
               PRDS(K) = FUDGEF*PRDS(K)*DUM/SUM_DEP
	       PRDG(K) = FUDGEF*PRDG(K)*DUM/SUM_DEP
           ENDIF

! IF CLOUD ICE/SNOW/GRAUPEL VAP DEPOSITION IS NEG, THEN ASSIGN TO SUBLIMATION PROCESSES

           IF (PRD(K).LT.0.) THEN
              EPRD(K)=PRD(K)
              PRD(K)=0.
           END IF
           IF (PRDS(K).LT.0.) THEN
              EPRDS(K)=PRDS(K)
              PRDS(K)=0.
           END IF
           IF (PRDG(K).LT.0.) THEN
              EPRDG(K)=PRDG(K)
              PRDG(K)=0.
           END IF

!.......................................................................
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! CONSERVATION OF WATER
! THIS IS ADOPTED LOOSELY FROM MM5 RESINER CODE. HOWEVER, HERE WE
! ONLY ADJUST PROCESSES THAT ARE NEGATIVE, RATHER THAN ALL PROCESSES.
! THIS SECTION IS SEPARATED INTO TWO PARTS, IF T < 0 C, T > 0 C
! DUE TO DIFFERENT PROCESSES THAT ACT DEPENDING ON FREEZING/ABOVE FREEZING

! IF MIXING RATIOS LESS THAN QSMALL, THEN NO DEPLETION OF WATER
! THROUGH MICROPHYSICAL PROCESSES, SKIP CONSERVATION

! NOTE: CONSERVATION NOT APPLIED TO NUMBER CONCENTRATION SPECIES. ADDITIONAL CATCH
! BELOW WILL PREVENT NEGATIVE NUMBER CONCENTRATION
! FOR EACH MICROPHYSICAL PROCESS WHICH PROVIDES A SOURCE FOR NUMBER, THERE IS A CHECK
! TO MAKE SURE THAT CAN'T EXCEED TOTAL NUMBER OF DEPLETED SPECIES WITH THE TIME
! STEP

!****SENSITIVITY - NO ICE

      IF (ILIQ.EQ.1) THEN
      MNUCCC(K)=0.
      NNUCCC(K)=0.
      MNUCCR(K)=0.
      NNUCCR(K)=0.
      MNUCCD(K)=0.
      NNUCCD(K)=0.
      END IF

! ****SENSITIVITY - NO GRAUPEL
      IF (IGRAUP.EQ.1) THEN
            PRACG(K) = 0.
            PSACR(K) = 0.
	    PSACWG(K) = 0.
	    PGSACW(K) = 0.
            PGRACS(K) = 0.
	    PRDG(K) = 0.
	    EPRDG(K) = 0.
            EVPMG(K) = 0.
            PGMLT(K) = 0.
	    NPRACG(K) = 0.
	    NPSACWG(K) = 0.
	    NSCNG(K) = 0.
 	    NGRACS(K) = 0.
	    NSUBG(K) = 0.
	    NGMLTG(K) = 0.
            NGMLTR(K) = 0.
! v3 5/27/11
            PIACRS(K)=PIACRS(K)+PIACR(K)
            PIACR(K) = 0.
! fix 070713
	    PRACIS(K)=PRACIS(K)+PRACI(K)
	    PRACI(K) = 0.
	    PSACWS(K)=PSACWS(K)+PGSACW(K)
	    PGSACW(K) = 0.
	    PRACS(K)=PRACS(K)+PGRACS(K)
	    PGRACS(K) = 0.
       END IF

! CONSERVATION OF QC

      DUM = (PRC(K)+PRA(K)+MNUCCC(K)+PSACWS(K)+PSACWI(K)+QMULTS(K)+PSACWG(K)+PGSACW(K)+QMULTG(K))*DT

      IF (DUM.GT.QC3D(K).AND.QC3D(K).GE.QSMALL) THEN
        RATIO = QC3D(K)/DUM

        PRC(K) = PRC(K)*RATIO
        PRA(K) = PRA(K)*RATIO
        MNUCCC(K) = MNUCCC(K)*RATIO
        PSACWS(K) = PSACWS(K)*RATIO
        PSACWI(K) = PSACWI(K)*RATIO
        QMULTS(K) = QMULTS(K)*RATIO
        QMULTG(K) = QMULTG(K)*RATIO
        PSACWG(K) = PSACWG(K)*RATIO
	PGSACW(K) = PGSACW(K)*RATIO
        END IF
 
! CONSERVATION OF QI

      DUM = (-PRD(K)-MNUCCC(K)+PRCI(K)+PRAI(K)-QMULTS(K)-QMULTG(K)-QMULTR(K)-QMULTRG(K) &
                -MNUCCD(K)+PRACI(K)+PRACIS(K)-EPRD(K)-PSACWI(K))*DT

      IF (DUM.GT.QI3D(K).AND.QI3D(K).GE.QSMALL) THEN

        RATIO = (QI3D(K)/DT+PRD(K)+MNUCCC(K)+QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+ &
                     MNUCCD(K)+PSACWI(K))/ &
                      (PRCI(K)+PRAI(K)+PRACI(K)+PRACIS(K)-EPRD(K))

        PRCI(K) = PRCI(K)*RATIO
        PRAI(K) = PRAI(K)*RATIO
        PRACI(K) = PRACI(K)*RATIO
        PRACIS(K) = PRACIS(K)*RATIO
        EPRD(K) = EPRD(K)*RATIO

        END IF

! CONSERVATION OF QR

      DUM=((PRACS(K)-PRE(K))+(QMULTR(K)+QMULTRG(K)-PRC(K))+(MNUCCR(K)-PRA(K))+ &
             PIACR(K)+PIACRS(K)+PGRACS(K)+PRACG(K))*DT

      IF (DUM.GT.QR3D(K).AND.QR3D(K).GE.QSMALL) THEN

        RATIO = (QR3D(K)/DT+PRC(K)+PRA(K))/ &
             (-PRE(K)+QMULTR(K)+QMULTRG(K)+PRACS(K)+MNUCCR(K)+PIACR(K)+PIACRS(K)+PGRACS(K)+PRACG(K))

        PRE(K) = PRE(K)*RATIO
        PRACS(K) = PRACS(K)*RATIO
        QMULTR(K) = QMULTR(K)*RATIO
        QMULTRG(K) = QMULTRG(K)*RATIO
        MNUCCR(K) = MNUCCR(K)*RATIO
        PIACR(K) = PIACR(K)*RATIO
        PIACRS(K) = PIACRS(K)*RATIO
        PGRACS(K) = PGRACS(K)*RATIO
        PRACG(K) = PRACG(K)*RATIO

        END IF

! CONSERVATION OF QNI
! CONSERVATION FOR GRAUPEL SCHEME

        IF (IGRAUP.EQ.0) THEN

      DUM = (-PRDS(K)-PSACWS(K)-PRAI(K)-PRCI(K)-PRACS(K)-EPRDS(K)+PSACR(K)-PIACRS(K)-PRACIS(K))*DT

      IF (DUM.GT.QNI3D(K).AND.QNI3D(K).GE.QSMALL) THEN

        RATIO = (QNI3D(K)/DT+PRDS(K)+PSACWS(K)+PRAI(K)+PRCI(K)+PRACS(K)+PIACRS(K)+PRACIS(K))/(-EPRDS(K)+PSACR(K))

       EPRDS(K) = EPRDS(K)*RATIO
       PSACR(K) = PSACR(K)*RATIO

       END IF

! FOR NO GRAUPEL, NEED TO INCLUDE FREEZING OF RAIN FOR SNOW
       ELSE IF (IGRAUP.EQ.1) THEN

      DUM = (-PRDS(K)-PSACWS(K)-PRAI(K)-PRCI(K)-PRACS(K)-EPRDS(K)+PSACR(K)-PIACRS(K)-PRACIS(K)-MNUCCR(K))*DT

      IF (DUM.GT.QNI3D(K).AND.QNI3D(K).GE.QSMALL) THEN

       RATIO = (QNI3D(K)/DT+PRDS(K)+PSACWS(K)+PRAI(K)+PRCI(K)+PRACS(K)+PIACRS(K)+PRACIS(K)+MNUCCR(K))/(-EPRDS(K)+PSACR(K))

       EPRDS(K) = EPRDS(K)*RATIO
       PSACR(K) = PSACR(K)*RATIO

       END IF

       END IF

! CONSERVATION OF QG

      DUM = (-PSACWG(K)-PRACG(K)-PGSACW(K)-PGRACS(K)-PRDG(K)-MNUCCR(K)-EPRDG(K)-PIACR(K)-PRACI(K)-PSACR(K))*DT

      IF (DUM.GT.QG3D(K).AND.QG3D(K).GE.QSMALL) THEN

        RATIO = (QG3D(K)/DT+PSACWG(K)+PRACG(K)+PGSACW(K)+PGRACS(K)+PRDG(K)+MNUCCR(K)+PSACR(K)+&
                  PIACR(K)+PRACI(K))/(-EPRDG(K))

       EPRDG(K) = EPRDG(K)*RATIO

      END IF

! TENDENCIES

      QV3DTEN(K) = QV3DTEN(K)+(-PRE(K)-PRD(K)-PRDS(K)-MNUCCD(K)-EPRD(K)-EPRDS(K)-PRDG(K)-EPRDG(K))

! v3 5/27/11 bug fix
!!!      T3DTEN(K) = T3DTEN(K)+(PRE(K)                                 &
!!!               *XXLV(K)+(PRD(K)+PRDS(K)+                            &
!!!                MNUCCD(K)+EPRD(K)+EPRDS(K)+PRDG(K)+EPRDG(K))*XXLS(K)+         &
!!!               (PSACWS(K)+PSACWI(K)+MNUCCC(K)+MNUCCR(K)+                      &
!!!                QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+PRACS(K) &
!!!                +PSACWG(K)+PRACG(K)+PGSACW(K)+PGRACS(K))*XLF(K))/CPM(K)
      T3DTEN(K) = T3DTEN(K)+(PRE(K)                                 &
               *ecnd(k)+(PRD(K)+PRDS(K)+                            &
                MNUCCD(K)+EPRD(K)+EPRDS(K)+PRDG(K)+EPRDG(K))*edep(k)+         &
               (PSACWS(K)+PSACWI(K)+MNUCCC(K)+MNUCCR(K)+                      &
                QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+PRACS(K) &
                +PSACWG(K)+PRACG(K)+PGSACW(K)+PGRACS(K)+PIACR(K)+PIACRS(K))*efrz(k))

      QC3DTEN(K) = QC3DTEN(K)+                                      &
                 (-PRA(K)-PRC(K)-MNUCCC(K)+PCC(K)-                  &
                  PSACWS(K)-PSACWI(K)-QMULTS(K)-QMULTG(K)-PSACWG(K)-PGSACW(K))
      QI3DTEN(K) = QI3DTEN(K)+                                      &
         (PRD(K)+EPRD(K)+PSACWI(K)+MNUCCC(K)-PRCI(K)-                                 &
                  PRAI(K)+QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+MNUCCD(K)-PRACI(K)-PRACIS(K))
      QR3DTEN(K) = QR3DTEN(K)+                                      &
                 (PRE(K)+PRA(K)+PRC(K)-PRACS(K)-MNUCCR(K)-QMULTR(K)-QMULTRG(K) &
             -PIACR(K)-PIACRS(K)-PRACG(K)-PGRACS(K))

      IF (IGRAUP.EQ.0) THEN

      QNI3DTEN(K) = QNI3DTEN(K)+                                    &
           (PRAI(K)+PSACWS(K)+PRDS(K)+PRACS(K)+PRCI(K)+EPRDS(K)-PSACR(K)+PIACRS(K)+PRACIS(K))
      NS3DTEN(K) = NS3DTEN(K)+(NSAGG(K)+NPRCI(K)-NSCNG(K)-NGRACS(K)+NIACRS(K))
      QG3DTEN(K) = QG3DTEN(K)+(PRACG(K)+PSACWG(K)+PGSACW(K)+PGRACS(K)+ &
                    PRDG(K)+EPRDG(K)+MNUCCR(K)+PIACR(K)+PRACI(K)+PSACR(K))
      NG3DTEN(K) = NG3DTEN(K)+(NSCNG(K)+NGRACS(K)+NNUCCR(K)+NIACR(K))

! FOR NO GRAUPEL, NEED TO INCLUDE FREEZING OF RAIN FOR SNOW
      ELSE IF (IGRAUP.EQ.1) THEN

      QNI3DTEN(K) = QNI3DTEN(K)+                                    &
           (PRAI(K)+PSACWS(K)+PRDS(K)+PRACS(K)+PRCI(K)+EPRDS(K)-PSACR(K)+PIACRS(K)+PRACIS(K)+MNUCCR(K))
      NS3DTEN(K) = NS3DTEN(K)+(NSAGG(K)+NPRCI(K)-NSCNG(K)-NGRACS(K)+NIACRS(K)+NNUCCR(K))

      END IF

      NC3DTEN(K) = NC3DTEN(K)+(-NNUCCC(K)-NPSACWS(K)                &
            -NPRA(K)-NPRC(K)-NPSACWI(K)-NPSACWG(K))

      NI3DTEN(K) = NI3DTEN(K)+                                      &
       (NNUCCC(K)-NPRCI(K)-NPRAI(K)+NMULTS(K)+NMULTG(K)+NMULTR(K)+NMULTRG(K)+ &
               NNUCCD(K)-NIACR(K)-NIACRS(K))

      NR3DTEN(K) = NR3DTEN(K)+(NPRC1(K)-NPRACS(K)-NNUCCR(K)      &
                   +NRAGG(K)-NIACR(K)-NIACRS(K)-NPRACG(K)-NGRACS(K))

! V1.3 move code below to before saturation adjustment
      IF (EPRD(K).LT.0.) THEN
         DUM = EPRD(K)*DT/QI3D(K)
            DUM = MAX(-1.,DUM)
         NSUBI(K) = DUM*NI3D(K)/DT
      END IF
      IF (EPRDS(K).LT.0.) THEN
         DUM = EPRDS(K)*DT/QNI3D(K)
           DUM = MAX(-1.,DUM)
         NSUBS(K) = DUM*NS3D(K)/DT
      END IF
      IF (PRE(K).LT.0.) THEN
         DUM = PRE(K)*DT/QR3D(K)
           DUM = MAX(-1.,DUM)
         NSUBR(K) = DUM*NR3D(K)/DT
      END IF
      IF (EPRDG(K).LT.0.) THEN
         DUM = EPRDG(K)*DT/QG3D(K)
           DUM = MAX(-1.,DUM)
         NSUBG(K) = DUM*NG3D(K)/DT
      END IF

!        nsubr(k)=0.
!        nsubs(k)=0.
!        nsubg(k)=0.

         NI3DTEN(K) = NI3DTEN(K)+NSUBI(K)
         NS3DTEN(K) = NS3DTEN(K)+NSUBS(K)
         NG3DTEN(K) = NG3DTEN(K)+NSUBG(K)
         NR3DTEN(K) = NR3DTEN(K)+NSUBR(K)

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! NOW CALCULATE SATURATION ADJUSTMENT TO CONDENSE EXTRA VAPOR ABOVE
! WATER SATURATION

      DUMT = T3D(K)+DT*T3DTEN(K)
      DUMQV = QV3D(K)+DT*QV3DTEN(K)
      DUMQC = QC3D(K)+DT*QC3DTEN(K)
      DUMQR = QR3D(K)+DT*QR3DTEN(K)
      DUMMQS = QNI3D(K)+DT*QNI3DTEN(K)
      DUMQG = QG3D(K)+DT*QG3DTEN(K)
      DUMQI = QI3D(K)+DT*QI3DTEN(K)
      if(eqtset.eq.2) PRES(K) = RHO(K)*DUMT*(R+RV*DUMQV)
      SAVEQC = DUMQC
      SAVET = DUMT
      call satadj2(DUMT,PRES(K),DUMQV,DUMQC,DUMQR,DUMQI,DUMMQS,DUMQG,RHO(K),eqtset,tsmall)

!!!      DUMQSS = EP_2*POLYSVP(DUMT,0)/ (PRES(K)-POLYSVP(DUMT,0))
!!!      DUMQC = MAX(DUMQC,0.)
!!!
!!!! SATURATION ADJUSTMENT FOR LIQUID
!!!
!!!      DUMS = DUMQV-DUMQSS
!!!      PCC(K) = DUMS/(1.+XXLV(K)**2*DUMQSS/(CPM(K)*RV*DUMT**2))/DT
!!!      IF (PCC(K)*DT+DUMQC.LT.0.) THEN
!!!           PCC(K) = -DUMQC/DT
!!!      END IF
!!!
!!!      QV3DTEN(K) = QV3DTEN(K)-PCC(K)
!!!      T3DTEN(K) = T3DTEN(K)+PCC(K)*XXLV(K)/CPM(K)
!!!      QC3DTEN(K) = QC3DTEN(K)+PCC(K)
      ! GHB2

      IF( abs(DUMT-SAVET).ge.0.0001 )THEN
        PCC(K) = (DUMQC-SAVEQC)*RDT
        QV3DTEN(K) = QV3DTEN(K)-PCC(K)
        QC3DTEN(K) = QC3DTEN(K)+PCC(K)
        T3DTEN(K) = T3DTEN(K)+(DUMT-SAVET)*RDT
      ENDIF

!.......................................................................
! ACTIVATION OF CLOUD DROPLETS

    ! GHB, 120124:
    IF(INUM.EQ.0)THEN
      IF (QC3D(K)+QC3DTEN(K)*DT.GE.QSMALL) THEN

! EFFECTIVE VERTICAL VELOCITY (M/S)

      IF (ISUB.EQ.0) THEN
! ADD SUB-GRID VERTICAL VELOCITY
         DUM = W3D(K)+WVAR(K)

! ASSUME MINIMUM EFF. SUB-GRID VELOCITY 0.10 M/S
         DUM = MAX(DUM,0.10)

      ELSE IF (ISUB.EQ.1) THEN
         DUM=W3D(K)
      END IF

! ONLY ACTIVATE IN REGIONS OF UPWARD MOTION
      IF (DUM.GE.0.001) THEN

      IF (IBASE.EQ.1) THEN

! ACTIVATE ONLY IF THERE IS LITTLE CLOUD WATER
! OR IF AT CLOUD BASE, OR AT LOWEST MODEL LEVEL (K=1)

         IDROP=0

! V1.3 USE CURRENT VALUE OF QC FOR IDROP
         IF (QC3D(K).LE.0.05E-3/RHO(K)) THEN
            IDROP=1
         END IF
         IF (K.EQ.1) THEN
            IDROP=1
         ELSE IF (K.GE.2) THEN
            IF (QC3D(K).GT.0.05E-3/RHO(K).AND. &
             QC3D(K-1).LE.0.05E-3/RHO(K-1)) THEN
            IDROP=1
            END IF
         END IF

         IF (IDROP.EQ.1) THEN
! ACTIVATE AT CLOUD BASE OR REGIONS WITH VERY LITTLE LIQ WATER

           IF (IACT.EQ.1) THEN
! USE ROGERS AND YAU (1989) TO RELATE NUMBER ACTIVATED TO W
! BASED ON TWOMEY 1959

            DUM=DUM*100.  ! CONVERT FROM M/S TO CM/S
            DUM2 = 0.88*C1**(2./(K1+2.))*(7.E-2*DUM**1.5)**(K1/(K1+2.))
            DUM2=DUM2*1.E6 ! CONVERT FROM CM-3 TO M-3
            DUM2=DUM2/RHO(K)  ! CONVERT FROM M-3 TO KG-1
            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           ELSE IF (IACT.EQ.2) THEN
! DROPLET ACTIVATION FROM ABDUL-RAZZAK AND GHAN (2000)

           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)
           ALPHA = G*MW*XXLV(K)/(CPM(K)*RR*T3D(K)**2)-G*MA/(RR*T3D(K))
           GAMM = RR*T3D(K)/(EVS(K)*MW)+MW*XXLV(K)**2/(CPM(K)*PRES(K)*MA*T3D(K))

           GG = 1./(RHOW*RR*T3D(K)/(EVS(K)*DV(K)*MW)+ XXLV(K)*RHOW/(KAP(K)*T3D(K))*(XXLV(K)*MW/ &
              (T3D(K)*RR)-1.))

           PSI = 2./3.*(ALPHA*DUM/GG)**0.5*AACT

           ETA1 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW1)
           ETA2 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW2)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

           DUM1 = 1./SM1**2*(F11*(PSI/ETA1)**1.5+F21*(SM1**2/(ETA1+3.*PSI))**0.75)
           DUM2 = 1./SM2**2*(F12*(PSI/ETA2)**1.5+F22*(SM2**2/(ETA2+3.*PSI))**0.75)

           SMAX = 1./(DUM1+DUM2)**0.5

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

            DUM2 = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2
           END IF  ! IACT

!.............................................................................
        ELSE IF (IDROP.EQ.0) THEN
! ACTIVATE IN CLOUD INTERIOR
! FIND EQUILIBRIUM SUPERSATURATION

           TAUC=1./(2.*PI*RHO(k)*DV(K)*NC3D(K)*(PGAM(K)+1.)/LAMC(K))
           IF (EPSR.GT.1.E-8) THEN
             TAUR=1./EPSR
           ELSE
             TAUR=1.E8
           END IF
           IF (EPSI.GT.1.E-8) THEN
             TAUI=1./EPSI
           ELSE
             TAUI=1.E8
           END IF
           IF (EPSS.GT.1.E-8) THEN
             TAUS=1./EPSS
           ELSE
             TAUS=1.E8
           END IF
           IF (EPSG.GT.1.E-8) THEN
             TAUG=1./EPSG
           ELSE
             TAUG=1.E8
           END IF

! EQUILIBRIUM SS INCLUDING BERGERON EFFECT

! hm fix 1/20/15
!           DUM3=(QVS(K)*RHO(K)/(PRES(K)-EVS(K))+DQSDT/CP)*G*DUM
           DUM3=(-QVS(K)*RHO(K)/(PRES(K)-EVS(K))+DQSDT/CP)*G*DUM
           DUM3=(DUM3*TAUC*TAUR*TAUI*TAUS*TAUG- &
           (QVS(K)-QVI(K))*(TAUC*TAUR*TAUI*TAUG+TAUC*TAUR*TAUS*TAUG+TAUC*TAUR*TAUI*TAUS))/ &
           (TAUC*TAUR*TAUI*TAUG+TAUC*TAUR*TAUS*TAUG+TAUC*TAUR*TAUI*TAUS+ &
            TAUR*TAUI*TAUS*TAUG+TAUC*TAUI*TAUS*TAUG)

           IF (DUM3/QVS(K).GE.1.E-6) THEN
           IF (IACT.EQ.1) THEN

! FIND MAXIMUM ALLOWED ACTIVATION WITH NON-EQULIBRIUM SS

            DUM=DUM*100.  ! CONVERT FROM M/S TO CM/S
            DUMACT = 0.88*C1**(2./(K1+2.))*(7.E-2*DUM**1.5)**(K1/(K1+2.))

! USE POWER LAW CCN SPECTRA

! CONVERT FROM ABSOLUTE SUPERSATURATION TO SUPERSATURATION RATIO IN %
            DUM3=DUM3/QVS(K)*100.

            DUM2=C1*DUM3**K1
! MAKE SURE VALUE DOESN'T EXCEED THAT FOR NON-EQUILIBRIUM SS
            DUM2=MIN(DUM2,DUMACT)
            DUM2=DUM2*1.E6 ! CONVERT FROM CM-3 TO M-3
            DUM2=DUM2/RHO(K)  ! CONVERT FROM M-3 TO KG-1
            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           ELSE IF (IACT.EQ.2) THEN

! FIND MAXIMUM ALLOWED ACTIVATION WITH NON-EQULIBRIUM SS

           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)
           ALPHA = G*MW*XXLV(K)/(CPM(K)*RR*T3D(K)**2)-G*MA/(RR*T3D(K))
           GAMM = RR*T3D(K)/(EVS(K)*MW)+MW*XXLV(K)**2/(CPM(K)*PRES(K)*MA*T3D(K))

           GG = 1./(RHOW*RR*T3D(K)/(EVS(K)*DV(K)*MW)+ XXLV(K)*RHOW/(KAP(K)*T3D(K))*(XXLV(K)*MW/ &
              (T3D(K)*RR)-1.))

           PSI = 2./3.*(ALPHA*DUM/GG)**0.5*AACT

           ETA1 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW1)
           ETA2 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW2)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

           DUM1 = 1./SM1**2*(F11*(PSI/ETA1)**1.5+F21*(SM1**2/(ETA1+3.*PSI))**0.75)
           DUM2 = 1./SM2**2*(F12*(PSI/ETA2)**1.5+F22*(SM2**2/(ETA2+3.*PSI))**0.75)

           SMAX = 1./(DUM1+DUM2)**0.5

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

           DUMACT = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

! USE LOGNORMAL AEROSOL
           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

! GET SUPERSATURATION RATIO FROM ABSOLUTE SUPERSATURATION
           SMAX = DUM3/QVS(K)

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

            DUM2 = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

! MAKE SURE ISN'T GREATER THAN NON-EQUIL. SS
            DUM2=MIN(DUM2,DUMACT)

            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           END IF ! IACT
           END IF ! DUM3/QVS > 1.E-6
        END IF  ! IDROP = 1

!.......................................................................
      ELSE IF (IBASE.EQ.2) THEN

           IF (IACT.EQ.1) THEN
! USE ROGERS AND YAU (1989) TO RELATE NUMBER ACTIVATED TO W
! BASED ON TWOMEY 1959

            DUM=DUM*100.  ! CONVERT FROM M/S TO CM/S
            DUM2 = 0.88*C1**(2./(K1+2.))*(7.E-2*DUM**1.5)**(K1/(K1+2.))
            DUM2=DUM2*1.E6 ! CONVERT FROM CM-3 TO M-3
            DUM2=DUM2/RHO(K)  ! CONVERT FROM M-3 TO KG-1
            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2

           ELSE IF (IACT.EQ.2) THEN

           SIGVL = 0.0761-1.55E-4*(T3D(K)-TMELT)
           AACT = 2.*MW/(RHOW*RR)*SIGVL/T3D(K)
           ALPHA = G*MW*XXLV(K)/(CPM(K)*RR*T3D(K)**2)-G*MA/(RR*T3D(K))
           GAMM = RR*T3D(K)/(EVS(K)*MW)+MW*XXLV(K)**2/(CPM(K)*PRES(K)*MA*T3D(K))

           GG = 1./(RHOW*RR*T3D(K)/(EVS(K)*DV(K)*MW)+ XXLV(K)*RHOW/(KAP(K)*T3D(K))*(XXLV(K)*MW/ &
              (T3D(K)*RR)-1.))

           PSI = 2./3.*(ALPHA*DUM/GG)**0.5*AACT

           ETA1 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW1)
           ETA2 = (ALPHA*DUM/GG)**1.5/(2.*PI*RHOW*GAMM*NANEW2)

           SM1 = 2./BACT**0.5*(AACT/(3.*RM1))**1.5
           SM2 = 2./BACT**0.5*(AACT/(3.*RM2))**1.5

           DUM1 = 1./SM1**2*(F11*(PSI/ETA1)**1.5+F21*(SM1**2/(ETA1+3.*PSI))**0.75)
           DUM2 = 1./SM2**2*(F12*(PSI/ETA2)**1.5+F22*(SM2**2/(ETA2+3.*PSI))**0.75)

           SMAX = 1./(DUM1+DUM2)**0.5

           UU1 = 2.*LOG(SM1/SMAX)/(4.242*LOG(SIG1))
           UU2 = 2.*LOG(SM2/SMAX)/(4.242*LOG(SIG2))
           DUM1 = NANEW1/2.*(1.-DERF1(UU1))
           DUM2 = NANEW2/2.*(1.-DERF1(UU2))

           DUM2 = (DUM1+DUM2)/RHO(K)  !CONVERT TO KG-1

! MAKE SURE THIS VALUE ISN'T GREATER THAN TOTAL NUMBER OF AEROSOL

            DUM2 = MIN((NANEW1+NANEW2)/RHO(K),DUM2)

            DUM2 = (DUM2-NC3D(K))/DT
            DUM2 = MAX(0.,DUM2)
            NC3DTEN(K) = NC3DTEN(K)+DUM2
           END IF  ! IACT
        END IF  ! IBASE
        END IF  ! W > 0.001
        END IF  ! QC3D > QSMALL
    ! GHB, 120124:
    ENDIF       ! INUM=0

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! SUBLIMATE, MELT, OR EVAPORATE NUMBER CONCENTRATION
! THIS FORMULATION ASSUMES 1:1 RATIO BETWEEN MASS LOSS AND
! LOSS OF NUMBER CONCENTRATION

!     IF (PCC(K).LT.0.) THEN
!        DUM = PCC(K)*DT/QC3D(K)
!           DUM = MAX(-1.,DUM)
!        NSUBC(K) = DUM*NC3D(K)/DT
!     END IF

! UPDATE TENDENCIES

!        NC3DTEN(K) = NC3DTEN(K)+NSUBC(K)

         END IF !!!!!! TEMPERATURE

! SWITCH LTRUE TO 1, SINCE HYDROMETEORS ARE PRESENT
         LTRUE = 1

 200     CONTINUE

        END DO

! V1.3 move precip initialization to here
! INITIALIZE PRECIP AND SNOW RATES

      PRECRT = 0.
      SNOWRT = 0.

! IF THERE ARE NO HYDROMETEORS, THEN SKIP TO END OF SUBROUTINE

        IF (LTRUE.EQ.0) GOTO 400

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!.......................................................................
! CALCULATE SEDIMENATION
! THE NUMERICS HERE FOLLOW FROM REISNER ET AL. (1998)
! FALLOUT TERMS ARE CALCULATED ON SPLIT TIME STEPS TO ENSURE NUMERICAL
! STABILITY, I.E. COURANT# < 1

!.......................................................................

      NSTEPR=1
      NSTEPI=1
      NSTEPS=1
      NSTEPC=1
      NSTEPG=1

      DO K = KTS,KTE
        temz(k) = 1.0/DZQ(K)
      ENDDO

! v3 5/27/11
      DO K = KTE,KTS,-1

        DUMI(K) = QI3D(K)+QI3DTEN(K)*DT
        DUMQS(K) = QNI3D(K)+QNI3DTEN(K)*DT
        DUMR(K) = QR3D(K)+QR3DTEN(K)*DT
        DUMFNI(K) = NI3D(K)+NI3DTEN(K)*DT
        DUMFNS(K) = NS3D(K)+NS3DTEN(K)*DT
        DUMFNR(K) = NR3D(K)+NR3DTEN(K)*DT
        DUMC(K) = QC3D(K)+QC3DTEN(K)*DT
        DUMFNC(K) = NC3D(K)+NC3DTEN(K)*DT
	DUMG(K) = QG3D(K)+QG3DTEN(K)*DT
	DUMFNG(K) = NG3D(K)+NG3DTEN(K)*DT

! SWITCH FOR CONSTANT DROPLET NUMBER
        IF (INUM.EQ.1) THEN
        DUMFNC(K) = NC3D(K)
        END IF

! GET DUMMY LAMDA

! MAKE SURE NUMBER CONCENTRATIONS ARE POSITIVE
      DUMFNI(K) = MAX(0.,DUMFNI(K))
      DUMFNS(K) = MAX(0.,DUMFNS(K))
      DUMFNC(K) = MAX(0.,DUMFNC(K))
      DUMFNR(K) = MAX(0.,DUMFNR(K))
      DUMFNG(K) = MAX(0.,DUMFNG(K))

!......................................................................
! CLOUD ICE

      IF (DUMI(K).GE.QSMALL) THEN
        DLAMI = (CONS12*DUMFNI(K)/DUMI(K))**(1./DI)
        DLAMI=MAX(DLAMI,LAMMINI)
        DLAMI=MIN(DLAMI,LAMMAXI)
      END IF
!......................................................................
! RAIN

      IF (DUMR(K).GE.QSMALL) THEN
        DLAMR = (PI*RHOW*DUMFNR(K)/DUMR(K))**(1./3.)
        DLAMR=MAX(DLAMR,LAMMINR)
        DLAMR=MIN(DLAMR,LAMMAXR)
      END IF
!......................................................................
! CLOUD DROPLETS

      IF (DUMC(K).GE.QSMALL) THEN
!         DUM = PRES(K)/(R*T3D(K))
! V1.5
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*RHO(K))+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

        DLAMC = (CONS26*DUMFNC(K)*GAMMA(PGAM(K)+4.)/(DUMC(K)*GAMMA(PGAM(K)+1.)))**(1./3.)
        LAMMIN = (PGAM(K)+1.)/60.E-6
        LAMMAX = (PGAM(K)+1.)/1.E-6
        DLAMC=MAX(DLAMC,LAMMIN)
        DLAMC=MIN(DLAMC,LAMMAX)
      END IF
!......................................................................
! SNOW

      IF (DUMQS(K).GE.QSMALL) THEN
        DLAMS = (CONS1*DUMFNS(K)/ DUMQS(K))**(1./DS)
        DLAMS=MAX(DLAMS,LAMMINS)
        DLAMS=MIN(DLAMS,LAMMAXS)
      END IF
!......................................................................
! GRAUPEL

      IF (DUMG(K).GE.QSMALL) THEN
        DLAMG = (CONS2*DUMFNG(K)/ DUMG(K))**(1./DG)
        DLAMG=MAX(DLAMG,LAMMING)
        DLAMG=MIN(DLAMG,LAMMAXG)
      END IF

!......................................................................
! CALCULATE NUMBER-WEIGHTED AND MASS-WEIGHTED TERMINAL FALL SPEEDS

! CLOUD WATER

      IF (DUMC(K).GE.QSMALL) THEN
      UNC =  ACN(K)*GAMMA(1.+BC+PGAM(K))/ (DLAMC**BC*GAMMA(PGAM(K)+1.))
      UMC = ACN(K)*GAMMA(4.+BC+PGAM(K))/  (DLAMC**BC*GAMMA(PGAM(K)+4.))
      ELSE
      UMC = 0.
      UNC = 0.
      END IF

      IF (DUMI(K).GE.QSMALL) THEN
      UNI =  AIN(K)*CONS27/DLAMI**BI
      UMI = AIN(K)*CONS28/(DLAMI**BI)
      ELSE
      UMI = 0.
      UNI = 0.
      END IF

      IF (DUMR(K).GE.QSMALL) THEN
      UNR = ARN(K)*CONS6/DLAMR**BR
      UMR = ARN(K)*CONS4/(DLAMR**BR)
      ELSE
      UMR = 0.
      UNR = 0.
      END IF

      IF (DUMQS(K).GE.QSMALL) THEN
      UMS = ASN(K)*CONS3/(DLAMS**BS)
      UNS = ASN(K)*CONS5/DLAMS**BS
      ELSE
      UMS = 0.
      UNS = 0.
      END IF

      IF (DUMG(K).GE.QSMALL) THEN
      UMG = AGN(K)*CONS7/(DLAMG**BG)
      UNG = AGN(K)*CONS8/DLAMG**BG
      ELSE
      UMG = 0.
      UNG = 0.
      END IF

! SET REALISTIC LIMITS ON FALLSPEED

! bug fix, 10/08/09
        dum=(rhosu/rho(k))**0.54
        UMS=MIN(UMS,1.2*dum)
        UNS=MIN(UNS,1.2*dum)
! v3 5/27/11
! fix for correction by AA 4/6/11
        UMI=MIN(UMI,1.2*(rhosu/rho(k))**0.35)
        UNI=MIN(UNI,1.2*(rhosu/rho(k))**0.35)
        UMR=MIN(UMR,9.1*dum)
        UNR=MIN(UNR,9.1*dum)
        UMG=MIN(UMG,20.*dum)
        UNG=MIN(UNG,20.*dum)

      FR(K) = UMR
      FI(K) = UMI
      FNI(K) = UNI
      FS(K) = UMS
      FNS(K) = UNS
      FNR(K) = UNR
      FC(K) = UMC
      FNC(K) = UNC
      FG(K) = UMG
      FNG(K) = UNG

! v3 5/27/11 MODIFY FALLSPEED BELOW LEVEL OF PRECIP

	IF (K.LE.KTE-1) THEN
        IF (FR(K).LT.1.E-10) THEN
	FR(K)=FR(K+1)
	END IF
        IF (FI(K).LT.1.E-10) THEN
	FI(K)=FI(K+1)
	END IF
        IF (FNI(K).LT.1.E-10) THEN
	FNI(K)=FNI(K+1)
	END IF
        IF (FS(K).LT.1.E-10) THEN
	FS(K)=FS(K+1)
	END IF
        IF (FNS(K).LT.1.E-10) THEN
	FNS(K)=FNS(K+1)
	END IF
        IF (FNR(K).LT.1.E-10) THEN
	FNR(K)=FNR(K+1)
	END IF
        IF (FC(K).LT.1.E-10) THEN
	FC(K)=FC(K+1)
	END IF
        IF (FNC(K).LT.1.E-10) THEN
	FNC(K)=FNC(K+1)
	END IF
        IF (FG(K).LT.1.E-10) THEN
	FG(K)=FG(K+1)
	END IF
        IF (FNG(K).LT.1.E-10) THEN
	FNG(K)=FNG(K+1)
	END IF
	END IF ! K LE KTE-1

      RGVM = MAX(FR(K),FNR(K))
! VVT CHANGED IFIX -> INT (GENERIC FUNCTION)
      NSTEPR = MAX(INT(RGVM*DT*temz(K)+1.),NSTEPR)

      RGVM = MAX(FI(K),FNI(K))
! VVT CHANGED IFIX -> INT (GENERIC FUNCTION)
      NSTEPI = MAX(INT(RGVM*DT*temz(K)+1.),NSTEPI)

      RGVM = MAX(FS(K),FNS(K))
! VVT CHANGED IFIX -> INT (GENERIC FUNCTION)
      NSTEPS = MAX(INT(RGVM*DT*temz(K)+1.),NSTEPS)

      RGVM = MAX(FC(K),FNC(K))
! VVT CHANGED IFIX -> INT (GENERIC FUNCTION)
      NSTEPC = MAX(INT(RGVM*DT*temz(K)+1.),NSTEPC)

      RGVM = MAX(FG(K),FNG(K))
! VVT CHANGED IFIX -> INT (GENERIC FUNCTION)
      NSTEPG = MAX(INT(RGVM*DT*temz(K)+1.),NSTEPG)

! MULTIPLY VARIABLES BY RHO
      DUMR(k) = DUMR(k)*RHO(K)
      DUMI(k) = DUMI(k)*RHO(K)
      DUMFNI(k) = DUMFNI(K)*RHO(K)
      DUMQS(k) = DUMQS(K)*RHO(K)
      DUMFNS(k) = DUMFNS(K)*RHO(K)
      DUMFNR(k) = DUMFNR(K)*RHO(K)
      DUMC(k) = DUMC(K)*RHO(K)
      DUMFNC(k) = DUMFNC(K)*RHO(K)
      DUMG(k) = DUMG(K)*RHO(K)
      DUMFNG(k) = DUMFNG(K)*RHO(K)

      END DO

! V1.3, change so that sub-stepping is done
! individually for each species

! RAIN

      dttmp = DT/NSTEPR
      DO K = KTS,KTE
        temr(k) = 1.0/(NSTEPR*RHO(k))
      ENDDO

      DO N = 1,NSTEPR

      DO K = KTS,KTE
      FALOUTR(K) = FR(K)*DUMR(K)
      FALOUTNR(K) = FNR(K)*DUMFNR(K)
      END DO
! TOP OF MODEL
      K = KTE
      FALTNDR = FALOUTR(K)*temz(k)
      FALTNDNR = FALOUTNR(K)*temz(k)
! ADD FALLOUT TERMS TO EULERIAN TENDENCIES
      QRSTEN(K) = QRSTEN(K)-FALTNDR*temr(k)
      NR3DTEN(K) = NR3DTEN(K)-FALTNDNR*temr(k)
      DUMR(K) = DUMR(K)-FALTNDR*dttmp
      DUMFNR(K) = DUMFNR(K)-FALTNDNR*dttmp
      DO K = KTE-1,KTS,-1
      FALTNDR = (FALOUTR(K+1)-FALOUTR(K))*temz(K)
      FALTNDNR = (FALOUTNR(K+1)-FALOUTNR(K))*temz(K)
      QRSTEN(K) = QRSTEN(K)+FALTNDR*temr(k)
      NR3DTEN(K) = NR3DTEN(K)+FALTNDNR*temr(k)
      DUMR(K) = DUMR(K)+FALTNDR*dttmp
      DUMFNR(K) = DUMFNR(K)+FALTNDNR*dttmp
      END DO
      PRECRT = PRECRT+(FALOUTR(KTS))  &
                     *dttmp
      END DO

! CLOUD ICE

      dttmp = DT/NSTEPI
      DO K = KTS,KTE
        temr(k) = 1.0/(NSTEPI*RHO(k))
      ENDDO

      DO N = 1,NSTEPI

      DO K = KTS,KTE
      FALOUTI(K) = FI(K)*DUMI(K)
      FALOUTNI(K) = FNI(K)*DUMFNI(K)
      END DO
! TOP OF MODEL
      K = KTE
      FALTNDI = FALOUTI(K)*temz(k)
      FALTNDNI = FALOUTNI(K)*temz(k)
! ADD FALLOUT TERMS TO EULERIAN TENDENCIES
      QISTEN(K) = QISTEN(K)-FALTNDI*temr(k)
      NI3DTEN(K) = NI3DTEN(K)-FALTNDNI*temr(k)
      DUMI(K) = DUMI(K)-FALTNDI*dttmp
      DUMFNI(K) = DUMFNI(K)-FALTNDNI*dttmp
      DO K = KTE-1,KTS,-1
      FALTNDI = (FALOUTI(K+1)-FALOUTI(K))*temz(K)
      FALTNDNI = (FALOUTNI(K+1)-FALOUTNI(K))*temz(K)
      QISTEN(K) = QISTEN(K)+FALTNDI*temr(k)
      NI3DTEN(K) = NI3DTEN(K)+FALTNDNI*temr(k)
      DUMI(K) = DUMI(K)+FALTNDI*dttmp
      DUMFNI(K) = DUMFNI(K)+FALTNDNI*dttmp
      END DO
      PRECRT = PRECRT+(FALOUTI(KTS))  &
                     *dttmp
      SNOWRT = SNOWRT+(FALOUTI(KTS))*dttmp
      END DO

! CLOUD DROPLETS

      dttmp = DT/NSTEPC
      DO K = KTS,KTE
        temr(k) = 1.0/(NSTEPC*RHO(k))
      ENDDO

      DO N = 1,NSTEPC

      DO K = KTS,KTE
      FALOUTC(K) = FC(K)*DUMC(K)
      FALOUTNC(K) = FNC(K)*DUMFNC(K)
      END DO
! TOP OF MODEL
      K = KTE
      FALTNDC = FALOUTC(K)*temz(k)
      FALTNDNC = FALOUTNC(K)*temz(k)
! ADD FALLOUT TERMS TO EULERIAN TENDENCIES
      QCSTEN(K) = QCSTEN(K)-FALTNDC*temr(k)
      NC3DTEN(K) = NC3DTEN(K)-FALTNDNC*temr(k)
      DUMC(K) = DUMC(K)-FALTNDC*dttmp
      DUMFNC(K) = DUMFNC(K)-FALTNDNC*dttmp
      DO K = KTE-1,KTS,-1
      FALTNDC = (FALOUTC(K+1)-FALOUTC(K))*temz(K)
      FALTNDNC = (FALOUTNC(K+1)-FALOUTNC(K))*temz(K)
      QCSTEN(K) = QCSTEN(K)+FALTNDC*temr(k)
      NC3DTEN(K) = NC3DTEN(K)+FALTNDNC*temr(k)
      DUMC(K) = DUMC(K)+FALTNDC*dttmp
      DUMFNC(K) = DUMFNC(K)+FALTNDNC*dttmp
      END DO
      PRECRT = PRECRT+(FALOUTC(KTS))  &
                     *dttmp
      END DO

! SNOW

      dttmp = DT/NSTEPS
      DO K = KTS,KTE
        temr(k) = 1.0/(NSTEPS*RHO(k))
      ENDDO

      DO N = 1,NSTEPS

      DO K = KTS,KTE
      FALOUTS(K) = FS(K)*DUMQS(K)
      FALOUTNS(K) = FNS(K)*DUMFNS(K)
      END DO
! TOP OF MODEL
      K = KTE
      FALTNDS = FALOUTS(K)*temz(k)
      FALTNDNS = FALOUTNS(K)*temz(k)
! ADD FALLOUT TERMS TO EULERIAN TENDENCIES
      QNISTEN(K) = QNISTEN(K)-FALTNDS*temr(k)
      NS3DTEN(K) = NS3DTEN(K)-FALTNDNS*temr(k)
      DUMQS(K) = DUMQS(K)-FALTNDS*dttmp
      DUMFNS(K) = DUMFNS(K)-FALTNDNS*dttmp
      DO K = KTE-1,KTS,-1
      FALTNDS = (FALOUTS(K+1)-FALOUTS(K))*temz(K)
      FALTNDNS = (FALOUTNS(K+1)-FALOUTNS(K))*temz(K)
      QNISTEN(K) = QNISTEN(K)+FALTNDS*temr(k)
      NS3DTEN(K) = NS3DTEN(K)+FALTNDNS*temr(k)
      DUMQS(K) = DUMQS(K)+FALTNDS*dttmp
      DUMFNS(K) = DUMFNS(K)+FALTNDNS*dttmp
      END DO
      PRECRT = PRECRT+(FALOUTS(KTS))  &
                     *dttmp
      SNOWRT = SNOWRT+(FALOUTS(KTS))*dttmp
      END DO

! GRAUPEL

      dttmp = DT/NSTEPG
      DO K = KTS,KTE
        temr(k) = 1.0/(NSTEPG*RHO(k))
      ENDDO

      DO N = 1,NSTEPG

      DO K = KTS,KTE
      FALOUTG(K) = FG(K)*DUMG(K)
      FALOUTNG(K) = FNG(K)*DUMFNG(K)
      END DO
! TOP OF MODEL
      K = KTE
      FALTNDG = FALOUTG(K)*temz(k)
      FALTNDNG = FALOUTNG(K)*temz(k)
! ADD FALLOUT TERMS TO EULERIAN TENDENCIES
      QGSTEN(K) = QGSTEN(K)-FALTNDG*temr(k)
      NG3DTEN(K) = NG3DTEN(K)-FALTNDNG*temr(k)
      DUMG(K) = DUMG(K)-FALTNDG*dttmp
      DUMFNG(K) = DUMFNG(K)-FALTNDNG*dttmp
      DO K = KTE-1,KTS,-1
      FALTNDG = (FALOUTG(K+1)-FALOUTG(K))*temz(K)
      FALTNDNG = (FALOUTNG(K+1)-FALOUTNG(K))*temz(K)
      QGSTEN(K) = QGSTEN(K)+FALTNDG*temr(k)
      NG3DTEN(K) = NG3DTEN(K)+FALTNDNG*temr(k)
      DUMG(K) = DUMG(K)+FALTNDG*dttmp
      DUMFNG(K) = DUMFNG(K)+FALTNDNG*dttmp
      END DO
      PRECRT = PRECRT+(FALOUTG(KTS))  &
                     *dttmp
      SNOWRT = SNOWRT+(FALOUTG(KTS))*dttmp
      END DO

      DO K=KTS,KTE

! ADD ON SEDIMENTATION TENDENCIES FOR MIXING RATIO TO REST OF TENDENCIES

        QR3DTEN(K)=QR3DTEN(K)+QRSTEN(K)
        QI3DTEN(K)=QI3DTEN(K)+QISTEN(K)
        QC3DTEN(K)=QC3DTEN(K)+QCSTEN(K)
        QG3DTEN(K)=QG3DTEN(K)+QGSTEN(K)
        QNI3DTEN(K)=QNI3DTEN(K)+QNISTEN(K)

! PUT ALL CLOUD ICE IN SNOW CATEGORY IF MEAN DIAMETER EXCEEDS 2 * dcs

! V1.7
!hm 7/9/09 bug fix
!        IF (QI3D(K).GE.QSMALL.AND.T3D(K).LT.273.15) THEN
        IF (QI3D(K).GE.QSMALL.AND.T3D(K).LT.TMELT.AND.LAMI(K).GE.1.E-10) THEN

        IF (1./LAMI(K).GE.2.*DCS) THEN
           QNI3DTEN(K) = QNI3DTEN(K)+QI3D(K)/DT+ QI3DTEN(K)
           NS3DTEN(K) = NS3DTEN(K)+NI3D(K)/DT+   NI3DTEN(K)
           QI3DTEN(K) = -QI3D(K)/DT
           NI3DTEN(K) = -NI3D(K)/DT
        END IF
        END IF

! hm add tendencies here, then call sizeparameter
! to ensure consisitency between mixing ratio and number concentration

          QC3D(k)        = QC3D(k)+QC3DTEN(k)*DT
          QI3D(k)        = QI3D(k)+QI3DTEN(k)*DT
          QNI3D(k)        = QNI3D(k)+QNI3DTEN(k)*DT
          QR3D(k)        = QR3D(k)+QR3DTEN(k)*DT
          NC3D(k)        = NC3D(k)+NC3DTEN(k)*DT
          NI3D(k)        = NI3D(k)+NI3DTEN(k)*DT
          NS3D(k)        = NS3D(k)+NS3DTEN(k)*DT
          NR3D(k)        = NR3D(k)+NR3DTEN(k)*DT

          IF (IGRAUP.EQ.0) THEN
          QG3D(k)        = QG3D(k)+QG3DTEN(k)*DT
          NG3D(k)        = NG3D(k)+NG3DTEN(k)*DT
          END IF

! ADD TEMPERATURE AND WATER VAPOR TENDENCIES FROM MICROPHYSICS
          T3D(K)         = T3D(K)+T3DTEN(k)*DT
          QV3D(K)        = QV3D(K)+QV3DTEN(k)*DT
          if(eqtset.eq.2) PRES(K) = RHO(K)*T3D(K)*(R+RV*QV3D(K))

! SATURATION VAPOR PRESSURE AND MIXING RATIO

!!!            EVS(K) = POLYSVP(T3D(K),0)   ! PA
!!!            EIS(K) = POLYSVP(T3D(K),1)   ! PA
            EVS(K) = 611.2 * EXP( 17.67 * ( T3D(K) - 273.15 ) / ( T3D(K) - 29.65 ) )
            EIS(K) = 611.2 * EXP( 21.8745584 * ( T3D(K) - 273.15 ) / ( T3D(K) - 7.66 ) )

! MAKE SURE ICE SATURATION DOESN'T EXCEED WATER SAT. NEAR FREEZING

            IF (EIS(K).GT.EVS(K)) EIS(K) = EVS(K)

            QVS(K) = EP_2*EVS(K)/(PRES(K)-EVS(K))
            QVI(K) = EP_2*EIS(K)/(PRES(K)-EIS(K))

            QVQVS(K) = QV3D(K)/QVS(K)
            QVQVSI(K) = QV3D(K)/QVI(K)

! AT SUBSATURATION, REMOVE SMALL AMOUNTS OF CLOUD/PRECIP WATER

! V1.3, change limit from 10^-7 to 10^-6
! V1.7 7/9/09 change limit from 10^-6 to 10^-8

             IF (QVQVS(K).LT.0.9) THEN
               IF (QR3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QR3D(K)
!!!                  T3D(K)=T3D(K)-QR3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QR3D(K)*ecnd(k)
                  QR3D(K)=0.
               END IF
               IF (QC3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QC3D(K)
!!!                  T3D(K)=T3D(K)-QC3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QC3D(K)*ecnd(k)
                  QC3D(K)=0.
               END IF
             END IF

             IF (QVQVSI(K).LT.0.9) THEN
               IF (QI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QI3D(K)
!!!                  T3D(K)=T3D(K)-QI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QI3D(K)*edep(k)
                  QI3D(K)=0.
               END IF
               IF (QNI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QNI3D(K)
!!!                  T3D(K)=T3D(K)-QNI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QNI3D(K)*edep(k)
                  QNI3D(K)=0.
               END IF
               IF (QG3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QG3D(K)
!!!                  T3D(K)=T3D(K)-QG3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QG3D(K)*edep(k)
                  QG3D(K)=0.
               END IF
             END IF

!..................................................................
! IF MIXING RATIO < QSMALL SET MIXING RATIO AND NUMBER CONC TO ZERO

       IF (QC3D(K).LT.QSMALL) THEN
         QC3D(K) = 0.
         NC3D(K) = 0.
       END IF
       IF (QR3D(K).LT.QSMALL) THEN
         QR3D(K) = 0.
         NR3D(K) = 0.
       END IF
       IF (QI3D(K).LT.QSMALL) THEN
         QI3D(K) = 0.
         NI3D(K) = 0.
       END IF
       IF (QNI3D(K).LT.QSMALL) THEN
         QNI3D(K) = 0.
         NS3D(K) = 0.
       END IF
       IF (QG3D(K).LT.QSMALL) THEN
         QG3D(K) = 0.
         NG3D(K) = 0.
       END IF

!..................................
! IF THERE IS NO CLOUD/PRECIP WATER, THEN SKIP CALCULATIONS

            IF (QC3D(K).LT.QSMALL.AND.QI3D(K).LT.QSMALL.AND.QNI3D(K).LT.QSMALL &
                 .AND.QR3D(K).LT.QSMALL.AND.QG3D(K).LT.QSMALL) GOTO 500

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATE INSTANTANEOUS PROCESSES

! ADD MELTING OF CLOUD ICE TO FORM RAIN

        IF (QI3D(K).GE.QSMALL.AND.T3D(K).GE.TMELT) THEN
           QR3D(K) = QR3D(K)+QI3D(K)
!!!           T3D(K) = T3D(K)-QI3D(K)*XLF(K)/CPM(K)
           T3D(K) = T3D(K)-QI3D(K)*efrz(k)
           QI3D(K) = 0.
           NR3D(K) = NR3D(K)+NI3D(K)
           NI3D(K) = 0.
        END IF

! ****SENSITIVITY - NO ICE
        IF (ILIQ.EQ.1) GOTO 778

! HOMOGENEOUS FREEZING OF CLOUD WATER

        IF (T3D(K).LE.233.15.AND.QC3D(K).GE.QSMALL) THEN
           QI3D(K)=QI3D(K)+QC3D(K)
!!!           T3D(K)=T3D(K)+QC3D(K)*XLF(K)/CPM(K)
           T3D(K)=T3D(K)+QC3D(K)*efrz(k)
           QC3D(K)=0.
           NI3D(K)=NI3D(K)+NC3D(K)
           NC3D(K)=0.
        END IF

! HOMOGENEOUS FREEZING OF RAIN

        IF (IGRAUP.EQ.0) THEN

        IF (T3D(K).LE.233.15.AND.QR3D(K).GE.QSMALL) THEN
           QG3D(K) = QG3D(K)+QR3D(K)
!!!           T3D(K) = T3D(K)+QR3D(K)*XLF(K)/CPM(K)
           T3D(K) = T3D(K)+QR3D(K)*efrz(k)
           QR3D(K) = 0.
           NG3D(K) = NG3D(K)+ NR3D(K)
           NR3D(K) = 0.
        END IF

        ELSE IF (IGRAUP.EQ.1) THEN

        IF (T3D(K).LE.233.15.AND.QR3D(K).GE.QSMALL) THEN
           QNI3D(K) = QNI3D(K)+QR3D(K)
!!!           T3D(K) = T3D(K)+QR3D(K)*XLF(K)/CPM(K)
           T3D(K) = T3D(K)+QR3D(K)*efrz(k)
           QR3D(K) = 0.
           NS3D(K) = NS3D(K)+NR3D(K)
           NR3D(K) = 0.
        END IF

        END IF

 778    CONTINUE

! MAKE SURE NUMBER CONCENTRATIONS AREN'T NEGATIVE

      NI3D(K) = MAX(0.,NI3D(K))
      NS3D(K) = MAX(0.,NS3D(K))
      NC3D(K) = MAX(0.,NC3D(K))
      NR3D(K) = MAX(0.,NR3D(K))
      NG3D(K) = MAX(0.,NG3D(K))

!......................................................................
! CLOUD ICE

      IF (QI3D(K).GE.QSMALL) THEN
         LAMI(K) = (CONS12*                 &
              NI3D(K)/QI3D(K))**(1./DI)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMI(K).LT.LAMMINI) THEN

      LAMI(K) = LAMMINI

      N0I(K) = LAMI(K)**(DI+1.)*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      ELSE IF (LAMI(K).GT.LAMMAXI) THEN
      LAMI(K) = LAMMAXI
      N0I(K) = LAMI(K)**(DI+1.)*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      END IF
      END IF

!......................................................................
! RAIN

      IF (QR3D(K).GE.QSMALL) THEN
      LAMR(K) = (PI*RHOW*NR3D(K)/QR3D(K))**(1./3.)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMR(K).LT.LAMMINR) THEN

      LAMR(K) = LAMMINR

      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      ELSE IF (LAMR(K).GT.LAMMAXR) THEN
      LAMR(K) = LAMMAXR
      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      END IF

      END IF

!......................................................................
! CLOUD DROPLETS

! MARTIN ET AL. (1994) FORMULA FOR PGAM

      IF (QC3D(K).GE.QSMALL) THEN

!         DUM = PRES(K)/(R*T3D(K))
! V1.5
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*RHO(K))+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

! CALCULATE LAMC

      LAMC(K) = (CONS26*NC3D(K)*GAMMA(PGAM(K)+4.)/   &
                 (QC3D(K)*GAMMA(PGAM(K)+1.)))**(1./3.)

! LAMMIN, 60 MICRON DIAMETER
! LAMMAX, 1 MICRON

      LAMMIN = (PGAM(K)+1.)/60.E-6
      LAMMAX = (PGAM(K)+1.)/1.E-6

      IF (LAMC(K).LT.LAMMIN) THEN
      LAMC(K) = LAMMIN
      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      ELSE IF (LAMC(K).GT.LAMMAX) THEN
      LAMC(K) = LAMMAX
      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      END IF

      END IF

!......................................................................
! SNOW

      IF (QNI3D(K).GE.QSMALL) THEN
      LAMS(K) = (CONS1*NS3D(K)/QNI3D(K))**(1./DS)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMS(K).LT.LAMMINS) THEN
      LAMS(K) = LAMMINS
      N0S(K) = LAMS(K)**(DS+1.)*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)

      ELSE IF (LAMS(K).GT.LAMMAXS) THEN

      LAMS(K) = LAMMAXS
      N0S(K) = LAMS(K)**(DS+1.)*QNI3D(K)/CONS1
      NS3D(K) = N0S(K)/LAMS(K)
      END IF

      END IF

!......................................................................
! GRAUPEL

      IF (QG3D(K).GE.QSMALL) THEN
      LAMG(K) = (CONS2*NG3D(K)/QG3D(K))**(1./DG)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMG(K).LT.LAMMING) THEN
      LAMG(K) = LAMMING
      N0G(K) = LAMG(K)**(DG+1.)*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)

      ELSE IF (LAMG(K).GT.LAMMAXG) THEN

      LAMG(K) = LAMMAXG
      N0G(K) = LAMG(K)**(DG+1.)*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)
      END IF

      END IF

 500  CONTINUE

      ifrad:  IF(radopt.ge.1)THEN
!! CALCULATE EFFECTIVE RADIUS

! hm 8/20/12
      IF (QI3D(K).GE.QSMALL) THEN
         EFFI(K) = 3./LAMI(K)/2.*1.E6
      ELSE
         EFFI(K) = 25.
      END IF

      IF (QNI3D(K).GE.QSMALL) THEN
         EFFS(K) = 3./LAMS(K)/2.*1.E6
      ELSE
         EFFS(K) = 25.
      END IF

      IF (QR3D(K).GE.QSMALL) THEN
         EFFR(K) = 3./LAMR(K)/2.*1.E6
      ELSE
         EFFR(K) = 25.
      END IF

      IF (QC3D(K).GE.QSMALL) THEN
      EFFC(K) = GAMMA(PGAM(K)+4.)/                        &
             GAMMA(PGAM(K)+3.)/LAMC(K)/2.*1.E6
      ELSE
      EFFC(K) = 25.
      END IF

      IF (QG3D(K).GE.QSMALL) THEN
         EFFG(K) = 3./LAMG(K)/2.*1.E6
      ELSE
         EFFG(K) = 25.
      END IF

! add combined cloud ice + snow effective radius, used by Goddard radiation

      if (qi3d(k).ge.qsmall.and.qni3d(k).ge.qsmall) then
         effis(k) = 3./2.*1.e6*(1./lami(k)**4+1./lams(k)**4)/        &
                    (1./lami(k)**3+1./lams(k)**3)
      end if
! if there is no cloud ice but snow is present, use snow eff radius, and vice versa
      if (qi3d(k).ge.qsmall.and.qni3d(k).lt.qsmall) then
         effis(k) = effi(k)
      end if
      if (qi3d(k).lt.qsmall.and.qni3d(k).ge.qsmall) then
         effis(k) = effs(k)
      end if
      if (qi3d(k).lt.qsmall.and.qni3d(k).lt.qsmall) then
         effis(k) = 25.
      end if
      ENDIF  ifrad

!---------------------------------!

! HM ADD 1/10/06, ADD UPPER BOUND ON ICE NUMBER, THIS IS NEEDED
! TO PREVENT VERY LARGE ICE NUMBER DUE TO HOMOGENEOUS FREEZING
! OF DROPLETS, ESPECIALLY WHEN INUM = 1, SET MAX AT 10 CM-3
!          NI3D(K) = MIN(NI3D(K),10.E6/RHO(K))
! HM, 3/4/13, LOWER MAXIMUM ICE CONCENTRATION TO ADDRESS PROBLEM
! OF EXCESSIVE AND PERSISTENT ANVIL
! NOTE: THIS MAY CHANGE/REDUCE SENSITIVITY TO AEROSOL/CCN CONCENTRATION
          NI3D(K) = MIN(NI3D(K),0.3E6/RHO(K))

! ADD BOUND ON DROPLET NUMBER - CANNOT EXCEED AEROSOL CONCENTRATION
          IF (INUM.EQ.0.AND.IACT.EQ.2) THEN
          NC3D(K) = MIN(NC3D(K),(NANEW1+NANEW2)/RHO(K))
          END IF
! SWITCH FOR CONSTANT DROPLET NUMBER
          IF (INUM.EQ.1) THEN
! CHANGE NDCNST FROM CM-3 TO KG-1
             NC3D(K) = NDCNST*1.E6/RHO(K)
          END IF

      END DO !!! K LOOP

 400         CONTINUE

! ALL DONE !!!!!!!!!!!
      RETURN
      END  SUBROUTINE M2005MICRO_GRAUPEL

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

!      REAL FUNCTION POLYSVP (T,TYPE)
!
!!-------------------------------------------
!
!!  COMPUTE SATURATION VAPOR PRESSURE
!
!!  POLYSVP RETURNED IN UNITS OF PA.
!!  T IS INPUT IN UNITS OF K.
!!  TYPE REFERS TO SATURATION WITH RESPECT TO LIQUID (0) OR ICE (1)
!
!      IMPLICIT NONE
!
!      REAL DUM
!      REAL T
!      INTEGER TYPE
!
!! REPLACE GOFF-GRATCH WITH FASTER FORMULATION FROM FLATAU ET AL. 1992, TABLE 4 (RIGHT-HAND COLUMN)
!
!! ice
!      real a0i,a1i,a2i,a3i,a4i,a5i,a6i,a7i,a8i 
!      data a0i,a1i,a2i,a3i,a4i,a5i,a6i,a7i,a8i /&
!	6.11147274, 0.503160820, 0.188439774e-1, &
!        0.420895665e-3, 0.615021634e-5,0.602588177e-7, &
!        0.385852041e-9, 0.146898966e-11, 0.252751365e-14/	
!
!! liquid
!      real a0,a1,a2,a3,a4,a5,a6,a7,a8 
!
!! V1.7
!      data a0,a1,a2,a3,a4,a5,a6,a7,a8 /&
!	6.11239921, 0.443987641, 0.142986287e-1, &
!        0.264847430e-3, 0.302950461e-5, 0.206739458e-7, &
!        0.640689451e-10,-0.952447341e-13,-0.976195544e-15/
!      real dt
!
!! ICE
!
!      IF (TYPE.EQ.1) THEN
!
!!         POLYSVP = 10.**(-9.09718*(273.16/T-1.)-3.56654*                &
!!          LOG10(273.16/T)+0.876793*(1.-T/273.16)+						&
!!          LOG10(6.1071))*100.
!
!
!!!!      dt = max(-80.,t-273.16)
!!!!      polysvp = a0i + dt*(a1i+dt*(a2i+dt*(a3i+dt*(a4i+dt*(a5i+dt*(a6i+dt*(a7i+a8i*dt))))))) 
!!!!      polysvp = polysvp*100.
!
!        ! GHB ... needed for consistency with CM1 satadj scheme
!        polysvp = 611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
!
!
!      END IF
!
!! LIQUID
!
!      IF (TYPE.EQ.0) THEN
!
!!!!       dt = max(-80.,t-273.16)
!!!!       polysvp = a0 + dt*(a1+dt*(a2+dt*(a3+dt*(a4+dt*(a5+dt*(a6+dt*(a7+a8*dt)))))))
!!!!       polysvp = polysvp*100.
!
!!         POLYSVP = 10.**(-7.90298*(373.16/T-1.)+                        &
!!             5.02808*LOG10(373.16/T)-									&
!!             1.3816E-7*(10**(11.344*(1.-T/373.16))-1.)+				&
!!             8.1328E-3*(10**(-3.49149*(373.16/T-1.))-1.)+				&
!!             LOG10(1013.246))*100.
!
!           ! GHB ... needed for consistency with CM1 satadj scheme
!           polysvp = 611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
!
!         END IF
!
!
!      END FUNCTION POLYSVP

!------------------------------------------------------------------------------

      REAL FUNCTION GAMMA(X)
!----------------------------------------------------------------------
!
! THIS ROUTINE CALCULATES THE GAMMA FUNCTION FOR A REAL ARGUMENT X.
!   COMPUTATION IS BASED ON AN ALGORITHM OUTLINED IN REFERENCE 1.
!   THE PROGRAM USES RATIONAL FUNCTIONS THAT APPROXIMATE THE GAMMA
!   FUNCTION TO AT LEAST 20 SIGNIFICANT DECIMAL DIGITS.  COEFFICIENTS
!   FOR THE APPROXIMATION OVER THE INTERVAL (1,2) ARE UNPUBLISHED.
!   THOSE FOR THE APPROXIMATION FOR X .GE. 12 ARE FROM REFERENCE 2.
!   THE ACCURACY ACHIEVED DEPENDS ON THE ARITHMETIC SYSTEM, THE
!   COMPILER, THE INTRINSIC FUNCTIONS, AND PROPER SELECTION OF THE
!   MACHINE-DEPENDENT CONSTANTS.
!
!
!*******************************************************************
!*******************************************************************
!
! EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
!
! BETA   - RADIX FOR THE FLOATING-POINT REPRESENTATION
! MAXEXP - THE SMALLEST POSITIVE POWER OF BETA THAT OVERFLOWS
! XBIG   - THE LARGEST ARGUMENT FOR WHICH GAMMA(X) IS REPRESENTABLE
!          IN THE MACHINE, I.E., THE SOLUTION TO THE EQUATION
!                  GAMMA(XBIG) = BETA**MAXEXP
! XINF   - THE LARGEST MACHINE REPRESENTABLE FLOATING-POINT NUMBER;
!          APPROXIMATELY BETA**MAXEXP
! EPS    - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1.0+EPS .GT. 1.0
! XMININ - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1/XMININ IS MACHINE REPRESENTABLE
!
!     APPROXIMATE VALUES FOR SOME IMPORTANT MACHINES ARE:
!
!                            BETA       MAXEXP        XBIG
!
! CRAY-1         (S.P.)        2         8191        966.961
! CYBER 180/855
!   UNDER NOS    (S.P.)        2         1070        177.803
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)        2          128        35.040
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)        2         1024        171.624
! IBM 3033       (D.P.)       16           63        57.574
! VAX D-FORMAT   (D.P.)        2          127        34.844
! VAX G-FORMAT   (D.P.)        2         1023        171.489
!
!                            XINF         EPS        XMININ
!
! CRAY-1         (S.P.)   5.45E+2465   7.11E-15    1.84E-2466
! CYBER 180/855
!   UNDER NOS    (S.P.)   1.26E+322    3.55E-15    3.14E-294
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)   3.40E+38     1.19E-7     1.18E-38
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)   1.79D+308    2.22D-16    2.23D-308
! IBM 3033       (D.P.)   7.23D+75     2.22D-16    1.39D-76
! VAX D-FORMAT   (D.P.)   1.70D+38     1.39D-17    5.88D-39
! VAX G-FORMAT   (D.P.)   8.98D+307    1.11D-16    1.12D-308
!
!*******************************************************************
!*******************************************************************
!
! ERROR RETURNS
!
!  THE PROGRAM RETURNS THE VALUE XINF FOR SINGULARITIES OR
!     WHEN OVERFLOW WOULD OCCUR.  THE COMPUTATION IS BELIEVED
!     TO BE FREE OF UNDERFLOW AND OVERFLOW.
!
!
!  INTRINSIC FUNCTIONS REQUIRED ARE:
!
!     INT, DBLE, EXP, LOG, REAL, SIN
!
!
! REFERENCES:  AN OVERVIEW OF SOFTWARE DEVELOPMENT FOR SPECIAL
!              FUNCTIONS   W. J. CODY, LECTURE NOTES IN MATHEMATICS,
!              506, NUMERICAL ANALYSIS DUNDEE, 1975, G. A. WATSON
!              (ED.), SPRINGER VERLAG, BERLIN, 1976.
!
!              COMPUTER APPROXIMATIONS, HART, ET. AL., WILEY AND
!              SONS, NEW YORK, 1968.
!
!  LATEST MODIFICATION: OCTOBER 12, 1989
!
!  AUTHORS: W. J. CODY AND L. STOLTZ
!           APPLIED MATHEMATICS DIVISION
!           ARGONNE NATIONAL LABORATORY
!           ARGONNE, IL 60439
!
!----------------------------------------------------------------------
      implicit none
      INTEGER I,N
      LOGICAL PARITY
      REAL                                                          &
          CONV,EPS,FACT,HALF,ONE,RES,SUM,TWELVE,                    &
          TWO,X,XBIG,XDEN,XINF,XMININ,XNUM,Y,Y1,YSQ,Z,ZERO
      REAL, DIMENSION(7) :: C
      REAL, DIMENSION(8) :: P
      REAL, DIMENSION(8) :: Q
!----------------------------------------------------------------------
!  MATHEMATICAL CONSTANTS
!----------------------------------------------------------------------
      DATA ONE,HALF,TWELVE,TWO,ZERO/1.0E0,0.5E0,12.0E0,2.0E0,0.0E0/


!----------------------------------------------------------------------
!  MACHINE DEPENDENT PARAMETERS
!----------------------------------------------------------------------
      DATA XBIG,XMININ,EPS/35.040E0,1.18E-38,1.19E-7/,XINF/3.4E38/
!----------------------------------------------------------------------
!  NUMERATOR AND DENOMINATOR COEFFICIENTS FOR RATIONAL MINIMAX
!     APPROXIMATION OVER (1,2).
!----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811E+0,2.47656508055759199108314E+1,  &
             -3.79804256470945635097577E+2,6.29331155312818442661052E+2,  &
             8.66966202790413211295064E+2,-3.14512729688483675254357E+4,  &
             -3.61444134186911729807069E+4,6.64561438202405440627855E+4/
      DATA Q/-3.08402300119738975254353E+1,3.15350626979604161529144E+2,  &
             -1.01515636749021914166146E+3,-3.10777167157231109440444E+3, &
              2.25381184209801510330112E+4,4.75584627752788110767815E+3,  &
            -1.34659959864969306392456E+5,-1.15132259675553483497211E+5/
!----------------------------------------------------------------------
!  COEFFICIENTS FOR MINIMAX APPROXIMATION OVER (12, INF).
!----------------------------------------------------------------------
      DATA C/-1.910444077728E-03,8.4171387781295E-04,                      &
           -5.952379913043012E-04,7.93650793500350248E-04,				   &
           -2.777777777777681622553E-03,8.333333333333333331554247E-02,	   &
            5.7083835261E-03/
!----------------------------------------------------------------------
!  STATEMENT FUNCTIONS FOR CONVERSION BETWEEN INTEGER AND FLOAT
!----------------------------------------------------------------------
      CONV(I) = REAL(I)
      PARITY=.FALSE.
      FACT=ONE
      N=0
      Y=X
      IF(Y.LE.ZERO)THEN
!----------------------------------------------------------------------
!  ARGUMENT IS NEGATIVE
!----------------------------------------------------------------------
        Y=-X
        Y1=AINT(Y)
        RES=Y-Y1
        IF(RES.NE.ZERO)THEN
          IF(Y1.NE.AINT(Y1*HALF)*TWO)PARITY=.TRUE.
          FACT=-PI/SIN(PI*RES)
          Y=Y+ONE
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  ARGUMENT IS POSITIVE
!----------------------------------------------------------------------
      IF(Y.LT.EPS)THEN
!----------------------------------------------------------------------
!  ARGUMENT .LT. EPS
!----------------------------------------------------------------------
        IF(Y.GE.XMININ)THEN
          RES=ONE/Y
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ELSEIF(Y.LT.TWELVE)THEN
        Y1=Y
        IF(Y.LT.ONE)THEN
!----------------------------------------------------------------------
!  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          Z=Y
          Y=Y+ONE
        ELSE
!----------------------------------------------------------------------
!  1.0 .LT. ARGUMENT .LT. 12.0, REDUCE ARGUMENT IF NECESSARY
!----------------------------------------------------------------------
          N=INT(Y)-1
          Y=Y-CONV(N)
          Z=Y-ONE
        ENDIF
!----------------------------------------------------------------------
!  EVALUATE APPROXIMATION FOR 1.0 .LT. ARGUMENT .LT. 2.0
!----------------------------------------------------------------------
        XNUM=ZERO
        XDEN=ONE
        DO I=1,8
          XNUM=(XNUM+P(I))*Z
          XDEN=XDEN*Z+Q(I)
        END DO
        RES=XNUM/XDEN+ONE
        IF(Y1.LT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          RES=RES/Y1
        ELSEIF(Y1.GT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  2.0 .LT. ARGUMENT .LT. 12.0
!----------------------------------------------------------------------
          DO I=1,N
            RES=RES*Y
            Y=Y+ONE
          END DO
        ENDIF
      ELSE
!----------------------------------------------------------------------
!  EVALUATE FOR ARGUMENT .GE. 12.0,
!----------------------------------------------------------------------
        IF(Y.LE.XBIG)THEN
          YSQ=Y*Y
          SUM=C(7)
          DO I=1,6
            SUM=SUM/YSQ+C(I)
          END DO
          SUM=SUM/Y-Y+SQRTPI
          SUM=SUM+(Y-HALF)*LOG(Y)
          RES=EXP(SUM)
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  FINAL ADJUSTMENTS AND RETURN
!----------------------------------------------------------------------
      IF(PARITY)RES=-RES
      IF(FACT.NE.ONE)RES=FACT/RES
  900 GAMMA=RES
      RETURN
! ---------- LAST LINE OF GAMMA ----------
      END FUNCTION GAMMA


      REAL FUNCTION DERF1(X)
      IMPLICIT NONE
      REAL X
      REAL, DIMENSION(0 : 64) :: A, B
      REAL W,T,Y
      INTEGER K,I
      DATA A/                                                 &
         0.00000000005958930743E0, -0.00000000113739022964E0, &
         0.00000001466005199839E0, -0.00000016350354461960E0, &
         0.00000164610044809620E0, -0.00001492559551950604E0, &
         0.00012055331122299265E0, -0.00085483269811296660E0, &
         0.00522397762482322257E0, -0.02686617064507733420E0, &
         0.11283791670954881569E0, -0.37612638903183748117E0, &
         1.12837916709551257377E0,	                          &
         0.00000000002372510631E0, -0.00000000045493253732E0, &
         0.00000000590362766598E0, -0.00000006642090827576E0, &
         0.00000067595634268133E0, -0.00000621188515924000E0, &
         0.00005103883009709690E0, -0.00037015410692956173E0, &
         0.00233307631218880978E0, -0.01254988477182192210E0, &
         0.05657061146827041994E0, -0.21379664776456006580E0, &
         0.84270079294971486929E0,							  &
         0.00000000000949905026E0, -0.00000000018310229805E0, &
         0.00000000239463074000E0, -0.00000002721444369609E0, &
         0.00000028045522331686E0, -0.00000261830022482897E0, &
         0.00002195455056768781E0, -0.00016358986921372656E0, &
         0.00107052153564110318E0, -0.00608284718113590151E0, &
         0.02986978465246258244E0, -0.13055593046562267625E0, &
         0.67493323603965504676E0, 							  &
         0.00000000000382722073E0, -0.00000000007421598602E0, &
         0.00000000097930574080E0, -0.00000001126008898854E0, &
         0.00000011775134830784E0, -0.00000111992758382650E0, &
         0.00000962023443095201E0, -0.00007404402135070773E0, &
         0.00050689993654144881E0, -0.00307553051439272889E0, &
         0.01668977892553165586E0, -0.08548534594781312114E0, &
         0.56909076642393639985E0,							  &
         0.00000000000155296588E0, -0.00000000003032205868E0, &
         0.00000000040424830707E0, -0.00000000471135111493E0, &
         0.00000005011915876293E0, -0.00000048722516178974E0, &
         0.00000430683284629395E0, -0.00003445026145385764E0, &
         0.00024879276133931664E0, -0.00162940941748079288E0, &
         0.00988786373932350462E0, -0.05962426839442303805E0, &
         0.49766113250947636708E0 /
      DATA (B(I), I = 0, 12) /                                  &
         -0.00000000029734388465E0,  0.00000000269776334046E0, 	&
         -0.00000000640788827665E0, -0.00000001667820132100E0,  &
         -0.00000021854388148686E0,  0.00000266246030457984E0, 	&
          0.00001612722157047886E0, -0.00025616361025506629E0, 	&
          0.00015380842432375365E0,  0.00815533022524927908E0, 	&
         -0.01402283663896319337E0, -0.19746892495383021487E0,  &
          0.71511720328842845913E0 /
      DATA (B(I), I = 13, 25) /                                 &
         -0.00000000001951073787E0, -0.00000000032302692214E0,  &
          0.00000000522461866919E0,  0.00000000342940918551E0, 	&
         -0.00000035772874310272E0,  0.00000019999935792654E0, 	&
          0.00002687044575042908E0, -0.00011843240273775776E0, 	&
         -0.00080991728956032271E0,  0.00661062970502241174E0, 	&
          0.00909530922354827295E0, -0.20160072778491013140E0, 	&
          0.51169696718727644908E0 /
      DATA (B(I), I = 26, 38) /                                 &
         0.00000000003147682272E0, -0.00000000048465972408E0,   &
         0.00000000063675740242E0,  0.00000003377623323271E0, 	&
        -0.00000015451139637086E0, -0.00000203340624738438E0, 	&
         0.00001947204525295057E0,  0.00002854147231653228E0, 	&
        -0.00101565063152200272E0,  0.00271187003520095655E0, 	&
         0.02328095035422810727E0, -0.16725021123116877197E0, 	&
         0.32490054966649436974E0 /
      DATA (B(I), I = 39, 51) /                                 &
         0.00000000002319363370E0, -0.00000000006303206648E0,   &
        -0.00000000264888267434E0,  0.00000002050708040581E0, 	&
         0.00000011371857327578E0, -0.00000211211337219663E0, 	&
         0.00000368797328322935E0,  0.00009823686253424796E0, 	&
        -0.00065860243990455368E0, -0.00075285814895230877E0, 	&
         0.02585434424202960464E0, -0.11637092784486193258E0, 	&
         0.18267336775296612024E0 /
      DATA (B(I), I = 52, 64) /                                 &
        -0.00000000000367789363E0,  0.00000000020876046746E0, 	&
        -0.00000000193319027226E0, -0.00000000435953392472E0, 	&
         0.00000018006992266137E0, -0.00000078441223763969E0, 	&
        -0.00000675407647949153E0,  0.00008428418334440096E0, 	&
        -0.00017604388937031815E0, -0.00239729611435071610E0, 	&
         0.02064129023876022970E0, -0.06905562880005864105E0,   &
         0.09084526782065478489E0 /
      W = ABS(X)
      IF (W .LT. 2.2D0) THEN
          T = W * W
          K = INT(T)
          T = T - K
          K = K * 13
          Y = ((((((((((((A(K) * T + A(K + 1)) * T +              &
              A(K + 2)) * T + A(K + 3)) * T + A(K + 4)) * T +     &
              A(K + 5)) * T + A(K + 6)) * T + A(K + 7)) * T +     &
              A(K + 8)) * T + A(K + 9)) * T + A(K + 10)) * T + 	  &
              A(K + 11)) * T + A(K + 12)) * W
      ELSE IF (W .LT. 6.9D0) THEN
          K = INT(W)
          T = W - K
          K = 13 * (K - 2)
          Y = (((((((((((B(K) * T + B(K + 1)) * T +               &
              B(K + 2)) * T + B(K + 3)) * T + B(K + 4)) * T + 	  &
              B(K + 5)) * T + B(K + 6)) * T + B(K + 7)) * T + 	  &
              B(K + 8)) * T + B(K + 9)) * T + B(K + 10)) * T + 	  &
              B(K + 11)) * T + B(K + 12)
          Y = Y * Y
          Y = Y * Y
          Y = Y * Y
          Y = 1 - Y * Y
      ELSE
          Y = 1
      END IF
      IF (X .LT. 0) Y = -Y
      DERF1 = Y
      END FUNCTION DERF1

!+---+-----------------------------------------------------------------+
!
      subroutine radar_init

      IMPLICIT NONE
      INTEGER:: n
      PI5 = PI*PI*PI*PI*PI
      lamda4 = lamda_radar*lamda_radar*lamda_radar*lamda_radar
      m_w_0 = m_complex_water_ray (lamda_radar, 0.0d0)
      m_i_0 = m_complex_ice_maetzler (lamda_radar, 0.0d0)
      K_w = (ABS( (m_w_0*m_w_0 - 1.0) /(m_w_0*m_w_0 + 2.0) ))**2

      do n = 1, nbins+1
         simpson(n) = 0.0d0
      enddo
      do n = 1, nbins-1, 2
         simpson(n) = simpson(n) + basis(1)
         simpson(n+1) = simpson(n+1) + basis(2)
         simpson(n+2) = simpson(n+2) + basis(3)
      enddo

      do n = 1, slen
         mixingrulestring_s(n:n) = char(0)
         matrixstring_s(n:n) = char(0)
         inclusionstring_s(n:n) = char(0)
         hoststring_s(n:n) = char(0)
         hostmatrixstring_s(n:n) = char(0)
         hostinclusionstring_s(n:n) = char(0)
         mixingrulestring_g(n:n) = char(0)
         matrixstring_g(n:n) = char(0)
         inclusionstring_g(n:n) = char(0)
         hoststring_g(n:n) = char(0)
         hostmatrixstring_g(n:n) = char(0)
         hostinclusionstring_g(n:n) = char(0)
      enddo

      mixingrulestring_s = 'maxwellgarnett'
      hoststring_s = 'air'
      matrixstring_s = 'water'
      inclusionstring_s = 'spheroidal'
      hostmatrixstring_s = 'icewater'
      hostinclusionstring_s = 'spheroidal'

      mixingrulestring_g = 'maxwellgarnett'
      hoststring_g = 'air'
      matrixstring_g = 'water'
      inclusionstring_g = 'spheroidal'
      hostmatrixstring_g = 'icewater'
      hostinclusionstring_g = 'spheroidal'

      end subroutine radar_init
!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_water_ray(lambda,T)

!      Complex refractive Index of Water as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.001,1.0] m; T in [-10.0,30.0] deg C
!      after Ray (1972)

      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: epsinf,epss,epsr,epsi
      DOUBLE PRECISION:: alpha,lambdas,sigma,nenner
      COMPLEX*16, PARAMETER:: i = (0d0,1d0)

      epsinf  = 5.27137d0 + 0.02164740d0 * T - 0.00131198d0 * T*T
      epss    = 78.54d+0 * (1.0 - 4.579d-3 * (T - 25.0)                 &
              + 1.190d-5 * (T - 25.0)*(T - 25.0)                        &
              - 2.800d-8 * (T - 25.0)*(T - 25.0)*(T - 25.0))
      alpha   = -16.8129d0/(T+273.16) + 0.0609265d0
      lambdas = 0.00033836d0 * exp(2513.98d0/(T+273.16)) * 1e-2

      nenner = 1.d0+2.d0*(lambdas/lambda)**(1d0-alpha)*sin(alpha*PI*0.5) &
             + (lambdas/lambda)**(2d0-2d0*alpha)
      epsr = epsinf + ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)   &
           * sin(alpha*PI*0.5)+1d0)) / nenner
      epsi = ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)            &
           * cos(alpha*PI*0.5)+0d0)) / nenner                           &
           + lambda*1.25664/1.88496
      
      m_complex_water_ray = SQRT(CMPLX(epsr,-epsi))
      
      END FUNCTION m_complex_water_ray

!+---+-----------------------------------------------------------------+
      
      COMPLEX*16 FUNCTION m_complex_ice_maetzler(lambda,T)
      
!      complex refractive index of ice as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.0001,30] m; T in [-250.0,0.0] C
!      Original comment from the Matlab-routine of Prof. Maetzler:
!      Function for calculating the relative permittivity of pure ice in
!      the microwave region, according to C. Maetzler, "Microwave
!      properties of ice and snow", in B. Schmitt et al. (eds.) Solar
!      System Ices, Astrophys. and Space Sci. Library, Vol. 227, Kluwer
!      Academic Publishers, Dordrecht, pp. 241-257 (1998). Input:
!      TK = temperature (K), range 20 to 273.15
!      f = frequency in GHz, range 0.01 to 3000
         
      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: f,c,TK,B1,B2,b,deltabeta,betam,beta,theta,alfa

      c = 2.99d8
      TK = T + 273.16
      f = c / lambda * 1d-9

      B1 = 0.0207
      B2 = 1.16d-11
      b = 335.0d0
      deltabeta = EXP(-10.02 + 0.0364*(TK-273.16))
      betam = (B1/TK) * ( EXP(b/TK) / ((EXP(b/TK)-1)**2) ) + B2*f*f
      beta = betam + deltabeta
      theta = 300. / TK - 1.
      alfa = (0.00504d0 + 0.0062d0*theta) * EXP(-22.1d0*theta)
      m_complex_ice_maetzler = 3.1884 + 9.1e-4*(TK-273.16)
      m_complex_ice_maetzler = m_complex_ice_maetzler                   &
                             + CMPLX(0.0d0, (alfa/f + beta*f)) 
      m_complex_ice_maetzler = SQRT(CONJG(m_complex_ice_maetzler))
      
      END FUNCTION m_complex_ice_maetzler
!+---+-----------------------------------------------------------------+

      subroutine rayleigh_soak_wetgraupel (x_g, a_geo, b_geo, fmelt,    &
                     meltratio_outside, m_w, m_i, lambda, C_back,       &
                     mixingrule,matrix,inclusion,                       &
                     host,hostmatrix,hostinclusion)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: x_g, a_geo, b_geo, fmelt, lambda,  &
                                     meltratio_outside
      DOUBLE PRECISION, INTENT(out):: C_back
      COMPLEX*16, INTENT(in):: m_w, m_i
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion,     &
                                     host, hostmatrix, hostinclusion

      COMPLEX*16:: m_core, m_air
      DOUBLE PRECISION:: D_large, D_g, rhog, x_w, xw_a, fm, fmgrenz,    &
                         volg, vg, volair, volice, volwater,            &
                         meltratio_outside_grenz, mra
      INTEGER:: error
      real :: rho_i, rho_w

      rho_i = 900.
      rho_w = 1000.


!     refractive index of air:
      m_air = (1.0d0,0.0d0)

!     Limiting the degree of melting --- for safety: 
      fm = DMAX1(DMIN1(fmelt, 1.0d0), 0.0d0)
!     Limiting the ratio of (melting on outside)/(melting on inside):
      mra = DMAX1(DMIN1(meltratio_outside, 1.0d0), 0.0d0)

!    ! The relative portion of meltwater melting at outside should increase
!    ! from the given input value (between 0 and 1)
!    ! to 1 as the degree of melting approaches 1,
!    ! so that the melting particle "converges" to a water drop.
!    ! Simplest assumption is linear:
      mra = mra + (1.0d0-mra)*fm

      x_w = x_g * fm

      D_g = a_geo * x_g**b_geo

      if (D_g .ge. 1d-12) then

       vg = PI/6. * D_g**3
       rhog = DMAX1(DMIN1(x_g / vg, DBLE(rho_i)), 10.0d0)
       vg = x_g / rhog
      
       meltratio_outside_grenz = 1.0d0 - rhog / rho_w

       if (mra .le. meltratio_outside_grenz) then
        !..In this case, it cannot happen that, during melting, all the
        !.. air inclusions within the ice particle get filled with
        !.. meltwater. This only happens at the end of all melting.
        volg = vg * (1.0d0 - mra * fm)
 
       else
        !..In this case, at some melting degree fm, all the air
        !.. inclusions get filled with meltwater.
        fmgrenz=(rho_i-rhog)/(mra*rho_i-rhog+rho_i*rhog/rho_w)

        if (fm .le. fmgrenz) then
         !.. not all air pockets are filled:
         volg = (1.0 - mra * fm) * vg
        else
         !..all air pockets are filled with meltwater, now the
         !.. entire ice sceleton melts homogeneously:
         volg = (x_g - x_w) / rho_i + x_w / rho_w
        endif

       endif

       D_large  = (6.0 / PI * volg) ** (1./3.)
       volice = (x_g - x_w) / (volg * rho_i)
       volwater = x_w / (rho_w * volg)
       volair = 1.0 - volice - volwater
      
       !..complex index of refraction for the ice-air-water mixture
       !.. of the particle:
       m_core = get_m_mix_nested (m_air, m_i, m_w, volair, volice,      &
                         volwater, mixingrule, host, matrix, inclusion, &
                         hostmatrix, hostinclusion, error)
       if (error .ne. 0) then
        C_back = 0.0d0
        return
       endif

       !..Rayleigh-backscattering coefficient of melting particle: 
       C_back = (ABS((m_core**2-1.0d0)/(m_core**2+2.0d0)))**2           &
                * PI5 * D_large**6 / lamda4

      else
       C_back = 0.0d0
      endif

      end subroutine rayleigh_soak_wetgraupel
!+---+-----------------------------------------------------------------+

      complex*16 function get_m_mix_nested (m_a, m_i, m_w, volair,      &
                     volice, volwater, mixingrule, host, matrix,        &
                     inclusion, hostmatrix, hostinclusion, cumulerror)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, host, matrix,          &
                     inclusion, hostmatrix, hostinclusion
      INTEGER, INTENT(out):: cumulerror

      DOUBLE PRECISION:: vol1, vol2
      COMPLEX*16:: mtmp
      INTEGER:: error

      !..Folded: ( (m1 + m2) + m3), where m1,m2,m3 could each be
      !.. air, ice, or water

      cumulerror = 0
      get_m_mix_nested = CMPLX(1.0d0,0.0d0)

      if (host .eq. 'air') then

       if (matrix .eq. 'air') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volice / MAX(volice+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, 0.0d0, vol1, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error
          
        if (hostmatrix .eq. 'air') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'icewater') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!!!         CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'ice') then

       if (matrix .eq. 'ice') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volair+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, 0.0d0, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'ice') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airwater') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         'air', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!!!         CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'water') then

       if (matrix .eq. 'water') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volice+volair,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, vol2, 0.0d0,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'water') then
         get_m_mix_nested = get_m_mix (2.0d0*m_a, mtmp, m_w,            &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airice') then
         get_m_mix_nested = get_m_mix (2.0d0*m_a, mtmp, m_w,            &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',         &
                           hostmatrix
!!!         CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'none') then

       get_m_mix_nested = get_m_mix (m_a, m_i, m_w,                     &
                       volair, volice, volwater, mixingrule,            &
                       matrix, inclusion, error)
       cumulerror = cumulerror + error
        
      else
       write(mp_debug,*) 'GET_M_MIX_NESTED: unknown matrix: ', host
!!!       CALL wrf_debug(150, mp_debug)
       cumulerror = cumulerror + 1
      endif

      IF (cumulerror .ne. 0) THEN
       write(mp_debug,*) 'GET_M_MIX_NESTED: error encountered'
!!!       CALL wrf_debug(150, mp_debug)
       get_m_mix_nested = CMPLX(1.0d0,0.0d0)    
      endif

      end function get_m_mix_nested

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION get_m_mix (m_a, m_i, m_w, volair, volice,     &
                     volwater, mixingrule, matrix, inclusion, error)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion
      INTEGER, INTENT(out):: error

      error = 0
      get_m_mix = CMPLX(1.0d0,0.0d0)

      if (mixingrule .eq. 'maxwellgarnett') then
       if (matrix .eq. 'ice') then
        get_m_mix = m_complex_maxwellgarnett(volice, volair, volwater,  &
                           m_i, m_a, m_w, inclusion, error)
       elseif (matrix .eq. 'water') then
        get_m_mix = m_complex_maxwellgarnett(volwater, volair, volice,  &
                           m_w, m_a, m_i, inclusion, error)
       elseif (matrix .eq. 'air') then
        get_m_mix = m_complex_maxwellgarnett(volair, volwater, volice,  &
                           m_a, m_w, m_i, inclusion, error)
       else
        write(mp_debug,*) 'GET_M_MIX: unknown matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        error = 1
       endif

      else
       write(mp_debug,*) 'GET_M_MIX: unknown mixingrule: ', mixingrule
!!!       CALL wrf_debug(150, mp_debug)
       error = 2
      endif

      if (error .ne. 0) then
       write(mp_debug,*) 'GET_M_MIX: error encountered'
!!!       CALL wrf_debug(150, mp_debug)
      endif

      END FUNCTION get_m_mix

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_maxwellgarnett(vol1, vol2, vol3,    &
                     m1, m2, m3, inclusion, error)

      IMPLICIT NONE

      COMPLEX*16 :: m1, m2, m3
      DOUBLE PRECISION :: vol1, vol2, vol3
      CHARACTER(len=*) :: inclusion

      COMPLEX*16 :: beta2, beta3, m1t, m2t, m3t
      INTEGER, INTENT(out) :: error

      error = 0

      if (DABS(vol1+vol2+vol3-1.0d0) .gt. 1d-6) then
       write(mp_debug,*) 'M_COMPLEX_MAXWELLGARNETT: sum of the ',       &
              'partial volume fractions is not 1...ERROR'
!!!       CALL wrf_debug(150, mp_debug)
       m_complex_maxwellgarnett=CMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m1t = m1**2
      m2t = m2**2
      m3t = m3**2

      if (inclusion .eq. 'spherical') then
       beta2 = 3.0d0*m1t/(m2t+2.0d0*m1t)
       beta3 = 3.0d0*m1t/(m3t+2.0d0*m1t)
      elseif (inclusion .eq. 'spheroidal') then
       beta2 = 2.0d0*m1t/(m2t-m1t) * (m2t/(m2t-m1t)*LOG(m2t/m1t)-1.0d0)
       beta3 = 2.0d0*m1t/(m3t-m1t) * (m3t/(m3t-m1t)*LOG(m3t/m1t)-1.0d0)
      else
       write(mp_debug,*) 'M_COMPLEX_MAXWELLGARNETT: ',                  &
                         'unknown inclusion: ', inclusion
!!!       CALL wrf_debug(150, mp_debug)
       m_complex_maxwellgarnett=DCMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m_complex_maxwellgarnett = &
       SQRT(((1.0d0-vol2-vol3)*m1t + vol2*beta2*m2t + vol3*beta3*m3t) / &
       (1.0d0-vol2-vol3+vol2*beta2+vol3*beta3))

      END FUNCTION m_complex_maxwellgarnett

!+---+-----------------------------------------------------------------+
!..Compute radar reflectivity assuming 10 cm wavelength radar and using
!.. Rayleigh approximation.  Only complication is melted snow/graupel
!.. which we treat as water-coated ice spheres and use Uli Blahak's
!.. library of routines.  The meltwater fraction is simply the amount
!.. of frozen species remaining from what initially existed at the
!.. melting level interface.
!+---+-----------------------------------------------------------------+
      subroutine calc_refl10cm (qv1d, qr1d, qs1d, qg1d, t1d, p1d, dBZ,  &
                          kts, kte, ii, jj, nr1d, ns1d, ng1d, rho1d)

      IMPLICIT NONE

!..Sub arguments
      INTEGER, INTENT(IN):: kts, kte, ii, jj
      REAL, DIMENSION(kts:kte), INTENT(IN)::                            &
                qv1d, qr1d, qs1d, qg1d, t1d, p1d, nr1d, ns1d, ng1d, rho1d
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: dBZ

!..Local variables
      REAL, DIMENSION(kts:kte):: temp, pres, qv, rho
      REAL, DIMENSION(kts:kte):: rr, rs, rg,rnr,rns,rng

      DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilamg, N0_r, N0_g,ilams,n0_s

      REAL, DIMENSION(kts:kte):: ze_rain, ze_snow, ze_graupel

      DOUBLE PRECISION:: lamg
      DOUBLE PRECISION:: fmelt_s, fmelt_g

      INTEGER:: i, k, k_0
      LOGICAL:: melti
      LOGICAL, DIMENSION(kts:kte):: L_qr, L_qs, L_qg

!..Single melting snow/graupel particle 70% meltwater on external sfc
      DOUBLE PRECISION, PARAMETER:: melt_outside_s = 0.7d0
      DOUBLE PRECISION, PARAMETER:: melt_outside_g = 0.7d0

      DOUBLE PRECISION:: cback, x, eta, f_d

! hm added parameter
      REAL R1,t_0,dumlams,dumlamr,dumlamg,dumn0s,dumn0r,dumn0g,ocms,obms,ocmg,obmg

      integer n

      R1 = 1.E-12
      t_0 = 273.15

!+---+

      do k = kts, kte
         dBZ(k) = -35.0
      enddo

!+---+-----------------------------------------------------------------+
!..Put column of data into local arrays.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k)
         qv(k) = MAX(1.E-10, qv1d(k))
         pres(k) = p1d(k)
!!!         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         rho(k) = rho1d(K)
         if (qr1d(k) .gt. R1) then
            rr(k) = qr1d(k)*rho(k)
            L_qr(k) = .true.
         else
            rr(k) = R1
            L_qr(k) = .false.
         endif
         if (qs1d(k) .gt. R1) then
            rs(k) = qs1d(k)*rho(k)
            L_qs(k) = .true.
         else
            rs(k) = R1
            L_qs(k) = .false.
         endif
         if (qg1d(k) .gt. R1) then
            rg(k) = qg1d(k)*rho(k)
            L_qg(k) = .true.
         else
            rg(k) = R1
            L_qg(k) = .false.
         endif

! hm add number concentration
         if (nr1d(k) .gt. R1) then
            rnr(k) = nr1d(k)*rho(k)
         else
            rnr(k) = R1
         endif
         if (ns1d(k) .gt. R1) then
            rns(k) = ns1d(k)*rho(k)
         else
            rns(k) = R1
         endif
         if (ng1d(k) .gt. R1) then
            rng(k) = ng1d(k)*rho(k)
         else
            rng(k) = R1
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope, and useful moments for snow.
!+---+-----------------------------------------------------------------+
      do k = kts, kte

! compute moments for snow

! calculate slope and intercept parameter

      dumLAMS = (CONS1*rns(K)/rs(K))**(1./DS)
      dumN0S = rns(K)*dumLAMS/rho(k)

! CHECK FOR SLOPE to make sure min/max bounds are not exceeded

! ADJUST VARS

      IF (dumLAMS.LT.LAMMINS) THEN
      dumLAMS = LAMMINS
      dumN0S = dumLAMS**4*rs(K)/CONS1
      ELSE IF (dumLAMS.GT.LAMMAXS) THEN
      dumLAMS = LAMMAXS
      dumN0S = dumLAMS**4*rs(k)/CONS1
      end if

      ilams(k)=1./dumlams
      n0_s(k)=dumn0s

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+

      do k = kte, kts, -1


! calculate slope and intercept parameter

      dumLAMg = (CONS2*rng(K)/rg(K))**(1./Dg)
      dumN0g = rng(K)*dumLAMg/rho(k)

! CHECK FOR SLOPE to make sure min/max bounds are not exceeded

! ADJUST VARS

      IF (dumLAMg.LT.LAMMINg) THEN
      dumLAMg = LAMMINg
      dumN0g = dumLAMg**4*rg(K)/CONS2
      ELSE IF (dumLAMg.GT.LAMMAXg) THEN
      dumLAMg = LAMMAXg
      dumN0g = dumLAMg**4*rg(k)/CONS2
      end if

      ilamg(k)=1./dumlamg
      n0_g(k)=dumn0g

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept & slope values for rain.
!+---+-----------------------------------------------------------------+

      do k = kte, kts, -1

! calculate slope and intercept parameter

      dumLAMr = (PI*RHOW*rnr(K)/rr(K))**(1./3.)
      dumN0r = rnr(K)*dumLAMr/rho(k)

! CHECK FOR SLOPE to make sure min/max bounds are not exceeded

! ADJUST VARS

      IF (dumLAMr.LT.LAMMINr) THEN
      dumLAMr = LAMMINr
      dumN0r = dumLAMr**4*rr(K)/(PI*RHOW)
      ELSE IF (dumLAMr.GT.LAMMAXr) THEN
      dumLAMr = LAMMAXr
      dumN0r = dumLAMr**4*rr(k)/(PI*RHOW)
      end if

      ilamr(k)=1./dumlamr
      n0_r(k)=dumn0r

      enddo

      melti = .false.
      k_0 = kts
      do k = kte-1, kts, -1
         if ( (temp(k).gt. T_0) .and. (rr(k).gt. 0.001e-3) &
                   .and. ((rs(k+1)+rg(k+1)).gt. 0.01e-3) ) then
            k_0 = MAX(k+1, k_0)
            melti=.true.
            goto 195
         endif
      enddo
 195  continue

!+---+-----------------------------------------------------------------+
!..Assume Rayleigh approximation at 10 cm wavelength. Rain (all temps)
!.. and non-water-coated snow and graupel when below freezing are
!.. simple. Integrations of m(D)*m(D)*N(D)*dD.
!+---+-----------------------------------------------------------------+

      do k = kts, kte
         ze_rain(k) = 1.e-22
         ze_snow(k) = 1.e-22
         ze_graupel(k) = 1.e-22
         if (L_qr(k)) ze_rain(k) = N0_r(k)*720.*ilamr(k)**7

         if (L_qs(k)) ze_snow(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)     &
                                 * (pi*rhosn/6./900.)*(pi*rhosn/6./900.) &
                                    * N0_s(k)*720.*ilams(k)**7
         if (L_qg(k)) ze_graupel(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)  &
                                    * (pi*rhog/6./900.)* (pi*rhog/6./900.)        &
                                    * N0_g(k)*720.*ilamg(k)**7
      enddo

!+---+-----------------------------------------------------------------+
!..Special case of melting ice (snow/graupel) particles.  Assume the
!.. ice is surrounded by the liquid water.  Fraction of meltwater is
!.. extremely simple based on amount found above the melting level.
!.. Uses code from Uli Blahak (rayleigh_soak_wetgraupel and supporting
!.. routines).
!+---+-----------------------------------------------------------------+

      if (melti .and. k_0.ge.2) then
       do k = k_0-1, 1, -1

!..Reflectivity contributed by melting snow
          fmelt_s = DMIN1(1.0d0-rs(k)/rs(k_0), 1.0d0)
          if (fmelt_s.gt.0.01d0 .and. fmelt_s.lt.0.99d0 .and.           &
                         rs(k).gt.R1) then
           eta = 0.d0
           obms = 1./ds
           ocms = (1./(pi*rhosn/6.))**obms
           do n = 1, nbs
              x = pi*rhosn/6. * Dds(n)**3
              call rayleigh_soak_wetgraupel (x, DBLE(ocms), DBLE(obms), &
                    fmelt_s, melt_outside_s, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_s, matrixstring_s,          &
                    inclusionstring_s, hoststring_s,                    &
                    hostmatrixstring_s, hostinclusionstring_s)
              f_d = N0_s(k)* DEXP(-Dds(n)/ilams(k))
              eta = eta + f_d * CBACK * simpson(n) * dts(n)

           enddo
           ze_snow(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif


!..Reflectivity contributed by melting graupel

          fmelt_g = DMIN1(1.0d0-rg(k)/rg(k_0), 1.0d0)
          if (fmelt_g.gt.0.01d0 .and. fmelt_g.lt.0.99d0 .and.           &
                         rg(k).gt.R1) then
           eta = 0.d0
           lamg = 1./ilamg(k)
           obmg = 1./dg
           ocmg = (1./(pi*rhog/6.))**obmg
           do n = 1, nbg
              x = pi*rhog/6. * Ddg(n)**3
              call rayleigh_soak_wetgraupel (x, DBLE(ocmg), DBLE(obmg), &
                    fmelt_g, melt_outside_g, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_g, matrixstring_g,          &
                    inclusionstring_g, hoststring_g,                    &
                    hostmatrixstring_g, hostinclusionstring_g)
              f_d = N0_g(k)* DEXP(-lamg*Ddg(n))
              eta = eta + f_d * CBACK * simpson(n) * dtg(n)
           enddo
           ze_graupel(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif

       enddo
      endif

      do k = kte, kts, -1
         dBZ(k) = 10.*log10((ze_rain(k)+ze_snow(k)+ze_graupel(k))*1.d18)
      enddo


      end subroutine calc_refl10cm

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine satadj2(tnew,prs,qvnew,qcnew,qrnew,qinew,qsnew,qgnew,rho,eqtset,tsmall)
      implicit none

      ! CM1 iterative saturation adjustment scheme for Morrison microphysics

      real, intent(inout) :: tnew,prs,qvnew,qcnew
      real, intent(in) :: qrnew,qinew,qsnew,qgnew,rho
      integer, intent(in) :: eqtset
      real, intent(in) :: tsmall

      integer :: n,iflag
      real :: esl,qvs,cvml,rm,lhv,tlast,dqv
      real :: converge,t1,d1,tem,ql,qi
      logical :: doit

!--------------------------------------------------------------------
!  iterative sat adj.

    iflag=0

    IF(eqtset.eq.2)THEN

        converge=2.0*tsmall

        esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
        qvs=ep_2*esl/(prs-esl)

        IF(qcnew.gt.qsmall .or. qvnew.gt.qvs)THEN

          ql=max(0.0,qcnew+qrnew)
          qi=max(0.0,qinew+qsnew+qgnew)
          cvml=cv+cvv*qvnew+cpl*ql+cpi*qi
          lhv=lv1-lv2*tnew

          t1=(lhv-rv*tnew)/cvml
          d1=t1*17.67*243.5

          n=0
          tlast=tnew
          doit=.true.

          do while( doit )
            n=n+1
            dqv=(qvs-qvnew)/(1.0+d1*qvs/((tnew-29.65)**2) )
            dqv=min(dqv,qcnew)
            if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew

            qvnew=qvnew+dqv
            qcnew=qcnew-dqv
            tnew=tnew-dqv*t1
            prs=rho*(R+rv*qvnew)*tnew

            doit = .false.
            if( abs(tnew-tlast).gt.converge )then
              tlast=tnew
              esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
              qvs=ep_2*esl/(prs-esl)
              doit = .true.
            endif

            if(n.gt.50) print *,'  satadj2:',n,tnew,prs
            if(n.eq.100)then
              print *,'  infinite loop!'
              iflag=1
              doit=.false.
            endif

          enddo

        ENDIF

    ELSE

        esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
        qvs=ep_2*esl/(prs-esl)
        lhv=lv1-lv2*tnew

        dqv=(qvs-qvnew)/(1.0+lhv*qvs*17.67*243.5/(cp*((tnew-29.65)**2)))
        if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
        dqv=min(dqv,max(0.0,qcnew))

        qvnew=qvnew+dqv
        qcnew=qcnew-dqv
        tnew=tnew-dqv*lhv/(cp*(1.+0.887*qvnew))

    ENDIF

      if(iflag.ne.0)then
        print *
        print *,' Convergence cannot be reached in satadj2 subroutine.'
        print *
        print *,' This may be a problem with the algorithm in satadj2.'
        print *,' However, the model may have became unstable somewhere'
        print *,' else and the symptoms first appeared here.'
        print *
        print *,' Try decreasing the timestep (dtl and/or nsound).'
        print *
        print *,'  ... stopping cm1 ... '
        print *
        call stopcm1
      endif

      END subroutine satadj2

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

END MODULE module_mp_GRAUPEL
#1/24           1587424407  1602  20    100644  546795    `
module_mp_nssl_2mom.F   !WRF:MODEL_LAYER:PHYSICS






!---------------------------------------------------------------------
! IMPORTANT: Best results are attained using the new 5th-order WENO advection option (4) for scalars:
! moist_adv_opt                       = 4,
! scalar_adv_opt                      = 4,
! (WENO = Weighted Essentially Non-Oscillatory)
!
! This module provides a 2-moment bulk microphysics scheme originally 
! developed by Conrad Ziegler (Zeigler, 1985, JAS) and modified/upgraded in 
! in Mansell, Zeigler, and Bruning (2010, JAS).  Two-moment adaptive sedimentation 
! follows Mansell (2010, JAS), using parameter infall = 4.
!
! Added info on graupel density and soaking is in Mansell and Ziegler (2013, JAS)
!
! Average graupel particle density is predicted, which affects fall speed as well. 
! Hail density prediction is by default disabled in this version, but may be enabled
! at some point if there is interest.
!
! Maintainer: Ted Mansell, National Severe Storms Laboratory <ted.mansell@noaa.gov>
!
! Microphysics References:
!
! Mansell, E. R., C. L. Ziegler, and E. C. Bruning, 2010: Simulated electrification of a small 
!   thunderstorm with two-moment bulk microphysics. J. Atmos. Sci., 67, 171-194, doi:10. 1175/2009JAS2965.1.
!
! Ziegler, C. L., 1985: Retrieval of thermal and microphysical variables in observed convective storms. 
!    Part I: Model development and preliminary testing. J. Atmos. Sci., 42, 1487-1509.
!
! Sedimentation reference:
!
! Mansell, E. R., 2010: On sedimentation and advection in multimoment bulk microphysics. 
!    J. Atmos. Sci., 67, 3084-3094, doi:10.1175/2010JAS3341.1.
!
! Possible parameters to adjust:
!
!  ccn : base cloud condensation nuclei concentration (use namelist.input value "nssl_cccn")
!  alphah, alphahl : Size distribution shape parameters for graupel (h) and hail (hl)
!  infall : changes sedimentation options to see effects (see below)
!
! lightning model references:
!
!    Fierro, A. O., E.R. Mansell, C. Ziegler and D. R. MacGorman 2013: The
!    implementation of an explicit charging and discharge lightning scheme
!    within the WRF-ARW model: Benchmark simulations of a continental squall line, a
!    tropical cyclone and a winter storm. Monthly Weather Review, Volume 141, 2390-2415 
!
!    Mansell et al. 2005: Charge structure and lightning sensitivity in a simulated 
!     multicell thunderstorm. J. Geophys. Res., 110, D12101, doi:10.1029/2004JD005287
!
! Note: Some parameters below apply to unreleased features.
!
!---------------------------------------------------------------------



MODULE module_mp_nssl_2mom

  IMPLICIT NONE
  
  public nssl_2mom_driver
  public nssl_2mom_init
  private gamma,gamxinf,GAML02, GAML02d300, GAML02d500, fqvs, fqis
  private gamma_dp
  private delbk, delabk
  private gammadp
  
  logical, private :: cleardiag = .false.
  PRIVATE

#ifdef WRF_CHEM
  integer, parameter :: wrfchem_flag = 1
#else
  integer, parameter :: wrfchem_flag = 0
#endif
  
  integer, private :: eqtset = 1 ! Flag for use with cm1 to use alternate equation set (changes latent heating rates)
   double precision, parameter, public :: zscale = 1.0d0 ! 1.000e-10
   double precision, parameter, public :: zscaleinv = 1.0d0/zscale ! 1.000e-10

  
  real, parameter :: warmonly = 0.0 ! testing parameter, set to 1.0 to reduce to warm-rain physics (ice variables stay zero)
  
  logical, parameter :: lwsm6 = .false. ! act like wsm6 for some single moment interactions

! some constants from WSM6
  real, parameter  :: dimax = 500.e-6    ! limited maximum value for the cloud-ice diamter
  real, parameter  :: roqimax = 2.08e22*dimax**8
  
! Params for dbz:
  integer  :: iuseferrier = 1  ! =1: use dry graupel only from Ferrier 1994; = 0: Use Smith (wet graupel)
  integer  :: idbzci      = 0
  integer  :: iusewetgraupel = 1 ! =1 to turn on use of QHW for graupel reflectivity (only for ZVDM -- mixedphase)
                                 ! =2 turn on for graupel density less than 300. only 
  integer  :: iusewethail = 0 ! =1 to turn on use of QHW for graupel reflectivity (only for ZVDM -- mixedphase)
  integer  :: iusewetsnow = 1 ! =1 to turn on diagnosed bright band

! microphysics

  real, public :: rho_qr = 1000., cnor = 8.0e5  ! cnor is set in namelist!!  rain params
  real, public :: rho_qs =  100., cnos = 3.0e6  ! set in namelist!!  snow params
  real, public :: rho_qh =  500., cnoh = 4.0e5  ! set in namelist!!  graupel params
  real, public :: rho_qhl=  900., cnohl = 4.0e4 ! set in namelist!!  hail params

  real, public :: hdnmn  = 170.0  ! minimum graupel density (for variable density graupel)
  real, public :: hldnmn = 500.0  ! minimum hail density (for variable density hail)

  real :: cnohmn  = 1.e-2 ! minimum intercept for 2-moment graupel (alphah < 0.5)
  real :: cnohlmn = 1.e-2 ! minimum intercept for 2-moment hail (alphahl < 0.5)
  
! Autoconversion parameters

  real   , private :: qcmincwrn      = 2.0e-3    ! qc threshold for autonconversion (LFO; for 10ICE use qminrncw for ircnw != 5)
  real   , private :: cwdiap         = 20.0e-6   ! threshold diameter of cloud drops (Ferrier 1994 autoconversion)
  real   , private :: cwdisp         = 0.15      ! assume droplet dispersion parameter (can be 0.3 for maritime)
  real   , public  :: ccn            = 0.6e+09   ! set in namelist!! Central plains CCN value
  real   , private :: qccn             ! ccn "mixing ratio"
  integer, private :: iauttim        = 1         ! 10-ice rain delay flag
  real   , private :: auttim         = 300.      ! 10-ice rain delay time
  real   , private :: qcwmntim       = 1.0e-5    ! 10-ice rain delay min qc for time accrual


! sedimentation flags
! itfall -> 0 = 1st order fallout (other options removed)
! iscfall, infall -> fallout options for charge and number concentration, respectively
!                    1 = mass-weighted fall speed; 2 = number-weighted fallspeed.
  integer, private :: itfall = 0
  integer, private :: iscfall = 1
  integer, private :: irfall = -1
  integer, public :: infall = 4   ! 0 -> uses number-wgt for N; NO correction applied (results in excessive size sorting)
                          ! 1 -> uses mass-weighted fallspeed for N ALWAYS
                          ! 2 -> uses number-wgt for N and mass-weighted correction for N (Method II in Mansell, 2010 JAS)
                          ! 3 -> uses number-wgt for N and Z-weighted correction for N (Method I in Mansell, 2010 JAS)
                          ! 4 -> Hybrid of 2 and 3: Uses minimum N from each method (z-wgt and m-wgt corrections) (Method I+II in Mansell, 2010 JAS)
                          ! 5 -> uses number-wgt for N and uses average of N-wgt and q-wgt instead of Max.
  real    :: rainfallfac = 1.0 ! factor to adjust rain fall speed (single moment only)
  integer, public :: icdx = 3 ! (graupel) 0=Ferrier; 1=leave drag coef. cd fixed; 2=vary by density, 4=set by user with cdxmin,cdxmax,etc.
  integer, public :: icdxhl = 3 ! (hail) 0=Ferrier; 1=leave drag coef. cd fixed; 2=vary by density, 4=set by user with cdxmin,cdxmax,etc.
  real   , private :: cdhmin = 0.45, cdhmax = 0.8        ! defaults for graupel (icdx=4)
  real   , private :: cdhdnmin = 500., cdhdnmax = 800.0  ! defaults for graupel (icdx=4)
  real   , private :: cdhlmin = 0.45, cdhlmax = 0.6      ! defaults for hail (icdx=4)
  real   , private :: cdhldnmin = 500., cdhldnmax = 800.0  ! defaults for hail (icdx=4)
  
  integer :: rssflg = 1   ! Rain size-sorting allowed (1, default), or disallowed (0).  If 0, sets N and Z-weighted fall speeds to q-weighted value
  integer :: sssflg = 1   ! As above but for snow
  integer :: hssflg = 1   ! As above but for graupel
  integer :: hlssflg = 1  ! As above but for hail

! input flags

  integer, private :: ndebug = -1, ncdebug = 0
  integer, private :: ipconc = 5
  integer, private :: ichaff = 0
  integer, private :: ilimit = 0
  
  real, private :: constccw = -1.

  real, private :: cimn = 1.0e3, cimx = 1.0e6


  real   , private :: ifrzg = 1.0 ! fraction of frozen drops going to graupel. 1=freeze all rain to graupel, 0=freeze all to hail
  real   , private :: ifrzs = 1.0 ! fraction of small frozen drops going to snow. 1=freeze rain to snow, 0=freeze to cloud ice
  integer, private :: irwfrz = 1 ! compute total rain that can freeze (checks heat budget)
  integer, private :: irimtim = 0 ! future use
!  integer, private :: infdo = 1   ! 1 = calculate number-weighted fall speeds

  real   , private :: rimc1 = 300.0, rimc2 = 0.44  ! rime density coeff. and power (Default Heymsfield and Pflaum, 1985)
  real   , private :: rimc3 = 170.0                ! minimum rime density
  real    :: rimc4 = 900.0                ! maximum rime density
  real   , private :: rimtim = 120.0               ! cut-off rime time (10ICE)
  real   , private :: eqtot = 1.0e-9               ! threshold for mass budget reporting

  integer, private :: ireadmic = 0

  integer, private :: iccwflg = 1     ! sets max size of first droplets in parcel to 4 micron radius (in two-moment liquid)
                             ! (first nucleation is done with a KW sat. adj. step)
  integer, private :: issfilt = 0     ! flag to turn on filtering of supersaturation field
  integer, public :: irenuc = 2      ! =1 to always allow renucleation of droplets within the cloud
                                      ! =2 renucleation following Twomey/Cohard&Pinty
                             ! i.e., not only at cloud base
  integer, private :: irenuc3d = 0      ! =1 to include horizontal gradient in renucleation of droplets within the cloud
  real    :: renucfrac = 0.0 ! = 0 : cnuc = cwccn
                             ! = 1 : cnuc = actual available CCN
                             ! otherwise cnuc = cwccn*(1. - renufrac) + ccnc(1:ngscnt)*renucfrac
  real   , private :: cck = 0.6       ! exponent in Twomey expression
  real   , private :: ciintmx = 1.0e6

  real   , private :: cwccn ! , cwmasn,cwmasx
  real   , private :: ccwmx

  integer, private :: idocw = 1, idorw = 1, idoci = 1, idoir = 1, idoip = 1, idosw = 1
  integer, private :: idogl = 1, idogm = 1, idogh = 1, idofw = 1, idohw = 1, idohl = 1
!  integer, private :: ido(3:14) = / 12*1 /


! 0,2, 5.00e-10, 1, 0, 0, 0      : itype1,itype2,cimas0,icfn,ihrn,ibfc,iacr
  integer, public :: itype1 = 0, itype2 = 2  ! controls Hallett-Mossop process
  integer, public :: icenucopt = 3       ! =1 Meyers/Ferrier primary ice nucleation; =2 Thompson/Cooper, =3 Phillips (Meyers/Demott)
  integer, private :: icfn = 2                ! contact freezing: 0 = off; 1 = hack (ok for single moment); 2 = full Cotton/Meyers version
  integer, private :: ihrn = 0            ! Hobbs-Rangno ice multiplication (Ferrier, 1994; use in 10-ice only)
  integer, public :: ibfc = 1            ! Flag to use Bigg freezing on droplets (0 = off (uses alternate freezing), 1 = on)
  integer, public :: iacr = 2            ! Flag for drop contact freezing with crytals
                                 ! (0=off; 1=drops > 500micron diameter; 2 = > 300micron)
  integer, private :: ibfr = 2            ! Flag for Bigg freezing conversion of freezing drops to graupel
                                 ! (1=min graupel size is vr1mm; 2=use min size of dfrz, 5= as for 2 and apply dbz conservation)
  integer, public :: ibiggopt = 1        ! 1 = old Bigg; 2 = experimental Bigg (only for imurain = 1, however)
  integer, public :: iacrsize = 5        ! assumed min size of drops freezing by capture
                                 !  1: > 500 micron diam
                                 !  2: > 300 micron
                                 !  3: > 40 micron
                                 !  4: all sizes
                                 !  5: > 150 micron (only for imurain = 1)
  real   , private :: cimas0 = 6.62e-11   ! default mass of Hallett-Mossop crystals
                                 ! 6.62e-11kg results in half the diam. (60 microns) of old default value of 5.0e-10
  real   , private :: cimas1 = 6.88e-13   ! default mass of new ice crystals
  real   , private :: splintermass = 6.88e-13
  real   , private :: cfnfac = 0.1        ! Hack factor that goes with icfn=1
  integer, private :: iscni = 4           ! default option for ice crystal aggregation/conversion to snow
  logical, private :: imeyers5 = .false.  ! .false.=off, true=on for Meyers ice nucleation for temp > -5 C
  real   , private :: dmincw = 15.0e-6    ! minimum droplet diameter for collection for iehw=3
  integer, public :: iehw = 1            ! 0 -> ehw=ehw0; 1 -> old ehw; 2 -> test ehw with Mason table data
  integer, public :: iehlw = 1           ! 0 -> ehlw=ehlw0; 1 -> old ehlw; 2 -> test ehlw with Mason table data
                                 ! For ehw/ehlw = 1, ehw0/ehlw0 act as maximum limit on collection efficiency (defaults are 1.0)
  integer, private :: ierw = 1            ! for single-moment rain (LFO/Z)
  real   , public :: ehw0 = 0.75          ! constant or max assumed graupel-droplet collection efficiency
  real   , private :: erw0 = 1.0          ! constant assumed rain-droplet collection efficiency
  real   , public :: ehlw0 = 0.75        ! constant or max assumed hail-droplet collection efficiency
  real    :: ehr0 = 1.0          ! constant or max assumed graupel-rain collection efficiency
  real    :: ehlr0 = 1.0         ! constant or max assumed hail-rain collection efficiency
  

  real   , private :: esilfo0 = 1.0       ! factor for LFO collection efficiency of snow for cloud ice.
  real   , private :: ehslfo0 = 1.0       ! factor for LFO collection efficiency of hail/graupel for snow.

  integer, private :: ircnw    = 5        ! single-moment warm-rain autoconversion option.  5= Ferrier 1994.
  real   , private :: qminrncw = 2.0e-3   ! qc threshold for rain autoconversion (NA for ircnw=5)

  integer, private :: iqcinit = 2         ! For ZVDxx schemes, flag to choose which way to initialize droplets
                                 ! 1 = Soong-Ogura adjustment
                                 ! 2 = Saturation adjustment to value of ssmxinit
                                 ! 3 = KW adjustment

  real   , private :: ssmxinit = 0.4      ! saturation percentage to adjust down to for initial cloud
                                 ! formation (ZVDxx scheme only)

  real   , private :: ewfac = 1.0         ! hack factor applied to graupel and hail collection eff. for droplets
  real   , private :: eii0 = 0.1 ,eii1 = 0.1  ! graupel-crystal coll. eff. parameters: eii0*exp(eii1*min(temcg(mgs),0.0))
                                     ! set eii1 = 0 to get a constant value of eii0
  real   , public :: eii0hl = 0.2 ,eii1hl = 0.0  ! hail-crystal coll. eff. parameters: eii0hl*exp(eii1hl*min(temcg(mgs),0.0))
                                     ! set eii1hl = 0 to get a constant value of eii0hl
  real   , public :: eri0 = 0.1   ! rain efficiency to collect ice crystals
  real   , private :: ehs0 = 0.1 ,ehs1 = 0.1  ! graupel-snow coll. eff. parameters: ehs0*exp(ehs1*min(temcg(mgs),0.0))
                                     ! set ehs1 = 0 to get a constant value of ehs0
  real   , private :: ess0 = 1.0 ,ess1 = 0.05 ! snow aggregation coefficients: ess0*exp(ess1*min(temcg(mgs),0.0))
                                     ! set ess1 = 0 to get a constant value of ess0
  real   , public :: esstem1 = -25.  ! lower temperature where snow aggregation turns on
  real   , public :: esstem2 = -20.  ! higher temperature for linear ramp of ess from zero at esstem1 to formula value at esstem2
  real   , private :: ehsfrac = 1.0           ! multiplier for graupel collection efficiency in wet growth
  real   , private :: ehimin = 0.0 ! Minimum collection efficiency (graupel - ice crystal)
  real   , private :: ehimax = 1.0 ! Maximum collection efficiency (graupel - ice crystal)
  real   , private :: ehsmax = 0.5 ! Maximum collection efficiency (graupel - snow)
  real   , private :: ecollmx = 0.5 ! Maximum collision efficiency for graup/hail with ice; used only for charging rates
  integer, private :: iglcnvi = 3  ! flag for riming conversion from cloud ice to rimed ice/graupel
  integer, private :: iglcnvs = 3  ! flag for conversion from snow to rimed ice/graupel

  real   , private :: rz          ! reflectivity conservation factor for graupel/rain
                         ! now calculated in icezvd_dr.F from alphah and rnu
                         ! currently only used for graupel melting to rain
  real   , private :: rzhl        ! reflectivity conservation factor for hail/rain
                         ! now calculated in icezvd_dr.F from alphahl and rnu

  real   , private :: rzs     ! reflectivity conservation factor for snow(imusnow=3) with rain (imurain=1)

  real   , private :: alphahacx = 0.0 ! assumed minimum shape parameter for zhacw and zhacr

  real   , private :: fconv = 1.0  ! factor to boost max graupel depletion by riming conversions in 10ICE

  real   , private :: rg0 = 400.0  ! reference graupel density for graupel fall speed

  integer, private :: rcond = 2    ! (Z only) rcond = 2 includes rain condensation in loop with droplet condensation
                                   ! 0 = no condensation on rain; 1 = bulk condensation on rain
  integer, parameter, private :: icond = 1    ! (Z only) icond = 1 calculates ice deposition (crystals and snow) BEFORE droplet condensation
                          ! icond = 2 does not work (intended to calc. dep in loop with droplet cond.)
  
  real   , public :: dfrz = 0.15e-3 ! 0.25e-3  ! minimum diameter of frozen drops from Bigg freezing (used for vfrz) for iacr > 1
                            ! and for ciacrf for iacr=4
  real   , public :: dmlt = 3.0e-3  ! maximum diameter for rain melting from graupel and hail
  real   , public :: dshd = 1.0e-3  ! nominal diameter for drops shed from graupel/hail

  integer, public :: ihmlt = 2      ! 1=old melting with vmlt; 2=new melting using mean volume diam of graupel/hail
  integer, public :: imltshddmr = 0 ! 0 (default)=mean diameter of drops produced during melting+shedding as before (using mean diameter of graupel/hail
                            ! and max mean diameter of rain)
                            ! 1=new method where mean diameter of rain during melting is adjusted linearly downward 
                            ! toward 3 mm for large (> sheddiam) graupel and hail, to take into account shedding of 
                            ! smaller drops.  sheddiam0 controls the size of graupel/hail above which the assumed 
                            ! mean diameter of rain is set to 3 mm
                            ! Only valid for ihmlt = 2 for ZVD(H) but also applies to ZVD(H)M


  integer, private :: nsplinter = 0  ! number of ice splinters per freezing drop, if negative, then per resulting graupel particle
  integer, private :: isnwfrac = 0   ! 0= no snow fragmentation; 1 = turn on snow fragmentation (Schuur, 2000)

!  integer, private :: denscale = 1  ! 1=scale num. conc. and charge by air density for advection, 0=turn off for comparison

  logical, private :: mixedphase = .false.   ! .false.=off, true=on to include mixed phase graupel
  integer, private :: imixedphase = 0
  logical, private :: qsdenmod = .false.     ! true = modify snow density by linear interpolation of snow and rain density
  logical, private :: qhdenmod = .false.     ! true = modify graupel density by linear interpolation of graupel and rain density
  logical, private :: qsvtmod = .false.      ! true = modify snow fall speed by linear interpolation of snow and rain vt
  real   , private :: sheddiam   = 8.0e-03  ! minimum diameter of graupel before shedding occurs
  real    :: sheddiamlg = 10.0e-03  ! diameter of hail to use fwmlarge
  real    :: sheddiam0  = 20.0e-03  ! diameter of hail at which all water is shed

  real   , private :: fwms = 0.5 ! maximum liquid water fraction on snow
  real   , private :: fwmh = 0.5 ! maximum liquid water fraction on graupel
  real   , private :: fwmhl = 0.5 ! maximum liquid water fraction on hail
  real    :: fwmlarge = 0.2 ! maximum liquid water fraction on hail larger than sheddiam
  integer :: ifwmfall = 0   ! whether to interpolate toward rain fall speed for graupel and hail
                            ! when diam < sheddiam and liquid fraction is predicted (0=no, 1=yes)
  
  logical :: rescale_high_alpha = .false.  ! whether to rescale number. conc. when alpha = alphamax (3-moment only)
  logical :: rescale_low_alpha = .true.    ! whether to rescale Z (graupel/hail) when alpha = alphamin (3-moment only)
  logical :: rescale_low_alphar = .true.    ! whether to rescale Z for rain when alpha = alphamin (3-moment only)

  real, parameter :: alpharmax = 8. ! limited for rwvent calculation
  
  integer, private ::  ihlcnh = 1  ! which graupel -> hail conversion to use
                          ! 1 = Milbrandt and Yau (2005) using Ziegler 1985 wet growth diameter
                          ! 2 = Straka and Mansell (2005) conversion using size threshold
  real, public :: hlcnhdia = 1.e-3 ! threshold diameter for graupel -> hail conversion for ihlcnh = 1 option.
  real, public :: hlcnhqmin = 0.1e-3 ! minimum graupel mass content for graupel -> hail conversion (ihlcnh = 1)
  real   , private :: hldia1 = 20.0e-3  ! threshold diameter for graupel -> hail conversion for ihlcnh = 2 option.
  integer :: icvhl2h = 0   ! allow conversion of hail back to graupel when hail density gets close to minimum allowed

  integer, public :: imurain = 1 ! 3 for gamma-volume, 1 for gamma-diameter DSD for rain.
  integer, public :: imusnow = 3 ! 3 for gamma-volume, 1 for gamma-diameter DSD for snow (=1 NOT IMPLEMENTED!!).
  integer :: iturbenhance = 0 ! enhancement of rain self-collection by turbulence
  integer, public :: isedonly = 0 ! 1= only do sedimentation and skip other microphysics
  integer, public :: iferwisventr = 2 ! =1 for Ferrier rwvent, =2 for Wisner rwvent (imurain=1)
  integer, public :: izwisventr   = 2 ! =1 for old Ziegler rwvent, =2 for Wisner-style rwvent (imurain=3)
  integer :: iresetmoments = 0 ! if >0, then set all moments to zero when one of them is zero (3-moment only)
  integer, public :: imaxdiaopt    = 3 ! = 1 use mean diameter for breakup
                               ! = 2 use maximum mass diameter for breakup
                               ! = 3 use mass-weighted diameter for breakup
  integer, public :: dmrauto       = 0 ! = -1 no limiter on crcnw
                              ! =  0 limit crcnw when qr > 1.2*L (Cohard-Pinty 2002)
                              ! =  1 DTD version based on MY code
                              ! =  2 DTD mass-weighted version based on MY code
                              ! =  3 Milbrandt version (from Cohard and Pinty's code
  real, parameter :: alpharaut = 0.0 ! MY2005 for autoconversion
  real    :: cxmin = 1.e-4  ! threshold cutoff for number concentration
  real    :: zxmin = 1.e-28 ! threshold cutoff for reflectivity moment
  
  integer :: ithompsoncnoh = 0 ! For single moment graupel only
                           ! 0 = fixed intercept
                           ! 1 = intercept based on graupel mass

  integer :: ivhmltsoak = 1   ! 0=off, 1=on : flag to simulate soaking (graupel/hail) during melting 
                         ! when liquid fraction is not predicted
  integer, public :: ioldlimiter = 0 ! test switch for new(=0) or old(=1) size limiter at the end of GS for 3-moment categories
  integer, public  :: isnowfall = 2   ! Option for choosing between snow fall speed parameters
                         ! 1 = original Zrnic et al. (Mansell et al. 2010)
                         ! 2 = Ferrier 1994 (results in slower fall speeds)
  
  integer, public  :: ibiggsnow   = 3 ! 1 = switch conversion over to snow for small frozen drops from Bigg freezing
                                       ! 2 = switch conversion over to snow for small frozen drops from rain-ice interaction
                                       ! 3 = switch conversion over to snow for small frozen drops from both
  
  integer, public  :: ixtaltype = 1 ! =1 column, =2 disk (similar to Takahashi)
  
  real, public     :: evapfac     = 1.0 ! Multiplier on rain evaporation rate

  integer, public :: ibinhmlr = 0  ! =1 use incomplete gammas to determine melting from larger and smaller sizes of graupel, and appropriate shed drop sizes 
                           ! =2 to test melting by temporary bins
  integer, public :: ibinhlmlr = 0  ! =1 use incomplete gammas to determine melting from larger and smaller sizes of hail, and appropriate shed drop sizes 
                            ! =2 to test melting by temporary bins
  


  integer, parameter :: lqmx = 30
  integer, parameter :: lt = 1
  integer, parameter :: lv = 2
  integer, parameter :: lc = 3
  integer, parameter :: lr = 4
  integer, parameter :: li = 5
  integer, parameter :: ls = 6
  integer, parameter :: lh = 7
  integer :: lhl = 0

  integer, public  :: lccn = 9 ! 0 or 9, other indices adjusted accordingly
  integer, private :: lccna = 0
  integer, private :: lcina = 0
  integer, private :: lcin = 0
  integer, private :: lnc = 9
  integer, private :: lnr = 10
  integer, private :: lni = 11
  integer, private :: lns = 12
  integer, private :: lnh = 13
  integer, private :: lnhl = 0
  integer, private :: lss = 0
  integer :: lvh = 15

  integer, private :: lhab = 8
  integer, private :: lg = 7

! Particle volume

  integer :: lvi = 0
  integer :: lvs = 0
  integer :: lvgl = 0
  integer :: lvgm = 0
  integer :: lvgh = 0
  integer :: lvf = 0
!  integer :: lvh = 16
  integer :: lvhl = 0

! liquid water fraction (not predicted here but tested for)
  integer :: lhw = 0
  integer :: lsw = 0
  integer :: lhlw = 0

! reflectivity (6th moment) ! not predicted here but may be tested against

  integer :: lzr = 0
  integer :: lzi = 0
  integer :: lzs = 0
  integer :: lzgl = 0
  integer :: lzgm = 0
  integer :: lzgh = 0
  integer :: lzf = 0
  integer :: lzh = 0
  integer :: lzhl = 0

! Space charge

  integer :: lscw = 0
  integer :: lscr = 0
  integer :: lsci = 0
  integer :: lscs = 0
  integer :: lsch = 0
  integer :: lschl = 0
  integer :: lscwi = 0
  integer :: lscpi = 0
  integer :: lscni = 0
  integer :: lscpli = 0
  integer :: lscnli = 0
  integer :: lschab = 0

  integer :: lscb = 0
  integer :: lsce = 0
  integer :: lsceq = 0

!  integer, parameter :: lscmx = 100

  integer :: lne = 0 ! last varible for transforming

  real :: cnoh0 = 4.0e+5
  real :: hwdn1 = 700.0

  real    :: alphai  = 0.0 ! shape parameter for ZIEG ice crystals ! not currently used
  real    :: alphas  = 0.0 ! shape parameter for ZIEG snow         ! used only for single moment
  real    :: alphar  = 0.0 ! shape parameter for rain (imurain=1 only)
  real, public    :: alphah  = 0.0 ! set in namelist!! shape parameter for ZIEG graupel
  real, public    :: alphahl = 1.0 ! set in namelist!! shape parameter for ZIEG hail

  real    :: dmuh    = 1.0  ! power in exponential part (graupel)
  real    :: dmuhl   = 1.0  ! power in exponential part (hail)

  real, parameter :: alphamax = 15.
  real, parameter :: alphamin = 0.
  real, parameter :: rnumin = -0.8
  real, parameter :: rnumax = 15.0

  
  real            :: cnu = 0.0
  real, parameter :: rnu = -0.8, snu = -0.8, cinu = 0.0
!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
  
  real xnu(lc:lqmx) ! 1st shape parameter (mass)
  real xmu(lc:lqmx) ! 2nd shape parameter (mass)
  real dnu(lc:lqmx) ! 1st shape parameter (diameter)
  real dmu(lc:lqmx) ! 2nd shape parameter (diameter)
  
  real ax(lc:lqmx)
  real bx(lc:lqmx)
  real fx(lc:lqmx)

      real da0 (lc:lqmx)          ! collection coefficients from Seifert 2005
      real dab0(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
      real dab1(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
      real da1 (lc:lqmx)          ! collection coefficients from Seifert 2005
      real bb  (lc:lqmx)

! put ipelec here for now....
  integer :: ipelec = 0
  integer :: isaund = 0
  logical :: idonic = .false.
      real, private    :: delqnw = -1.0e-10!-1.0e-12 !
      real, private    :: delqxw =  1.0e-10! 1.0e-12 !
      real :: tindmn = 233, tindmx = 298.0  ! min and max temperatures where inductive charging is allowed

!
!  gamma function lookup table
!
      integer ngm0,ngm1,ngm2
      parameter (ngm0=3001,ngm1=500,ngm2=500)
      double precision, parameter :: dgam = 0.01, dgami = 100.
      double precision gmoi(0:ngm0) ! ,gmod(0:ngm1,0:ngm2),gmdi(0:ngm1,0:ngm2)

      integer, parameter :: nqiacralpha = 120 ! 15
      integer, parameter :: nqiacrratio =  50 ! 25
      real,    parameter :: dqiacralpha = 15./Float(nqiacralpha), dqiacrratio = 25./Float(nqiacrratio) 
      real,    parameter :: dqiacrratioinv = 1./dqiacrratio, dqiacralphainv = 1./dqiacralpha
      real :: ciacrratio(0:nqiacrratio,0:nqiacralpha)
      real :: qiacrratio(0:nqiacrratio,0:nqiacralpha)
      double precision :: gamxinflu(0:nqiacrratio,0:nqiacralpha,8,2) ! last index for graupel (1) or hail (2)

    integer, parameter :: ngdnmm = 9
    real :: mmgraupvt(ngdnmm,3)  ! Milbrandt and Morrison (2013) fall speed coefficients for graupel/hail

    DATA mmgraupvt(:,1) / 50., 150., 250., 350., 450., 550., 650., 750., 850./
    DATA mmgraupvt(:,2) / 62.923, 94.122, 114.74, 131.21, 145.26, 157.71, 168.98, 179.36, 189.02 /
    DATA mmgraupvt(:,3) / 0.67819, 0.63789, 0.62197, 0.61240, 0.60572, 0.60066, 0.59663, 0.59330, 0.59048 /

      integer lsc(lc:lqmx)
      integer ln(lc:lqmx)
      integer ipc(lc:lqmx)
      integer lvol(lc:lqmx)
      integer lz(lc:lqmx)
      integer lliq(ls:lqmx)
      integer denscale(lc:lqmx) ! flag for density scaling (mixing ratio conversion)

      integer ido(lc:lqmx)
      logical ldovol

      real xdn0(lc:lqmx)
      real xdnmx(lc:lqmx), xdnmn(lc:lqmx)
      real cdx(lc:lqmx)
      real cno(lc:lqmx)
      real xvmn(lc:lqmx), xvmx(lc:lqmx)
      real qxmin(lc:lqmx)

      integer nqsat
      parameter (nqsat=1000001) ! (nqsat=20001)
      real fqsat,fqsati
      parameter (fqsat=0.002,fqsati=1./fqsat)
      real tabqvs(nqsat),tabqis(nqsat),dtabqvs(nqsat),dtabqis(nqsat)

!
!  constants
!
      real, parameter :: cp608 = 0.608          ! constant used in conversion of T to Tv
      real, parameter :: ar = 841.99666         ! rain terminal velocity power law coefficient (LFO)
      real, parameter :: br = 0.8               ! rain terminal velocity power law coefficient (LFO)
      real, parameter :: aradcw = -0.27544      !
      real, parameter :: bradcw = 0.26249e+06   !
      real, parameter :: cradcw = -1.8896e+10   !
      real, parameter :: dradcw = 4.4626e+14    !
      real, parameter :: bta1 = 0.6             ! beta-1 constant used for ice nucleation by deposition (Ferrier 94, among others)
      real, parameter :: cnit = 1.0e-02         ! No for ice nucleation by deposition (Cotton et al. 86)
      real, parameter :: dragh = 0.60           ! coefficient used to adjust fall speed for hail versus graupel (Pruppacher and Klett 78)
      real, parameter :: dnz00 = 1.225          ! reference/MSL air density
      real, parameter :: rho00 = 1.225          ! reference/MSL air density
!      cs = 4.83607122       ! snow terminal velocity power law coefficient (LFO)
!      ds = 0.25             ! snow terminal velocity power law coefficient (LFO)
!  new values for  cs and ds
      real, parameter :: cs = 12.42             ! snow terminal velocity power law coefficient 
      real, parameter :: ds = 0.42              ! snow terminal velocity power law coefficient 
      real, parameter :: pi = 3.141592653589793
      real, parameter :: piinv = 1./pi
      real, parameter :: pid4 = pi/4.0

      real, parameter :: gr = 9.8

!
! max and min mean volumes
!
      real xvrmn, xvrmx0  ! min, max rain volumes
      real xvsmn, xvsmx  ! min, max snow volumes
      real xvfmn, xvfmx  ! min, max frozen drop volumes
      real xvgmn, xvgmx  ! min, max graupel volumes
      real xvhmn, xvhmn0, xvhmx, xvhmx0  ! min, max hail volumes
      real xvhlmn, xvhlmx  ! min, max lg hail volumes

      real, parameter :: dhlmn = 0.3e-3, dhlmx = 40.e-3
      real, parameter :: dhmn0 = 0.3e-3
      real, public :: dhmn = dhmn0, dhmx = -1.

      real, parameter :: cwradn = 2.5e-6, xcradmn = cwradn    ! minimum radius
      real, parameter :: cwradx = 40.e-6, xcradmx = cwradx    ! maximum radius
      real, parameter :: cwc1 = 6.0/(pi*1000.)

!      parameter( xvcmn=4.188e-18 )   ! mks  min volume = 3 micron radius
      real, parameter :: xvcmn=0.523599*(2.*cwradn)**3    ! mks  min volume = 2.5 micron radius
      real, parameter :: xvcmx=0.523599*(2.*xcradmx)**3    ! mks  min volume = 2.5 micron radius
      real, parameter :: cwmasn = 1000.*xvcmn   ! minimum mass, defined by radius of 5.0e-6
      real, parameter :: cwmasx = 1000.*xvcmx   ! maximum mass, defined by radius of 50.0e-6
      real, parameter :: cwmasn5 = 1000.*0.523599*(2.*5.0e-6)**3 !  5.23e-13

      real, parameter :: xvimn=0.523599*(2.*5.e-6)**3    ! mks  min volume = 5 micron radius
      real, parameter :: xvimx=0.523599*(2.*1.e-3)**3    ! mks  max volume = 1 mm radius (solid sphere approx)
      
      real     :: xvdmx = -1.0 ! 3.0e-3
      real     :: xvrmx
      parameter( xvrmn=0.523599*(80.e-6)**3, xvrmx0=0.523599*(6.e-3)**3 ) !( was 4.1887e-9 )  ! mks
      parameter( xvsmn=0.523599*(0.1e-3)**3, xvsmx=0.523599*(10.e-3)**3 ) !( was 4.1887e-9 )  ! mks
      parameter( xvfmn=0.523599*(0.1e-3)**3, xvfmx=0.523599*(10.e-3)**3 )  ! mks xvfmx = (pi/6)*(10mm)**3
      parameter( xvgmn=0.523599*(0.1e-3)**3, xvgmx=0.523599*(10.e-3)**3 )  ! mks xvfmx = (pi/6)*(10mm)**3
      parameter( xvhmn0=0.523599*(0.3e-3)**3, xvhmx0=0.523599*(20.e-3)**3 )  ! mks xvfmx = (pi/6)*(10mm)**3
      parameter( xvhlmn=0.523599*(dhlmn)**3, xvhlmx=0.523599*(dhlmx)**3 )  ! mks xvfmx = (pi/6)*(10mm)**3

!
!  electrical permitivity of air C / (N m**2) -  check the units
!
      real eperao
      parameter (eperao  = 8.8592e-12 )

      real ec,eci  ! fundamental unit of charge
      parameter (ec = 1.602e-19)
      parameter (eci = 1.0/ec)

      real    :: scwppmx = 20.0e-12
      real    :: scippmx = 20.0e-12
!
!  constants
!
      real, parameter :: c1f3 = 1.0/3.0

      real, parameter :: cai = 21.87455
      real, parameter :: caw = 17.2693882
      real, parameter :: cbi = 7.66
      real, parameter :: cbw = 35.86

      real, parameter :: tfr = 273.15, tfrh = 233.15

      real, parameter :: cp = 1004.0, rd = 287.04
      real, parameter :: cpi = 1./cp
      real, parameter :: cap = rd/cp, poo = 1.0e+05

      real, parameter :: rw = 461.5              ! gas const. for water vapor
      real, parameter :: advisc0 = 1.832e-05     ! reference dynamic viscosity (SMT; see Beard & Pruppacher 71)
      real, parameter :: advisc1 = 1.718e-05     ! dynamic viscosity constant used in thermal conductivity calc
      real, parameter :: tka0 = 2.43e-02         ! reference thermal conductivity
      real, parameter :: tfrcbw = tfr - cbw
      real, parameter :: tfrcbi = tfr - cbi

     ! GHB: Needed for eqtset=2 in cm1
!     REAL, PRIVATE ::      cv = cp - rd
     real, private, parameter ::      cv = 717.0             ! specific heat at constant volume - air
     REAL, PRIVATE, parameter ::      cvv = 1408.5
     REAL, PRIVATE, parameter ::      cpl = 4190.0
     REAL, PRIVATE, parameter ::      cpigb = 2106.0
     ! GHB

      real, parameter ::  bfnu0 = (rnu + 2.0)/(rnu + 1.0) 
      real :: ventr, ventrn, ventc, c1sw


      real :: cckm,ccne,ccnefac,cnexp,CCNE0

      integer :: na = 9
      integer :: nxtra = 1
      real gf4p5, gf4ds, gf4br
      real gsnow1, gsnow53, gsnow73
      real gfcinu1, gfcinu1p47, gfcinu2p47

      real :: cwchtmp0 = 1.0
      real :: cwchltmp0 = 1.0

      real    :: esctot = 1.0e-13

      integer iexy(lc:lqmx,lc:lqmx)
      integer :: ieswi = 1,  ieswc = 1, ieswr = 0
      integer :: iehlsw = 1, iehli = 1,  iehlc = 1, iehlr = 0
      integer :: iehwsw = 1, iehwi = 1,  iehwc = 1, iehwr = 0

      logical, parameter :: do_satadj_for_wrfchem = .true.

! #####################################################################
! #####################################################################

 CONTAINS

! #####################################################################
! #####################################################################

 REAL FUNCTION fqvs(t)
  implicit none
  real :: t
  fqvs = exp(caw*(t-273.15)/(t-cbw))
 END FUNCTION fqvs

 REAL FUNCTION fqis(t)
  implicit none
  real :: t
  fqis = exp(cai*(t-273.15)/(t-cbi))
 END FUNCTION fqis

! #####################################################################
 
       SUBROUTINE nssl_2mom_init(  &
     & ipctmp, mixphase,ihvol,idonictmp,eqtset_tmp)

  implicit none
  
   integer, optional, intent(in) :: eqtset_tmp


   integer, intent(in) :: ipctmp,mixphase,ihvol
   logical, optional, intent(in) :: idonictmp
     double precision :: arg
     real    :: temq
     integer :: igam
     integer :: i,il,j,l
     integer :: ltmp
     integer :: isub
     real    :: bxh,bxhl

      real    :: alp,ratio,x,y
     


!
! set some global values from namelist input
!
!      open(unit=20,file='namelist.input',form='formatted',status='old',    &
!           access='sequential')
!         read(20,nml=micro_params)
!      close(unit=20)

      IF ( present( eqtset_tmp ) ) eqtset = eqtset_tmp



      cwccn = ccn

      lhab = 8
      lhl = 8
      IF ( ihvol == -1 ) THEN
        lhab = 7  ! turns off hail -- option for single moment, only!!
        lhl = 0
      ENDIF

!      IF ( ipelec > 0 ) idonic = .true.

!
! Build lookup table for saturation mixing ratio (Soong and Ogura 73)
!

      do l = 1,nqsat
      temq = 163.15 + (l-1)*fqsat
      tabqvs(l) = exp(caw*(temq-273.15)/(temq-cbw))
      dtabqvs(l) = ((-caw*(-273.15 + temq))/(temq - cbw)**2 + &
     &                 caw/(temq - cbw))*tabqvs(l)
      tabqis(l) = exp(cai*(temq-273.15)/(temq-cbi))
      dtabqis(l) = ((-cai*(-273.15 + temq))/(temq - cbi)**2 + &
     &                 cai/(temq - cbi))*tabqis(l)
      end do

      bx(lr) = 0.85
      ax(lr) = 1647.81
      fx(lr) = 135.477
      
      IF ( icdx > 0 ) THEN
        bx(lh) = 0.5
        ax(lh) = 75.7149
      ELSE
        bx(lh) = 0.37 ! 0.6
        ax(lh) = 19.3
      ENDIF
!      bx(lh) = 0.6

      IF ( lhl .gt. 1 ) THEN
        IF (icdxhl > 0 ) THEN
         bx(lhl) = 0.5
         ax(lhl) = 75.7149
        ELSE
        ax(lhl) = 206.984
        bx(lhl) = 0.6384
        ENDIF
      ENDIF

! fill in the complete gamma function lookup table
     gmoi(0) = 1.d32
     do igam = 1,ngm0
      arg = dgam*igam
      gmoi(igam) = gamma_dp(arg)
     end do

     ! build lookup table to compute the number and mass fractions of rain drops 
     ! (imurain=1) greater than a given diameter. Used for qiacr and ciacr
     ! Uses incomplete gamma functions
      
      bxh = bx(lh)
      bxhl = bx(Max(lh,lhl))
      
      DO j = 0,nqiacralpha
      alp = float(j)*dqiacralpha
      y = gamma(1.+alp)
      DO i = 1,nqiacrratio
        ratio = float(i)*dqiacrratio
        x = gamxinf( 1.+alp, ratio )
!        write(0,*) 'i, x/y = ',i, x/y
        ciacrratio(i,j) = x/y

        gamxinflu(i,j,1,1) = x/y
        gamxinflu(i,j,2,1) = gamxinf( 2.0+alp, ratio )/y
        gamxinflu(i,j,3,1) = gamxinf( 2.5+alp+0.5*bxh, ratio )/y
        gamxinflu(i,j,5,1) = gamxinf( 5.0+alp, ratio )/y
        gamxinflu(i,j,6,1) = gamxinf( 5.5+alp+0.5*bxh, ratio )/y
        
        gamxinflu(i,j,1,2) = gamxinflu(i,j,1,1)
        gamxinflu(i,j,2,2) = gamxinflu(i,j,2,1)
        gamxinflu(i,j,3,2) = gamxinf( 2.5+alp+0.5*bxhl, ratio )/y
        gamxinflu(i,j,5,2) = gamxinflu(i,j,5,1)
        gamxinflu(i,j,6,2) = gamxinf( 5.5+alp+0.5*bxhl, ratio )/y

      IF ( alp > 1.1 ) THEN
       gamxinflu(i,j,7,1) = gamxinf( alp - 1., ratio )/y
       gamxinflu(i,j,8,1) = gamxinf( alp - 0.5 + 0.5*bxh, ratio )/y
       gamxinflu(i,j,8,2) = gamxinf( alp - 0.5 + 0.5*bxhl, ratio )/y
      ELSE
       gamxinflu(i,j,7,1) = gamxinf( .1, ratio )/y
       gamxinflu(i,j,8,1) = gamxinf( 1.1 - 0.5 + 0.5*bxh, ratio )/y
       gamxinflu(i,j,8,2) = gamxinf( 1.1 - 0.5 + 0.5*bxhl, ratio )/y
      ENDIF
        
        gamxinflu(i,j,7,2) = gamxinflu(i,j,7,1)

      ENDDO
      ENDDO
      ciacrratio(0,:) = 1.0

      DO j = 0,nqiacralpha
      alp = float(j)*dqiacralpha
      y = gamma(4.+alp)
      DO i = 1,nqiacrratio
        ratio = float(i)*dqiacrratio
        x = gamxinf( 4.+alp, ratio )
!        write(0,*) 'i, x/y = ',i, x/y
        qiacrratio(i,j) = x/y
        gamxinflu(i,j,4,1) = x/y
        gamxinflu(i,j,4,2) = x/y

      ENDDO
      ENDDO
      qiacrratio(0,:) = 1.0


      isub = Min( 0, ihvol) ! is -1 or 0

      lccn = 0
      lccna = 0
      lnc = 0
      lnr = 0
      lni = 0
      lns = 0
      lnh = 0
      lnhl = 0
      lvh = 0
      lvhl = 0
      lzr = 0
      lzh = 0
      lzhl = 0
      lsw = 0
      lhw = 0
      lhlw = 0

      denscale(:) = 0
      
!      lccn = 9

    ipconc = ipctmp

    IF ( ipconc == 0 ) THEN
       IF ( ihvol >= 0 ) THEN
       lvh = 9
       ltmp = 9
       denscale(lvh) = 1
       ELSE ! no hail
       ltmp = lhab
       lhl = 0
       ENDIF
    ELSEIF ( ipconc == 5 ) THEN
      lccn = lhab+1 ! 9
      lnc = lhab+2 ! 10
      lnr = lhab+3 ! 11
      lni = lhab+4 !12
      lns = lhab+5 !13
      lnh = lhab+6 !14
      IF ( ihvol >= 0 ) THEN
      lnhl = lhab+7 ! 15
      ENDIF
      lvh = lhab+8 + isub ! 16 + isub ! isub adjusts to 15 if hail is off
      ltmp = lvh
      denscale(lccn:lvh) = 1
      IF ( ihvol == 1 ) THEN
       lvhl = ltmp+1
       ltmp = lvhl
       denscale(lvhl) = 1
      ENDIF
      IF ( mixedphase ) THEN
      lsw  = ltmp+1
      lhw  = ltmp+2
      lhlw = ltmp+3
      ltmp = lhlw
      ENDIF
    ELSEIF ( ipconc >= 6 ) THEN
      write(0,*) 'NSSL microphysics has not been compiled for 3-moment. Sorry.'
        STOP
      lccn = 9
      lnc = 10
      lnr = 11
      lni = 12
      lns = 13
      lnh = 14
      IF ( ihvol >= 0 ) THEN
      lnhl = 15
      ENDIF
      IF ( ipconc == 6 ) THEN
      lzh = 16 + isub
      lvh = 17 + isub
      ELSEIF ( ipconc == 7 ) THEN
      lzh = 16
      lzr = 17
      lvh = 18
      ELSEIF ( ipconc == 8 ) THEN
      lzr = 16
      lzh = 17
      lzhl = 18
      lvh = 19
      ENDIF
      ltmp = lvh
      denscale(lccn:lvh) = 1
      IF ( ihvol == 1 ) THEN
       lvhl = ltmp+1
       ltmp = lvhl
       denscale(lvhl) = 1
      ENDIF
      IF ( mixedphase ) THEN
      lsw  = ltmp+1
      lhw  = ltmp+2
      lhlw = ltmp+3
      ltmp = lhlw
      ENDIF
    ELSE
      write(0,*) 'nssl_2mom_init: Invalid value of ipctmp'
      STOP
    ENDIF


    
      na = ltmp
      
      ln(lc) = lnc
      ln(lr) = lnr
      ln(li) = lni
      ln(ls) = lns
      ln(lh) = lnh
      IF ( lhl .gt. 1 ) ln(lhl) = lnhl

      ipc(lc) = 2
      ipc(lr) = 3
      ipc(li) = 1
      ipc(ls) = 4
      ipc(lh) = 5
      IF ( lhl .gt. 1 ) ipc(lhl) = 5
      
      ldovol = .false.
      lvol(:) = 0
      lvol(li) = lvi
      lvol(ls) = lvs
      lvol(lh) = lvh
      IF ( lhl .gt. 1 .and. lvhl .gt. 1 ) lvol(lhl) = lvhl
      
      lne = Max(lnh,lnhl)
      lne = Max(lne,lvh)
      lne = Max(lne,lvhl)
      lne = Max(lne,na)

      lsc(:) = 0
      lsc(lc) = lscw
      lsc(lr) = lscr
      lsc(li) = lsci
      lsc(ls) = lscs
      lsc(lh) = lsch
      IF ( lhl .gt. 1 ) lsc(lhl) = lschl


      DO il = lc,lhab
        ldovol = ldovol .or. ( lvol(il) .gt. 1 )
      ENDDO

!      write(0,*) 'nssl_2mom_init: ldovol = ',ldovol

      lz(:) = 0
      lz(lr) = lzr
      lz(li) = lzi
      lz(ls) = lzs
      lz(lh) = lzh
      IF ( lhl .gt. 1 .and. lzhl > 1 ) lz(lhl) = lzhl

      lliq(:) = 0
      lliq(ls) = lsw
      lliq(lh) = lhw
      IF ( lhl .gt. 1 ) lliq(lhl) = lhlw
      IF ( mixedphase ) THEN
!       write(0,*) 'lsw,lhw,lhlw = ',lsw,lhw,lhlw
      ENDIF



      xnu(lc) = 0.0
      xmu(lc) = 1.
      
      IF ( imurain == 3 ) THEN
        xnu(lr) = -0.8
        xmu(lr) = 1.
      ELSEIF ( imurain == 1 ) THEN
        xnu(lr) = (alphar - 2.0)/3.0
        xmu(lr) = 1./3.
      ENDIF

      xnu(li) = 0.0
      xmu(li) = 1.

      dnu(lc) = 3.*xnu(lc) + 2. ! alphac
      dmu(lc) = 3.*xmu(lc)

      dnu(lr) = 3.*xnu(lr) + 2. ! alphar
      dmu(lr) = 3.*xmu(lr)

      dnu(ls) = -0.4 ! alphas
      dmu(ls) = 3.

      xnu(ls) = -0.8
      xmu(ls) = 1.

      dnu(lh) = alphah
      dmu(lh) = dmuh

      xnu(lh) = (dnu(lh) - 2.)/3.
      xmu(lh) = dmuh/3.

      rz =  ((4 + alphah)*(5 + alphah)*(6 + alphah)*(1. + xnu(lr)))/ &
     &  ((1 + alphah)*(2 + alphah)*(3 + alphah)*(2. + xnu(lr)))

!      IF ( ipconc .lt. 5 ) alphahl = alphah

      rzhl =  ((4 + alphahl)*(5 + alphahl)*(6 + alphahl)*(1. + xnu(lr)))/ &
     &  ((1 + alphahl)*(2 + alphahl)*(3 + alphahl)*(2. + xnu(lr)))

      rzs =   & 
     &  ((1. + alphar)*(2. + alphar)*(3. + alphar)*(2. + xnu(ls)))/  &
     &  ((4. + alphar)*(5. + alphar)*(6. + alphar)*(1. + xnu(ls)))

!      write(0,*) 'rz,rzhl = ', rz,rzhl

      IF ( ipconc .lt. 4 ) THEN

      dnu(ls) = alphas
      dmu(ls) = 1.

      xnu(ls) = (dnu(ls) - 2.)/3.
      xmu(ls) = 1./3.


      ENDIF

      IF ( lhl .gt. 1 ) THEN

      dnu(lhl) = alphahl
      dmu(lhl) = dmuhl

      xnu(lhl) = (dnu(lhl) - 2.)/3.
      xmu(lhl) = dmuhl/3.

      ENDIF

      cno(lc)  = 1.0e+08
      IF ( li .gt. 1 ) cno(li)  = 1.0e+08
      cno(lr)  = cnor
      IF ( ls .gt. 1 ) cno(ls)  = cnos ! 8.0e+06
      IF ( lh .gt. 1 ) cno(lh)  = cnoh ! 4.0e+05
      IF ( lhl .gt. 1 ) cno(lhl)  = cnohl ! 4.0e+05
!
!  density maximums and minimums
!
      xdnmx(:) = 900.0

      xdnmx(lr) = 1000.0
      xdnmx(lc) = 1000.0
      xdnmx(li) =  917.0
      xdnmx(ls) =  300.0
      xdnmx(lh) =  900.0
      IF ( lhl .gt. 1 ) xdnmx(lhl) = 900.0
!
      xdnmn(:) = 900.0

      xdnmn(lr) = 1000.0
      xdnmn(lc) = 1000.0
      xdnmn(li) =  100.0
      xdnmn(ls) =  100.0
      xdnmn(lh) =  hdnmn
      IF ( lhl .gt. 1 ) xdnmn(lhl) = hldnmn

      xdn0(:) = 900.0

      xdn0(lc) = 1000.0
      xdn0(li) = 900.0
      xdn0(lr) = 1000.0
      xdn0(ls) = rho_qs ! 100.0
      xdn0(lh) = rho_qh ! (0.5)*(xdnmn(lh)+xdnmx(lh))
      IF ( lhl .gt. 1 ) xdn0(lhl) = rho_qhl ! 800.0

!
!  Set terminal velocities...
!    also set drag coefficients
!
      cdx(lr) = 0.60
      cdx(lh) = 0.8 ! 1.0 ! 0.45
      cdx(ls) = 2.00
      IF ( lhl .gt. 1 ) cdx(lhl) = 0.45

      ido(lc) = idocw
      ido(lr) = idorw
      ido(li) = idoci
      ido(ls) = idosw
      ido(lh)  = idohw
      IF ( lhl .gt. 1 ) ido(lhl) = idohl

      IF ( irfall .lt. 0 ) irfall = infall
      IF ( lzr > 0 ) irfall = 0

      qccn = ccn/rho00
!      xvcmx = (4./3.)*pi*xcradmx**3

! set max rain diameter
      IF ( xvdmx .gt. 0.0 ) THEN
        xvrmx = 0.523599*(xvdmx)**3
      ELSE
        xvrmx = xvrmx0
      ENDIF

         IF ( dhmn <= 0.0 ) THEN
           xvhmn = xvhmn0
!           xvhmn = Min(xvhmn0, 0.523599*(dfrz)**3 )
         ELSE
           xvhmn = 0.523599*(dhmn)**3
!           xvhmn = 0.523599*(Min(dhmn,dfrz))**3
         ENDIF

         IF ( dhmx <= 0.0 ) THEN
           xvhmx = xvhmx0
         ELSE
           xvhmx = 0.523599*(dhmx)**3
         ENDIF

! load max/min diameters
      xvmn(lc) = xvcmn
      xvmn(li) = xvimn
      xvmn(lr) = xvrmn
      xvmn(ls) = xvsmn
      xvmn(lh) = xvhmn

      xvmx(lc) = xvcmx
      xvmx(li) = xvimx
      xvmx(lr) = xvrmx
      xvmx(ls) = xvsmx
      xvmx(lh) = xvhmx

      IF ( lhl .gt. 1 ) THEN
      xvmn(lhl) = xvhlmn
      xvmx(lhl) = xvhlmx
      ENDIF

!
!  cloud water constants in mks units
!
!      cwmasn = 4.25e-15  ! radius of 1.0e-6
!      cwmasn = 5.23e-13   ! minimum mass, defined by radius of 5.0e-6
!      cwmasn5 =  5.23e-13
!      cwradn = 5.0e-6     ! minimum radius
!      cwmasx = 5.25e-10   ! maximum mass, defined by radius of 50.0e-6
!      mwfac = 6.0**(1./3.)
      IF ( ipconc .ge. 2 ) THEN
!        cwmasn = xvmn(lc)*1000.  ! minimum mass, defined by minimum droplet volume
!        cwradn = 1.0e-6          ! minimum radius
!        cwmasx = xvmx(lc)*1000.  ! maximum mass, defined by maximum droplet volume
        
      ENDIF
!        rwmasn = xvmn(lr)*1000.  ! minimum mass, defined by minimum rain volume
!        rwmasx = xvmx(lr)*1000.  ! maximum mass, defined by maximum rain volume

      IF ( lhl < 1 ) ifrzg = 1

      ventr = 1.
      IF ( imurain == 3 ) THEN
!       IF ( izwisventr == 1 ) THEN
        ventr = Gamma(rnu + 4./3.)/((rnu + 1.)**(1./3.)*Gamma(rnu + 1.)) ! Ziegler 1985
!       ELSE
        ventrn =  Gamma(rnu + 1.5 + br/6.)/(Gamma(rnu + 1.)*(rnu + 1.)**((1.+br)/6. + 1./3.) ) ! adapted from Wisner et al. 1972; for second term in rwvent
!        ventr = Gamma(rnu + 4./3.)/((rnu + 1.)**(1./3.)*Gamma(rnu + 1.)) ! Ziegler 1985, still use for first term in rwvent
!        ventr  = Gamma(rnu + 4./3.)/Gamma(rnu + 1.) 
!       ENDIF
      ELSE ! imurain == 1
!       IF ( iferwisventr == 1 ) THEN
        ventr = Gamma(2. + alphar)  ! Ferrier 1994
!       ELSEIF ( iferwisventr == 2 ) THEN
        ventrn =  Gamma(alphar + 2.5 + br/2.)/Gamma(alphar + 1.) ! adapted from Wisner et al. 1972
!       ENDIF
      ENDIF
      ventc   = Gamma(cnu + 4./3.)/(cnu + 1.)**(1./3.)/Gamma(cnu + 1.)
      c1sw = Gamma(snu + 4./3.)*(snu + 1.0)**(-1./3.)/gamma(snu + 1.0) 

  ! set threshold mixing ratios

      qxmin(:) = 1.0e-12

      qxmin(lc) = 1.e-9
      qxmin(lr) = 1.e-7
      IF ( li > 1 ) qxmin(li) = 1.e-12
      IF ( ls > 1 ) qxmin(ls) = 1.e-7
      IF ( lh > 1 ) qxmin(lh) = 1.e-7
      IF ( lhl .gt. 1 ) qxmin(lhl) = 1.e-7

      IF ( lc .gt. 1 .and. lnc .gt. 1 ) qxmin(lc) = 1.0e-13
      IF ( lr .gt. 1 .and. lnr .gt. 1 ) qxmin(lr) = 1.0e-12

      IF ( li .gt. 1 .and. lni .gt. 1 ) qxmin(li ) = 1.0e-13
      IF ( ls .gt. 1 .and. lns .gt. 1 ) qxmin(ls ) = 1.0e-13
      IF ( lh .gt. 1 .and. lnh .gt. 1 ) qxmin(lh ) = 1.0e-12
      IF ( lhl.gt. 1 .and. lnhl.gt. 1 ) qxmin(lhl) = 1.0e-12

  ! constants for droplet nucleation

      cckm = cck-1.
      ccnefac =  (1.63/(cck * beta(3./2., cck/2.)))**(cck/(cck + 2.0))
      cnexp   = (3./2.)*cck/(cck+2.0)
! ccne is all the factors with w in eq. A7 in Mansell et al. 2010 (JAS).  The constant changes
! if k (cck) is changed!
      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
      ccne0 = ccnefac*1.e6*(1.e-6)**(2./(2.+cck))
      write(0,*) 'cwccn, cck, ccne = ',cwccn,cck,ccne,ccnefac,cnexp
      IF ( cwccn .lt. 0.0 ) THEN
      cwccn = Abs(cwccn)
      ccwmx = 50.e9 ! cwccn
      ELSE
      ccwmx = 50.e9 ! cwccn ! *1.4
      ENDIF

!
!
!  Set collection coefficients (Seifert and Beheng 05)
!
      bb(:) = 1.0/3.0
      bb(li) = 0.3429
      DO il = lc,lhab
        da0(il) = delbk(bb(il), xnu(il), xmu(il), 0)
        da1(il) = delbk(bb(il), xnu(il), xmu(il), 1)

!        write(0,*) 'il, da0, da1, xnu, xmu = ', il, da0(il), da1(il), xnu(il), xmu(il)
      ENDDO

      dab0(:,:) = 0.0
      dab1(:,:) = 0.0

      DO il = lc,lhab
        DO j = lc,lhab
          IF ( il .ne. j ) THEN

            dab0(il,j) = delabk(bb(il), bb(j), xnu(il), xnu(j), xmu(il), xmu(j), 0)
            dab1(il,j) = delabk(bb(il), bb(j), xnu(il), xnu(j), xmu(il), xmu(j), 1)

!           write(0,*) 'il, j, dab0, dab1 = ',il, j, dab0(il,j), dab1(il,j)
          ENDIF
        ENDDO
      ENDDO

        gf4br = gamma(4.0+br)
        gf4ds = gamma(4.0+ds)
        gf4p5 = gamma(4.0+0.5)
        gfcinu1 = gamma(cinu + 1.0)
        gfcinu1p47 = gamma(cinu + 1.47167)
        gfcinu2p47 = gamma(cinu + 2.47167)

        gsnow1 = gamma(snu + 1.0)
        gsnow53 = gamma(snu + 5./3.)
        gsnow73 = gamma(snu + 7./3.)

        IF ( lh  .gt. 1 ) cwchtmp0 = 6.0/pi*gamma( (xnu(lh) + 1.)/xmu(lh) )/gamma( (xnu(lh) + 2.)/xmu(lh) )
        IF ( lhl .gt. 1 ) cwchltmp0 = 6.0/pi*gamma( (xnu(lhl) + 1)/xmu(lhl) )/gamma( (xnu(lhl) + 2)/xmu(lhl) )


      iexy(:,:)=0; ! sets to zero the ones Imight have forgotten

!     snow
      iexy(ls,li) = ieswi
      iexy(ls,lc) = ieswc ; iexy(ls,lr) = ieswr ;

!     graupel
      iexy(lh,ls)  = iehwsw ; iexy(lh,li) = iehwi ;
      iexy(lh,lc) = iehwc ; iexy(lh,lr)  = iehwr ;

!     hail
      IF (lhl .gt. 1 ) THEN
      iexy(lhl,ls)  = iehlsw ; iexy(lhl,li) = iehli ;
      iexy(lhl,lc) = iehlc ; iexy(lhl,lr)  = iehlr ;
      ENDIF


  RETURN
END SUBROUTINE nssl_2mom_init

! #####################################################################
! #####################################################################

SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw, chl,  &
                              cn, vhw, vhl,                                             &
                              zrw, zhw, zhl,                                            &
                              qsw, qhw, qhlw,                                           &
                              th, pii, p, w, dn, dz, dtp, itimestep,                    &
                              RAIN,nrain,                                               &
                              tcond,tevac,tevar,train,                                  &
                              ruh,rvh,rmh,rr,                                           &
                              dx, dy,                                                   &
                              tkediss,                                                  &
                              re_cloud, re_ice, re_snow,                                &
                              has_reqc, has_reqi, has_reqs,                             &
                              rainncw2, rainnci2,                                         &
                              dbz, vzf,compdbz,                                         &
                              rscghis_2d,                                               &
                              scr,scw,sci,scs,sch,schl,sctot,noninduc,                  &
                              induc,elec,scion,sciona,                                  &
                              pcc2, pre2, depsubr,      &
                              mnucf2, melr2, ctr2,     &
                              rim1_2, rim2_2,rim3_2, &
                              nctr2, nnuccd2, nnucf2, &
                              effc2,effr2,effi2,       &
                              effs2, effg2,                       &
                              fc2, fr2,fi2,fs2,fg2, &
                              fnc2, fnr2,fni2,fns2,fng2, &
!                              qcond,qdep,qfrz,qrauto,qhcnvi,qhcollw,qscollw,            &
!                              ncauto, niinit,nifrz,                                     &
!                              re_liquid, re_graupel, re_hail, re_icesnow,               &
!                              vtcloud, vtrain, vtsnow, vtgraupel, vthail,               &
                              ipelectmp,                                                &
                              diagflag,                                                 &
                              nssl_progn,                                              & ! wrf-chem 
! 20130903 acd_mb_washout start
                              rainprod, evapprod,                                       & ! wrf-chem 
! 20130903 acd_mb_washout end
                              ids,ide, jds,jde, kds,kde,                                &  ! domain dims
                              ims,ime, jms,jme, kms,kme,                                &  ! memory dims
                              its,ite, jts,jte, kts,kte)                                   ! tile dims



#ifdef DM_PARALLEL
#endif

      implicit none

#if defined(DM_PARALLEL) || defined(MPI)
      INCLUDE 'mpif.h'
#else
      integer :: mytask = 0
#endif

 !Subroutine arguments:
      integer, intent(in), optional ::                                                   &
                            ids,ide, jds,jde, kds,kde

      integer, intent(in)::                                                             &
                            ims,ime, jms,jme, kms,kme,                                   &
                            its,ite, jts,jte, kts,kte
      real, dimension(ims:ime, jms:jme, kms:kme), intent(inout)::                        &
                            qv,qc,qr,qi,qs,qh,th
      real, dimension(ims:ime, jms:jme, kms:kme), optional, intent(inout)::                        &
                              zrw, zhw, zhl,                                            &
                              qsw, qhw, qhlw,                                           &
                            qhl,ccw,crw,cci,csw,chw,chl,vhw,vhl
      real, dimension(ims:ime, jms:jme, kms:kme), optional, intent(inout):: dbz, vzf, cn
      real, dimension(ims:ime, jms:jme), optional, intent(inout):: compdbz
      real, dimension(ims:ime, jms:jme), optional, intent(inout):: rscghis_2d
!      real, dimension(ims:ime, jms:jme, kms:kme), optional, intent(inout)::rscghis_3d
      real, dimension(ims:ime, jms:jme, kms:kme),  optional, intent(inout)::                   &
                            scr,scw,sci,scs,sch,schl,sciona,sctot,induc,noninduc  ! space charge
      real, dimension(ims:ime, jms:jme, kms:kme),  optional, intent(in) :: elec ! elecsave = Ez     
      real, dimension(ims:ime, jms:jme, kms:kme,2),optional, intent(inout) :: scion  
      real, dimension(ims:ime, jms:jme, kms:kme), intent(in)::  p,w,dz,dn

      real, dimension(ims:ime, jms:jme, kms:kme), intent(inout)::  pii
      real, dimension(ims:ime, jms:jme, kms:kme), optional, intent(inout)::   &
                              pcc2, pre2, depsubr,      &
                              mnucf2, melr2, ctr2,     &
                              rim1_2, rim2_2,rim3_2, &
                              nctr2, nnuccd2, nnucf2, &
                              effc2,effr2,effi2,       &
                              effs2, effg2,                       &
                              fc2, fr2,fi2,fs2,fg2, &
                              fnc2, fnr2,fni2,fns2,fng2
!                              qcond,qdep,qfrz,qrauto,qhcnvi,qhcollw,qscollw,            &
!                              ncauto, niinit,nifrz,                                     &
!                              re_liquid, re_graupel, re_hail, re_icesnow,               &
!                              vtcloud, vtrain, vtsnow, vtgraupel, vthail               

      integer, intent(in) :: nrain
      real, dimension(ims:ime, jms:jme,nrain), intent(inout)::                                 &
                            rain                          ! accumulated precip (NC) and rate (NCV)
      real, dimension(ims:ime, jms:jme)::                                 &
                            RAINNC,RAINNCV,SNOWNC,SNOWNCV,GRPLNC,GRPLNCV,SR,HAILNC,HAILNCV         ! accumulated precip (NC) and rate (NCV)
      real*8, intent(inout) :: tcond,tevac,tevar,train
      REAL, DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN)::  rmh, rr
      real, intent(in), dimension(ims:ime) :: ruh
      real, intent(in), dimension(jms:jme) :: rvh
      real*8, dimension(jte) :: bud1,bud2
      REAL, DIMENSION(ims:ime, kms:kme, jms:jme), optional, INTENT(INOUT):: &
                          re_cloud, re_ice, re_snow
      REAL, DIMENSION(ims:ime, kms:kme, jms:jme), optional, INTENT(IN):: tkediss
      INTEGER, INTENT(IN), optional :: has_reqc, has_reqi, has_reqs
      real, dimension(ims:ime, jms:jme), intent(out), optional ::                                 &
                            rainncw2, rainnci2       ! liquid rain, ice, accumulation rates
      real, optional, intent(in) :: dx,dy
      real, intent(in)::    dtp
      integer, intent(in):: itimestep !, ccntype
      logical, optional, intent(in) :: diagflag
      integer, optional, intent(in) :: ipelectmp

  LOGICAL, INTENT(IN), OPTIONAL ::    nssl_progn  ! wrf-chem
!   REAL, DIMENSION(ims:ime, jms:jme, kms:kme), optional,INTENT(INOUT):: qndrop
  LOGICAL :: flag_qndrop  ! wrf-chem

! 20130903 acd_ck_washout start
! rainprod - total tendency of conversion of cloud water/ice and graupel to rain (kg kg-1 s-1)
! evapprod - tendency of evaporation of rain (kg kg-1 s-1)
! 20130903 acd_ck_washout end
   REAL, DIMENSION(ims:ime, jms:jme, kms:kme), optional,INTENT(INOUT)::  rainprod, evapprod

!
! local variables
!
     real, dimension(its:ite, 1, kts:kte) :: elec2 ! ez = elecsave slab
!     real, dimension(its:ite, 1, kts:kte,2) :: scion2 ! 1=- , 2=+
     real, dimension(its:ite, kts:kte) :: rainprod2d, evapprod2d
     real, dimension(its:ite, 1, kts:kte, na) :: an
     real, dimension(its:ite, 1, kts:kte, nxtra) :: axtra
     real, dimension(its:ite, 1, kts:kte) :: t0,t1,t2,t3,t4,t5,t6,t7,t8,t9
     real, dimension(its:ite, 1, kts:kte) :: dn1,t00,t77,ssat,pn,wn,dz2d,dz2dinv,dbz2d,vzf2d
     real, dimension(its:ite, 1, na) :: xfall
     integer, parameter :: nor = 0, ng = 0
     integer :: nx,ny,nz
     integer ix,jy,kz,i,j,k,il,n
     integer :: infdo
     real :: ssival, ssifac, t8s, t9s, qvapor
     integer :: ltemq
     double precision :: dp1
     integer :: jye, lnb
     integer :: imx,kmx
     real    :: dbzmx
     integer :: vzflag0 = 0
     logical :: makediag
      real, parameter :: cnin20 = 1.0e3
      real, parameter :: cnin10 = 5.0e1
      real, parameter :: cnin1a = 4.5
      real, parameter :: cnin2a = 12.96
      real, parameter :: cnin2b = 0.639

      logical, parameter :: invertccn = .false. ! =true for base state of ccn=0, =false for ccn initialized in the base state

      real :: tmp,dv

      double precision :: dt1,dt2
      double precision :: timesed,timesed1,timesed2,timesed3, timegs, timenucond, timedbz,zmaxsed
      double precision :: timevtcalc,timesetvt
      
#ifdef MPI

#if defined(MPI) 
      integer, parameter :: ntot = 50
      double precision  mpitotindp(ntot), mpitotoutdp(ntot)
      INTEGER :: mpi_error_code = 1
#endif
#endif


! -------------------------------------------------------------------


      
!      write(0,*) 'N2M: entering routine'

     flag_qndrop = .false.
     IF ( PRESENT ( nssl_progn ) ) flag_qndrop = nssl_progn
       
     IF ( present( vzf ) ) vzflag0 = 1
     
     IF ( present( ipelectmp ) ) THEN
       ipelec = ipelectmp
     ELSE
       ipelec = 0
     ENDIF
!       IF ( present( dbz ) ) THEN
!       DO jy = jts,jte
!         DO kz = kts,kte
!           DO ix = its,ite
!             dbz(ix,jy,kz) = 0.0
!           ENDDO
!         ENDDO
!       ENDDO
!       ENDIF

     
     makediag = .true.
     IF ( present( diagflag ) ) THEN
      makediag = diagflag
      IF ( diagflag ) cleardiag = .true.
     ENDIF

!     write(0,*) 'N2M: makediag = ',makediag
     
     
     nx = ite-its+1
     ny = 1         ! set up as 2D slabs
     nz = kte-kts+1
     
! set up CCN array and some other static local values

!     ENDIF ! itimestep == 1

! sedimentation settings

      infdo = 2
      
      IF ( infall .ne. 1 .or. iscfall .ge. 2 ) THEN
         infdo = 1
      ELSE
         infdo = 0
      ENDIF

      IF ( infall .ge. 3 .or. ipconc .ge. 6 ) THEN
         infdo = 2
      ENDIF
     

        HAILNCV(its:ite,jts:jte) = 0.

     lnb = Max(lh,lhl)+1 ! lnc
!     IF ( lccn > 1 ) lnb = lccn

       jye = jte

     IF ( present( compdbz ) .and. makediag ) THEN
     DO jy = jts,jye
       DO ix = its,ite
        compdbz(ix,jy) = -3.0
       ENDDO
     ENDDO
     ENDIF

      zmaxsed = 0.0d0
      timevtcalc = 0.0d0
      timesetvt = 0.0d0
      timesed = 0.0d0
      timesed1 = 0.0d0
      timesed2 = 0.0d0
      timesed3 = 0.0d0
      timegs = 0.0d0
      timenucond = 0.0d0


!     write(0,*) 'N2M: jy loop 1, lhl,na = ',lhl,na,present(qhl)

     DO jy = jts,jye
     
     xfall(:,:,:) = 0.0

!     write(0,*) 'N2M: load an, jy,lccn = ',jy,lccn,qccn

     IF ( present( pcc2 ) .and. makediag ) THEN
         axtra(its:ite,1,kts:kte,:) = 0.0
     ENDIF
   ! copy from 3D array to 2D slab
   
       DO kz = kts,kte
        DO ix = its,ite
        
          an(ix,1,kz,lt)   = th(ix,jy,kz)
          an(ix,1,kz,lv)   = qv(ix,jy,kz)
          an(ix,1,kz,lc)   = qc(ix,jy,kz)
          an(ix,1,kz,lr)   = qr(ix,jy,kz)
          an(ix,1,kz,li)   = qi(ix,jy,kz)
          an(ix,1,kz,ls)   = qs(ix,jy,kz)
          an(ix,1,kz,lh)   = qh(ix,jy,kz)
          IF ( lhl > 1 ) an(ix,1,kz,lhl)  = qhl(ix,jy,kz)
          IF ( lccn > 1 ) THEN
           IF ( present( cn ) ) THEN
            an(ix,1,kz,lccn) = cn(ix,jy,kz)
           ELSE
            an(ix,1,kz,lccn) = qccn - ccw(ix,jy,kz)
           ENDIF
          ENDIF
          IF ( ipconc >= 5 ) THEN
             an(ix,1,kz,lnc)  = ccw(ix,jy,kz)
          IF ( constccw > 0.0 ) THEN
            an(ix,1,kz,lnc)  = constccw
          ENDIF
          an(ix,1,kz,lnr)  = crw(ix,jy,kz)
          an(ix,1,kz,lni)  = cci(ix,jy,kz)
          an(ix,1,kz,lns)  = csw(ix,jy,kz)
          an(ix,1,kz,lnh)  = chw(ix,jy,kz)
          IF ( lhl > 1 ) an(ix,1,kz,lnhl) = chl(ix,jy,kz)
          ENDIF
          IF ( lvh > 0 ) an(ix,1,kz,lvh)  = vhw(ix,jy,kz)
          IF ( lvhl > 0 .and. present( vhl ) ) an(ix,1,kz,lvhl)  = vhl(ix,jy,kz)

          


          
          t0(ix,1,kz) = th(ix,jy,kz)*pii(ix,jy,kz) ! temperature (Kelvin)
          t1(ix,1,kz) = 0.0
          t2(ix,1,kz) = 0.0
          t3(ix,1,kz) = 0.0
          t4(ix,1,kz) = 0.0
          t5(ix,1,kz) = 0.0
          t6(ix,1,kz) = 0.0
          t7(ix,1,kz) = 0.0
          t8(ix,1,kz) = 0.0
          t9(ix,1,kz) = 0.0
          t00(ix,1,kz) = 380.0/p(ix,jy,kz)
          t77(ix,1,kz) = pii(ix,jy,kz)
          dbz2d(ix,1,kz) = 0.0
          vzf2d(ix,1,kz) = 0.0

          dn1(ix,1,kz) = dn(ix,jy,kz)
          pn(ix,1,kz) = p(ix,jy,kz)
          wn(ix,1,kz) = w(ix,jy,kz)
          dz2d(ix,1,kz) = dz(ix,jy,kz)
          dz2dinv(ix,1,kz) = 1./dz(ix,jy,kz)
          
         ltemq = Int( (t0(ix,1,kz)-163.15)/fqsat+1.5 )
         ltemq = Min( nqsat, Max(1,ltemq) )
!
! saturation mixing ratio
!
      t8s = t00(ix,1,kz)*tabqvs(ltemq)  !saturation mixing ratio wrt water
      t9s = t00(ix,1,kz)*tabqis(ltemq)  !saturation mixing ratio wrt ice

!
!  calculate rate of nucleation
!
      ssival = Min(t8s,max(an(ix,1,kz,lv),0.0))/t9s  ! qv/qvi

      if ( ssival .gt. 1.0 ) then
!
      IF ( icenucopt == 1 ) THEN

      if ( t0(ix,1,kz).le.268.15 ) then

       dp1 = cnin20*exp( Min( 57.0 ,(cnin2a*(ssival-1.0)-cnin2b) ) )
       t7(ix,1,kz) = Min(dp1, 1.0d30)
      end if

!
!   Default value of imeyers5 turns off nucleation by Meyer at higher temperatures
!  This is really from Ferrier (1994), eq. 4.31 - 4.34
      IF ( imeyers5 ) THEN
      if ( t0(ix,1,kz).lt.tfr .and. t0(ix,1,kz).gt.268.15 ) then
      qvapor = max(an(ix,1,kz,lv),0.0)
      ssifac = 0.0
      if ( (qvapor-t9s) .gt. 1.0e-5 ) then
      if ( (t8s-t9s) .gt. 1.0e-5 ) then
      ssifac = (qvapor-t9s) /(t8s-t9s)
      ssifac = ssifac**cnin1a
      end if
      end if
      t7(ix,1,kz) = cnin10*ssifac*exp(-(t0(ix,1,kz)-tfr)*bta1)
      end if
      ENDIF

      ELSEIF ( icenucopt == 2 ) THEN ! Thompson/Cooper; Note Thompson 2004 has constants of
                                     ! 0.005 and 0.304 because the line function was estimated from Cooper's plot
                                     ! Here, the fit line values from Cooper 1986 are converted. Very little difference 
                                     ! in practice
      
        t7(ix,1,kz) = 1000.*0.00446684*exp(0.3108*(273.16 - Max(233.0, t0(ix,1,kz) ) ) ) ! factor of 1000 to convert L**-1 to m**-3

!        write(0,*) 'Cooper t7,ssival = ',ix,kz,t7(ix,1,kz),ssival
      
      ELSEIF ( icenucopt == 3 ) THEN ! Phillips (Meyers/DeMott)

      if ( t0(ix,1,kz).le.268.15 .and.  t0(ix,1,kz) > 243.15 ) then ! Meyers with factor of Psi=0.06
        
       dp1 = 0.06*cnin20*exp( Min( 57.0 ,(cnin2a*(ssival-1.0)-cnin2b) ) )
       t7(ix,1,kz) = Min(dp1, 1.0d30)
      elseif ( t0(ix,1,kz) <= 243.15 ) then ! Phillips estimate of DeMott et al (2003) data
       dp1 = 1000.*( exp( Min( 57.0 ,cnin2a*(ssival-1.1) ) ) )**0.3
       t7(ix,1,kz) = Min(dp1, 1.0d30)
      
      end if
      
      ENDIF ! icenucopt


!
      end if ! ( ssival .gt. 1.0 )
!

        ENDDO ! ix
       ENDDO ! kz

         IF ( wrfchem_flag > 0 ) THEN
           IF ( PRESENT( rainprod ) ) rainprod2d(its:ite,kts:kte) = 0
           IF ( PRESENT( evapprod ) ) evapprod2d(its:ite,kts:kte) = 0
         ENDIF

   ! transform from number mixing ratios to number conc.
     
     DO il = lnb,na
       IF ( denscale(il) == 1 ) THEN
         DO kz = kts,kte
          DO ix = its,ite
           an(ix,1,kz,il) = an(ix,1,kz,il)*dn(ix,jy,kz)
          ENDDO
         ENDDO
       ENDIF
     ENDDO ! il
        
! sedimentation
      xfall(:,:,:) = 0.0
       
      IF ( .true. ) THEN


! for real cases when hydrometeor mixing ratios have been initialized without concentrations
      call sediment1d(dtp,nx,ny,nz,an,na,nor,nor,xfall,dn1,dz2d,dz2dinv, &
     &                    t0,t7,infdo,jy,its,jts &
     &   ,timesed1,timesed2,timesed3,zmaxsed,timesetvt)


! copy xfall to appropriate places...

!     write(0,*) 'N2M: end sediment, jy = ',jy

       DO ix = its,ite
         IF ( lhl > 1 ) THEN
         RAINNCV(ix,jy) = dtp*dn1(ix,1,1)*(xfall(ix,1,lr) + xfall(ix,1,ls)*1000./xdn0(lr) + &
              &            xfall(ix,1,lh)*1000./xdn0(lr) + xfall(ix,1,lhl)*1000./xdn0(lr) )
         ELSE
         RAINNCV(ix,jy) = dtp*dn1(ix,1,1)*(xfall(ix,1,lr) + xfall(ix,1,ls)*1000./xdn0(lr) + &
              &            xfall(ix,1,lh)*1000./xdn0(lr) )
         ENDIF
         IF ( present ( rainncw2 ) ) THEN ! rain only
           rainncw2(ix,jy) =  rainncw2(ix,jy) +  dtp*dn1(ix,1,1)*xfall(ix,1,lr)
         ENDIF
         IF ( present ( rainnci2 ) ) THEN ! ice only
           IF ( lhl > 1 ) THEN
             rainnci2(ix,jy) =rainnci2(ix,jy) + dtp*dn1(ix,1,1)*(xfall(ix,1,ls)*1000./xdn0(lr) + &
     &            xfall(ix,1,lh)*1000./xdn0(lr) + xfall(ix,1,lhl)*1000./xdn0(lr) )
           ELSE
             rainnci2(ix,jy) = rainnci2(ix,jy) + dtp*dn1(ix,1,1)*(xfall(ix,1,ls)*1000./xdn0(lr) + &
     &            xfall(ix,1,lh)*1000./xdn0(lr) )
           ENDIF
         ENDIF
         SNOWNCV(ix,jy) = dtp*dn1(ix,1,1)*xfall(ix,1,ls)*1000./xdn0(lr)
         GRPLNCV(ix,jy) = dtp*dn1(ix,1,1)*xfall(ix,1,lh)*1000./xdn0(lr)
         RAINNC(ix,jy)  = RAINNC(ix,jy) + RAINNCV(ix,jy)

         do n = 1,nrain
           RAIN(ix,jy,n) = RAIN(ix,jy,n) + 0.1*RAINNCV(ix,jy)
         enddo

!         bud1(jy) = bud1(jy) + RAINNCV(ix,jy)*ruh(ix)*rvh(jy)*dx*dy
         train = train + RAINNCV(ix,jy)*ruh(ix)*rvh(jy)*dx*dy
!         do k=1,kte
!           bud2(jy) = bud2(jy) - rr(ix,jy,kz)*PRE(kz)*ruh(ix)*rvh(jy)*rmh(ix,jy,kz)*tem1
!         enddo

         SNOWNC(ix,jy)  = SNOWNC(ix,jy) + SNOWNCV(ix,jy)
         IF ( lhl > 1 ) THEN
           IF ( .true. ) THEN
             HAILNCV(ix,jy) = dtp*dn1(ix,1,1)*xfall(ix,1,lhl)*1000./xdn0(lr)
             HAILNC(ix,jy)  = HAILNC(ix,jy) + HAILNCV(ix,jy)
           ELSE
             GRPLNCV(ix,jy) = dtp*dn1(ix,1,1)*xfall(ix,1,lhl)*1000./xdn0(lr)
           ENDIF
         ENDIF
         GRPLNC(ix,jy)  = GRPLNC(ix,jy) + GRPLNCV(ix,jy)
       ENDDO
       
      ENDIF ! .false.
 
      IF ( isedonly /= 1 ) THEN
   ! call nssl_2mom_gs: main gather-scatter routine to calculate microphysics

!     write(0,*) 'N2M: gs, jy = ',jy
!      IF ( isedonly /= 2 ) THEN


      
      call nssl_2mom_gs   &
     &  (nx,ny,nz,na,jy   &
     &  ,nor,nor          &
     &  ,dtp,dz2d       &
     &  ,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9      &
     &  ,an,dn1,t77                  &
     &  ,pn,wn,0                   &
     &  ,t00,t77,                             &
     &   ventr,ventc,c1sw,1,ido,    &
     &   xdnmx,xdnmn,                  &
!     &   ln,ipc,lvol,lz,lliq,   &
     &   cdx,                              &
     &   xdn0,dbz2d,                &
     &   timevtcalc,axtra, makediag  &
     &   ,rainprod2d, evapprod2d  &
     & ,elec2,its,ids,ide,jds,jde &
     & )





   ENDIF ! isedonly /= 1
   
 ! droplet nucleation/condensation/evaporation
   IF ( .true. ) THEN
   CALL NUCOND    &
     &  (nx,ny,nz,na,jy & 
     &  ,nor,nor & 
     &  ,dtp,dz2d & 
     &  ,t0,t9 & 
     &  ,an,dn1,t77 & 
     &  ,pn,wn & 
     &  ,axtra, makediag  &
     &  ,ssat,t00,t77,flag_qndrop)


   ENDIF



! compute diagnostic S-band reflectivity if needed
     IF ( present( dbz ) .and. makediag ) THEN
   ! calc dbz
      
      IF ( .true. ) THEN
      call radardd02(nx,ny,nz,nor,na,an,t0,         &
     &    dbz2d,dn1,nz,cnoh,rho_qh,ipconc, 0)
      ENDIF ! .false.

     
       DO kz = kts,kte
        DO ix = its,ite
         dbz(ix,jy,kz) = dbz2d(ix,1,kz)
         IF ( present( vzf ) ) THEN
           vzf(ix,jy,kz) = vzf2d(ix,1,kz)
         ENDIF
          IF ( present( compdbz ) ) THEN
            compdbz(ix,jy) = Max( compdbz(ix,jy), dbz2d(ix,1,kz) )
          ENDIF
        ENDDO
       ENDDO


! Following Greg Thompson, calculation for effective radii. Used by RRTMG LW/SW schemes if enabled in module_physics_init.F
      IF ( present( has_reqc ).and. present( has_reqi ) .and. present( has_reqs ) .and.  &
           present( re_cloud ).and. present( re_ice ) .and. present( re_snow ) ) THEN
       IF ( has_reqc.ne.0 .and. has_reqi.ne.0 .and. has_reqs.ne.0) THEN
         DO kz = kts,kte
          DO ix = its,ite
             re_cloud(ix,jy,kz)  = 2.51E-6
             re_ice(ix,jy,kz)    = 10.01E-6
             re_snow(ix,jy,kz)   = 25.E-6
             t1(ix,1,kz) = 2.51E-6
             t2(ix,1,kz) = 10.01E-6
             t3(ix,1,kz) = 25.E-6
          ENDDO
         ENDDO

          call calc_eff_radius   &
     &         (nx,ny,nz,na,jy & 
     &          ,nor,nor & 
     &          ,t1,t2,t3  & 
     &          ,an,dn1 )

        DO kz = kts,kte
          DO ix = its,ite
             re_cloud(ix,jy,kz) = MAX(2.51E-6, MIN(t1(ix,1,kz), 50.E-6))
             re_ice(ix,jy,kz)   = MAX(10.01E-6, MIN(t2(ix,1,kz), 125.E-6))
             re_snow(ix,jy,kz)  = MAX(25.E-6, MIN(t3(ix,1,kz), 999.E-6))
          ENDDO
         ENDDO
       
         ENDIF
        ENDIF

       IF ( present( effc2 ) .and. makediag ) THEN
          call calc_eff_radius2   &
     &         (nx,ny,nz,na,jy & 
     &          ,nor,nor & 
     &          ,t1,t2,t3,t4,t5  & 
     &          ,an,dn1 )

        DO kz = kts,kte
          DO ix = its,ite
             effc2(ix,jy,kz) = 1.e6*t1(ix,1,kz) ! MAX(2.51E-6, MIN(t1(ix,1,kz), 50.E-6))
             effi2(ix,jy,kz) = 1.e6*t2(ix,1,kz) !MAX(10.01E-6, MIN(t2(ix,1,kz), 125.E-6))
             effs2(ix,jy,kz) = 1.e6*t3(ix,1,kz) !MAX(25.E-6, MIN(t3(ix,1,kz), 999.E-6))
             effr2(ix,jy,kz) = 1.e6*t4(ix,1,kz) !MAX(25.E-6, MIN(t4(ix,1,kz), 999.E-6))
             effg2(ix,jy,kz) = 1.e6*t5(ix,1,kz) !MAX(25.E-6, MIN(t5(ix,1,kz), 999.E-6))
             
          ENDDO
         ENDDO
       
         ENDIF


       ENDIF
   
! transform concentrations back to mixing ratios
     DO il = lnb,na
      IF ( denscale(il) == 1 ) THEN
       DO kz = kts,kte
        DO ix = its,ite
         an(ix,1,kz,il) = an(ix,1,kz,il)/dn(ix,jy,kz)
        ENDDO
       ENDDO
      ENDIF
     ENDDO ! il
   
   ! copy 2D slabs back to 3D

   
       DO kz = kts,kte
        DO ix = its,ite
        
         th(ix,jy,kz)  = an(ix,1,kz,lt)
         IF ( eqtset > 2 ) THEN
          pii(ix,jy,kz) = t77(ix,1,kz)
         ENDIF
         qv(ix,jy,kz)  = an(ix,1,kz,lv)
         qc(ix,jy,kz)  = an(ix,1,kz,lc)
         qr(ix,jy,kz)  = an(ix,1,kz,lr)
         qi(ix,jy,kz)  = an(ix,1,kz,li)
         qs(ix,jy,kz)  = an(ix,1,kz,ls)
         qh(ix,jy,kz)  = an(ix,1,kz,lh)
         IF ( lhl > 1 ) qhl(ix,jy,kz) = an(ix,1,kz,lhl)
         IF ( present( cn ) .and. lccn > 1 .and. .not. flag_qndrop) THEN
           cn(ix,jy,kz) = an(ix,1,kz,lccn)
         ENDIF
         IF ( ipconc >= 5 ) THEN

          ccw(ix,jy,kz) = an(ix,1,kz,lnc)
          crw(ix,jy,kz) = an(ix,1,kz,lnr)
          cci(ix,jy,kz) = an(ix,1,kz,lni)
          csw(ix,jy,kz) = an(ix,1,kz,lns)
          chw(ix,jy,kz) = an(ix,1,kz,lnh)
          IF ( lhl > 1 ) chl(ix,jy,kz) = an(ix,1,kz,lnhl)
         ENDIF




         IF ( lvh > 0 )  vhw(ix,jy,kz) = an(ix,1,kz,lvh)
         IF ( lvhl > 0 .and. present( vhl ) ) vhl(ix,jy,kz) = an(ix,1,kz,lvhl)

#ifdef WRF_CHEM
         IF ( wrfchem_flag > 0 ) THEN
           IF ( PRESENT( rainprod ) ) rainprod(ix,jy,kz) = rainprod2d(ix,kz)
           IF ( PRESENT( evapprod ) ) evapprod(ix,jy,kz) = evapprod2d(ix,kz)
         ENDIF
#endif
        ENDDO
       ENDDO
  
     ENDDO ! jy






  RETURN
END SUBROUTINE nssl_2mom_driver

! #####################################################################
! #####################################################################

      REAL FUNCTION GAMMA(xx)

      implicit none
      real xx
      integer j

! Double precision ser,stp,tmp,x,y,cof(6)

      real*8 ser,stp,tmp,x,y,cof(6)
      SAVE cof,stp
      DATA cof,stp/76.18009172947146d+0,  &
     &            -86.50532032941677d0,   &
     &             24.01409824083091d0,   &
     &             -1.231739572450155d0,  &
     &              0.1208650973866179d-2,&
     &             -0.5395239384953d-5,   &
     &              2.5066282746310005d0/

      IF ( xx <= 0.0 ) THEN
        write(0,*) 'Argument to gamma must be > 0!! xx = ',xx
        STOP
      ENDIF
      
      x = xx
      y = x
      tmp = x + 5.5d0
      tmp = (x + 0.5d0)*Log(tmp) - tmp
      ser = 1.000000000190015d0
      DO j=1,6
        y = y + 1.0d0
        ser = ser + cof(j)/y
      END DO
      gamma = Exp(tmp + log(stp*ser/x))

      RETURN
      END FUNCTION GAMMA

! #####################################################################

        real function GAMXINF(A1,X1)

!       ===================================================
!       Purpose: Compute the incomplete gamma function
!                from x to infinity
!       Input :  a   --- Parameter ( a  170 )
!                x   --- Argument 
!       Output:  GIM --- gamma(a,x) t=x,Infinity
!       Routine called: GAMMA for computing gamma(x)
!       ===================================================

!        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        implicit none
        real :: a1,x1
        double precision :: xam,dlog,s,r,ga,t0,a,x
        integer :: k
        double precision :: gin, gim
        
        a = a1
        x = x1
        XAM=-X+A*DLOG(X)
        IF (XAM.GT.700.0.OR.A.GT.170.0) THEN
           WRITE(*,*)'a and/or x too large'
           STOP
        ENDIF
        IF (X.EQ.0.0) THEN
           GIN=0.0
           GIM = GAMMA(A1)
        ELSE IF (X.LE.1.0+A) THEN
           S=1.0D0/A
           R=S
           DO 10 K=1,60
              R=R*X/(A+K)
              S=S+R
              IF (DABS(R/S).LT.1.0D-15) GO TO 15
10         CONTINUE
15         GIN=DEXP(XAM)*S
           ga = GAMMA(A1)
           GIM=GA-GIN
        ELSE IF (X.GT.1.0+A) THEN
           T0=0.0D0
           DO 20 K=60,1,-1
              T0=(K-A)/(1.0D0+K/(X+T0))
20         CONTINUE
           GIM=DEXP(XAM)/(X+T0)
!           GA = GAMMA(A1)
!           GIN=GA-GIM
        ENDIF
        
        gamxinf = GIM
        return
        END function GAMXINF

! #####################################################################

!**************************** GAML02 *********************** 
!  This calculates Gamma(0.2,x)/Gamma[0.2], where is a ratio
!   It is used for qiacr with the gamma of volume to calculate what 
!   fraction of drops exceed a certain size (this version is for 40 micron drops)
! **********************************************************
      real FUNCTION GAML02(x) 
      implicit none
      integer ig, i, ii, n, np
      real x
      integer ng
      parameter(ng=12)
      real gamxg(ng), xg(ng)
      DATA xg/0.01,0.02,0.025,0.04,0.075,0.1,0.25,0.5,0.75,1.,2.,10./ 
      DATA gamxg/  &
     &  7.391019203578037e-8,0.02212726874591478,0.06959352407989682, &
     &  0.2355654024970809,0.46135930387500346,0.545435791452399,     &
     &  0.7371571313308203,                                           &
     &  0.8265676632204345,0.8640182781845841,0.8855756211304151,     &
     &  0.9245079225301251,                                           &
     &  0.9712578342732681/
      IF ( x .ge. xg(ng) ) THEN
        gaml02 = xg(ng)
        RETURN
      ENDIF
      IF ( x .lt. xg(1) ) THEN
        gaml02 = 0.0
        RETURN
      ENDIF
      DO ii = 1,ng-1
        i = ng - ii
        n = i
        np = n + 1
        IF ( x .ge. xg(i) ) THEN
!         GOTO 2 
          gaml02 = gamxg(N)+((X-XG(N))/(XG(NP)-XG(N)))* &
     &            ( gamxg(NP) - gamxg(N) ) 
          RETURN
        ENDIF
      ENDDO
      RETURN
      END FUNCTION GAML02

!**************************** GAML02d300 *********************** 
!  This calculates Gamma(0.2,x)/Gamma[0.2], where is a ratio
!   It is used for qiacr with the gamma of volume to calculate what 
!   fraction of drops exceed a certain size (this version is for 300 micron drops) (see zieglerstuff.nb)
! **********************************************************
      real FUNCTION GAML02d300(x) 
      implicit none
      integer ig, i, ii, n, np
      real x
      integer ng
      parameter(ng=9)
      real gamxg(ng), xg(ng)
      DATA xg/0.04,0.075,0.1,0.25,0.5,0.75,1.,2.,10./ 
      DATA gamxg/                           &
     &  0.0,                                  &
     &  7.391019203578011e-8,0.0002260640810600053,  &
     &  0.16567071824457152,                         &
     &  0.4231369044918005,0.5454357914523988,       &
     &  0.6170290936864555,                           &
     &  0.7471346054110058,0.9037156157718299 /
      IF ( x .ge. xg(ng) ) THEN
        GAML02d300 = xg(ng)
        RETURN
      ENDIF
      IF ( x .lt. xg(1) ) THEN
        GAML02d300 = 0.0
        RETURN
      ENDIF
      DO ii = 1,ng-1
        i = ng - ii
        n = i
        np = n + 1
        IF ( x .ge. xg(i) ) THEN
!         GOTO 2 
          GAML02d300 = gamxg(N)+((X-XG(N))/(XG(NP)-XG(N)))*  &
     &            ( gamxg(NP) - gamxg(N) ) 
          RETURN
        ENDIF
      ENDDO
      RETURN
      END FUNCTION GAML02d300
!c

! #####################################################################
! #####################################################################

!**************************** GAML02 *********************** 
!  This calculates Gamma(0.2,x)/Gamma[0.2], where is a ratio
!   It is used for qiacr with the gamma of volume to calculate what 
!   fraction of drops exceed a certain size (this version is for 500 micron drops) (see zieglerstuff.nb)
! **********************************************************
      real FUNCTION GAML02d500(x) 
      implicit none
      integer ig, i, ii, n, np
      real x
      integer ng
      parameter(ng=9)
      real gamxg(ng), xg(ng)
      DATA xg/0.04,0.075,0.1,0.25,0.5,0.75,1.,2.,10./ 
      DATA gamxg/  &
     &  0.0,0.0,   &
     &  2.2346039e-13, 0.0221272687459,  &
     &  0.23556540,  0.38710348,         &
     &  0.48136183,0.6565833,            &
     &  0.86918315 /
      IF ( x .ge. xg(ng) ) THEN
        GAML02d500 = xg(ng)
        RETURN
      ENDIF
      IF ( x .lt. xg(1) ) THEN
        GAML02d500 = 0.0
        RETURN
      ENDIF
      DO ii = 1,ng-1
        i = ng - ii
        n = i
        np = n + 1
        IF ( x .ge. xg(i) ) THEN
!         GOTO 2 
          GAML02d500 = gamxg(N)+((X-XG(N))/(XG(NP)-XG(N)))*  &
     &            ( gamxg(NP) - gamxg(N) ) 
          RETURN
        ENDIF
      ENDDO
      RETURN
      END FUNCTION GAML02d500
!c

! #####################################################################

! #####################################################################


        real function BETA(P,Q)
!
!       ==========================================
!       Purpose: Compute the beta function B(p,q)
!       Input :  p  --- Parameter  ( p > 0 )
!                q  --- Parameter  ( q > 0 )
!       Output:  BT --- B(p,q)
!       Routine called: GAMMA for computing gamma(x)
!       ==========================================
!
!        IMPLICIT real (A-H,O-Z)
        implicit none
        double precision p1,gp,q1,gq, ppq,gpq
        real p,q
        
        p1 = p
        q1 = q
        CALL GAMMADP(P1,GP)
        CALL GAMMADP(Q1,GQ)
        PPQ=P1+Q1
        CALL GAMMADP(PPQ,GPQ)
        beta=GP*GQ/GPQ
        RETURN
        END function BETA

! #####################################################################
! #####################################################################

      DOUBLE PRECISION FUNCTION GAMMA_DP(xx)

      implicit none
      double precision xx
      integer j

! Double precision ser,stp,tmp,x,y,cof(6)

      real*8 ser,stp,tmp,x,y,cof(6)
      SAVE cof,stp
      DATA cof,stp/76.18009172947146d+0,  &
     &            -86.50532032941677d0,   &
     &             24.01409824083091d0,   &
     &             -1.231739572450155d0,  &
     &              0.1208650973866179d-2,&
     &             -0.5395239384953d-5,   &
     &              2.5066282746310005d0/

      x = xx
      y = x
      tmp = x + 5.5d0
      tmp = (x + 0.5d0)*Log(tmp) - tmp
      ser = 1.000000000190015d0
      DO j=1,6
        y = y + 1.0d0
        ser = ser + cof(j)/y
      END DO
      gamma_dp = Exp(tmp + log(stp*ser/x))

      RETURN
      END function gamma_dp
! #####################################################################

        SUBROUTINE GAMMADP(X,GA)
!
!       ==================================================
!       Purpose: Compute gamma function Gamma(x)
!       Input :  x  --- Argument of Gamma(x)
!                       ( x is not equal to 0,-1,-2,...)
!       Output:  GA --- gamma(x)
!       ==================================================
!
!        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        implicit none
        
        double precision, parameter :: PI=3.141592653589793D0
        double precision :: x,ga,z,r,gr
        integer :: k,m1,m
        
        double precision :: G(26)
        
        IF (X.EQ.INT(X)) THEN
           IF (X.GT.0.0D0) THEN
              GA=1.0D0
              M1=X-1
              DO 10 K=2,M1
10               GA=GA*K
           ELSE
              GA=1.0D+300
           ENDIF
        ELSE
           IF (DABS(X).GT.1.0D0) THEN
              Z=DABS(X)
              M=INT(Z)
              R=1.0D0
              DO 15 K=1,M
15               R=R*(Z-K)
              Z=Z-M
           ELSE
              Z=X
           ENDIF
           DATA G/1.0D0,0.5772156649015329D0,                  &
     &          -0.6558780715202538D0, -0.420026350340952D-1,  &
     &          0.1665386113822915D0,-.421977345555443D-1,     &
     &          -.96219715278770D-2, .72189432466630D-2,       &
     &          -.11651675918591D-2, -.2152416741149D-3,       &
     &          .1280502823882D-3, -.201348547807D-4,          &
     &          -.12504934821D-5, .11330272320D-5,             &
     &          -.2056338417D-6, .61160950D-8,                 &
     &          .50020075D-8, -.11812746D-8,                   &
     &          .1043427D-9, .77823D-11,                       &
     &          -.36968D-11, .51D-12,                          &
     &          -.206D-13, -.54D-14, .14D-14, .1D-15/
           GR=G(26)
           DO 20 K=25,1,-1
20            GR=GR*Z+G(K)
           GA=1.0D0/(GR*Z)
           IF (DABS(X).GT.1.0D0) THEN
              GA=GA*R
              IF (X.LT.0.0D0) GA=-PI/(X*GA*DSIN(PI*X))
           ENDIF
        ENDIF
        RETURN
        END SUBROUTINE GAMMADP


! #####################################################################
! #####################################################################
!
!
! #####################################################################
      Function delbk(bb,nu,mu,k)
!   
!  Purpose: Caluculates collection coefficients following Siefert (2006)
!
!  delbk is equation (90) (b collecting b -- self-collection)
!  mass-diameter relationship: D = a*x**(b), where x = particle mass
!  general distribution: n(x) = A*x**(nu)*Exp(-lam*x**(mu))
!  where
!      A = mu*N/(Gamma((nu+1)/mu)) *lam**((nu+1)/mu)
!
!      lam = ( Gamma((nu+1)/mu)/Gamma((nu+2)/mu) * xbar )**(-mu)
!
!     where  xbar = L/N  (mass content)/(number concentration) = q*rhoa/N
!

      implicit none
      real delbk, gamma
      real nu, mu, bb
      integer k
      
      real tmp, del
      real x1, x2, x3, x4
      integer i

        tmp = ((1.0 + nu)/mu)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        x1 = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = ((2.0 + nu)/mu)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        x2 = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = ((1.0 + 2.0*bb + k + nu)/mu)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        x3 = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
      
!      delbk =  &
!     &  ((Gamma((1.0 + nu)/mu)/Gamma((2.0 + nu)/mu))**(2.0*bb + k)* &
!     &    Gamma((1.0 + 2.0*bb + k + nu)/mu))/Gamma((1.0 + nu)/mu)

      delbk =  &
     &  ((x1/x2)**(2.0*bb + k)* &
     &    x3)/x1
      
      RETURN
      END  Function delbk
      
! #####################################################################
!
!
! #####################################################################
! Equation (91) in Seifert and Beheng (2006) ("a" collecting "b")
      Function delabk(ba,bb,nua,nub,mua,mub,k)
      
      implicit none
      real delabk, gamma
      real nua, mua, ba
      integer k
      real nub, mub, bb
      
      integer i
      real tmp,del
      
      real g1pnua, g2pnua, g1pbapnua, g1pbbpk, g1pnub, g2pnub
      
        tmp = (1. + nua)/mua
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        IF ( i+1 > ngm0 ) THEN
          write(0,*) 'delabk: i+1 > ngm0!!!!',i,ngm0,nua,mua,tmp
          STOP
        ENDIF
        g1pnua = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
!        write(91,*) 'delabk: g1pnua,gamma = ',g1pnua,Gamma((1. + nua)/mua)

        tmp = ((2. + nua)/mua)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g2pnua = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = ((1. + ba + nua)/mua)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g1pbapnua = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = ((1. + nub)/mub)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g1pnub = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = ((2 + nub)/mub)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g2pnub = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = ((1. + bb + k + nub)/mub)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g1pbbpk = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

      delabk =  &
     &  (2.*(g1pnua/g2pnua)**ba*     &
     &    g1pbapnua*                                               &
     &    (g1pnub/g2pnub)**(bb + k)*                                &
     &    g1pbbpk)/                                                &
     &  (g1pnua*g1pnub)              
      
      RETURN
      END Function delabk
      

! #####################################################################
!
! #####################################################################
!--------------------------------------------------------------------------
      subroutine cld_cpu(string)

      implicit none
      character( LEN = * ) string
      
      return
      
      end subroutine cld_cpu

!
!--------------------------------------------------------------------------
!
!--------------------------------------------------------------------------
!
      subroutine sediment1d(dtp,nx,ny,nz,an,na,nor,norz,xfall,dn,dz3d,dz3dinv, &
     &                    t0,t7,infdo,jslab,its,jts,  &
     &   timesed1,timesed2,timesed3,zmaxsed,timesetvt) ! used for timing
!
! Sedimentation driver -- column by column
!
!  Written by ERM 10/2011
!
!
!
      implicit none

      integer nx,ny,nz,nor,norz,ngt,jgs,na,ia
      integer id ! =1 use density, =0 no density
      integer :: its,jts ! SW point of local tile
      
      integer ng1
      parameter(ng1 = 1)

      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real dz3d(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real dz3dinv(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t0(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t7(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

!      real gz(-nor+ng1:nz+nor),z1d(-nor+ng1:nz+nor,4)
      real dtp
      real xfall(nx,ny,na)  ! array for stuff landing on the ground
      real xfall0(nx,ny)    ! dummy array
      integer infdo
      integer jslab ! which line of xfall to use
            
      integer ix,jy,kz,ndfall,n,k,il,in
      real tmp, vtmax, dtptmp, dtfrac
      real, parameter :: dz = 200.

      real :: xvt(nz+1,nx,3,lc:lhab) ! (nx,nz,2,lc:lhab) ! 1=mass-weighted, 2=number-weighted
      real :: tmpn(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real :: tmpn2(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real :: z(-nor+ng1:nx+nor,-norz+ng1:nz+norz,lr:lhab)
      real :: db1(nx,nz+1),dtz1(nz+1,nx,0:1),dz2dinv(nz+1,nx),db1inv(nx,nz+1)
      
      real :: rhovtzx(nz,nx)
      
      double precision :: timesed1,timesed2,timesed3, zmaxsed,timesetvt,dummy
      double precision :: dt1,dt2,dt3,dt4

      integer,parameter :: ngs = 128 
      integer :: ngscnt,mgs,ipconc0
      
      real ::  qx(ngs,lv:lhab) 
      real ::  qxw(ngs,ls:lhab) 
      real ::  cx(ngs,lc:lhab) 
      real ::  xv(ngs,lc:lhab) 
      real ::  vtxbar(ngs,lc:lhab,3) 
      real ::  xmas(ngs,lc:lhab) 
      real ::  xdn(ngs,lc:lhab) 
      real ::  xdia(ngs,lc:lhab,3) 
      real ::  vx(ngs,li:lhab) 
      real ::  alpha(ngs,lc:lhab) 
      real ::  zx(ngs,lr:lhab) 
      logical :: hasmass(nx,lc+1:lhab)

      integer igs(ngs),kgs(ngs)
      
      real rho0(ngs),temcg(ngs)

      real temg(ngs)
      
      real rhovt(ngs)
      
      real cwnc(ngs),cinc(ngs)
      real fadvisc(ngs),cwdia(ngs),cipmas(ngs)
      
      real cimasn,cimasx,cnina(ngs),cimas(ngs)
      
      real cnostmp(ngs)
      

!-----------------------------------------------------------------------------

      integer :: ixb, jyb, kzb
      integer :: ixe, jye, kze
      integer :: plo, phi

      logical :: debug_mpi = .TRUE.

! ###################################################################




      kzb = 1
      kze = nz

      ixb = 1
      ixe = nx


      jy = 1
      jgs = jy


!
!  zero the precip flux arrays (2d)
!

      xvt(:,:,:,:) = 0.0

      if ( ndebug .gt. 0 ) write(0,*) 'dbg = 3a'


      DO kz = kzb,kze
      DO ix = ixb,ixe
       db1(ix,kz) = dn(ix,jy,kz)
       db1inv(ix,kz) = 1./dn(ix,jy,kz)
       rhovtzx(kz,ix) = Sqrt(rho00*db1inv(ix,kz) )
      ENDDO
      ENDDO

      DO kz = kzb,kze
      DO ix = ixb,ixe
       dtz1(kz,ix,0) = dz3dinv(ix,jy,kz)
       dtz1(kz,ix,1) = dz3dinv(ix,jy,kz)*db1inv(ix,kz) 
       dz2dinv(kz,ix) = dz3dinv(ix,jy,kz)
      ENDDO
      ENDDO

      IF ( lzh .gt. 1 ) THEN
      DO kz = kzb,kze
      DO ix = ixb,ixe
        an(ix,jy,kz,lzh) = Max( 0., an(ix,jy,kz,lzh) )
      ENDDO
      ENDDO
      ENDIF

      
      DO il = lc+1,lhab
       DO ix = ixb,ixe
!        hasmass(ix,il) = Any( an(ix,jy,:,il) > qxmin(il) )
       ENDDO
      ENDDO




      if (ndebug .gt. 0 ) write(0,*) 'dbg = 3a2'

! loop over columns
      DO ix = ixb,ixe
      
      dummy = 0.d0

      
      call ziegfall1d(nx,ny,nz,nor,norz,na,dtp,jgs,ix, & 
     &  xvt, rhovtzx, & 
     &  an,dn,ipconc,t0,t7,cwmasn,cwmasx, & 
     &  cwradn, & 
     &  qxmin,xdnmx,xdnmn,cdx,cno,xdn0,xvmn,xvmx, & 
     &  ngs,qx,qxw,cx,xv,vtxbar,xmas,xdn,xdia,vx,alpha,zx,igs,kgs, &
     &  rho0,temcg,temg,rhovt,cwnc,cinc,fadvisc,cwdia,cipmas,cnina,cimas, &
     &  cnostmp,              &
     &  infdo,0               &
     & )


! loop over each species and do sedimentation for all moments
     DO il = lc,lhab

!       IF ( .not. hasmass(ix,il) ) CYCLE

!      plo = nz
!      phi = 0


      vtmax = 0.0
      
      do kz = kzb,kze
      
      vtmax = Max(vtmax,xvt(kz,ix,1,il)*dz2dinv(kz,ix))
      vtmax = Max(vtmax,xvt(kz,ix,2,il)*dz2dinv(kz,ix))
      vtmax = Max(vtmax,xvt(kz,ix,3,il)*dz2dinv(kz,ix))

!      IF ( dtp*xvt(kz,ix,1,il)*dz2dinv(kz,ix) >= 0.7 .or. &
!     &     dtp*xvt(kz,ix,2,il)*dz2dinv(kz,ix) >= 0.7 .or. &
!     &     dtp*xvt(kz,ix,3,il)*dz2dinv(kz,ix) >= 0.7 ) THEN
!          
!          zmaxsed = Max(zmaxsed, float(kz) )
!!          plo = Min(plo,kz)
!!          phi = Max(phi,kz)
!           
!      ENDIF
      
      ENDDO
      
      IF ( vtmax == 0.0 ) CYCLE


      
      IF ( dtp*vtmax .lt. 0.7 ) THEN ! check whether multiple steps are needed.
        ndfall = 1
      ELSE
       IF ( dtp > 20.0 ) THEN ! more stringent subdivision for large time steps
         ndfall = Max(2, Int(dtp*vtmax/0.7) + 1)
       ELSE ! more relaxed for small time steps, but might still be a problem for very thin vertical layers near the ground
         ndfall = 1+Int(dtp*vtmax + 0.301)
       ENDIF
      ENDIF
      
      IF ( ndfall .gt. 1 ) THEN
        dtptmp = dtp/Real(ndfall)
!        write(0,*) 'subdivide fallout on its,jts,ix,plo,phi = ',its,jts,ix,plo,phi
!        write(0,*) 'for il,jsblab,c,ndfall = ',il,jslab,dtp*vtmax,ndfall
      ELSE
        dtptmp = dtp
      ENDIF
      
      dtfrac = dtptmp/dtp


      DO n = 1,ndfall

      IF ( n .ge. 2 ) THEN
!
!  zero the precip flux arrays (2d)
!
      
!      xvt(:,:,:,il) = 0.0
      dummy = 0.d0
      call ziegfall1d(nx,ny,nz,nor,norz,na,dtp,jgs,ix, & 
     &  xvt, rhovtzx, & 
     &  an,dn,ipconc,t0,t7,cwmasn,cwmasx, & 
     &  cwradn, & 
     &  qxmin,xdnmx,xdnmn,cdx,cno,xdn0,xvmn,xvmx, & 
     &  ngs,qx,qxw,cx,xv,vtxbar,xmas,xdn,xdia,vx,alpha,zx,igs,kgs, &
     &  rho0,temcg,temg,rhovt,cwnc,cinc,fadvisc,cwdia,cipmas,cnina,cimas, &
     &  cnostmp,             &
     &  infdo,il)


      ENDIF ! (n .ge. 2)


        IF ( il >= lr .and. ( infall .eq. 3 .or. infall .eq. 4 ) .and. ln(il) > 0 ) THEN
           IF ( (il .eq. lr .and. irfall .eq. infall .and. lzr < 1) .or. (il .ge. lh .and. lz(il) .lt. 1 ) ) THEN
            call calczgr1d(nx,ny,nz,nor,na,an,ixe,kze, & 
     &         z,db1,jgs,ipconc, dnu(il), il, ln(il), qxmin(il), xvmn(il), xvmx(il), lvol(il), xdn0(il), ix )
           ENDIF
        ENDIF

      if (ndebug .gt. 0 ) write(0,*) 'dbg = 1b'

! mixing ratio

      call fallout1d(nx,ny,nz,nor,na,dtptmp,dtfrac,jgs,xvt(1,1,1,il), & 
     &             an,db1,il,1,xfall,dtz1,ix)


      if (ndebug .gt. 0 ) write(0,*) 'dbg = 3c'

! volume

      IF ( ldovol .and. il >= li ) THEN
        IF ( lvol(il) .gt. 1 ) THEN
         call fallout1d(nx,ny,nz,nor,na,dtptmp,dtfrac,jgs,xvt(1,1,1,il), & 
     &              an,db1,lvol(il),0,xfall,dtz1,ix)
        ENDIF
      ENDIF


      if (ndebug .gt. 0 ) write(0,*) 'dbg = 3d'

      
      IF ( ipconc .gt. 0 ) THEN !{
        IF ( ipconc .ge. ipc(il) ) THEN

      IF ( ( infall .ge. 2 .or. (infall .eq. 0 .and. il .lt. lh) ) .and. lz(il) .lt. 1) THEN !{
!
! load number conc. into tmpn to do fallout by mass-weighted mean fall speed
!  to put a lower bound on number conc.
!

        IF ( ( infall .eq. 3 .or. infall .eq. 4 ) .and. ( il .eq. lh .or. il .eq. lhl .or.  & 
     &      ( il .eq. lr .and. irfall .eq. infall) ) ) THEN

          DO kz = kzb,kze
!            DO ix = ixb,ixe
              tmpn2(ix,jy,kz) = z(ix,kz,il)
!            ENDDO
          ENDDO
          DO kz = kzb,kze
!            DO ix = ixb,ixe
              tmpn(ix,jy,kz) = an(ix,jy,kz,ln(il))
!            ENDDO
          ENDDO
        
        ELSE
          
          DO kz = kzb,kze
!            DO ix = ixb,ixe
              tmpn(ix,jy,kz) = an(ix,jy,kz,ln(il))
!            ENDDO
          ENDDO

        ENDIF

      ENDIF !}


      if (ndebug .gt. 0 ) write(0,*) 'dbg = 3f'

       in = 2
       IF ( infall .eq. 1 ) in = 1

         call fallout1d(nx,ny,nz,nor,na,dtptmp,dtfrac,jgs,xvt(1,1,in,il), & 
     &        an,db1,ln(il),0,xfall,dtz1,ix)


         IF ( lz(il) .lt. 1 ) THEN ! if not 3-moment, run one of the correction schemes
         IF ( (infall .ge. 2 .or. infall .eq. 3) .and. .not. (infall .eq. 0 .and. il .ge. lh) & 
     &       .and. ( il .eq. lr .or. (il .ge. li .and. il .le. lhab) )) THEN
!     :        .or. il .eq. lhl )) THEN
           
           xfall0(:,jgs) = 0.0

           IF ( ( infall .eq. 3 .or. infall .eq. 4 ) .and.  & 
     &        ( il .ge. lh .or. (il .eq. lr .and. irfall .eq. infall) ) ) THEN
             call fallout1d(nx,ny,nz,nor,1,dtptmp,dtfrac,jgs,xvt(1,1,3,il), & 
     &         tmpn2,db1,1,0,xfall0,dtz1,ix)
             call fallout1d(nx,ny,nz,nor,1,dtptmp,dtfrac,jgs,xvt(1,1,1,il), & 
     &         tmpn,db1,1,0,xfall0,dtz1,ix)
           ELSE
             call fallout1d(nx,ny,nz,nor,1,dtptmp,dtfrac,jgs,xvt(1,1,1,il), & 
     &         tmpn,db1,1,0,xfall0,dtz1,ix)
           ENDIF

           IF ( ( infall .eq. 3 .or. infall .eq. 4 ) .and. ( (il .eq. lr .and. irfall .eq. infall) & 
     &            .or. il .ge. lh ) ) THEN
! "Method I" - dbz correction

             call calcnfromz1d(nx,ny,nz,nor,na,an,tmpn2,ixe,kze, & 
     &       z,db1,jgs,ipconc, dnu(il), il, ln(il), qxmin(il), xvmn(il), xvmx(il),tmpn,  & 
     &       lvol(il), rho_qh, infall, ix)

           ELSEIF ( infall .eq. 5 .and. il .ge. lh .or. ( il == lr .and. irfall == 5 ) ) THEN

             DO kz = kzb,kze
!              DO ix = ixb,ixe
               an(ix,jgs,kz,ln(il)) = Max( an(ix,jgs,kz,ln(il)), 0.5* ( an(ix,jgs,kz,ln(il)) + tmpn(ix,jy,kz) ))
              
!              ENDDO
             ENDDO           

           ELSEIF ( .not. (il .eq. lr .and. irfall .eq. 0) ) THEN
! "Method II" M-wgt N-fallout correction

             DO kz = kzb,kze
!              DO ix = ixb,ixe

               an(ix,jgs,kz,ln(il)) = Max( an(ix,jgs,kz,ln(il)), tmpn(ix,jy,kz) )
              
!              ENDDO
             ENDDO
           ENDIF 
           ENDIF ! lz(il) .lt. 1
           

         ENDIF
        ENDIF


      ENDIF !}


      ENDDO ! n=1,ndfall
      ENDDO ! il
      
      ENDDO ! ix



      
      RETURN
      END SUBROUTINE SEDIMENT1D


! #####################################################################

!
! #####################################################################


!
!--------------------------------------------------------------------------
!
!--------------------------------------------------------------------------
!
      subroutine fallout1d(nx,ny,nz,nor,na,dtp,dtfrac,jgs,vt,   &
     &  a,db1,ia,id,xfall,dtz1,ixcol)
!
! First-order, upwind fallout scheme
!
!  Written by ERM 6/10/2011
!
!
!
      implicit none

      integer nx,ny,nz,nor,ngt,jgs,na,ia
      integer id ! =1 use density, =0 no density
      integer ng1
      parameter(ng1 = 1)
      integer :: ixcol

!      real dz3dinv(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)
!      real a(nx,ny,nz,na)
      real a(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor,na) ! quantity to be 'advected'
      real vt(nz+1,nx)  ! terminal speed for a
      real dtp,dtfrac
      real cmax
      real xfall(nx,ny,na)  ! array for stuff landing on the ground
      real db1(nx,nz+1),dtz1(nz+1,nx,0:1)

! Local
           
      integer ix,jy,kz,n,k
      integer iv1,iv2
      real tmp
      integer imn,imx,kmn,kmx
      real qtmp1(nz+1)

!-----------------------------------------------------------------------------

      integer :: ixb, jyb, kzb
      integer :: ixe, jye, kze

      logical :: debug_mpi = .TRUE.

! ###################################################################

      jy = 1

      iv1 = 0
      iv2 = 0

      imn = nx
      imx = 1
      kmn = nz
      kmx = 1

      cmax = 0.0

      kzb = 1
      kze = nz

      ixb = ixcol
      ixe = ixcol
      ix  = ixcol

      qtmp1(nz+1) = 0.0
      
      DO kz = kzb,kze
!        DO ix = ixb,ixe
!         cmax = Max(cmax, vt(ix,kz)*dz3dinv(ix,jy,kz)) 
         
         IF ( id == 1 ) THEN
         qtmp1(kz) = a(ix,jgs,kz,ia)*vt(kz,ix)*db1(ix,kz)
         ELSE
         qtmp1(kz) = a(ix,jgs,kz,ia)*vt(kz,ix)
         ENDIF
         
         IF ( a(ix,jgs,kz,ia) .ne. 0.0 ) THEN
!           imn = Min(ix,imn)
!           imx = Max(ix,imx)
           kmn = Min(kz,kmn)
           kmx = Max(kz,kmx)
         ENDIF
!        ENDDO
      ENDDO
      
      kmn = Max(1,kmn-1)
      
! first check if fallout is worth doing
!      IF ( cmax .eq. 0.0 .or. imn .gt. imx ) THEN
!        RETURN
!      ENDIF
      
      IF ( kmn == 1 ) THEN
      
      kz = 1
!      do ix = imn,imx ! 1,nx-1
         xfall(ix,jy,ia) = xfall(ix,jy,ia) + a(ix,jgs,kz,ia)*vt(kz,ix)*dtfrac
!      enddo
      
      ENDIF

      do kz = 1,nz
!      do ix = 1,nx
        a(ix,jgs,kz,ia) =  a(ix,jgs,kz,ia) + dtp*dtz1(kz,ix,id)*(qtmp1(kz+1) - qtmp1(kz) )
!      enddo
      enddo

      
      RETURN
      END SUBROUTINE FALLOUT1D

! ##############################################################################
! ##############################################################################

      subroutine calczgr1d(nx,ny,nz,nor,na,a,ixe,kze,              &
     &    z,db,jgs,ipconc, alpha, l,ln, qmin, xvmn,xvmx, lvol, rho_qx, ixcol)


      implicit none

      integer nx,ny,nz,nor,na,ngt,jgs
      integer :: ixcol
      integer, parameter :: norz = 3
      real a(-nor+1:nx+nor,-nor+1:ny+nor,-nor+1:nz+nor,na)
      real z(-nor+1:nx+nor,-nor+1:nz+nor,lr:lhab)   ! reflectivity
      real db(nx,nz+1)  ! air density
!      real gt(-nor+1:nx+nor,-nor+1:ny+nor,-nor+1:nz+nor,ngt)

      integer ixe,kze
      real    alpha
      real    qmin
      real    xvmn,xvmx
      integer ipconc
      integer l   ! index for q
      integer ln  ! index for N
      integer lvol ! index for volume
      real    rho_qx


      integer ix,jy,kz
      real vr,qr,nrx,rd,xv,g1,zx,chw,xdn
      
      
      jy = jgs
      ix = ixcol
      
      IF ( l .eq. lh .or. l .eq. lhl .or. ( l .eq. lr .and. imurain == 1 )  ) THEN
      
      
      DO kz = 1,kze
          
          
          
          IF (  a(ix,jy,kz,l) .gt. qmin .and. a(ix,jy,kz,ln) .gt. 1.e-15 ) THEN
            
            IF ( lvol .gt. 1 ) THEN
                IF ( a(ix,jy,kz,lvol) .gt. 0.0 ) THEN
                  xdn = db(ix,kz)*a(ix,jy,kz,l)/a(ix,jy,kz,lvol)
                  xdn = Min( 900., Max( hdnmn, xdn ) )
                ELSE
                  xdn = rho_qx
                ENDIF
            ELSE
                xdn = rho_qx
            ENDIF

            IF ( l == lr ) xdn = 1000.

            qr = a(ix,jy,kz,l)
            xv = db(ix,kz)*a(ix,jy,kz,l)/(xdn*a(ix,jy,kz,ln))
            chw = a(ix,jy,kz,ln)

             IF ( xv .lt. xvmn .or. xv .gt. xvmx ) THEN
              xv = Min( xvmx, Max( xvmn,xv ) )
              chw = db(ix,kz)*a(ix,jy,kz,l)/(xv*xdn)
             ENDIF

             g1 = (6.0 + alpha)*(5.0 + alpha)*(4.0 + alpha)/  &
     &            ((3.0 + alpha)*(2.0 + alpha)*(1.0 + alpha))
             zx = g1*db(ix,kz)**2*(a(ix,jy,kz,l))*a(ix,jy,kz,l)/chw
!             z(ix,kz,l)  = 1.e18*zx*(6./(pi*1000.))**2
             z(ix,kz,l)  = zx*(6./(pi*1000.))**2


!          IF ( ny.eq.2 .and. kz .ge. 25 .and. kz .le. 29 .and. z(ix,kz,l) .gt. 0. ) THEN
!             write(*,*) 'calczgr: z,dbz,xdn = ',ix,kz,z(ix,kz,l),10*log10(z(ix,kz,l)),xdn
!          ENDIF
          
          ELSE
           
            z(ix,kz,l) = 0.0
           
          ENDIF
          
      ENDDO
      
      ELSEIF ( l .eq. lr .and. imurain == 3) THEN

      xdn = 1000.
      
      DO kz = 1,kze
          IF (  a(ix,jy,kz,l) .gt. qmin .and. a(ix,jy,kz,ln) .gt. 1.e-15 ) THEN

            vr = db(ix,kz)*a(ix,jy,kz,l)/(xdn*a(ix,jy,kz,ln))
!            z(ix,kz,l) = 3.6e18*(rnu+2.0)*a(ix,jy,kz,ln)*vr**2/(rnu+1.0)
            z(ix,kz,l) = 3.6*(rnu+2.0)*a(ix,jy,kz,ln)*vr**2/(rnu+1.0)
!            qr = a(ix,jy,kz,lr)
!            nrx = a(ix,jy,kz,lnr)
          
          ELSE
           
            z(ix,kz,l) = 0.0
           
          ENDIF
      
          
      ENDDO
      
      ENDIF
      
      RETURN
      
      END subroutine calczgr1d

! ##############################################################################
! ##############################################################################
!
!  Subroutine to correct number concentration to prevent reflectivity growth by 
!  sedimentation in 2-moment ZXX scheme.
!  Calculation is in a slab (constant jgs)
!

      subroutine calcnfromz1d(nx,ny,nz,nor,na,a,t0,ixe,kze,    &
     &    z0,db,jgs,ipconc, alpha, l,ln, qmin, xvmn,xvmx,t1, &
     &    lvol, rho_qx, infall, ixcol)

      
      implicit none

      integer nx,ny,nz,nor,na,ngt,jgs,ixcol

      real a(-nor+1:nx+nor,-nor+1:ny+nor,-nor+1:nz+nor,na)  ! sedimented N and q
      real t0(-nor+1:nx+nor,-nor+1:ny+nor,-nor+1:nz+nor)    ! sedimented reflectivity
      real t1(-nor+1:nx+nor,-nor+1:ny+nor,-nor+1:nz+nor)    ! sedimented N (by Vm)
!      real gt(-nor+1:nx+nor,-nor+1:ny+nor,-nor+1:nz+nor,ngt)
      real z0(-nor+1:nx+nor,-nor+1:nz+nor,lr:lhab)   ! initial reflectivity

      real db(nx,nz+1)  ! air density
      
      integer ixe,kze
      real    alpha
      real    qmin
      real    xvmn,xvmx
      integer ipconc
      integer l   ! index for q
      integer ln  ! index for N
      integer lvol ! index for volume
      real    rho_qx
      integer infall
      
      
      integer ix,jy,kz
      double precision vr,qr,nrx,rd,g1,zx,chw,z,znew,zt,zxt
      real xv,xdn
      integer :: ndbz, nmwgt, nnwgt, nwlessthanz
      
      ndbz = 0
      nmwgt = 0
      nnwgt = 0
      nwlessthanz = 0
      

      
      jy = jgs
      ix = ixcol
      
      IF ( l .eq. lh .or. l .eq. lhl .or. ( l == lr .and. imurain == 1 ) ) THEN
      
             g1 = (6.0 + alpha)*(5.0 + alpha)*(4.0 + alpha)/  &
     &            ((3.0 + alpha)*(2.0 + alpha)*(1.0 + alpha))
      
      DO kz = 1,kze

         
          IF (   t0(ix,jy,kz) .gt. 0. ) THEN ! {
            
            IF ( lvol .gt. 1 ) THEN
               IF ( a(ix,jy,kz,lvol) .gt. 0.0 ) THEN
                 xdn = db(ix,kz)*a(ix,jy,kz,l)/a(ix,jy,kz,lvol)
                 xdn = Min( 900., Max( hdnmn, xdn ) )
               ELSE 
                 xdn = rho_qx
               ENDIF
            ELSE
               xdn = rho_qx
            ENDIF
            
            IF ( l == lr ) xdn = 1000.
          
            qr = a(ix,jy,kz,l)
            xv = db(ix,kz)*a(ix,jy,kz,l)/(xdn*a(ix,jy,kz,ln))
            chw = a(ix,jy,kz,ln)

             IF ( xv .lt. xvmn .or. xv .gt. xvmx ) THEN
              xv = Min( xvmx, Max( xvmn,xv ) )
              chw = db(ix,kz)*a(ix,jy,kz,l)/(xv*xdn)
             ENDIF

             zx = g1*db(ix,kz)**2*( a(ix,jy,kz,l))*a(ix,jy,kz,l)/chw
             z  = zx*(6./(pi*1000.))**2

            
           IF ( (z .gt. t0(ix,jy,kz) .and. z .gt. 0.0 .and.  &
     &           t0(ix,jy,kz) .gt. z0(ix,kz,l) )) THEN !{
           
            zx = t0(ix,jy,kz)/((6./(pi*1000.))**2)
            
            nrx =  g1*db(ix,kz)**2*( a(ix,jy,kz,l))*a(ix,jy,kz,l)/zx
            IF ( infall .eq. 3 ) THEN
              IF ( nrx .gt. a(ix,jy,kz,ln) ) THEN
                ndbz = ndbz + 1
                IF ( t1(ix,jy,kz) .lt. ndbz ) nwlessthanz = nwlessthanz + 1
              ELSE
                nnwgt = nnwgt + 1
              ENDIF
              a(ix,jy,kz,ln) = Max( real(nrx), a(ix,jy,kz,ln) )
            ELSE
             IF (  nrx .gt. a(ix,jy,kz,ln) .and. t1(ix,jy,kz) .gt. a(ix,jy,kz,ln) ) THEN
              IF ( nrx .lt. t1(ix,jy,kz)  ) THEN
                ndbz = ndbz + 1
              ELSE
                nmwgt = nmwgt + 1
                IF ( t1(ix,jy,kz) .lt. ndbz ) nwlessthanz = nwlessthanz + 1
              ENDIF
             ELSE
              nnwgt = nnwgt + 1
             ENDIF
              
              a(ix,jy,kz,ln) = Max(Min( real(nrx), t1(ix,jy,kz) ), a(ix,jy,kz,ln) )
            ENDIF

           ELSE ! } {
             IF ( t1(ix,jy,kz) .gt. 0 .and. a(ix,jy,kz,ln) .gt. 0 ) THEN
              IF ( t1(ix,jy,kz) .gt. a(ix,jy,kz,ln) ) THEN
                nmwgt = nmwgt + 1
              ELSE
                nnwgt = nnwgt + 1
              ENDIF
            ENDIF
            a(ix,jy,kz,ln) = Max(t1(ix,jy,kz), a(ix,jy,kz,ln) )
            nrx = a(ix,jy,kz,ln)



           ENDIF ! }

           ! }
          ELSE ! {
            IF ( t1(ix,jy,kz) .gt. 0 .and. a(ix,jy,kz,ln) .gt. 0 ) THEN
              IF ( t1(ix,jy,kz) .gt. a(ix,jy,kz,ln) ) THEN
                nmwgt = nmwgt + 1
              ELSE
                nnwgt = nnwgt + 1
              ENDIF
            ENDIF
          ENDIF! }
          
      ENDDO
      
      
      ELSEIF ( l .eq. lr .and. imurain == 3) THEN

      xdn = 1000.
      
      DO kz = 1,kze
          IF (  t0(ix,jy,kz) .gt. 0. ) THEN

            vr = db(ix,kz)*a(ix,jy,kz,l)/(xdn*a(ix,jy,kz,ln))
            z = 3.6*(rnu+2.0)*a(ix,jy,kz,ln)*vr**2/(rnu+1.0)
          
             IF ( z .gt. t0(ix,jy,kz) .and. z .gt. 0.0 .and.  &
     &          t0(ix,jy,kz) .gt. 0.0                         &
     &          .and. t0(ix,jy,kz) .gt. z0(ix,kz,l) ) THEN

            vr = db(ix,kz)*a(ix,jy,kz,l)/(xdn)
             chw =  a(ix,jy,kz,ln)
            nrx =   3.6*(rnu+2.0)*vr**2/((rnu+1.0)*t0(ix,jy,kz))
             IF ( infall .eq. 3 ) THEN
              a(ix,jy,kz,ln) = Max( real(nrx), a(ix,jy,kz,ln) )
            ELSEIF ( infall .eq. 4 ) THEN
              a(ix,jy,kz,ln) = Max( Min( real(nrx), t1(ix,jy,kz)), a(ix,jy,kz,ln) )
            ENDIF

           ELSE

            a(ix,jy,kz,ln) = Max(t1(ix,jy,kz), a(ix,jy,kz,ln) )

           ENDIF

          ELSE

            a(ix,jy,kz,ln) = Max(t1(ix,jy,kz), a(ix,jy,kz,ln) )

          ENDIF


      ENDDO

      ENDIF

      RETURN

      END subroutine calcnfromz1d


! ##############################################################################
! ##############################################################################
!
!  Subroutine to calculate number concentrations from initial state that has only mixing ratio.
!  N will be in #/kg, NOT #/m^3, since sedimentation is done next.
!

      subroutine calcnfromq(nx,ny,nz,an,na,nor,norz,dn)

      
      implicit none

      integer nx,ny,nz,nor,norz,na,ngt,jgs,ixcol

      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)  ! scalars (q, N, Z)

      real dn(nx,nz+1)  ! air density
      
      integer ixe,kze
      real    alpha
      real    qmin
      real    xvmn,xvmx
      integer ipconc
      integer lvol ! index for volume
      integer infall
      
      
      integer ix,jy,kz
      double precision vr,q,nrx,rd,g1h,g1r,g1s,zx,chw,z,znew,zt,zxt,n1,laminv1
      double precision :: zr, zs, zh, dninv
      real, parameter :: xn0s = 3.0e6, xn0r = 8.0e6, xn0h = 4.0e4
      real, parameter :: xdnr = 1000., xdns = 100. ,xdnh = 900.0
      real, parameter :: zhfac = 1./(pi*xdnh*xn0h)
      real, parameter :: zrfac = 1./(pi*xdnr*xn0r)
      real, parameter :: zsfac = 1./(pi*xdns*xn0s)
      real, parameter :: g0 = (6.0)*(5.0)*(4.0)/((3.0)*(2.0)*(1.0))

      real xv,xdn
      integer :: ndbz, nmwgt, nnwgt, nwlessthanz

! ------------------------------------------------------------------
      
      
      jy = 1
      
      
         g1h = (6.0 + alphah)*(5.0 + alphah)*(4.0 + alphah)/  &
     &        ((3.0 + alphah)*(2.0 + alphah)*(1.0 + alphah))
     
         IF ( imurain == 3 ) THEN
         g1r = (rnu+2.0)/(rnu+1.0)
         ELSE ! imurain == 1
         g1r = (6.0 + alphar)*(5.0 + alphar)*(4.0 + alphar)/  &
     &        ((3.0 + alphar)*(2.0 + alphar)*(1.0 + alphar))
         ENDIF

         g1s = (snu+2.0)/(snu+1.0)
      
      DO kz = 1,nz
       DO ix = 1,nx ! ixcol

         dninv = 1./dn(ix,kz)
         
   !  Cloud droplets
         
         IF ( lnc > 1 ) THEN
           IF ( an(ix,jy,kz,lnc) <= 0.0 .and. an(ix,jy,kz,lc) > qxmin(lc) ) THEN
             an(ix,jy,kz,lnc) = qccn
           ENDIF
         ENDIF

   !  rain
         
         IF ( lnr > 1 ) THEN
           IF ( an(ix,jy,kz,lnr) <= 0.0 .and. an(ix,jy,kz,lr) > qxmin(lr) ) THEN

             q = an(ix,jy,kz,lr)
             
             laminv1 = (dn(ix,kz) * q * zrfac)**(0.25)  ! inverse of slope
             
             n1 = laminv1*xn0h  ! number concentration for inv. exponential single moment input
             
             nrx =  n1*g1r/g0   ! number concentration for different shape parameter

             an(ix,jy,kz,lnr) = nrx ! *dninv ! convert to number mixing ratio
             
           ENDIF
         ENDIF

  ! snow
         IF ( lns > 1 ) THEN
           IF ( an(ix,jy,kz,lns) <= 0.0 .and. an(ix,jy,kz,ls) > qxmin(ls) ) THEN

             q = an(ix,jy,kz,ls)
             
             laminv1 = (dn(ix,kz) * q * zsfac)**(0.25)  ! inverse of slope
             
             n1 = laminv1*xn0s  ! number concentration for inv. exponential single moment input
             
             nrx =  n1*g1s/g0   ! number concentration for different shape parameter

             an(ix,jy,kz,lns) = nrx ! *dninv ! convert to number mixing ratio
             
           ENDIF
         ENDIF
         
    ! graupel

         IF ( lnh > 1 ) THEN
           IF ( an(ix,jy,kz,lnh) <= 0.0 .and. an(ix,jy,kz,lh) > qxmin(lh) ) THEN
             IF ( lvh > 1 ) THEN
               IF ( an(ix,jy,kz,lvh) <= 0.0 ) THEN
                 an(ix,jy,kz,lvh) = an(ix,jy,kz,lh)/xdnh
               ENDIF
             ENDIF

             q = an(ix,jy,kz,lh)
             
             laminv1 = (dn(ix,kz) * q * zhfac)**(0.25)  ! inverse of slope
             
             n1 = laminv1*xn0h  ! number concentration for inv. exponential single moment input
             
             nrx =  n1*g1h/g0   ! number concentration for different shape parameter

             an(ix,jy,kz,lnh) = nrx ! *dninv ! convert to number mixing ratio

           ENDIF
         ENDIF
 
      ENDDO ! ix
      ENDDO ! kz
      
      RETURN
      
      END subroutine calcnfromq

! #####################################################################
! #####################################################################

   SUBROUTINE calc_eff_radius    &
     &  (nx,ny,nz,na,jyslab & 
     &  ,nor,norz & 
     &  ,t1,t2,t3  & 
     &  ,an,dn )

   implicit none

      integer, parameter :: ng1 = 1
      integer :: nx,ny,nz,na
      integer :: ng
      integer :: nor,norz, jyslab ! ,nht,ngt,igsr
      real    :: dtp  ! time step


!
! external temporary arrays
!

      real t1(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t3(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      

      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

      


      
    ! local
    
      real pb(-norz+ng1:nz+norz)
      real pinit(-norz+ng1:nz+norz)

! 
!  declarations microphysics and for gather/scatter
!
      integer nxmpb,nzmpb,nxz
      integer mgs,ngs,numgs,inumgs
      parameter (ngs=1)
      integer ngscnt,igs(ngs),kgs(ngs)
      real rho0(ngs)

      integer ix,kz,i,n, kp1
      integer :: jy, jgs
      integer ixb,ixe,jyb,jye,kzb,kze
    
      integer itile,jtile,ktile
      integer ixend,jyend,kzend,kzbeg
      integer nxend,nyend,nzend,nzbeg

      real :: qx(ngs,lv:lhab)
      real :: cx(ngs,lc:lhab)
      real :: xv(ngs,lc:lhab)
      real :: xmas(ngs,lc:lhab)
      real :: xdn(ngs,lc:lhab)
      real :: xdia(ngs,lc:lhab,3)
      real :: alpha(ngs,lc:lhab)
      
      real :: gamc1,gamc2,gami1,gami2,gams1,gams2, factor_c, factor_i, factor_s
      real :: lam_c, lam_i, lam_s
      integer :: il


! -------------------------------------------------------------------------------
      itile = nx
      jtile = ny
      ktile = nz
      ixend = nx
      jyend = ny
      kzend = nz
      nxend = nx + 1
      nyend = ny + 1
      nzend = nz
      kzbeg = 1
      nzbeg = 1

       jy = 1
       pb(:) = 0.0
       pinit(:) = 0.0

     gamc1 = Gamma(2. + cnu)
     gamc2 = 1. ! Gamma[1 + alphac]
     gami1 = Gamma(2. + cinu)
     gami2 = 1. ! Gamma[1 + alphac]
     gams1 = Gamma(2. + cinu)
     gams2 = Gamma(1. + snu)

     factor_c = (1. + cnu)*Gamma(1. + cnu)/Gamma(5./3. + cnu)
     factor_i = (1. + cinu)*Gamma(1. + cinu)/Gamma(5./3. + cinu)
     factor_s = (1. + snu)*Gamma(1. + snu)/Gamma(5./3. + snu)

!
!     jy = 1 ! working on a 2d slab
!!  VERY IMPORTANT:  SET jgs = jy

      jgs = jy

      mgs = 1
      DO kz = 1,nz
       DO ix = 1,nx ! ixcol

         rho0(mgs) = dn(ix,jy,kz)
         DO il = lc,ls
          qx(mgs,il) = max(an(ix,jy,kz,il), 0.0) 
          cx(mgs,il) = max(an(ix,jy,kz,ln(il)), 0.0) 
         ENDDO
         
         IF ( qx(mgs,lc) > qxmin(lc) ) THEN
! Lambda for cloud droplets 
         lam_c = ((cx(mgs,lc)*(Pi/6.)*xdn0(lc)*Gamc1)/(qx(mgs,lc)*rho0(mgs)*Gamc2))**(1./3.)
          t1(ix,jy,kz) = 0.5*factor_c/lam_c
         ENDIF

         IF ( qx(mgs,li) > qxmin(li) ) THEN
! Lambda for cloud ice 
         lam_i = ((cx(mgs,li)*(Pi/6.)*xdn0(li)*Gami1)/(qx(mgs,li)*rho0(mgs)*Gami2))**(1./3.)
          t2(ix,jy,kz) = 0.5*factor_i/lam_i
         ENDIF

         IF ( qx(mgs,ls) > qxmin(ls) ) THEN
! Lambda for snow
         lam_s = ((cx(mgs,ls)*(Pi/6.)*xdn0(ls)*Gams1)/(qx(mgs,ls)*rho0(mgs)*Gams2))**(1./3.)
          t3(ix,jy,kz) = 0.5*factor_s/lam_s
         ENDIF

      
       ENDDO ! ix
      ENDDO ! kz

   RETURN
   END SUBROUTINE calc_eff_radius

! #####################################################################
! #####################################################################

   SUBROUTINE calc_eff_radius2    &
     &  (nx,ny,nz,na,jyslab & 
     &  ,nor,norz & 
     &  ,t1,t2,t3,t4,t5  & 
     &  ,an,dn )

   implicit none

      integer, parameter :: ng1 = 1
      integer :: nx,ny,nz,na
      integer :: ng
      integer :: nor,norz, jyslab ! ,nht,ngt,igsr
      real    :: dtp  ! time step


!
! external temporary arrays
!

      real t1(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t3(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t4(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t5(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      

      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

      


      
    ! local
    
      real pb(-norz+ng1:nz+norz)
      real pinit(-norz+ng1:nz+norz)

! 
!  declarations microphysics and for gather/scatter
!
      integer nxmpb,nzmpb,nxz
      integer mgs,ngs,numgs,inumgs
      parameter (ngs=1)
      integer ngscnt,igs(ngs),kgs(ngs)
      real rho0(ngs)

      integer ix,kz,i,n, kp1
      integer :: jy, jgs
      integer ixb,ixe,jyb,jye,kzb,kze
    
      integer itile,jtile,ktile
      integer ixend,jyend,kzend,kzbeg
      integer nxend,nyend,nzend,nzbeg

      real :: qx(ngs,lv:lhab)
      real :: cx(ngs,lc:lhab)
      real :: xv(ngs,lc:lhab)
      real :: xmas(ngs,lc:lhab)
      real :: xdn(ngs,lc:lhab)
      real :: xdia(ngs,lc:lhab,3)
      real :: alpha(ngs,lc:lhab)
      
      real :: gamc1,gamc2,gami1,gami2,gams1,gams2, factor_c, factor_i, factor_s
      real :: lam_c, lam_i, lam_s, lam_r, lam_h, lam_hl
      real :: gamr1,gamr2,gamh1,gamh2,factor_r,factor_h,factor_hl
      integer :: il
      real :: hwdn,hldn
      double precision :: numh, numhl,denomh,denomhl
      


! -------------------------------------------------------------------------------
      itile = nx
      jtile = ny
      ktile = nz
      ixend = nx
      jyend = ny
      kzend = nz
      nxend = nx + 1
      nyend = ny + 1
      nzend = nz
      kzbeg = 1
      nzbeg = 1

       jy = 1
       pb(:) = 0.0
       pinit(:) = 0.0
!
! effective radius here is calculated as the ratio of integrated volume (d**3) to the integrated area (d**2)
! Mass mixing ratio thresholds are used to try to limit noisy small values
!
     gamc1 = Gamma(2. + cnu)
     gamc2 = 1. ! Gamma[1 + alphac]
     gami1 = Gamma(2. + cinu)
     gami2 = 1. ! Gamma[1 + alphac]
     gams1 = Gamma(2. + snu)
     gams2 = Gamma(1. + snu)
     gamr1 = Gamma(2. + rnu)
     gamr2 = Gamma(1. + rnu)

     factor_c = (1. + cnu)*Gamma(1. + cnu)/Gamma(5./3. + cnu)
     factor_i = (1. + cinu)*Gamma(1. + cinu)/Gamma(5./3. + cinu)
     factor_s = (1. + snu)*Gamma(1. + snu)/Gamma(5./3. + snu)
     
     IF ( imurain == 3 ) THEN
       factor_r = (1. + rnu)*Gamma(1. + rnu)/Gamma(5./3. + rnu)
     ELSE
       factor_r = ((Pi*(alphar+3.)*(alphar+1.)*(alphar+1.))/6.)**(1./3.)
     ENDIF
     
      factor_h = ((Pi*(alphah+3.)*(alphah+1.)*(alphah+1.))/6.)**(1./3.)
      factor_hl = ((Pi*(alphahl+3.)*(alphahl+1.)*(alphahl+1.))/6.)**(1./3.)

!
!     jy = 1 ! working on a 2d slab
!!  VERY IMPORTANT:  SET jgs = jy

      jgs = jy

      mgs = 1
      DO kz = 1,nz
       DO ix = 1,nx ! ixcol

         rho0(mgs) = dn(ix,jy,kz)
         DO il = lc,lhab
          qx(mgs,il) = max(an(ix,jy,kz,il), 0.0) 
          cx(mgs,il) = max(an(ix,jy,kz,ln(il)), 0.0) 
         ENDDO
         
         IF ( qx(mgs,lc) > Max(1.e-8,qxmin(lc)) ) THEN
! Lambda for cloud droplets 
         lam_c = ((cx(mgs,lc)*(Pi/6.)*xdn0(lc)*Gamc1)/(qx(mgs,lc)*rho0(mgs)*Gamc2))**(1./3.)
          t1(ix,jy,kz) = 0.5*factor_c/lam_c
         ENDIF

         IF ( qx(mgs,li) > Max(1.e-8,qxmin(li)) ) THEN
! Lambda for cloud ice 
         lam_i = ((cx(mgs,li)*(Pi/6.)*xdn0(li)*Gami1)/(qx(mgs,li)*rho0(mgs)*Gami2))**(1./3.)
          t2(ix,jy,kz) = 0.5*factor_i/lam_i
         ENDIF

         IF ( qx(mgs,ls) > Max(1.e-8,qxmin(ls)) ) THEN
! Lambda for snow
         lam_s = ((cx(mgs,ls)*(Pi/6.)*xdn0(ls)*Gams1)/(qx(mgs,ls)*rho0(mgs)*Gams2))**(1./3.)
          t3(ix,jy,kz) = 0.5*factor_s/lam_s
         ENDIF

         IF ( qx(mgs,lr) > Max(1.e-8,qxmin(lr)) ) THEN
           IF ( imurain == 1 ) THEN ! gamma-diameter
! Lambda for rain
             lam_r = factor_r *((xdn0(lr)*cx(mgs,lr))/(qx(mgs,lr)*rho0(mgs)))**(1./3.)
             t4(ix,jy,kz) = 0.5*(alphar+3.)/lam_r
           ELSE ! gamma-volume
! Lambda for rain
             lam_r = ((cx(mgs,lr)*(Pi/6.)*xdn0(lr)*Gamr1)/(qx(mgs,lr)*rho0(mgs)*Gamr2))**(1./3.)
             t4(ix,jy,kz) = 0.5*factor_r/lam_r
           ENDIF
         ENDIF

         IF ( qx(mgs,lh) > Max(1.e-8,qxmin(lh)) .and.  qx(mgs,lhl) < Max(1.e-8,qxmin(lhl)) ) THEN
! Lambda for graupel
          hwdn = xdn0(lh)
          IF ( lvh > 1 ) THEN ! variable density
            IF ( an(ix,jy,kz,lvh) > 1.e-30 ) THEN
              hwdn = rho0(mgs)*qx(mgs,lh)/an(ix,jy,kz,lvh)
            ENDIF
          ENDIF
            
            lam_h = factor_h *((hwdn*cx(mgs,lh))/(qx(mgs,lh)*rho0(mgs)))**(1./3.)
             t5(ix,jy,kz) = 0.5*(alphah+3.)/lam_h
             
         ELSEIF ( qx(mgs,lh) < Max(1.e-8,qxmin(lh)) .and.  qx(mgs,lhl) > Max(1.e-8,qxmin(lhl)) ) THEN
! Lambda for hail
          hldn = xdn0(lhl)
          IF ( lvhl > 1 ) THEN ! variable density
            IF ( an(ix,jy,kz,lvhl) > 1.e-30 ) THEN
              hldn = rho0(mgs)*qx(mgs,lhl)/an(ix,jy,kz,lvhl)
            ENDIF
          ENDIF
            
            lam_hl = factor_hl *((hldn*cx(mgs,lhl))/(qx(mgs,lhl)*rho0(mgs)))**(1./3.)
             t5(ix,jy,kz) = 0.5*(alphahl+3.)/lam_hl

         ELSEIF ( qx(mgs,lh) > Max(1.e-8,qxmin(lh)) .and.  qx(mgs,lhl) > Max(1.e-8,qxmin(lhl)) ) THEN
!  r_eff graupel and hail combined
          
          hldn = xdn0(lhl)
          IF ( lvhl > 1 ) THEN ! variable density
            IF ( an(ix,jy,kz,lvhl) > 1.e-30 ) THEN
              hldn = rho0(mgs)*qx(mgs,lhl)/an(ix,jy,kz,lvhl)
            ENDIF
          ENDIF
          
          hwdn = xdn0(lh)
          IF ( lvh > 1 ) THEN ! variable density
            IF ( an(ix,jy,kz,lvh) > 1.e-30 ) THEN
              hwdn = rho0(mgs)*qx(mgs,lh)/an(ix,jy,kz,lvh)
            ENDIF
          ENDIF
            
            lam_h = factor_h *((hwdn*cx(mgs,lh))/(qx(mgs,lh)*rho0(mgs)))**(1./3.)
            lam_hl = factor_hl *((hldn*cx(mgs,lhl))/(qx(mgs,lhl)*rho0(mgs)))**(1./3.)
            
            numh = cx(mgs,lh)*(alphah+3.)*(alphah+2.)*(alphah+1.)/lam_h**3
            numhl = cx(mgs,lhl)*(alphahl+3.)*(alphahl+2.)*(alphahl+1.)/lam_hl**3
            
            denomh = cx(mgs,lh)*(alphah+2.)*(alphah+1.)/lam_h**2
            denomhl = cx(mgs,lhl)*(alphahl+2.)*(alphahl+1.)/lam_hl**2
            
            t5(ix,jy,kz) = 0.5*(numh + numhl)/(denomh + denomhl)


         ENDIF





        IF ( .false. ) THEN
      ! test code for separate graupel and hail 
         IF ( qx(mgs,lh) > Max(1.e-8,qxmin(lh)) ) THEN
! Lambda for graupel
          hwdn = xdn0(lh)
          IF ( lvh > 1 ) THEN ! variable density
            IF ( an(ix,jy,kz,lvh) > 1.e-30 ) THEN
              hwdn = rho0(mgs)*qx(mgs,lh)/an(ix,jy,kz,lvh)
            ENDIF
          ENDIF
            
            lam_h = factor_h *((hwdn*cx(mgs,lh))/(qx(mgs,lh)*rho0(mgs)))**(1./3.)
             t1(ix,jy,kz) = 0.5*(alphah+3.)/lam_h

         ENDIF

         IF ( qx(mgs,lhl) > Max(1.e-8,qxmin(lhl)) ) THEN
! Lambda for hail
          hldn = xdn0(lhl)
          IF ( lvhl > 1 ) THEN ! variable density
            IF ( an(ix,jy,kz,lvhl) > 1.e-30 ) THEN
              hldn = rho0(mgs)*qx(mgs,lhl)/an(ix,jy,kz,lvhl)
            ENDIF
          ENDIF
            
            lam_hl = factor_hl *((hldn*cx(mgs,lhl))/(qx(mgs,lhl)*rho0(mgs)))**(1./3.)
             t2(ix,jy,kz) = 0.5*(alphahl+3.)/lam_hl
         
         ENDIF
       ENDIF
      
       ENDDO ! ix
      ENDDO ! kz

   RETURN
   END SUBROUTINE calc_eff_radius2


! #####################################################################
! #####################################################################

      SUBROUTINE QVEXCESS(ngs,mgs,qwvp0,qv0,qcw1,pres,thetap0,theta0, &
     &    qvex,pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ss1,pk,ngscnt)
      
!#####################################################################
!  Purpose: find the amount of vapor that can be condensed to liquid
!#####################################################################

      implicit none

      integer ngs,mgs,ngscnt
      
      real theta2temp
      
      real qvex
      
      integer nqsat
      real fqsat, cbw
      
      real ss1  ! 'target' supersaturation
!
!  input arrays
!
      real qv0(ngs), qcw1(ngscnt), pres(ngs), qwvp0(mgs)
      real thetap0(ngs), theta0(ngs)
      real fcqv1(ngs), felvcp(ngs), pi0(ngs)
      real pk(ngs)
      
      real tabqvs(nqsat)
!
! Local stuff
!
      
      integer itertd
      integer ltemq
      real gamss
      real theta(ngs), qvap(ngs), pqs(ngs), qcw(ngs), qwv(ngs)
      real qcwtmp(ngs), qss(ngs), qvs(ngs), qwvp(ngs)
      real dqcw(ngs), dqwv(ngs), dqvcnd(ngs)
      real temg(ngs), temcg(ngs), thetap(ngs)
      
      real tfr
      parameter ( tfr = 273.15 )
            
!      real poo,cap
!      parameter ( cap = rd/cp, poo = 1.0e+05 )
!
!
!  Modified Straka adjustment (nearly identical to Tao et al. 1989 MWR)
!
!
!
!  set up temperature and vapor arrays
!
      pqs(mgs) = (380.0)/(pres(mgs))
      thetap(mgs) = thetap0(mgs)
      theta(mgs) = thetap(mgs) + theta0(mgs)
      qwvp(mgs) = qwvp0(mgs)
      qvap(mgs) = max( (qwvp0(mgs) + qv0(mgs)), 0.0 )
      temg(mgs) = theta(mgs)*pk(mgs) ! ( pres(mgs) / poo ) ** cap
!      temg(mgs) = theta2temp( theta(mgs), pres(mgs) )
!
!
!
!  reset temporaries for cloud particles and vapor
!
      
      qwv(mgs) = max( 0.0, qvap(mgs) )
      qcw(mgs) = max( 0.0, qcw1(mgs) )
!
!
      qcwtmp(mgs) = qcw(mgs)
      temcg(mgs) = temg(mgs) - tfr
      ltemq = (temg(mgs)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )

      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
      qss(mgs) = (0.01*ss1 + 1.0)*qvs(mgs)
!
!  iterate  adjustment
!
      do itertd = 1,2
!
!
!  calculate super-saturation
!
      dqcw(mgs) = 0.0
      dqwv(mgs) = ( qwv(mgs) - qss(mgs) )
!
!  evaporation and sublimation adjustment
!
      if( dqwv(mgs) .lt. 0. ) then           !  subsaturated
        if( qcw(mgs) .gt. -dqwv(mgs) ) then  ! check if qc can make up all of the deficit
          dqcw(mgs) = dqwv(mgs)
          dqwv(mgs) = 0.
        else                                 !  otherwise make all qc available for evap
          dqcw(mgs) = -qcw(mgs)
          dqwv(mgs) = dqwv(mgs) + qcw(mgs)
        end if
!
        qwvp(mgs) = qwvp(mgs) - ( dqcw(mgs)  )  ! add to perturbation vapor
!
        qcw(mgs) = qcw(mgs) + dqcw(mgs)

        thetap(mgs) = thetap(mgs) +  &
     &                1./pi0(mgs)*  &
     &                (felvcp(mgs)*dqcw(mgs) )

      end if  ! dqwv(mgs) .lt. 0. (end of evap/sublim)
!
! condensation/deposition
!
      IF ( dqwv(mgs) .ge. 0. ) THEN
!
      dqvcnd(mgs) = dqwv(mgs)/(1. + fcqv1(mgs)*qss(mgs)/  &
     &  ((temg(mgs)-cbw)**2))
!
!
      dqcw(mgs) = dqvcnd(mgs)
!
      thetap(mgs) = thetap(mgs) +  &
     &   (felvcp(mgs)*dqcw(mgs) )    &
     & / (pi0(mgs))
      qwvp(mgs) = qwvp(mgs) - ( dqvcnd(mgs) )
      qcw(mgs) = qcw(mgs) + dqcw(mgs)
!
      END IF !  dqwv(mgs) .ge. 0.

      theta(mgs) = thetap(mgs) + theta0(mgs)
      temg(mgs) = theta(mgs)*pk(mgs) ! ( pres(mgs) / poo ) ** cap
!      temg(mgs) = theta2temp( theta(mgs), pres(mgs) )
      qvap(mgs) = Max((qwvp(mgs) + qv0(mgs)), 0.0)
      temcg(mgs) = temg(mgs) - tfr
!      tqvcon = temg(mgs)-cbw
      ltemq = (temg(mgs)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )
      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
      qcw(mgs) = max( 0.0, qcw(mgs) )
      qwv(mgs) = max( 0.0, qvap(mgs))
      qss(mgs) = (0.01*ss1 + 1.0)*qvs(mgs)
      end do
!
!  end the saturation adjustment iteration loop
!
!
      qvex = Max(0.0, qcw(mgs) - qcw1(mgs) )

      RETURN
      END SUBROUTINE QVEXCESS

! #####################################################################
! #####################################################################





!
! ##############################################################################
!
      SUBROUTINE setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno,cnostmp, &
     &                 xmas,vtxbar,xdn,xvmn0,xvmx0,xv,cdx,            &
     &                 ipconc1,ndebug1,ngs,nz,kgs,fadvisc,   &
     &                 cwmasn,cwmasx,cwradn,cnina,cimna,cimxa,      &
     &                 itype1a,itype2a,temcg,infdo,alpha,ildo,axh,bxh,axhl,bxhl)


      implicit none
      
      integer ngscnt,ngs0,ngs,nz
!      integer infall    ! whether to calculate number-weighted fall speeds
      
      real xv(ngs,lc:lhab)
      real qx(ngs,lv:lhab)
      real qxw(ngs,ls:lhab)
      real cx(ngs,lc:lhab)
      real vtxbar(ngs,lc:lhab,3)
      real xmas(ngs,lc:lhab)
      real xdn(ngs,lc:lhab)
      real xdia(ngs,lc:lhab,3)
      real xvmn0(lc:lhab), xvmx0(lc:lhab)
      real qxmin(lc:lhab)
      real cdx(lc:lhab)
      real alpha(ngs,lc:lhab)
      
      real rho0(ngs),rhovt(ngs),temcg(ngs)
      real cno(lc:lhab)
      real cnostmp(ngs)
      
      real cwc1, cimna, cimxa
      real cnina(ngs)
      integer kgs(ngs)
      real fadvisc(ngs)
      real fsw
      
      integer ipconc1
      integer ndebug1
      
      integer, intent (in) :: itype1a,itype2a,infdo
      integer, intent (in) :: ildo ! which species to do, or all if ildo=0

      real :: axh(ngs),bxh(ngs)
      real :: axhl(ngs),bxhl(ngs)
      
! Local vars

      
      
      real cd
      real cwc0 ! ,cwc1
      real :: cwch(ngscnt), cwchl(ngscnt)
      real :: cwchtmp,cwchltmp,xnutmp
      real pii
      real cimasx,cimasn
      real cwmasn,cwmasx,cwradn
      real cwrad
      real vr,rnux
      real alp
      
      real ccimx

      integer mgs
      
      real arx,frx,vtrain,fw
      real fwlo,fwhi,rfwdiff
      real ar,br,cs,ds
!      real gf4p5, gf4ds, gf4br, ifirst, gf1ds
!      real gfcinu1, gfcinu1p47, gfcinu2p47
      real gr
      real rwrad,rwdia
      real mwfac
      integer il

!      save gf4p5, gf4ds, gf4br, ifirst, gf1ds
!      save gfcinu1, gfcinu1p47, gfcinu2p47
!      data ifirst /0/
      
      real bta1,cnit
      parameter ( bta1 = 0.6, cnit = 1.0e-02 )
      real x,y,tmp,del
      real aax,bbx,delrho
      integer :: indxr
      real mwt
      real, parameter :: rho00 = 1.225
      integer i
      real xvbarmax

      integer l1, l2


!
! set values
!
!      cwmasn = 5.23e-13  ! radius of 5.0e-6
!      cwradn = 5.0e-6
!      cwmasx = 5.25e-10  ! radius of 50.0e-6

      fwlo = 0.2                ! water fraction to start weighting toward rain fall speed
      fwhi = 0.4                ! water fraction at which rain fall speed only is used
      rfwdiff = 1./(fwhi - fwlo)
      
!      pi = 4.0*atan(1.0)
      pii = piinv ! 1.0/pi

      arx = 10.
      frx = 516.575 ! raind fit parameters for arx*(1 - Exp(-fx*d)), where d is rain diameter in meters.

      ar = 841.99666  
      br = 0.8
      gr = 9.8
!  new values for  cs and ds
      cs = 12.42
      ds = 0.42

      IF ( ildo == 0 ) THEN
        l1 = lc
        l2 = lhab
      ELSE
        l1 = ildo
        l2 = ildo
      ENDIF

!      IF ( ifirst .eq. 0 ) THEN
!        ifirst = 1
!        gf4br = gamma(4.0+br)
!        gf4ds = gamma(4.0+ds)
!!        gf1ds = gamma(1.0+ds)
!        gf4p5 = gamma(4.0+0.5)
!        gfcinu1 = gamma(cinu + 1.0)
!        gfcinu1p47 = gamma(cinu + 1.47167)
!        gfcinu2p47 = gamma(cinu + 2.47167)
        
        IF ( lh  .gt. 1 ) THEN
          IF ( dmuh == 1.0 ) THEN
            cwchtmp = ((3. + dnu(lh))*(2. + dnu(lh))*(1.0 + dnu(lh)))**(-1./3.)
          ELSE
            cwchtmp = 6.0*pii*gamma( (xnu(lh) + 1.)/xmu(lh) )/gamma( (xnu(lh) + 2.)/xmu(lh) )
          ENDIF
        ENDIF
        IF ( lhl .gt. 1 ) THEN
          IF ( dmuhl == 1.0 ) THEN
            cwchltmp = ((3. + dnu(lhl))*(2. + dnu(lhl))*(1.0 + dnu(lhl)))**(-1./3.)
          ELSE
            cwchltmp = 6.0*pii*gamma( (xnu(lhl) + 1)/xmu(lhl) )/gamma( (xnu(lhl) + 2)/xmu(lhl) )
          ENDIF
        ENDIF

        IF ( ipconc .le. 5 ) THEN
          IF ( lh  .gt. 1 ) cwch(:) =  cwchtmp 
          IF ( lhl .gt. 1 ) cwchl(:) = cwchltmp
        ELSE
          DO mgs = 1,ngscnt
          
          IF ( lh  .gt. 1 .and. ( ildo == 0 .or. ildo == lh ) ) THEN
           IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
            IF ( dmuh == 1.0 ) THEN
              cwch(mgs) = ((3. + alpha(mgs,lh))*(2. + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))**(-1./3.)
             ELSE
             xnutmp = (alpha(mgs,lh) - 2.0)/3.0
             cwch(mgs) =  6.0*pii*gamma( (xnutmp + 1.)/xmu(lh) )/gamma( (xnutmp + 2.)/xmu(lh) )
            ENDIF
           ELSE
             cwch(mgs) = cwchtmp
           ENDIF
          ENDIF
          IF ( lhl .gt. 1 .and. ( ildo == 0 .or. ildo == lhl ) ) THEN
           IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
            IF ( dmuhl == 1.0 ) THEN
              cwchl(mgs) = ((3. + alpha(mgs,lhl))*(2. + alpha(mgs,lhl))*(1.0 + alpha(mgs,lhl)))**(-1./3.)
             ELSE
             xnutmp = (alpha(mgs,lhl) - 2.0)/3.0
             cwchl(mgs) = 6.0*pii*gamma( (xnutmp + 1)/xmu(lhl) )/gamma( (xnutmp + 2)/xmu(lhl) )
            ENDIF
           ELSE
             cwchl(mgs) = cwchltmp
           ENDIF
          ENDIF
          
          ENDDO
        
        ENDIF
       

      cimasn = Min( cimas0, 6.88e-13)
      cimasx = 1.0e-8
      ccimx = 5000.0e3   ! max of 5000 per liter

      cwc1 = 6.0/(pi*1000.)
      cwc0 = pii ! 6.0*pii
      mwfac = 6.0**(1./3.)

      
      if (ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set scale diameter'
!


!
!  cloud water variables
! ################################################################
!
!  DROPLETS
!
!
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set cloud water variables'
      
      IF ( ildo == 0 .or. ildo == lc ) THEN
      
      do mgs = 1,ngscnt
      xv(mgs,lc) = 0.0
      
      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN !{
      
      IF ( ipconc .ge. 2 .and. cx(mgs,lc) .gt. 1.0e-9 ) THEN !{
        xmas(mgs,lc) =  &
     &    min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),cwmasn),cwmasx )
        xv(mgs,lc) = xmas(mgs,lc)/xdn(mgs,lc)
      ELSE
       IF ( ipconc .lt. 2 ) THEN
         cx(mgs,lc) = rho0(mgs)*ccn/rho00 ! scales to local density, relative to standard air density
       ENDIF
       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 0.01 ) THEN !{
        xmas(mgs,lc) =  &
     &     min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),xdn(mgs,lc)*xvmn(lc)), &
     &      xdn(mgs,lc)*xvmx(lc) )
        
        xv(mgs,lc) = xmas(mgs,lc)/xdn(mgs,lc)
        cx(mgs,lc) = qx(mgs,lc)*rho0(mgs)/xmas(mgs,lc)
        
       ELSEIF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .le. 0.01 ) THEN
        xmas(mgs,lc) = xdn(mgs,lc)*4.*pi/3.*(5.0e-6)**3
        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)
        xv(mgs,lc) = xmas(mgs,lc)/xdn(mgs,lc)
        
       ELSE
        xmas(mgs,lc) = cwmasn
        xv(mgs,lc) = xmas(mgs,lc)/1000.
! do not define ccw here! it can feed back to ccn!!!    cx(mgs,lc) = 0.0 ! cwnc(mgs)
       ENDIF !}
      ENDIF !}
!      IF ( ipconc .lt. 2 ) THEN
!        xmas(mgs,lc) = &
!     &    min( max(qx(mgs,lc)*rho0(mgs)/cwnc(mgs),cwmasn),cwmasx )
!        cx(mgs,lc) = Max(1.0,qx(mgs,lc)*rho0(mgs)/xmas(mgs,lc))
!      ELSE
!        cwnc(mgs) = an(igs(mgs),jgs,kgs(mgs),lnc)
!        cx(mgs,lc) = cwnc(mgs)
!      ENDIF
      xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**(1./3.)
      xdia(mgs,lc,2) = xdia(mgs,lc,1)**2
      xdia(mgs,lc,3) = xdia(mgs,lc,1)
      cwrad = 0.5*xdia(mgs,lc,1)
      IF ( fadvisc(mgs) > 0.0 ) THEN
      vtxbar(mgs,lc,1) =  &
     &   (2.0*gr*xdn(mgs,lc) *(cwrad**2)) &
     &  /(9.0*fadvisc(mgs))
      ELSE
       vtxbar(mgs,lc,1) = 0.0
      ENDIF

      
      ELSE
       xmas(mgs,lc) = cwmasn
       IF ( ipconc .le. 1 ) cx(mgs,lc) = 0.01
       xdia(mgs,lc,1) = 2.*cwradn
       xdia(mgs,lc,2) = 4.*cwradn**2
       xdia(mgs,lc,3) = xdia(mgs,lc,1)
       vtxbar(mgs,lc,1) = 0.0
       
      ENDIF !} qcw .gt. qxmin(lc)
      
      end do
      
      ENDIF



!
! cloud ice variables
! columns
!
! ################################################################
!
!  CLOUD ICE
!
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set cip'
      
      IF ( li .gt. 1 .and. ( ildo == 0 .or. ildo == li ) ) THEN
      do mgs = 1,ngscnt
       xdn(mgs,li)  = 900.0
      IF ( ipconc .eq. 0 ) THEN
!       cx(mgs,li) = min(cnit*exp(-temcg(mgs)*bta1),1.e+09)
        cx(mgs,li) = cnina(mgs)
       IF ( cimna .gt. 1.0 ) THEN
         cx(mgs,li) = Max(cimna,cx(mgs,li))
       ENDIF
       IF ( cimxa .gt. 1.0 ) THEN
         cx(mgs,li) = Min(cimxa,cx(mgs,li))
       ENDIF
! erm 3/28/2002
       IF ( itype1a .ge. 1 .or. itype2a .ge. 1 ) THEN
        cx(mgs,li) = Max(cx(mgs,li),qx(mgs,li)*rho0(mgs)/cimasx)
        cx(mgs,li) = Min(cx(mgs,li),qx(mgs,li)*rho0(mgs)/cimasn)
       ENDIF
!
       cx(mgs,li) = max(1.0e-20,cx(mgs,li))
!       cx(mgs,li) = Min(ccimx, cx(mgs,li))

      
      ELSEIF ( ipconc .ge. 1 ) THEN
        IF ( qx(mgs,li) .gt. qxmin(li) ) THEN
         cx(mgs,li) = Max(cx(mgs,li),qx(mgs,li)*rho0(mgs)/cimasx)
         cx(mgs,li) = Min(cx(mgs,li),qx(mgs,li)*rho0(mgs)/cimasn)
!         cx(mgs,li) = Max(1.0,cx(mgs,li))
        ENDIF
      ENDIF
      
      IF ( qx(mgs,li) .gt. qxmin(li) ) THEN
      xmas(mgs,li) = &
     &     max( qx(mgs,li)*rho0(mgs)/cx(mgs,li), cimasn )
!     &  min( max(qx(mgs,li)*rho0(mgs)/cx(mgs,li),cimasn),cimasx )
      
!      if ( temcg(mgs) .gt. 0.0 ) then
!      xdia(mgs,li,1) = 0.0
!      else
      if ( xmas(mgs,li) .gt. 0.0 ) THEN ! cimasn ) then
!c      xdia(mgs,li,1) = 0.4892*(xmas(mgs,li)**(0.4554))
!       xdia(mgs,li,1) = 0.1871*(xmas(mgs,li)**(0.3429))

!       xdia(mgs,li,1) = (132.694*5.40662/xmas(mgs,li))**(-1./2.9163)  ! for inverse exponential distribution
       IF ( ixtaltype == 1 ) THEN ! column
       xdia(mgs,li,1) = 0.1871*(xmas(mgs,li)**(0.3429))
       xdia(mgs,li,3) = 0.1871*(xmas(mgs,li)**(0.3429))
       ELSEIF  ( ixtaltype == 2 ) THEN ! disk
        xdia(mgs,li,1) = 0.277823*xmas(mgs,li)**0.359971
        xdia(mgs,li,3) = 0.277823*xmas(mgs,li)**0.359971
       ENDIF
      end if
!      end if
!      xdia(mgs,li,1) = max(xdia(mgs,li,1), 5.e-6)
!      xdia(mgs,li,1) = min(xdia(mgs,li,1), 1000.e-6)

       IF ( ipconc .ge. 0 ) THEN
!      vtxbar(mgs,li,1) = rhovt(mgs)*49420.*40.0005/5.40662*xdia(mgs,li,1)**(1.415) ! mass-weighted
!      vtxbar(mgs,li,1) = (4.942e4)*(xdia(mgs,li,1)**(1.4150))
        xv(mgs,li) = xmas(mgs,li)/xdn(mgs,li)
        IF ( ixtaltype == 1 ) THEN ! column
        tmp = (67056.6300748612*rhovt(mgs))/  &
     &   (((1.0 + cinu)/xv(mgs,li))**0.4716666666666667*gfcinu1)
        vtxbar(mgs,li,2) = tmp*gfcinu1p47
        vtxbar(mgs,li,1) = tmp*gfcinu2p47/(1. + cinu)
        vtxbar(mgs,li,3) = vtxbar(mgs,li,1) 
        ELSEIF  ( ixtaltype == 2 ) THEN ! disk -- but just use column fall speed for now
        tmp = (67056.6300748612*rhovt(mgs))/  &
     &   (((1.0 + cinu)/xv(mgs,li))**0.4716666666666667*gfcinu1)
        vtxbar(mgs,li,2) = tmp*gfcinu1p47
        vtxbar(mgs,li,1) = tmp*gfcinu2p47/(1. + cinu)
        vtxbar(mgs,li,3) = vtxbar(mgs,li,1) 
        
        ENDIF
!      vtxbar(mgs,li,1) = vtxbar(mgs,li,2)*(1.+cinu)/(1. + cinu)
!      xdn(mgs,li)   = min(max(769.8*xdia(mgs,li,1)**(-0.0140),300.0),900.0)
!      xdn(mgs,li) = 900.0
        xdia(mgs,li,2) = xdia(mgs,li,1)**2
!      vtxbar(mgs,li,1) = vtxbar(mgs,li,1)*rhovt(mgs)
       ELSE
         xdia(mgs,li,1) = max(xdia(mgs,li,1), 10.e-6)
         xdia(mgs,li,1) = min(xdia(mgs,li,1), 1000.e-6)
         vtxbar(mgs,li,1) = (4.942e4)*(xdia(mgs,li,1)**(1.4150))
!      xdn(mgs,li)   = min(max(769.8*xdia(mgs,li,1)**(-0.0140),300.0),900.0)
         xdn(mgs,li) = 900.0
         xdia(mgs,li,2) = xdia(mgs,li,1)**2
         vtxbar(mgs,li,1) = vtxbar(mgs,li,1)*rhovt(mgs)
         xv(mgs,li) = xmas(mgs,li)/xdn(mgs,li)
       ENDIF ! ipconc gt 3
      ELSE
       xmas(mgs,li) = 1.e-13
       xdn(mgs,li)  = 900.0
       xdia(mgs,li,1) = 1.e-7
       xdia(mgs,li,2) = (1.e-14)
       xdia(mgs,li,3) = 1.e-7
       vtxbar(mgs,li,1) = 0.0
!       cicap(mgs) = 0.0
!       ciat(mgs) = 0.0
      ENDIF
      end do
      
      ENDIF ! li .gt. 1


! ################################################################
!
!  RAIN
!
      
!
      IF ( ildo == 0 .or. ildo == lr ) THEN
      do mgs = 1,ngscnt
      if ( qx(mgs,lr) .gt. qxmin(lr) ) then
      
!      IF ( qx(mgs,lr) .gt. 10.0e-3 ) &
!     &  write(0,*)  'RAIN1: ',igs(mgs),kgs(mgs),qx(mgs,lr)
      
      if ( ipconc .ge. 3 ) then
        xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*Max(1.0e-11,cx(mgs,lr)))
        xvbarmax = xvmx(lr)
        IF ( imaxdiaopt == 1 ) THEN
          xvbarmax = xvmx(lr)
        ELSEIF ( imaxdiaopt == 2 ) THEN ! test against maximum mass diameter
         IF ( imurain == 1 ) THEN
           xvbarmax = xvmx(lr)/((3. + alpha(mgs,lr))**3/((3. + alpha(mgs,lr))*(2. + alpha(mgs,lr))*(1. + alpha(mgs,lr))))
         ELSEIF ( imurain == 3 ) THEN
           
         ENDIF
        ELSEIF ( imaxdiaopt == 3 ) THEN ! test against mass-weighted diameter
         IF ( imurain == 1 ) THEN
           xvbarmax = xvmx(lr)/((4. + alpha(mgs,lr))**3/((3. + alpha(mgs,lr))*(2. + alpha(mgs,lr))*(1. + alpha(mgs,lr))))
         ELSEIF ( imurain == 3 ) THEN
           
         ENDIF
        ENDIF
       
        IF ( xv(mgs,lr) .gt. xvbarmax ) THEN
          xv(mgs,lr) = xvbarmax
          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvbarmax*xdn(mgs,lr))
        ELSEIF ( xv(mgs,lr) .lt. xvmn(lr) ) THEN
          xv(mgs,lr) = xvmn(lr)
          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmn(lr)*xdn(mgs,lr))
        ENDIF


        xmas(mgs,lr) = xv(mgs,lr)*xdn(mgs,lr)
        xdia(mgs,lr,3) = (xmas(mgs,lr)*cwc1)**(1./3.) ! xdia(mgs,lr,1)
        IF ( imurain == 3 ) THEN
!          xdia(mgs,lr,1) = (6.*pii*xv(mgs,lr)/(alpha(mgs,lr)+1.))**(1./3.)
          xdia(mgs,lr,1) = xdia(mgs,lr,3) ! formulae for Ziegler (1985) use mean volume diameter, not lambda**(-1)
        ELSE ! imurain == 1, Characteristic diameter (1/lambda)
          xdia(mgs,lr,1) = (6.*pii*xv(mgs,lr)/((alpha(mgs,lr)+3.)*(alpha(mgs,lr)+2.)*(alpha(mgs,lr)+1.)))**(1./3.)
        ENDIF
!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)

! Inverse exponential version:
!        xdia(mgs,lr,1) =
!     &  (qx(mgs,lr)*rho0(mgs)
!     & /(pi*xdn(mgs,lr)*cx(mgs,lr)))**(0.333333)
      ELSE
        xdia(mgs,lr,1) = &
     &  (qx(mgs,lr)*rho0(mgs)/(pi*xdn(mgs,lr)*cno(lr)))**(0.25) 
        xmas(mgs,lr) = xdn(mgs,lr)*(pi/6.)*xdia(mgs,lr,1)**3
        xdia(mgs,lr,3) = (xmas(mgs,lr)*cwc1)**(1./3.)
        cx(mgs,lr) = cno(lr)*xdia(mgs,lr,1)
        xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
      end if
      else
        xdia(mgs,lr,1) = 1.e-9
        xdia(mgs,lr,3) = 1.e-9
        xmas(mgs,lr) = xdn(mgs,lr)*(pi/6.)*xdia(mgs,lr,1)**3
!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)
      end if
      xdia(mgs,lr,2) = xdia(mgs,lr,1)**2
!      xmas(mgs,lr) = xdn(mgs,lr)*(pi/6.)*xdia(mgs,lr,1)**3
      end do
      
      ENDIF
! ################################################################
!
!  SNOW
!

      IF ( ls .gt. 1 .and. ( ildo == 0 .or. ildo == ls ) ) THEN
      
      do mgs = 1,ngscnt 
      if ( qx(mgs,ls) .gt. qxmin(ls) ) then
      if ( ipconc .ge. 4 ) then ! 

        xv(mgs,ls) = rho0(mgs)*qx(mgs,ls)/(xdn(mgs,ls)*Max(1.0e-9,cx(mgs,ls)))
!      parameter( xvmn(lr)=2.8866e-13, xvmx(lr)=4.1887e-9 )  ! mks
        xmas(mgs,ls) = xv(mgs,ls)*xdn(mgs,ls)

        IF ( xv(mgs,ls) .lt. xvmn(ls) .or. xv(mgs,ls) .gt. xvmx(ls) ) THEN
          xv(mgs,ls) = Min( xvmx(ls), Max( xvmn(ls),xv(mgs,ls) ) )
          xmas(mgs,ls) = xv(mgs,ls)*xdn(mgs,ls)
          cx(mgs,ls) = rho0(mgs)*qx(mgs,ls)/(xmas(mgs,ls))
        ENDIF

        xdia(mgs,ls,1) = (xv(mgs,ls)*cwc0*6.0)**(1./3.)
        xdia(mgs,ls,3) = xdia(mgs,ls,1)

      ELSE
        xdia(mgs,ls,1) =  &
     &    (qx(mgs,ls)*rho0(mgs)/(pi*xdn(mgs,ls)*cnostmp(mgs)))**(0.25) 
        cx(mgs,ls) = cnostmp(mgs)*xdia(mgs,ls,1)
        xv(mgs,ls) = rho0(mgs)*qx(mgs,ls)/(xdn(mgs,ls)*cx(mgs,ls))
        xdia(mgs,ls,3) = (xv(mgs,ls)*cwc0*6.0)**(1./3.)
      end if
      else
      xdia(mgs,ls,1) = 1.e-9
      xdia(mgs,ls,3) = 1.e-9
      cx(mgs,ls) = 0.0
      end if
      xdia(mgs,ls,2) = xdia(mgs,ls,1)**2
!      swdia3(mgs) = xdia(mgs,ls,2)*xdia(mgs,ls,1)
!      xmas(mgs,ls) = xdn(mgs,ls)*(pi/6.)*swdia3(mgs)
      end do
      
      ENDIF ! ls .gt 1
!
!
! ################################################################
!
!  GRAUPEL
!

      IF ( lh .gt. 1 .and. ( ildo == 0 .or. ildo == lh ) ) THEN
      
      do mgs = 1,ngscnt 
      if ( qx(mgs,lh) .gt. qxmin(lh) ) then
      if ( ipconc .ge. 5 ) then

        xv(mgs,lh) = rho0(mgs)*qx(mgs,lh)/(xdn(mgs,lh)*Max(1.0e-9,cx(mgs,lh)))
        xmas(mgs,lh) = xv(mgs,lh)*xdn(mgs,lh)

        IF ( xv(mgs,lh) .lt. xvmn(lh) .or. xv(mgs,lh) .gt. xvmx(lh) ) THEN
          xv(mgs,lh) = Min( xvmx(lh), Max( xvmn(lh),xv(mgs,lh) ) )
          xmas(mgs,lh) = xv(mgs,lh)*xdn(mgs,lh)
          cx(mgs,lh) = rho0(mgs)*qx(mgs,lh)/(xmas(mgs,lh))
        ENDIF

         xdia(mgs,lh,3) = (xv(mgs,lh)*6.*pii)**(1./3.) ! mwfac*xdia(mgs,lh,1) ! (xv(mgs,lh)*cwc0*6.0)**(1./3.)
         IF ( dmuh == 1.0 ) THEN
           xdia(mgs,lh,1) = cwch(mgs)*xdia(mgs,lh,3)
         ELSE
           xdia(mgs,lh,1) = (xv(mgs,lh)*cwch(mgs))**(1./3.)
         ENDIF

      ELSE
      xdia(mgs,lh,1) =  &
     &  (qx(mgs,lh)*rho0(mgs)/(pi*xdn(mgs,lh)*cno(lh)))**(0.25) 
      cx(mgs,lh) = cno(lh)*xdia(mgs,lh,1)
      xv(mgs,lh) = Max(xvmn(lh), rho0(mgs)*qx(mgs,lh)/(xdn(mgs,lh)*cx(mgs,lh)) )
      xdia(mgs,lh,3) = (xv(mgs,lh)*6./pi)**(1./3.) 
      end if
      else
      xdia(mgs,lh,1) = 1.e-9
      xdia(mgs,lh,3) = 1.e-9
      end if
      xdia(mgs,lh,2) = xdia(mgs,lh,1)**2
!      hwdia3(mgs) = xdia(mgs,lh,2)*xdia(mgs,lh,1)
!      xmas(mgs,lh) = xdn(mgs,lh)*(pi/6.)*hwdia3(mgs)
      end do
      
      ENDIF

!
! ################################################################
!
!  HAIL
!

      IF ( lhl .gt. 1 .and. ( ildo == 0 .or. ildo == lhl ) ) THEN
      
      do mgs = 1,ngscnt 
      if ( qx(mgs,lhl) .gt. qxmin(lhl) ) then
      if ( ipconc .ge. 5 ) then

        xv(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/(xdn(mgs,lhl)*Max(1.0e-9,cx(mgs,lhl)))
        xmas(mgs,lhl) = xv(mgs,lhl)*xdn(mgs,lhl)
!        write(0,*) 'setvt: xv = ',xv(mgs,lhl),xdn(mgs,lhl),cx(mgs,lhl),xmas(mgs,lhl),qx(mgs,lhl)

        IF ( xv(mgs,lhl) .lt. xvmn(lhl) .or. xv(mgs,lhl) .gt. xvmx(lhl) ) THEN
          xv(mgs,lhl) = Min( xvmx(lhl), Max( xvmn(lhl),xv(mgs,lhl) ) )
          xmas(mgs,lhl) = xv(mgs,lhl)*xdn(mgs,lhl)
          cx(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/(xmas(mgs,lhl))
        ENDIF

        xdia(mgs,lhl,3) = (xv(mgs,lhl)*6./pi)**(1./3.) ! mwfac*xdia(mgs,lh,1) ! (xv(mgs,lh)*cwc0*6.0)**(1./3.)
         IF ( dmuhl == 1.0 ) THEN
           xdia(mgs,lhl,1) = cwchl(mgs)*xdia(mgs,lhl,3)
         ELSE
           xdia(mgs,lhl,1) = (xv(mgs,lhl)*cwchl(mgs))**(1./3.)
         ENDIF
        
!        write(0,*) 'setvt: xv = ',xv(mgs,lhl),xdn(mgs,lhl),cx(mgs,lhl),xdia(mgs,lhl,3)
      ELSE
      xdia(mgs,lhl,1) = &
     &  (qx(mgs,lhl)*rho0(mgs)/(pi*xdn(mgs,lhl)*cno(lhl)))**(0.25) 
      cx(mgs,lhl) = cno(lhl)*xdia(mgs,lhl,1)
      xv(mgs,lhl) = Max(xvmn(lhl), rho0(mgs)*qx(mgs,lhl)/(xdn(mgs,lhl)*cx(mgs,lhl)) )
      xdia(mgs,lhl,3) = (xv(mgs,lhl)*6./pi)**(1./3.) 
      end if
      else
      xdia(mgs,lhl,1) = 1.e-9
      xdia(mgs,lhl,3) = 1.e-9
      end if
      xdia(mgs,lhl,2) = xdia(mgs,lhl,1)**2
!      hwdia3(mgs) = xdia(mgs,lh,2)*xdia(mgs,lh,1)
!      xmas(mgs,lh) = xdn(mgs,lh)*(pi/6.)*hwdia3(mgs)
      end do
      
      ENDIF
!      
!
!
!  Set terminal velocities...
!    also set drag coefficients (moved to start of subroutine)
!
!      cdx(lr) = 0.60
!      cdx(lh) = 0.45
!      cdx(lhl) = 0.45
!      cdx(lf) = 0.45
!      cdx(lgh) = 0.60
!      cdx(lgm) = 0.80
!      cdx(lgl) = 0.80
!      cdx(lir) = 2.00
!
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set terminal velocities'
!
!
! ################################################################
!
!  RAIN
!
      IF ( ildo == 0 .or. ildo == lr ) THEN
      do mgs = 1,ngscnt
      if ( qx(mgs,lr) .gt. qxmin(lr) ) then
      IF ( ipconc .lt. 3 ) THEN
        vtxbar(mgs,lr,1) = rainfallfac*(ar*gf4br/6.0)*(xdia(mgs,lr,1)**br)*rhovt(mgs)
!        write(91,*) 'vtxbar: ',vtxbar(mgs,lr,1),mgs,gf4br,xdia(mgs,lr,1),rhovt(mgs)
      ELSE
        
        IF ( imurain == 1 ) THEN ! DSD of Diameter
        
        ! using functional form of  arx*(1 - Exp(-frx*diameter) ), with arx =       arx = 10.
        !  and frx = 516.575 ! raind fit parameters for arx*(1 - Exp(-fx*d)), where d is rain diameter in meters.

        
          alp = alpha(mgs,lr)
          
          vtxbar(mgs,lr,1) = rhovt(mgs)*arx*(1.0 - (1.0 + frx*xdia(mgs,lr,1))**(-alp - 4.0) ) ! mass weighted
          
          IF ( infdo .ge. 1 .and. rssflg == 1 ) THEN
            vtxbar(mgs,lr,2) = rhovt(mgs)*arx*(1.0 - (1.0 + frx*xdia(mgs,lr,1))**(-alp - 1.0) ) ! number weighted
          ELSE
            vtxbar(mgs,lr,2) = vtxbar(mgs,lr,1)
          ENDIF
          
          IF ( infdo .ge. 2 .and. rssflg == 1 ) THEN
            vtxbar(mgs,lr,3) = rhovt(mgs)*arx*(1.0 - (1.0 + frx*xdia(mgs,lr,1))**(-alp - 7.0) ) ! z-weighted
          ELSE
            vtxbar(mgs,lr,3) = vtxbar(mgs,lr,1)
          ENDIF
          
!          write(91,*) 'setvt: alp,vn,vm,vz = ',alp,vtxbar(mgs,lr,2), vtxbar(mgs,lr,1), vtxbar(mgs,lr,3),alpha(mgs,lr)

        ELSEIF ( imurain == 3 ) THEN ! DSD of Volume
        
        IF ( lzr < 1 ) THEN ! not 3-moment rain
        rwdia = Min( xdia(mgs,lr,1), 8.0e-3 )
        
         vtxbar(mgs,lr,1) = rhovt(mgs)*6.0*pii*( 0.04771 + 3788.0*rwdia -  &
     &        1.105e6*rwdia**2 + 1.412e8*rwdia**3 - 6.527e9*rwdia**4)
        
        IF ( infdo .ge. 1 ) THEN
         vtxbar(mgs,lr,2) = (0.09112 + 2714.0*rwdia - 4.872e5*rwdia**2 +  &
     &            4.495e7*rwdia**3 - 1.626e9*rwdia**4)*rhovt(mgs)
        ENDIF
        
        IF ( infdo .ge. 2 ) THEN ! Z-weighted fall speed
        vtxbar(mgs,lr,3)  = rhovt(mgs)*(  &
     &       0.0911229 +                  &
     &  9246.494*(rwdia) -               &
     &  3.2839926e6*(rwdia**2) +          &
     &  4.944093e8*(rwdia**3) -          &
     &  2.631718e10*(rwdia**4) )
        ENDIF
        
        ELSE ! 3-moment rain, gamma-volume

        vr = xv(mgs,lr)
        rnux = alpha(mgs,lr)
        
        IF ( infdo .ge. 1 .and. rssflg == 1) THEN ! number-weighted; DTD: added size-sorting flag
        vtxbar(mgs,lr,2) = rhovt(mgs)*                             &
     &     (((1. + rnux)/vr)**(-1.333333)*                         &
     &    (0.0911229*((1. + rnux)/vr)**1.333333*Gamma(1. + rnux) + &
     &      (5430.3131*(1. + rnux)*Gamma(4./3. + rnux))/           &
     &       vr - 1.0732802e6*((1. + rnux)/vr)**0.6666667*         &
     &       Gamma(1.666667 + rnux) +                              &
     &      8.584110982429507e7*((1. + rnux)/vr)**(1./3.)*         &
     &       Gamma(2. + rnux) -                                    &
     &      2.3303765697228556e9*Gamma(7./3. + rnux)))/            &
     &  Gamma(1. + rnux)
        ENDIF

!  mass-weighted
       vtxbar(mgs,lr,1)  = rhovt(mgs)*                                                 &
     &   (0.0911229*(1 + rnux)**1.3333333333333333*Gamma(2. + rnux) +                  &
     &    5430.313059683277*(1 + rnux)*vr**0.3333333333333333*                         &
     &     Gamma(2.333333333333333 + rnux) -                                           &
     &    1.0732802065650471e6*(1 + rnux)**0.6666666666666666*vr**0.6666666666666666*  &
     &     Gamma(2.6666666666666667 + rnux) +                                          &
     &    8.584110982429507e7*(1 + rnux)**0.3333333333333333*vr*Gamma(3 + rnux) -      &
     &    2.3303765697228556e9*vr**1.3333333333333333*                                 &
     &     Gamma(3.333333333333333 + rnux))/                                           &
     &  ((1 + rnux)**2.333333333333333*Gamma(1 + rnux)) 
     
        IF(infdo .ge. 1 .and. rssflg == 0) THEN ! No size-sorting, set N-weighted fall speed to mass-weighted
          vtxbar(mgs,lr,2) = vtxbar(mgs,lr,1)
        ENDIF     
      
        IF ( infdo .ge. 2 .and. rssflg == 1) THEN ! Z-weighted fall speed
        vtxbar(mgs,lr,3)  =   rhovt(mgs)*                                          &
     &  ((1. + rnux)*(0.0911229*(1 + rnux)**1.3333333333333333*Gamma(3. + rnux) +  &
     &      5430.313059683277*(1 + rnux)*vr**0.3333333333333333*                   &
     &       Gamma(3.3333333333333335 + rnux) -                                    &
     &      1.0732802065650471e6*(1 + rnux)**0.6666666666666666*                   &
     &       vr**0.6666666666666666*Gamma(3.6666666666666665 + rnux) +             &
     &      8.5841109824295e7*(1 + rnux)**0.3333333333333333*vr*Gamma(4. + rnux) - &
     &      2.3303765697228556e9*vr**1.3333333333333333*                           &
     &       Gamma(4.333333333333333 + rnux)))/                                    &
     &  ((1 + rnux)**3.3333333333333335*(2 + rnux)*Gamma(1 + rnux))
        
!         write(0,*) 'setvt: mgs,lzr,infdo = ',mgs,lzr,infdo
!         write(0,*) 'vt1,2,3 = ',vtxbar(mgs,lr,1),vtxbar(mgs,lr,2),vtxbar(mgs,lr,3)
        
        ELSEIF (infdo .ge. 2) THEN ! No size-sorting, set Z-weighted fall speed to mass-weighted
          vtxbar(mgs,lr,3) = vtxbar(mgs,lr,1)
        ENDIF
        
        
        ENDIF
       ENDIF ! imurain

!        IF ( rwrad*mwfac .gt. 6.0e-4  ) THEN
!          vtxbar(mgs,lr,1) = 20.1*Sqrt(100.*rwrad*mwfac)*rhovt(mgs)
!        ELSE
!          vtxbar(mgs,lr,1) = 80.0e2*rwrad*rhovt(mgs)*mwfac
!        ENDIF
!        IF ( rwrad .gt. 6.0e-4  ) THEN
!          vtxbar(mgs,lr,2) = 20.1*Sqrt(100.*rwrad)*rhovt(mgs)
!        ELSE
!          vtxbar(mgs,lr,2) = 80.0e2*rwrad*rhovt(mgs)
!        ENDIF
      ENDIF ! ipconc
      else  ! qr < qrmin
      vtxbar(mgs,lr,1) = 0.0
      vtxbar(mgs,lr,2) = 0.0
      end if
      end do
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set rain vt'
      
      ENDIF
!
! ################################################################
!
!  SNOW !Zrnic et al. (1993)
!
      IF ( ls .gt. 1 .and. ( ildo == 0 .or. ildo == ls ) ) THEN
      do mgs = 1,ngscnt
      if ( qx(mgs,ls) .gt. qxmin(ls) ) then
        IF ( ipconc .ge. 4 ) THEN
         if ( mixedphase .and. qsvtmod ) then
         else
          IF ( isnowfall == 1 ) THEN
           ! original (Zrnic et al. 1993)
           vtxbar(mgs,ls,1) = 5.72462*rhovt(mgs)*(xv(mgs,ls))**(1./12.)
          ELSEIF ( isnowfall == 2 ) THEN
          ! Ferrier:
            vtxbar(mgs,ls,1) = 11.9495*rhovt(mgs)*(xv(mgs,ls))**(0.14)
          ENDIF
          
          IF(sssflg == 1) THEN
            IF ( isnowfall == 1 ) THEN
              vtxbar(mgs,ls,2) = 4.04091*rhovt(mgs)*(xv(mgs,ls))**(1./12.)
            ELSEIF ( isnowfall == 2 ) THEN
            ! Ferrier:
              vtxbar(mgs,ls,1) = 7.02909*rhovt(mgs)*(xv(mgs,ls))**(0.14)
            ENDIF
          ELSE
            vtxbar(mgs,ls,2) = vtxbar(mgs,ls,1)
          ENDIF
          vtxbar(mgs,ls,3) = vtxbar(mgs,ls,1)
         endif
        ELSE
         vtxbar(mgs,ls,1) = (cs*gf4ds/6.0)*(xdia(mgs,ls,1)**ds)*rhovt(mgs)
         vtxbar(mgs,ls,2) = vtxbar(mgs,ls,1)
        ENDIF
      else
      vtxbar(mgs,ls,1) = 0.0
      end if
      end do
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set snow vt'
      
      ENDIF ! ls .gt. 1
!
!
! ################################################################
!
!  GRAUPEL !Wisner et al. (1972)
!
      IF ( lh .gt. 1 .and. ( ildo == 0 .or. ildo == lh ) ) THEN
      
      do mgs = 1,ngscnt
      vtxbar(mgs,lh,1) = 0.0
      if ( qx(mgs,lh) .gt. qxmin(lh) ) then
       IF ( icdx .eq. 1 ) THEN
         cd = cdx(lh)
       ELSEIF ( icdx .eq. 2 ) THEN
!         cd = Max(0.6, Min(1.0, 0.6 + 0.4*(xdnmx(lh) - xdn(mgs,lh))/(xdnmx(lh)-xdnmn(lh)) ) )
!         cd = Max(0.6, Min(1.0, 0.6 + 0.4*(900.0 - xdn(mgs,lh))/(900. - 300.) ) )
         cd = Max(0.45, Min(1.0, 0.45 + 0.35*(800.0 - Max( 500., Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 500.) ) )
!         cd = Max(0.55, Min(1.0, 0.55 + 0.25*(800.0 - Max( 500., Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 500.) ) )
       ELSEIF ( icdx .eq. 3 ) THEN
!         cd = Max(0.45, Min(1.0, 0.45 + 0.55*(800.0 - Max( 300., Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 300.) ) )
         cd = Max(0.45, Min(1.2, 0.45 + 0.55*(800.0 - Max( hdnmn, Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 170.0) ) )
       ELSEIF ( icdx .eq. 4 ) THEN
         cd = Max(cdhmin, Min(cdhmax, cdhmin + (cdhmax-cdhmin)* &
     &        (cdhdnmax - Max( cdhdnmin, Min( cdhdnmax, xdn(mgs,lh) ) ) )/(cdhdnmax - cdhdnmin) ) )
       ELSEIF ( icdx .eq. 5 ) THEN
         cd = cdx(lh)*(xdn(mgs,lh)/rho_qh)**(2./3.)
       ELSEIF ( icdx .eq. 6 ) THEN ! Milbrandt and Morrison (2013)
         indxr = Int( (xdn(mgs,lh)-50.)/100. ) + 1
         indxr = Min( ngdnmm, Max(1,indxr) )
         
         
         delrho = Max( 0.0, 0.01*(xdn(mgs,lh) - mmgraupvt(indxr,1)) )
         IF ( indxr < ngdnmm ) THEN
          
          axh(mgs) = mmgraupvt(indxr,2) + delrho*(mmgraupvt(indxr+1,2) - mmgraupvt(indxr,2) )
          bxh(mgs) = mmgraupvt(indxr,3) + delrho*(mmgraupvt(indxr+1,3) - mmgraupvt(indxr,3) )

          
         ELSE
          axh(mgs) = mmgraupvt(indxr,2)
          bxh(mgs) = mmgraupvt(indxr,3)
         ENDIF
         
         aax = axh(mgs)
         bbx = bxh(mgs)
         
       ENDIF
       
      IF ( alpha(mgs,lh) .eq. 0.0 .and. icdx > 0 .and. icdx /= 6 ) THEN
      vtxbar(mgs,lh,1) = (gf4p5/6.0)*  &
     &  Sqrt( (xdn(mgs,lh)*xdia(mgs,lh,1)*4.0*gr) /  &
     &    (3.0*cd*rho0(mgs)) )
      ELSE
        IF ( icdx /= 6 ) bbx = bx(lh)
        tmp = 4. + alpha(mgs,lh) + bbx
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = 4. + alpha(mgs,lh)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        y = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
        
!        aax = Max( 1.0, Min(2.0, (xdn(mgs,lh)/400.) ) )
!        vtxbar(mgs,lh,1) =  rhovt(mgs)*aax*ax(lh)*(xdia(mgs,lh,1)**bx(lh)*x)/y
        
        IF ( icdx > 0 .and. icdx /= 6) THEN
          aax = Sqrt(4.0*xdn(mgs,lh)*gr/(3.0*cd*rho00))
          vtxbar(mgs,lh,1) =  rhovt(mgs)*aax* Sqrt(xdia(mgs,lh,1)) * x/y
          axh(mgs) = aax
          bxh(mgs) = bbx
        ELSEIF (icdx == 6 ) THEN
          vtxbar(mgs,lh,1) =  rhovt(mgs)*aax* xdia(mgs,lh,1)**bbx * x/y
        ELSE
          axh(mgs) = ax(lh)
          bxh(mgs) = bx(lh)
          vtxbar(mgs,lh,1) =  rhovt(mgs)*ax(lh)*(xdia(mgs,lh,1)**bx(lh)*x)/y          
        ENDIF

!     &    Gamma(4.0 + dnu(lh) + 0.6))/Gamma(4. + dnu(lh))
      ENDIF

      IF ( lwsm6 .and. ipconc == 0 ) THEN
!         vtxbar(mgs,lh,1) = (330.*gf4ds/6.0)*(xdia(mgs,ls,1)**ds)*rhovt(mgs)
         vtxbar(mgs,lh,1) = (330.*gf4br/6.0)*(xdia(mgs,lh,1)**br)*rhovt(mgs)
      ENDIF
      
      end if
      end do
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set hail vt'
      
      ENDIF ! lh .gt. 1
!
!
! ################################################################
!
!  HAIL
!
      IF ( lhl .gt. 1 .and. ( ildo == 0 .or. ildo == lhl ) ) THEN
      
      do mgs = 1,ngscnt
      vtxbar(mgs,lhl,1) = 0.0
      if ( qx(mgs,lhl) .gt. qxmin(lhl) ) then

       IF ( icdxhl .eq. 1 ) THEN
         cd = cdx(lhl)
       ELSEIF ( icdxhl .eq. 3 ) THEN
!         cd = Max(0.45, Min(1.0, 0.45 + 0.55*(800.0 - Max( 300., Min( 800.0, xdn(mgs,lhl) ) ) )/(800. - 300.) ) )
         cd = Max(0.45, Min(1.2, 0.45 + 0.55*(800.0 - Max( hldnmn, Min( 800.0, xdn(mgs,lhl) ) ) )/(800. - 170.0) ) )
       ELSEIF ( icdxhl .eq. 4 ) THEN
         cd = Max(cdhlmin, Min(cdhlmax, cdhlmin + (cdhlmax-cdhlmin)*  &
     &       (cdhldnmax - Max( cdhldnmin, Min( cdhldnmax, xdn(mgs,lhl) ) ) )/(cdhldnmax - cdhldnmin) ) )
       ELSEIF ( icdxhl .eq. 5 ) THEN
         cd = cdx(lh)*(xdn(mgs,lhl)/rho_qh)**(2./3.)
       ELSEIF ( icdxhl .eq. 6 ) THEN ! Milbrandt and Morrison (2013)
         indxr = Int( (xdn(mgs,lhl)-50.)/100. ) + 1
         indxr = Min( ngdnmm, Max(1,indxr) )
         
         
         delrho = Max( 0.0, 0.01*(xdn(mgs,lhl) - mmgraupvt(indxr,1)) )
         IF ( indxr < ngdnmm ) THEN
          
          axhl(mgs) = mmgraupvt(indxr,2) + delrho*(mmgraupvt(indxr+1,2) - mmgraupvt(indxr,2) )
          bxhl(mgs) = mmgraupvt(indxr,3) + delrho*(mmgraupvt(indxr+1,3) - mmgraupvt(indxr,3) )

          
         ELSE
          axhl(mgs) = mmgraupvt(indxr,2)
          bxhl(mgs) = mmgraupvt(indxr,3)
         ENDIF
         
         aax = axhl(mgs)
         bbx = bxhl(mgs)
         
       ELSE
!         cd = Max(0.6, Min(1.0, 0.6 + 0.4*(900.0 - xdn(mgs,lhl))/(900. - 300.) ) )
!        cd = Max(0.5, Min(0.8, 0.5 + 0.3*(xdnmx(lhl) - xdn(mgs,lhl))/(xdnmx(lhl)-xdnmn(lhl)) ) )
         cd = Max(0.45, Min(0.6, 0.45 + 0.15*(800.0 - Max( 500., Min( 800.0, xdn(mgs,lhl) ) ) )/(800. - 500.) ) )
       ENDIF

      IF ( alpha(mgs,lhl) .eq. 0.0 .and. icdxhl > 0 .and. icdxhl /= 6) THEN
      vtxbar(mgs,lhl,1) = (gf4p5/6.0)* &
     &  Sqrt( (xdn(mgs,lhl)*xdia(mgs,lhl,1)*4.0*gr) / &
     &    (3.0*cd*rho0(mgs)) )
      ELSE
        IF ( icdxhl /= 6 ) bbx = bx(lhl)
        tmp = 4. + alpha(mgs,lhl) + bbx
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = 4. + alpha(mgs,lhl)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        y = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        IF ( icdxhl > 0 .and. icdxhl /= 6) THEN
          aax = Sqrt(4.0*xdn(mgs,lhl)*gr/(3.0*cd*rho00))
          vtxbar(mgs,lhl,1) =  rhovt(mgs)*aax* Sqrt(xdia(mgs,lhl,1)) * x/y
          axhl(mgs) = aax
          bxhl(mgs) = bbx
        ELSEIF ( icdxhl == 6 ) THEN
          vtxbar(mgs,lhl,1) =  rhovt(mgs)*aax* (xdia(mgs,lhl,1))**bbx * x/y
        ELSE
          axhl(mgs) = ax(lhl)
          bxhl(mgs) = bx(lhl)
         vtxbar(mgs,lhl,1) =  rhovt(mgs)*(ax(lhl)*xdia(mgs,lhl,1)**bx(lhl)*x)/y
        ENDIF
        
!     &    Gamma(4.0 + dnu(lh) + 0.6))/Gamma(4. + dnu(lh))
      ENDIF


      end if
      end do
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set hail vt'
      
      ENDIF ! lhl .gt. 1


      IF ( infdo .ge. 1 ) THEN

!      DO il = lc,lhab
!      IF ( il .ne. lr ) THEN
        DO mgs = 1,ngscnt
          vtxbar(mgs,lc,2) = vtxbar(mgs,lc,1)
        IF ( li .gt. 1 ) THEN
!          vtxbar(mgs,li,2) = rhovt(mgs)*49420.*1.25447*xdia(mgs,li,1)**(1.415) ! n-wgt (Ferrier 94)
!          vtxbar(mgs,li,2) = vtxbar(mgs,li,1)

! test print stuff...
!          IF ( xdia(mgs,li,1) .gt. 200.e-6 ) THEN
!            tmp = (xv(mgs,li)*cwc0)**(1./3.)
!            x = rhovt(mgs)*49420.*40.0005/5.40662*tmp**(1.415)
!            y = rhovt(mgs)*49420.*1.25447*tmp**(1.415)
!            write(6,*) 'Ice fall: ',vtxbar(mgs,li,1),x,y,tmp,xdia(mgs,li,1)
!          ENDIF
        ENDIF
!          vtxbar(mgs,ls,2) = vtxbar(mgs,ls,1)
        ENDDO

        IF ( lg .gt. lr ) THEN

        DO il = lg,lhab
         IF ( ildo == 0 .or. ildo == il ) THEN

            DO mgs = 1,ngscnt
             IF ( qx(mgs,il) .gt. qxmin(il) ) THEN
              IF ( (il .eq. lh .and. hssflg == 1) .or. ( lhl .gt. 1 .and. il .eq. lhl .and. hlssflg == 1) ) THEN ! DTD: added flag for size-sorting
              
              ! DTD: allow for setting of number-weighted and z-weighted fall speeds to the mass-weighted value,
              ! effectively turning off size-sorting

              IF ( il .eq. lh ) THEN ! {
             
               IF ( icdx .eq. 1 ) THEN
                 cd = cdx(lh)
               ELSEIF ( icdx .eq. 2 ) THEN
!                 cd = Max(0.6, Min(1.0, 0.6 + 0.4*(xdnmx(lh) - xdn(mgs,lh))/(xdnmx(lh)-xdnmn(lh)) ) )
!                 cd = Max(0.6, Min(1.0, 0.6 + 0.4*(900.0 - xdn(mgs,lh))/(900. - 300.) ) )
                 cd = Max(0.45, Min(1.0, 0.45 + 0.35*(800.0 - Max( 500., Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 500.) ) )
!                 cd = Max(0.55, Min(1.0, 0.55 + 0.25*(800.0 - Max( 500., Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 500.) ) )
               ELSEIF ( icdx .eq. 3 ) THEN
!                 cd = Max(0.45, Min(1.0, 0.45 + 0.55*(800.0 - Max( 170.0, Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 170.0) ) )
                 cd = Max(0.45, Min(1.2, 0.45 + 0.55*(800.0 - Max( hdnmn, Min( 800.0, xdn(mgs,lh) ) ) )/(800. - 170.0) ) )
               ELSEIF ( icdx .eq. 4 ) THEN
                 cd = Max(cdhmin, Min(cdhmax, cdhmin + (cdhmax-cdhmin)* &
     &            (cdhdnmax - Max( cdhdnmin, Min( cdhdnmax, xdn(mgs,lh) ) ) )/(cdhdnmax - cdhdnmin) ) )
               ELSEIF ( icdx .eq. 5 ) THEN
                 cd = cdx(lh)*(xdn(mgs,lh)/rho_qh)**(2./3.)
               ELSEIF ( icdx .eq. 6 ) THEN ! Milbrandt and Morrison (2013)
                  aax = axh(mgs)
                  bbx = bxh(mgs)
               ENDIF
               
              ELSEIF ( lhl .gt. 1 .and. il .eq. lhl ) THEN
             
               IF ( icdxhl .eq. 1 ) THEN
                 cd = cdx(lhl)
               ELSEIF ( icdxhl .eq. 3 ) THEN
!               cd = Max(0.45, Min(1.0, 0.45 + 0.55*(800.0 - Max( 300., Min( 800.0, xdn(mgs,lhl) ) ) )/(800. - 300.) ) )
                cd = Max(0.45, Min(1.2, 0.45 + 0.55*(800.0 - Max( hldnmn, Min( 800.0, xdn(mgs,lhl) ) ) )/(800. - 170.0) ) )
               ELSEIF ( icdxhl .eq. 4 ) THEN
                cd = Max(cdhlmin, Min(cdhlmax, cdhlmin + (cdhlmax-cdhlmin)*  &
     &               (cdhldnmax - Max( cdhldnmin, Min( cdhldnmax, xdn(mgs,lhl) ) ) )/(cdhldnmax - cdhldnmin) ) )
               ELSEIF ( icdxhl == 5 ) THEN
!                cd = Max(0.6, Min(1.0, 0.6 + 0.4*(900.0 - xdn(mgs,lhl))/(900. - 300.) ) )
!                cd = Max(0.5, Min(0.8, 0.5 + 0.3*(xdnmx(lhl) - xdn(mgs,lhl))/(xdnmx(lhl)-xdnmn(lhl)) ) )
                 cd = Max(0.45, Min(0.6, 0.45 + 0.15*(800.0 - Max( 500., Min( 800.0, xdn(mgs,lhl) ) ) )/(800. - 500.) ) )
               ELSEIF ( icdxhl .eq. 6 ) THEN ! Milbrandt and Morrison (2013)
                  aax = axhl(mgs)
                  bbx = bxhl(mgs)
               ENDIF
               
              ENDIF ! }

               IF ( alpha(mgs,il) .eq. 0. .and. infdo .lt. 2 .and.   &
               ( ( il==lh .and. icdx > 0 .and. icdx /= 6) .or. ( il==lhl .and. icdxhl > 0 .and. icdxhl /= 6 ) ) ) THEN ! {
                 vtxbar(mgs,il,2) =   &
     &              Sqrt( (xdn(mgs,il)*xdia(mgs,il,1)*pi*gr) / &
     &                (3.0*cd*rho0(mgs)) )

               ELSE
               IF ( il == lh  .and. icdx   /= 6 ) bbx = bx(il)
               IF ( il == lhl .and. icdxhl /= 6 ) bbx = bx(il)
               tmp = 1. + alpha(mgs,il) + bbx
               i = Int(dgami*(tmp))
               del = tmp - dgam*i
               x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
  
               tmp = 1. + alpha(mgs,il)
               i = Int(dgami*(tmp))
               del = tmp - dgam*i
               y = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

                 IF ( il .eq. lh  .or. il .eq. lhl) THEN ! {
                   IF ( ( il==lh .and. icdx > 0 ) ) THEN
                     IF ( icdx /= 6 ) THEN
                      aax = Sqrt(4.0*xdn(mgs,il)*gr/(3.0*cd*rho00))
                      vtxbar(mgs,il,2) =  rhovt(mgs)*aax* xdia(mgs,il,1)**0.5 * x/y
                     ELSE !  (icdx == 6 ) THEN
                       vtxbar(mgs,il,2) =  rhovt(mgs)*aax* xdia(mgs,il,1)**bbx * x/y
                     ENDIF
!                   ELSE
!                     aax = ax(il)
!                     vtxbar(mgs,il,2) =  rhovt(mgs)*ax(il)*(xdia(mgs,il,1)**bx(il)*x)/y
!                   ENDIF

                   ELSEIF ( ( il==lhl .and. icdxhl > 0 ) ) THEN
                     IF ( icdxhl /= 6 ) THEN
                       aax = Sqrt(4.0*xdn(mgs,il)*gr/(3.0*cd*rho00))
                       vtxbar(mgs,il,2) =  rhovt(mgs)*aax* xdia(mgs,il,1)**0.5 * x/y
                     ELSE ! ( icdxhl == 6 )
                       vtxbar(mgs,il,2) =  rhovt(mgs)*aax* xdia(mgs,il,1)**bbx * x/y
                     ENDIF
                   ELSE
                     aax = ax(il)
                     vtxbar(mgs,il,2) =  rhovt(mgs)*ax(il)*(xdia(mgs,il,1)**bx(il)*x)/y
                   ENDIF

!                  vtxbar(mgs,il,2) =  &
!     &               rhovt(mgs)*(xdn(mgs,il)/400.)*(75.715*xdia(mgs,il,1)**0.6* &
!     &               x)/y
!                  vtxbar(mgs,il,2) =  &
!     &               rhovt(mgs)*(xdn(mgs,il)/400.)*(ax(il)*xdia(mgs,il,1)**bx(il)* &
!     &               x)/y
                  IF ( infdo .ge. 2 ) THEN ! Z-weighted
                   vtxbar(mgs,il,3) = rhovt(mgs)*                 &
     &                (aax*(1.0/xdia(mgs,il,1) )**(- bbx)*  &
     &                 Gamma(7.0 + alpha(mgs,il) + bbx))/Gamma(7. + alpha(mgs,il))
!     &                (aax*(1.0/xdia(mgs,il,1) )**(- bx(il))*  &
!     &                 Gamma(7.0 + alpha(mgs,il) + bx(il)))/Gamma(7. + alpha(mgs,il))
                  ENDIF

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set hail vt3'

                 ELSE ! hail
                  vtxbar(mgs,il,2) =  &
     &               rhovt(mgs)*(ax(il)*xdia(mgs,il,1)**bx(il)* &
     &               x)/y

                 IF ( infdo .ge. 2 ) THEN ! Z-weighted
                  vtxbar(mgs,il,3) = rhovt(mgs)*                 &
     &              (aax*(1.0/xdia(mgs,il,1) )**(- bbx)*  &
     &               Gamma(7.0 + alpha(mgs,il) + bbx))/Gamma(7. + alpha(mgs,il))
!     &              (ax(il)*(1.0/xdia(mgs,il,1) )**(- bx(il))*  &
!     &               Gamma(7.0 + alpha(mgs,il) + bx(il)))/Gamma(7. + alpha(mgs,il))
                  ENDIF

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set hail vt4'

                 ENDIF ! }
!     &             Gamma(1.0 + dnu(il) + 0.6)/Gamma(1. + dnu(il))
               ENDIF ! }

!              IF ( infdo .ge. 2 ) THEN ! Z-weighted
!               vtxbar(mgs,il,3) = rhovt(mgs)*                 &
!     &            (ax(il)*(1.0/xdia(mgs,il,1) )**(- bx(il))*  &
!     &             Gamma(7.0 + alpha(mgs,il) + bx(il)))/Gamma(7. + alpha(mgs,il))
!              ENDIF

!               IF ( lhl .gt. 1 .and. il .eq. lhl ) THEN
!                write(0,*) 'setvt: ',qx(mgs,il),xdia(mgs,il,1),xdia(mgs,il,3),dnu(il),ax(il),bx(il)
!               ENDIF
             ELSEIF ( (il .eq. lh .and. hssflg == 0) .or. ( lhl .gt. 1 .and. il .eq. lhl .and. hlssflg == 0) ) THEN ! no size-sorting for graupel or hail
              vtxbar(mgs,il,2) = vtxbar(mgs,il,1)
              vtxbar(mgs,il,3) = vtxbar(mgs,il,1)
             ELSE ! not lh or lhl
              vtxbar(mgs,il,2) = &
     &            Sqrt( (xdn(mgs,il)*xdia(mgs,il,1)*pi*gr) /  &
     &              (3.0*cdx(il)*rho0(mgs)) )
              vtxbar(mgs,il,3) = vtxbar(mgs,il,1)

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set graupel vt5'


              ENDIF
             ELSE ! qx < qxmin
              vtxbar(mgs,il,2) = 0.0

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set graupel vt6'

             ENDIF
           ENDDO ! mgs

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set graupel vt7'

        ENDIF
        ENDDO ! il

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set graupel vt8'

        ENDIF ! lg .gt. 1 
        
!      ENDIF
!      ENDDO

      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: Set graupel vt9'

!       DO mgs = 1,ngscnt
!        IF ( qx(mgs,lr) > qxmin(lr) ) THEN
!         write(0,*) 'setvt2: mgs,lzr,infdo = ',mgs,lzr,infdo
!         write(0,*) 'vt1,2,3 = ',vtxbar(mgs,lr,1),vtxbar(mgs,lr,2),vtxbar(mgs,lr,3)
!        ENDIF
!       ENDDO

      ENDIF ! infdo .ge. 1 
      
      if ( ndebug1 .gt. 0 ) write(0,*) 'SETVTZ: END OF ROUTINE'

!############ SETVTZ ############################

      RETURN
      END SUBROUTINE setvtz
!--------------------------------------------------------------------------

!
! ##############################################################################

!
!  subroutine to calculate fall speeds of hydrometeors
!

      subroutine ziegfall1d(nx,ny,nz,nor,norz,na,dtp,jgs,ixcol, &
     &  xvt, rhovtzx,                                           &
     &  an,dn,ipconc0,t0,t7,cwmasn,cwmasx,       &
     &  cwradn,                                   &
     &  qxmin,xdnmx,xdnmn,cdx,cno,xdn0,xvmn,xvmx,  &
     &  ngs,qx,qxw,cx,xv,vtxbar,xmas,xdn,xdia,vx,alpha,zx,igs,kgs, &
     &  rho0,temcg,temg,rhovt,cwnc,cinc,fadvisc,cwdia,cipmas,cnina,cimas, &
     &  cnostmp,                     &
     &  infdo,ildo,timesetvt)

! 12.16.2005: .F version use in transitional SWM model
!
! 10.10.2003: Added cimn and cimx to setting for cci and cip.
!
! TO DO LIST:
!
! need to set up values for:
!     :  cipdia,cidia,cwdia,cwmas,vtwbar,
!     :  rho0,temcg,cip,cci
!
! and need to put fallspeed values in cwvt etc.
!
      
      implicit none
      integer ng1
      parameter(ng1 = 1)
      
      integer, intent(in) :: ixcol ! which column to return
      integer, intent(in) :: ildo
      
      integer nx,ny,nz,nor,norz,ngt,jgs,na
      real an(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor,na)
      real dn(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)
      real t0(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)
      real t7(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)
      real dtp,dtz1
      
      real :: rhovtzx(nz,nx)
      
      integer ndebugzf
      parameter (ndebugzf = 0)

      integer ix,jy,kz,i,j,k,il
      integer infdo
!
!
      real xvt(nz+1,nx,3,lc:lhab) ! 1=mass-weighted, 2=number-weighted

      real qxmin(lc:lhab)
      real xdn0(lc:lhab)
      real xvmn(lc:lhab), xvmx(lc:lhab)
      double precision,optional :: timesetvt

      integer :: ngs
      integer :: ngscnt,mgs,ipconc0
!      parameter ( ngs=200 )
      
      real ::  qx(ngs,lv:lhab) 
      real ::  qxw(ngs,ls:lhab) 
      real ::  cx(ngs,lc:lhab) 
      real ::  xv(ngs,lc:lhab) 
      real ::  vtxbar(ngs,lc:lhab,3) 
      real ::  xmas(ngs,lc:lhab) 
      real ::  xdn(ngs,lc:lhab) 
      real ::  xdia(ngs,lc:lhab,3) 
      real ::  vx(ngs,li:lhab) 
      real ::  alpha(ngs,lc:lhab) 
!#ifdef Z3MOM
      real ::  zx(ngs,lr:lhab) 
!#endif

      real xdnmx(lc:lhab), xdnmn(lc:lhab)
      real axh(ngs),bxh(ngs),axhl(ngs),bxhl(ngs)

!
!   drag coefficients
!
      real cdx(lc:lhab)
!
! Fixed intercept values for single moment scheme
!
      real cno(lc:lhab)
      
      real cwccn0,cwmasn,cwmasx,cwradn
!      real cwc0

      integer nxmpb,nzmpb,nxz,numgs,inumgs
      integer kstag
      parameter (kstag=1)

      integer igs(ngs),kgs(ngs)
      
      real rho0(ngs),temcg(ngs)

      real temg(ngs)
      
      real rhovt(ngs)
      
      real cwnc(ngs),cinc(ngs)
      real fadvisc(ngs),cwdia(ngs),cipmas(ngs)
      
!      real cimasn,cimasx,
      real :: cnina(ngs),cimas(ngs)
      
      real :: cnostmp(ngs)

!      real pii
!
!
!  general constants for microphysics
!

! 
! Miscellaneous
!
      
      logical flag
      logical ldoliq
      
    
      real chw, qr, z, rd, alp, z1, g1, vr, nrx, tmp
      
      real vtmax
      real xvbarmax
      
      integer l1, l2
      
      double precision :: dpt1, dpt2


!-----------------------------------------------------------------------------
! MPI LOCAL VARIABLES 

      integer :: ixb, jyb, kzb
      integer :: ixe, jye, kze

      logical :: debug_mpi = .false.


      if (ndebugzf .gt. 0 ) write(0,*) "ZIEGFALL: ENTERED SUBROUTINE"

! #####################################################################
! BEGIN EXECUTABLE
! #####################################################################
!

!  constants
!

      ldoliq = .false.
      IF ( ls .gt. 1 ) THEN
      DO il = ls,lhab
        ldoliq = ldoliq .or. ( lliq(il) .gt. 1 )
      ENDDO
      ENDIF
      
!      poo = 1.0e+05
!      cp608 = 0.608
!      cp = 1004.0
!      cv = 717.0
!      dnz00 = 1.225
!      rho00 = 1.225
!      cs = 4.83607122
!      ds = 0.25
!  new values for  cs and ds
!      cs = 12.42
!      ds = 0.42
!      pi = 4.0*atan(1.0)
!      pii = piinv ! 1./pi
!      pid4 = pi/4.0 
!      qccrit = 2.0e-03
!      qscrit = 6.0e-04
!      cwc0 = pii
      
!
!
!  general constants for microphysics
!
      
!
!  ci constants in mks units
!
!      cimasn = 6.88e-13 
!      cimasx = 1.0e-8
!
!  Set terminal velocities...
!    also set drag coefficients
!
      jy = jgs
      nxmpb = ixcol
      nzmpb = 1
      nxz = 1*nz
!      ngs = nz
      numgs = 1

      IF ( ildo == 0 ) THEN
        l1 = lc
        l2 = lhab
      ELSE
        l1 = ildo
        l2 = ildo
      ENDIF


      do inumgs = 1,numgs
       ngscnt = 0


       do kz = nzmpb,nz
        do ix = ixcol,ixcol
        flag = .false.

        
        DO il = l1,l2
          flag =  flag .or. ( an(ix,jy,kz,il)  .gt. qxmin(il) ) 
        ENDDO

        if ( flag ) then
! load temp quantities

        ngscnt = ngscnt + 1
        igs(ngscnt) = ix
        kgs(ngscnt) = kz
        if ( ngscnt .eq. ngs ) goto 1100
        end if
!#ifndef MPI
        end do !!ix
!#endif
        nxmpb = 1
       end do !! kz

!      if ( jy .eq. (ny-jstag) ) iend = 1

 1100 continue

      if ( ngscnt .eq. 0 ) go to 9998
!
!  set temporaries for microphysics variables
!


!
!  Reconstruct various quantities 
!
      do mgs = 1,ngscnt

       rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
       rhovt(mgs) = rhovtzx(kgs(mgs),ixcol) !  Sqrt(rho00/rho0(mgs))
       temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
       temcg(mgs) = temg(mgs) - tfr

        
!
      end do
!
! only need fadvisc for 
      IF ( lc .gt. 1 .and. (ildo == 0 .or. ildo == lc ) ) then
        do mgs = 1,ngscnt
         fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* &
     &   (temg(mgs)/296.0)**(1.5)
        end do
      ENDIF

      IF ( ipconc .eq. 0 ) THEN
      do mgs = 1,ngscnt
      cnina(mgs) = t7(igs(mgs),jgs,kgs(mgs))
      end do
      ENDIF


      IF ( ildo > 0 ) THEN
        vtxbar(:,ildo,:) = 0.0
      ELSE
        vtxbar(:,:,:) = 0.0
      ENDIF
      
!      do mgs = 1,ngscnt
!        qx(mgs,lv) = max(an(igs(mgs),jy,kgs(mgs),lv), 0.0) 
!      ENDDO
      DO il = l1,l2
      do mgs = 1,ngscnt
        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0) 
      ENDDO
      end do
      
      cnostmp(:) = cno(ls)
      IF ( ipconc < 1 .and. lwsm6 .and. (ildo == 0 .or. ildo == ls )) THEN
        DO mgs = 1,ngscnt
          tmp = Min( 0.0, temcg(mgs) )
          cnostmp(mgs) = Min( 2.e8, 2.e6*exp(0.12*tmp) )
        ENDDO
      ENDIF


!
!  set concentrations
!
      cx(:,:) = 0.0
      
      if ( ipconc .ge. 1 .and. li .gt. 1 .and. (ildo == 0 .or. ildo == li ) ) then
       do mgs = 1,ngscnt
        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
       end do
      end if
      if ( ipconc .ge. 2 .and. lc .gt. 1 .and. (ildo == 0 .or. ildo == lc ) ) then
       do mgs = 1,ngscnt
        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
!        cx(mgs,lc) = Min( ccwmx, cx(mgs,lc) )
       end do
      end if
      if ( ipconc .ge. 3 .and. lr .gt. 1 .and. (ildo == 0 .or. ildo == lr ) ) then
       do mgs = 1,ngscnt
        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
!        IF ( qx(mgs,lr) .le. qxmin(lr) ) THEN
!        ELSE
!          cx(mgs,lr) = Max( 0.0, cx(mgs,lr) )
!        ENDIF
       end do
      end if
      if ( ipconc .ge. 4  .and. ls .gt. 1 .and. (ildo == 0 .or. ildo == ls ) ) then
       do mgs = 1,ngscnt
        cx(mgs,ls) = Max(an(igs(mgs),jy,kgs(mgs),lns), 0.0)
!        IF ( qx(mgs,ls) .le. qxmin(ls) ) THEN
!        ELSE
!          cx(mgs,ls) = Max( 0.0, cx(mgs,ls) )
!        ENDIF
       end do
      end if

      if ( ipconc .ge. 5  .and. lh .gt. 1 .and. (ildo == 0 .or. ildo == lh ) ) then
       do mgs = 1,ngscnt

        cx(mgs,lh) = Max(an(igs(mgs),jy,kgs(mgs),lnh), 0.0)
!        IF ( qx(mgs,lh) .le. qxmin(lh) ) THEN
!        ELSE
!          cx(mgs,lh) = Max( 0.0, cx(mgs,lh) )
!        ENDIF

       end do
      ENDIF

      if ( ipconc .ge. 5  .and. lhl .gt. 1 .and. (ildo == 0 .or. ildo == lhl ) ) then
       do mgs = 1,ngscnt

        cx(mgs,lhl) = Max(an(igs(mgs),jy,kgs(mgs),lnhl), 0.0)
!        IF ( qx(mgs,lhl) .le. qxmin(lhl) ) THEN
!          cx(mgs,lhl) = 0.0
!        ELSEIF ( cx(mgs,lhl) .eq. 0.0 .and. qx(mgs,lhl) .lt. 3.0*qxmin(lhl) ) THEN
!          qx(mgs,lhl) = 0.0
!        ELSE
!          cx(mgs,lhl) = Max( 0.0, cx(mgs,lhl) )
!        ENDIF

       end do
      end if
       
      do mgs = 1,ngscnt
        xdn(mgs,lc) = xdn0(lc)
        xdn(mgs,lr) = xdn0(lr)
!        IF ( ls .gt. 1 .and. lvs .eq. 0 ) xdn(mgs,ls) = xdn0(ls)
!        IF ( lh .gt. 1 .and. lvh .eq. 0 ) xdn(mgs,lh) = xdn0(lh)
        IF ( li .gt. 1 )  xdn(mgs,li) = xdn0(li)
        IF ( ls .gt. 1 )  xdn(mgs,ls) = xdn0(ls)
        IF ( lh .gt. 1 )  xdn(mgs,lh) = xdn0(lh)
        IF ( lhl .gt. 1 ) xdn(mgs,lhl) = xdn0(lhl)
      end do

!
! Set mean particle volume
!
      IF ( ldovol .and. (ildo == 0 .or. ildo >= li ) ) THEN
      
      vx(:,:) = 0.0
      
       DO il = l1,l2
        
        IF ( lvol(il) .ge. 1 ) THEN
        
          DO mgs = 1,ngscnt
            vx(mgs,il) = Max(an(igs(mgs),jy,kgs(mgs),lvol(il)), 0.0)
            IF ( vx(mgs,il) .gt. rho0(mgs)*qxmin(il)*1.e-3 .and. qx(mgs,il) .gt. qxmin(il) ) THEN
              xdn(mgs,il) = Min( xdnmx(il), Max( xdnmn(il), rho0(mgs)*qx(mgs,il)/vx(mgs,il) ) )
            ENDIF
          ENDDO
          
        ENDIF
      
       ENDDO
      
      ENDIF

      DO il = lg,lhab
      DO mgs = 1,ngscnt
        alpha(mgs,il) = dnu(il)
      ENDDO
      ENDDO
      
      IF ( imurain == 1 ) THEN
        alpha(:,lr) = alphar
      ELSEIF ( imurain == 3 ) THEN
        alpha(:,lr) = xnu(lr)
      ENDIF
       






!
!  Set density
!
      if (ndebugzf .gt. 0 ) write(0,*)  'ZIEGFALL: call setvtz'
!
      
      call setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno,cnostmp,   &
     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,        &
     &                 ipconc,ndebugzf,ngs,nz,kgs,fadvisc, &
     &                 cwmasn,cwmasx,cwradn,cnina,cimn,cimx,    &
     &                 itype1,itype2,temcg,infdo,alpha,ildo,axh,bxh,axhl,bxhl)



!
! put fall speeds into the x-z arrays
!
      DO il = l1,l2
      do mgs = 1,ngscnt
       
       vtmax = 150.0

       
       IF ( vtxbar(mgs,il,2) .gt. vtxbar(mgs,il,1)  .or. &
     &      ( vtxbar(mgs,il,1) .gt. vtxbar(mgs,il,3) .and. vtxbar(mgs,il,3) > 0.0) ) THEN
          
          
          
          vtxbar(mgs,il,1) = Max( vtxbar(mgs,il,1), vtxbar(mgs,il,2) )
          vtxbar(mgs,il,3) = Max( vtxbar(mgs,il,3), vtxbar(mgs,il,1) )
          
       ENDIF

       
       IF ( vtxbar(mgs,il,1) .gt. vtmax .or. vtxbar(mgs,il,2) .gt. vtmax .or. &
     &      vtxbar(mgs,il,3) .gt. vtmax ) THEN
       
        vtxbar(mgs,il,1) = Min(vtmax,vtxbar(mgs,il,1) )
        vtxbar(mgs,il,2) = Min(vtmax,vtxbar(mgs,il,2) )
        vtxbar(mgs,il,3) = Min(vtmax,vtxbar(mgs,il,3) )
        
!        call commasmpi_abort()
       ENDIF


       xvt(kgs(mgs),igs(mgs),1,il) = vtxbar(mgs,il,1)
       xvt(kgs(mgs),igs(mgs),2,il) = vtxbar(mgs,il,2)
       IF ( infdo .ge. 2 ) THEN
       xvt(kgs(mgs),igs(mgs),3,il) = vtxbar(mgs,il,3)
       ELSE
       xvt(kgs(mgs),igs(mgs),3,il) = 0.0
       ENDIF

!       xvt(kgs(mgs),igs(mgs),2,il) = xvt(kgs(mgs),igs(mgs),1,il)

      enddo
      ENDDO


      if (ndebugzf .gt. 0 ) write(0,*)  'ZIEGFALL: COPIED FALL SPEEDS'



 9998 continue

      if (ndebugzf .gt. 0 ) write(0,*)  'ZIEGFALL: DONE WITH LOOP'

      if ( kz .gt. nz-1 ) then
        go to 1200
      else
        nzmpb = kz 
      end if

      if (ndebugzf .gt. 0 ) write(0,*) 'ZIEGFALL: SET NZMPB'

      end do !! inumgs

      if (ndebugzf .gt. 0 ) write(0,*) 'ZIEGFALL: SET NXMPB'

 1200 continue


!       ENDDO ! ix
!      ENDDO ! kz


      if (ndebugzf .gt. 0 ) write(0,*) "ZIEGFALL: EXITING SUBROUTINE"


      RETURN
      END subroutine ziegfall1d

! #####################################################################
! #####################################################################


! #####################################################################
! #####################################################################

! ##############################################################################
      subroutine radardd02(nx,ny,nz,nor,na,an,temk,         &
     &    dbz,db,nzdbz,cnoh0t,hwdn1t,ipconc, iunit)
!
! 11.13.2005: Changed values of indices for reordering of lip
!
! 07.13.2005: Fixed an error where cnoh was being used for graupel and frozen drops
!
! 01.24.2005: add ice crystal reflectivity using parameterization of
!             Heymsfield (JAS, 1977).  Could also try Ferrier for this, too.
!
!  09.28.2002 Test alterations for dry ice following Ferrier (1994)
!      for equivalent melted diameter reflectivity.
!      Converted to Fortran by ERM.
!      
!Date: Tue, 21 Nov 2000 10:13:36 -0600 (CST)
!From: Matthew Gilmore <gilmore@hesston.met.tamu.edu>
!
!PRO RF_SPEC ; Computes Radar Reflectivity
!COMMON MAINB, data, x1d, y1d, z1d, iconst, rconst, labels, nx, ny, nz, dshft
!
!;MODIFICATION HISTORY
!; 5/99  -Svelta Veleva introduces variable dielf (const_ki_x) as a (weak)
!;   function of density.  This leads to slight modification of dielf such
!;   that the snow reflectivity is slightly increased - not a big effect.
!;   This is believed to be more accurate than assuming the dielectric
!;   constant for snow is the same as for hail in previous versions.
!
!;On 6/13/99 I added the VIL computation (k=0 in vil array)
!;On 6/15/99 I removed the number concentration dependencies as a function
!;           of temperature (only use for ferrier!)
!;On 6/15/99 I added the Composite reflectivity (k=1 in VIL array)
!;On 6/15/99 I added the Severe Hail Index computation (k=2 in vil array)
!;
!; 6/99 - Veleva and Seo argue that since graupel is more similar to
!;   snow (in number conc and size density) than it is to hail, we
!;   should not weight wetted graupel with the .95 exponent correction
!;   factor as in the case of hail.  An if-statement checks the size
!;   density for wet hail/graupel and treats them appropriately.
!;
!; 6/22/99 - Added function to compute height of max rf and 40 dbz echo top
!;           Also added vilqr which is the model vertical integrated liquid only
!;           using qr.  Will need to check...doesn't seem consistent with vilZ
!;


      implicit none
      
      character(LEN=15), parameter :: microp = 'ZVD'
      integer nx,ny,nz,nor,na,ngt
      integer nzdbz    !  how many levels actually to process
      
      integer ng1,n10
      integer iunit
      integer, parameter :: printyn = 0

      parameter( ng1 = 1 )
      
      real cnoh0t,hwdn1t
      integer ipconc
      real vr


      integer imapz,mzdist
      
      integer vzflag
      integer, parameter :: norz = 3
      real an(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor,na)
      real db(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)  ! air density
!      real gt(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor,ngt)
      real temk(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)  ! air temperature (kelvin)
      real dbz(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-nor+ng1:nz+nor)   ! reflectivity
      real gz(-nor+1:nz+nor) ! ,z1d(-nor+1:nz+nor,4)
      
!      real g,rgas,eta,inveta
      real cr1, cr2 ,  hwdnsq,swdnsq
      real rwdnsq, dhmin, qrmin, qsmin, qhmin, qhlmin, tfr, tfrh, zrc
      real reflectmin,  kw_sq
      real const_ki_sn, const_ki_h, ki_sq_sn
      real ki_sq_h, dielf_sn, dielf_h
      real pi
      logical ltest

!  Other data arrays
       real gtmp     (nx,nz)
       real dtmp     (nx,nz)
       real tmp

       real*8 dtmps, dtmpr, dtmph, dtmphl, g1, zx, ze, x

       integer i,j,k,ix,jy,kz,ihcnt

        real*8 xcnoh, xcnos, dadh, dads, zhdryc, zsdryc, zhwetc,zswetc
        real*8 dadr
        real dbzmax,dbzmin
        parameter ( dbzmin = 0 )

      real cnow,cnoi,cnoip,cnoir,cnor,cnos
      real cnogl,cnogm,cnogh,cnof,cnoh,cnohl

      real swdn, rwdn ,hwdn,gldn,gmdn,ghdn,fwdn,hldn
      real swdn0

      real rwdnmx,cwdnmx,cidnmx,xidnmx,swdnmx,gldnmx,gmdnmx
      real ghdnmx,fwdnmx,hwdnmx,hldnmx
      real rwdnmn,cwdnmn,cidnmn,xidnmn,swdnmn,gldnmn,gmdnmn
      real ghdnmn,fwdnmn,hwdnmn,hldnmn
 
      real gldnsq,gmdnsq,ghdnsq,fwdnsq,hldnsq

      real dadgl,dadgm,dadgh,dadhl,dadf
      real zgldryc,zglwetc,zgmdryc, zgmwetc,zghdryc,zghwetc
      real zhldryc,zhlwetc,zfdryc,zfwetc

      real dielf_gl,dielf_gm,dielf_gh,dielf_hl,dielf_fw
      
      integer imx,jmx,kmx
      
      real swdia,gldia,gmdia,ghdia,fwdia,hwdia,hldia
      
      real csw,cgl,cgm,cgh,cfw,chw,chl
      real xvs,xvgl,xvgm,xvgh,xvf,xvh,xvhl
      
      real cwc0
      integer izieg
      integer ice10
      real rhos
      parameter ( rhos = 0.1 )
      
      real qxw    ! temp value for liquid water on ice mixing ratio
      real qh

      real, parameter :: cwmasn = 5.23e-13   ! minimum mass, defined by radius of 5.0e-6
      real, parameter :: cwmasx = 5.25e-10   ! maximum mass, defined by radius of 50.0e-6
      real, parameter :: cwradn = 5.0e-6     ! minimum radius

      real cwnccn(nz)
      
      real :: vzsnow, vzrain, vzgraupel, vzhail
      real :: ksq
      real :: dtp


! #########################################################################      

      vzflag = 0
      
      izieg = 0
      ice10 = 0
!      g=9.806                 ! g: gravity constant
!      rgas=287.04             ! rgas: gas constant for dry air
!      rcp=rgas/cp             ! rcp: gamma constant
!      eta=0.622
!      inveta = 1./eta
!      rcpinv = 1./rcp
!      cpr=cp/rgas
!      cvr=cv/rgas
      pi = 4.0*ATan(1.)
      cwc0 = piinv ! 1./pi ! 6.0/pi
      
      cnoh = cnoh0t
      hwdn = hwdn1t

      rwdn = 1000.0
      swdn = 100.0

      qrmin = 1.0e-05
      qsmin = 1.0e-06
      qhmin = 1.0e-05

!
!  default slope intercepts
!
      cnow  = 1.0e+08
      cnoi  = 1.0e+08
      cnoip = 1.0e+08 
      cnoir = 1.0e+08 
      cnor  = 8.0e+06 
      cnos  = 8.0e+06 
      cnogl = 4.0e+05 
      cnogm = 4.0e+05 
      cnogh = 4.0e+05 
      cnof  = 4.0e+05
      cnohl = 1.0e+03


      imx = 1
      jmx = 1
      kmx = 1
      i = 1


       IF ( microp(1:4) .eq. 'ZIEG' ) THEN !  na .ge. 14 .and. ipconc .ge. 3 ) THEN 

!        write(0,*)  'Set reflectivity for ZIEG'
         izieg = 1

         hwdn = hwdn1t ! 500.


         cnor  = cno(lr)
         cnos  = cno(ls)
         cnoh  = cno(lh)
         qrmin = qxmin(lr)
         qsmin = qxmin(ls)
         qhmin = qxmin(lh)
         IF ( lhl .gt. 1 ) THEN
            cnohl  = cno(lhl)
            qhlmin = qxmin(lhl)
         ENDIF

       ELSEIF ( microp(1:3) .eq. 'ZVD' ) THEN !  na .ge. 14 .and. ipconc .ge. 3 ) THEN 

         izieg = 1
         
         swdn0 = swdn

         cnor  = cno(lr)
         cnos  = cno(ls)
         cnoh  = cno(lh)
         
         qrmin = qxmin(lr)
         qsmin = qxmin(ls)
         qhmin = qxmin(lh)
         IF ( lhl .gt. 1 ) THEN
            cnohl  = cno(lhl)
            qhlmin = qxmin(lhl)
         ENDIF
!         write(*,*) 'radardbz: ',db(1,1,1),temk(1,1,1),an(1,1,1,lr),an(1,1,1,ls),an(1,1,1,lh)


        ENDIF


!      cdx(lr) = 0.60
!      
!      IF ( lh > 1 ) THEN
!      cdx(lh) = 0.8 ! 1.0 ! 0.45
!      cdx(ls) = 2.00
!      ENDIF
!
!      IF ( lhl .gt. 1 ) cdx(lhl) = 0.45
!
!      xvmn(lc) = xvcmn
!      xvmn(lr) = xvrmn
!
!      xvmx(lc) = xvcmx
!      xvmx(lr) = xvrmx
!
!      IF ( lh > 1 ) THEN
!      xvmn(ls) = xvsmn
!      xvmn(lh) = xvhmn
!      xvmx(ls) = xvsmx
!      xvmx(lh) = xvhmx
!      ENDIF
!
!      IF ( lhl .gt. 1 ) THEN
!      xvmn(lhl) = xvhlmn
!      xvmx(lhl) = xvhlmx
!      ENDIF
!
!      xdnmx(lr) = 1000.0
!      xdnmx(lc) = 1000.0
!      IF ( lh > 1 ) THEN
!      xdnmx(li) =  917.0
!      xdnmx(ls) =  300.0
!      xdnmx(lh) =  900.0
!      ENDIF
!      IF ( lhl .gt. 1 ) xdnmx(lhl) = 900.0
!!
!      xdnmn(:) = 900.0
!      
!      xdnmn(lr) = 1000.0
!      xdnmn(lc) = 1000.0
!      IF ( lh > 1 ) THEN
!      xdnmn(li) =  100.0
!      xdnmn(ls) =  100.0
!      xdnmn(lh) =  hdnmn
!      ENDIF
!      IF ( lhl .gt. 1 ) xdnmn(lhl) = 500.0
!
!      xdn0(:) = 900.0
!      
!      xdn0(lc) = 1000.0
!      xdn0(lr) = 1000.0
!      IF ( lh > 1 ) THEN
!      xdn0(li) = 900.0
!      xdn0(ls) = 100.0 ! 100.0
!      xdn0(lh) = hwdn1t ! (0.5)*(xdnmn(lh)+xdnmx(lh))
!      ENDIF
!      IF ( lhl .gt. 1 ) xdn0(lhl) = 800.0

!
!  slope intercepts
!
!      cnow  = 1.0e+08
!      cnoi  = 1.0e+08
!      cnoip = 1.0e+08 
!      cnoir = 1.0e+08 
!      cnor  = 8.0e+06 
!      cnos  = 8.0e+06 
!      cnogl = 4.0e+05 
!      cnogm = 4.0e+05 
!      cnogh = 4.0e+05 
!      cnof  = 4.0e+05
!c      cnoh  = 4.0e+04
!      cnohl = 1.0e+03
!
!
!  density maximums and minimums
!
      rwdnmx = 1000.0
      cwdnmx = 1000.0
      cidnmx =  917.0
      xidnmx =  917.0
      swdnmx =  200.0
      gldnmx =  400.0
      gmdnmx =  600.0
      ghdnmx =  800.0
      fwdnmx =  900.0
      hwdnmx =  900.0
      hldnmx =  900.0
!
      rwdnmn = 1000.0
      cwdnmn = 1000.0
      xidnmn =  001.0
      cidnmn =  001.0
      swdnmn =  001.0
      gldnmn =  200.0
      gmdnmn =  400.0
      ghdnmn =  600.0
      fwdnmn =  700.0
      hwdnmn =  700.0
      hldnmn =  900.0

      
      gldn = (0.5)*(gldnmn+gldnmx)  ! 300.
      gmdn = (0.5)*(gmdnmn+gmdnmx)  ! 500.
      ghdn = (0.5)*(ghdnmn+ghdnmx)  ! 700.
      fwdn = (0.5)*(fwdnmn+fwdnmx)  ! 800.
      hldn = (0.5)*(hldnmn+hldnmx)  ! 900.


      cr1  = 7.2e+20
      cr2  = 7.295e+19
      hwdnsq = hwdn**2
      swdnsq = swdn**2
      rwdnsq = rwdn**2

      gldnsq = gldn**2
      gmdnsq = gmdn**2
      ghdnsq = ghdn**2
      fwdnsq = fwdn**2
      hldnsq = hldn**2
      
      dhmin = 0.005
      tfr   = 273.16
      tfrh  = tfr - 8.0
      zrc   = cr1*cnor
      reflectmin = 0.0
      kw_sq = 0.93
      dbzmax = dbzmin
      
      ihcnt=0

            
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  Dielectric Factor  - Formulas implemented by Svetla Veleva
!                       following Battan, "Radar Meteorology" - p. 40
!  The result of these calculations is that the dielf numerator (ki_sq) without
!  the density ratio is  .2116 for hail if using 917 density and .25 for
!  snow if using 220 density.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      const_ki_sn = 0.5 - (0.5-0.46)/(917.-220.)*(swdn-220.)
      const_ki_h  = 0.5 - (0.5-0.46)/(917.-220.)*(hwdn-220.)
      ki_sq_sn = (swdnsq/rwdnsq) * const_ki_sn**2
      ki_sq_h  = (hwdnsq/rwdnsq) * const_ki_h**2
      dielf_sn = ki_sq_sn / kw_sq
      dielf_h  = ki_sq_h  / kw_sq
            
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  Use the next line if you want to hardwire dielf for dry hail for both dry
!  snow and dry hail.
!  This would be equivalent to what Straka had originally. (i.e, .21/.93)
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      dielf_sn = (swdnsq/rwdnsq)*.21/ kw_sq
      dielf_h  = (hwdnsq/rwdnsq)*.21/ kw_sq

      dielf_gl  = (gldnsq/rwdnsq)*.21/ kw_sq
      dielf_gm  = (gmdnsq/rwdnsq)*.21/ kw_sq
      dielf_gh  = (ghdnsq/rwdnsq)*.21/ kw_sq
      dielf_hl  = (hldnsq/rwdnsq)*.21/ kw_sq
      dielf_fw  = (fwdnsq/rwdnsq)*.21/ kw_sq

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  Notes on dielectric factors  - from Eun-Kyoung Seo
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! constants for both snow and hail would be (x=s,h).....
!       xwdnsq/rwdnsq *0.21/kw_sq   ! Straka/Smith - the original
!       xwdnsq/rwdnsq *0.224        ! Ferrier - for particle sizes in equiv. drop diam
!       xwdnsq/rwdnsq *0.176/kw_sq  ! =0.189 in Smith - for particle sizes in equiv 
!                       ice spheres
!       xwdnsq/rwdnsq *0.208/kw_sq  ! Smith '84 - for particle sizes in equiv melted drop diameter
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


! VIL algorithm constants
!      Ztop = 10.**(56./10)           !56 dbz is the max rf used by WATADS in cell vil


! Hail detection algorithm constants
!      ZL = 40.
!      ZU = 50.
!      Ho = 3400.  !WATADS Defaults
!      Hm20 = 6200.      !WATADS Defaults

!      DO kz = 1,Min(nzdbz,nz-1)

      DO jy=1,1

        DO kz = 1,nz
         
          DO ix=1,nx
            dbz(ix,jy,kz) = 0.0
                      
          vzsnow = 0.0
          vzrain = 0.0
          vzgraupel = 0.0
          vzhail = 0.0
          
          dtmph = 0.0
          dtmps = 0.0
          dtmphl = 0.0
          dtmpr = 0.0
           dadr = (db(ix,jy,kz)/(pi*rwdn*cnor))**(0.25)
!-----------------------------------------------------------------------
! Compute Rain Radar Reflectivity
!-----------------------------------------------------------------------
           
           dtmp(ix,kz) = 0.0
           gtmp(ix,kz) = 0.0
           IF ( an(ix,jy,kz,lr) .ge. qrmin ) THEN
             IF ( ipconc .le. 2 ) THEN
               gtmp(ix,kz) = dadr*an(ix,jy,kz,lr)**(0.25)
               dtmp(ix,kz) = zrc*gtmp(ix,kz)**7
             ELSEIF ( an(ix,jy,kz,lnr) .gt. 1.e-3 ) THEN
               IF ( imurain == 3 ) THEN
                 vr = db(ix,jy,kz)*an(ix,jy,kz,lr)/(1000.*an(ix,jy,kz,lnr))
                 dtmp(ix,kz) = 3.6e18*(rnu+2.)*an(ix,jy,kz,lnr)*vr**2/(rnu+1.)
               ELSE ! imurain == 1
                g1 = (6.0 + alphar)*(5.0 + alphar)*(4.0 + alphar)/((3.0 + alphar)*(2.0 + alphar)*(1.0 + alphar))
                zx = g1*(db(ix,jy,kz)*an(ix,jy,kz,lr))**2/an(ix,jy,kz,lnr)
                ze =1.e18*zx*(6./(pi*1000.))**2 ! note: using 1000. here for water density
                dtmp(ix,kz) = ze
               ENDIF
             ENDIF
             dtmpr = dtmp(ix,kz)
           ENDIF
           
!-----------------------------------------------------------------------
! Compute snow and graupel reflectivity
!
! Lou modified to look at parcel temperature rather than base state
!-----------------------------------------------------------------------

          IF( lhab .gt. lr ) THEN

!    qs2d   = reform(data[*,*,k,10],[nx*ny])
!    qh2d   = reform(data[*,*,k,11],[nx*ny])

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! Only use the following lines if running Straka's GEMS microphysics
!  (Sam 1-d version modified by L Wicker does not use this)
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    ;xcnoh    = cnoh*exp(-0.025*(temp-tfr))
!    ;xcnos    = cnos*exp(-0.038*(temp-tfr))
!    ;good = where(temp GT tfr, n_elements)
!    ;IF n_elements NE 0 THEN xcnoh(good) = cnoh*exp(-0.075*(temp(good)-tfr))
!    ;IF n_elements NE 0 THEN xcnos(good) = cnos*exp(-0.088*(temp(good)-tfr))

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! Only use the following lines if running Ferrier micro with No=No(T)
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    ;  NOSE = -.15
!    ;  NOGE =  .0
!    ;  xcnoh = cnoh*(1.>exp(NOGE*(temp-tfr)) )
!    ;  xcnos = cnos*(1.>exp(NOSE*(temp-tfr)) )

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! Use the following lines if Nos and Noh are constant
!  (As in Svetla's version of Ferrier, GCE Tao, and SAM 1-d)
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        xcnoh    = cnoh
        xcnos    = cnos

!
! Temporary fix for predicted number concentration -- need a 
! more appropriate reflectivity equation!
!
!        IF ( an(ix,jy,kz,lns) .lt. 0.1 ) THEN
!         swdia = (xvrmn*cwc0)**(1./3.)
!         xcnos = an(ix,jy,kz,ls)*db(ix,jy,kz)/(xvrmn*swdn*swdia)
!        ELSE
!      ! changed back to diameter of mean volume!!!
!         swdia =
!     >  (an(ix,jy,kz,ls)*db(ix,jy,kz)
!     > /(pi*swdn*an(ix,jy,kz,lns)))**(1./3.)
!
!        xcnos = an(ix,jy,kz,lns)/swdia
!        ENDIF

        IF ( ls .gt. 1 ) THEN ! {
        
        IF ( lvs .gt. 1 ) THEN
          IF ( an(ix,jy,kz,lvs) .gt. 0.0 ) THEN
            swdn = db(ix,jy,kz)*an(ix,jy,kz,ls)/an(ix,jy,kz,lvs)
            swdn = Min( 300., Max( 100., swdn ) )
          ELSE 
            swdn = swdn0
          ENDIF
        
        ENDIF 
        
        IF ( ipconc .ge. 5 ) THEN ! {

        xvs = db(ix,jy,kz)*an(ix,jy,kz,ls)/  &
     &      (swdn*Max(1.0e-3,an(ix,jy,kz,lns)))
        IF ( xvs .lt. xvsmn .or. xvs .gt. xvsmx ) THEN
          xvs = Min( xvsmx, Max( xvsmn,xvs ) )
          csw = db(ix,jy,kz)*an(ix,jy,kz,ls)/(xvs*swdn)
        ENDIF

         swdia = (xvs*cwc0)**(1./3.)
         xcnos = an(ix,jy,kz,ls)*db(ix,jy,kz)/(xvs*swdn*swdia)
         
         ENDIF ! }
         ENDIF  ! }

!        IF ( an(ix,jy,kz,lnh) .lt. 0.1 ) THEN
!         hwdia = (xvrmn*cwc0)**(1./3.)
!         xcnoh = an(ix,jy,kz,lh)*db(ix,jy,kz)/(xvrmn*hwdn*hwdia)
!        ELSE
!      ! changed back to diameter of mean volume!!!
!         hwdia =
!     >  (an(ix,jy,kz,lh)*db(ix,jy,kz)
!     > /(pi*hwdn*an(ix,jy,kz,lnh)))**(1./3.)
!        
!         xcnoh = an(ix,jy,kz,lnh)/hwdia
!        ENDIF

        IF ( lh .gt. 1 ) THEN ! {

        IF ( lvh .gt. 1 ) THEN
          IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
            hwdn = db(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
            hwdn = Min( 900., Max( hdnmn, hwdn ) )
          ELSE 
            hwdn = 500. ! hwdn1t
          ENDIF
        ELSE
          hwdn = hwdn1t
        ENDIF 
        
        IF ( ipconc .ge. 5 ) THEN ! {

        xvh = db(ix,jy,kz)*an(ix,jy,kz,lh)/       &
     &      (hwdn*Max(1.0e-3,an(ix,jy,kz,lnh)))
        IF ( xvh .lt. xvhmn .or. xvh .gt. xvhmx ) THEN
          xvh = Min( xvhmx, Max( xvhmn,xvh ) )
          chw = db(ix,jy,kz)*an(ix,jy,kz,lh)/(xvh*hwdn)
        ENDIF

         hwdia = (xvh*cwc0)**(1./3.)
         xcnoh = an(ix,jy,kz,lh)*db(ix,jy,kz)/(xvh*hwdn*hwdia)
         
        ENDIF ! } ipconc .ge. 5
 
        ENDIF ! }

        dadh = 0.0
        dadhl = 0.0
        dads = 0.0
        IF ( xcnoh .gt. 0.0 ) THEN 
          dadh = ( db(ix,jy,kz) /(pi*hwdn*xcnoh) )**(.25)
          zhdryc = 0.224*cr2*(db(ix,jy,kz)/rwdn)**2/xcnoh ! dielf_h*cr1*xcnoh          ! SV - equiv formula as before but
                                        ! ratio of densities included in
                                        ! dielf_h rather than here following
                                        ! Battan.
        ELSE
          dadh = 0.0
          zhdryc = 0.0
        ENDIF
        
        IF ( xcnos .gt. 0.0 ) THEN
          dads = ( db(ix,jy,kz) /(pi*swdn*xcnos) )**(.25)
          zsdryc = 0.224*cr2*(db(ix,jy,kz)/rwdn)**2/xcnos ! dielf_sn*cr1*xcnos         ! SV - similar change as above
        ELSE
          dads = 0.0
          zsdryc = 0.0
        ENDIF
        zhwetc = zhdryc ! cr1*xcnoh      !Hail/graupel version with .95 power bug removed
        zswetc = zsdryc ! cr1*xcnos
!           
! snow contribution
!
          IF ( ls .gt. 1 ) THEN
          
          gtmp(ix,kz) = 0.0 
          qxw = 0.0 
          dtmps = 0.0
           IF ( an(ix,jy,kz,ls) .ge. qsmin ) THEN !{
            IF ( ipconc .ge. 4 ) THEN  ! (Ferrier 94) !{

             if (lsw .gt. 1) THEN 
               qxw = an(ix,jy,kz,lsw)
             ELSEIF ( iusewetsnow == 1 .and. temk(ix,jy,kz) .gt. tfr+1. .and. an(ix,jy,kz,ls) > an(ix,jy,kz,lr) &
     &              .and. an(ix,jy,kz,lr) > qsmin) THEN
               qxw = Min(0.5*an(ix,jy,kz,ls), an(ix,jy,kz,lr))
             ENDIF

             vr = xvs ! db(ix,jy,kz)*an(ix,jy,kz,lr)/(1000.*an(ix,jy,kz,lnr))
!             gtmp(ix,kz) = 3.6e18*(0.243*rhos**2/0.93)*(snu+2.)*an(ix,jy,kz,lns)*vr**2/(snu+1.)
             
             ksq = 0.189 ! Smith (1984, JAMC) for equiv. ice sphere
             IF ( an(ix,jy,kz,lns) .gt. 1.e-7 ) THEN
               IF ( qxw > qsmin ) THEN ! old version
!                gtmp(ix,kz) = 3.6e18*(snu+2.)*( 0.224*an(ix,jy,kz,ls) + 0.776*qxw)*an(ix,jy,kz,ls)/ &
!     &              (an(ix,jy,kz,lns)*(snu+1.)*rwdn**2)*db(ix,jy,kz)**2
                gtmp(ix,kz) = 3.6e18*(snu+2.)*( 0.224*(an(ix,jy,kz,ls)+qxw) + 0.776*qxw)*(an(ix,jy,kz,ls)+qxw)/ &
     &              (an(ix,jy,kz,lns)*(snu+1.)*rwdn**2)*db(ix,jy,kz)**2

               ELSE ! new form using a mass relationship m = p d^2 (instead of d^3 -- Cox 1988 QJRMS) so that density depends on size
                    ! p = 1.06214 for m = p v^(2/3)
                 gtmp(ix,kz) = 1.e18* 1.06214**2*(ksq*an(ix,jy,kz,ls) + (1.-ksq)*qxw)*an(ix,jy,kz,ls)*db(ix,jy,kz)**2*gsnow1* gsnow73/    &
     &                   (an(ix,jy,kz,lns)*(917.)**2* gsnow53**2)
               ENDIF
             
             ENDIF
             
!             tmp = Min(1.0,1.e3*(an(ix,jy,kz,ls))*db(ix,jy,kz))
!             gtmp(ix,kz) = Max( 1.0*gtmp(ix,kz), 750.0*(tmp)**1.98)
             dtmps = gtmp(ix,kz)
             dtmp(ix,kz) = dtmp(ix,kz) + gtmp(ix,kz)
            ELSE
             gtmp(ix,kz) = dads*an(ix,jy,kz,ls)**(0.25)
             
             IF ( gtmp(ix,kz) .gt. 0.0 ) THEN !{
             dtmps = zsdryc*an(ix,jy,kz,ls)**2/gtmp(ix,kz)
             IF ( temk(ix,jy,kz) .lt. tfr ) THEN
               dtmp(ix,kz) = dtmp(ix,kz) +          &
     &                   zsdryc*an(ix,jy,kz,ls)**2/gtmp(ix,kz)
             ELSE
               dtmp(ix,kz) = dtmp(ix,kz) +          &
     &                  zswetc*an(ix,jy,kz,ls)**2/gtmp(ix,kz)
             ENDIF
             ENDIF !}
            ENDIF !}
           
           ENDIF !}
           
           ENDIF


!
! ice crystal contribution (Heymsfield, 1977, JAS)
!
         IF ( li .gt. 1 .and. idbzci .ne. 0 ) THEN
          
          gtmp(ix,kz) = 0.0 
           IF ( an(ix,jy,kz,li) .ge. 0.1e-3 ) THEN
             gtmp(ix,kz) = Min(1.0,1.e3*(an(ix,jy,kz,li))*db(ix,jy,kz))
             dtmp(ix,kz) = dtmp(ix,kz) + 750.0*(gtmp(ix,kz))**1.98
           ENDIF
           
          ENDIF
          
!           
! graupel/hail contribution
!
         IF ( lh .gt. 1 ) THEN ! {
           gtmp(ix,kz) = 0.0 
           dtmph = 0.0
           qxw = 0.0

          IF ( izieg .ge. 1 .and. ipconc .ge. 5 ) THEN

           ltest = .false.
           
           IF ( ltest .or. (an(ix,jy,kz,lh) .ge. qhmin .and. an(ix,jy,kz,lnh) .gt. 1.e-6 )) THEN
            
            IF ( lvh .gt. 1 ) THEN
             
             IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
               hwdn = db(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
               hwdn = Min( 900., Max( 100., hwdn ) )
              ELSE 
               hwdn = 500. ! hwdn1t
              ENDIF

             ENDIF

             chw = an(ix,jy,kz,lnh)
            IF ( chw .gt. 0.0 ) THEN                                         ! (Ferrier 94)
             xvh = db(ix,jy,kz)*an(ix,jy,kz,lh)/(hwdn*Max(1.0e-3,chw))
             IF ( xvh .lt. xvhmn .or. xvh .gt. xvhmx ) THEN
              xvh = Min( xvhmx, Max( xvhmn,xvh ) )
              chw = db(ix,jy,kz)*an(ix,jy,kz,lh)/(xvh*hwdn)
             ENDIF
             
             qh = an(ix,jy,kz,lh)
             
             IF ( lhw .gt. 1 ) THEN
               IF ( iusewetgraupel .eq. 1 ) THEN
                  qxw = an(ix,jy,kz,lhw)
               ELSEIF ( iusewetgraupel .eq. 2 ) THEN
                  IF ( hwdn .lt. 300. ) THEN
                    qxw = an(ix,jy,kz,lhw)
                  ENDIF
               ENDIF
             ELSEIF ( iusewetgraupel .eq. 3 ) THEN
                  IF ( hwdn .lt. 300. .and. temk(ix,jy,kz) > tfr .and. an(ix,jy,kz,lr) > qhmin ) THEN
                    qxw = Min( an(ix,jy,kz,lh), an(ix,jy,kz,lr))
                    qh = qh + qxw
                  ENDIF
             ELSEIF ( iusewetgraupel == 4 .and. temk(ix,jy,kz) .gt. tfr+0.25 .and. an(ix,jy,kz,lh) > an(ix,jy,kz,lr) &
     &              .and. an(ix,jy,kz,lr) > qhmin) THEN
               qxw = Min(0.5*an(ix,jy,kz,lh), an(ix,jy,kz,lr))
               qh = qh + qxw

             ENDIF
             
             IF ( lzh .gt. 1 ) THEN
             ELSE
             g1 = (6.0 + alphah)*(5.0 + alphah)*(4.0 + alphah)/((3.0 + alphah)*(2.0 + alphah)*(1.0 + alphah))
!             zx = g1*(db(ix,jy,kz)*an(ix,jy,kz,lh))**2/chw
!             ze = 0.224*1.e18*zx*(6./(pi*1000.))**2
             zx = g1*db(ix,jy,kz)**2*( 0.224*qh + 0.776*qxw)*qh/chw
             ze =1.e18*zx*(6./(pi*1000.))**2
             dtmp(ix,kz) = dtmp(ix,kz) + ze
             dtmph = ze
             ENDIF
             
            ENDIF
             
        !     IF ( an(ix,jy,kz,lh) .gt. 1.0e-3 ) write(0,*)  'Graupel Z : ',dtmph,ze
           ENDIF
          
          ELSE
          
          dtmph = 0.0
          
           IF ( an(ix,jy,kz,lh) .ge. qhmin ) THEN
             gtmp(ix,kz) = dadh*an(ix,jy,kz,lh)**(0.25)
             IF ( gtmp(ix,kz) .gt. 0.0 ) THEN
             dtmph =  zhdryc*an(ix,jy,kz,lh)**2/gtmp(ix,kz)
             IF ( temk(ix,jy,kz) .lt. tfr ) THEN
               dtmp(ix,kz) = dtmp(ix,kz) +                   &
     &                  zhdryc*an(ix,jy,kz,lh)**2/gtmp(ix,kz)
             ELSE
!               IF ( hwdn .gt. 700.0 ) THEN
                 dtmp(ix,kz) = dtmp(ix,kz) +                   &
     &                  zhdryc*an(ix,jy,kz,lh)**2/gtmp(ix,kz)
! 
!     &                               (zhwetc*gtmp(ix,kz)**7)**0.95
!               ELSE
!                 dtmp(ix,kz) = dtmp(ix,kz) + zhwetc*gtmp(ix,kz)**7
!               ENDIF
             ENDIF
             ENDIF
           ENDIF
          
         
          
          ENDIF
 

          ENDIF ! }
          
          ENDIF ! na .gt. 5

        
        IF ( izieg .ge. 1 .and. lhl .gt. 1 ) THEN

        hldn = 900.0
        gtmp(ix,kz) = 0.0
        dtmphl = 0.0
        qxw = 0.0
        

        IF ( lvhl .gt. 1 ) THEN
          IF ( an(ix,jy,kz,lvhl) .gt. 0.0 ) THEN
            hldn = db(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
            hldn = Min( 900., Max( 300., hldn ) )
          ELSE 
            hldn = 900. 
          ENDIF
        ELSE
          hldn = rho_qhl
        ENDIF 


        IF ( ipconc .ge. 5 ) THEN

           ltest = .false.

          IF ( ltest .or. ( an(ix,jy,kz,lhl) .ge. qhlmin .and. an(ix,jy,kz,lnhl) .gt. 0.) ) THEN !{
            chl = an(ix,jy,kz,lnhl)
            IF ( chl .gt. 0.0 ) THEN !{
             xvhl = db(ix,jy,kz)*an(ix,jy,kz,lhl)/         &
     &        (hldn*Max(1.0e-9,an(ix,jy,kz,lnhl)))
            IF ( xvhl .lt. xvhlmn .or. xvhl .gt. xvhlmx ) THEN ! {
              xvhl = Min( xvhlmx, Max( xvhlmn,xvhl ) )
              chl = db(ix,jy,kz)*an(ix,jy,kz,lhl)/(xvhl*hldn)
              an(ix,jy,kz,lnhl) = chl
            ENDIF ! }

             IF ( lhlw .gt. 1 ) THEN
               IF ( iusewethail .eq. 1 ) THEN
                  qxw = an(ix,jy,kz,lhlw)
               ELSEIF ( iusewethail .eq. 2 ) THEN
                  IF ( hldn .lt. 300. ) THEN
                    qxw = an(ix,jy,kz,lhlw)
                  ENDIF
               ENDIF
             ENDIF
            
             IF ( lzhl .gt. 1 ) THEN !{
             ELSE !}

             g1 = (6.0 + alphahl)*(5.0 + alphahl)*(4.0 + alphahl)/((3.0 + alphahl)*(2.0 + alphahl)*(1.0 + alphahl))
             zx = g1*db(ix,jy,kz)**2*( 0.224*an(ix,jy,kz,lhl) + 0.776*qxw)*an(ix,jy,kz,lhl)/chl
!             zx = g1*(db(ix,jy,kz)*an(ix,jy,kz,lhl))**2/chl
             ze = 0.224*1.e18*zx*(6./(pi*1000.))**2
             dtmp(ix,kz) = dtmp(ix,kz) + ze
             dtmphl = ze
             
             ENDIF !}
            ENDIF!}
        !     IF ( an(ix,jy,kz,lh) .gt. 1.0e-3 ) write(0,*)  'Graupel Z : ',dtmph,ze
           ENDIF

          
          ELSE
          
          
           IF ( an(ix,jy,kz,lhl) .ge. qhlmin ) THEN ! {
            dadhl = ( db(ix,jy,kz) /(pi*hldn*cnohl) )**(.25)
             gtmp(ix,kz) = dadhl*an(ix,jy,kz,lhl)**(0.25)
             IF ( gtmp(ix,kz) .gt. 0.0 ) THEN ! {

              zhldryc = 0.224*cr2*( db(ix,jy,kz)/rwdn)**2/cnohl 

             dtmphl =  zhldryc*an(ix,jy,kz,lhl)**2/gtmp(ix,kz)

             IF ( temk(ix,jy,kz) .lt. tfr ) THEN
               dtmp(ix,kz) = dtmp(ix,kz) +                   &
     &                  zhldryc*an(ix,jy,kz,lhl)**2/gtmp(ix,kz)
             ELSE
!               IF ( hwdn .gt. 700.0 ) THEN
                 dtmp(ix,kz) = dtmp(ix,kz) +                   &
     &                  zhldryc*an(ix,jy,kz,lhl)**2/gtmp(ix,kz)
! 
!     :                               (zhwetc*gtmp(ix,kz)**7)**0.95
!               ELSE
!                 dtmp(ix,kz) = dtmp(ix,kz) + zhwetc*gtmp(ix,kz)**7
!               ENDIF
             ENDIF
             ENDIF ! }
           
           ENDIF ! }
          
         ENDIF ! ipconc .ge. 5


        ENDIF ! izieg .ge. 1 .and. lhl .gt. 1 

          
           
          IF ( dtmp(ix,kz) .gt. 0.0 ) THEN
            dbz(ix,jy,kz) = Max(dbzmin, 10.0*Log10(dtmp(ix,kz)) )
            
            IF ( dbz(ix,jy,kz) .gt. dbzmax ) THEN
              dbzmax = Max(dbzmax,dbz(ix,jy,kz))
              imx = ix
              jmx = jy
              kmx = kz
            ENDIF
          ELSE 
             dbz(ix,jy,kz) = dbzmin
             IF ( lh > 1 .and. lhl > 1) THEN
               IF ( an(ix,jy,kz,lh) > 1.0e-3 ) THEN
                 write(0,*) 'radardbz: qr,qh,qhl = ',an(ix,jy,kz,lr), an(ix,jy,kz,lh),an(ix,jy,kz,lhl)
                 write(0,*) 'radardbz: dtmps,dtmph,dadh,dadhl,dtmphl = ',dtmps,dtmph,dadh,dadhl,dtmphl
                 
                 IF ( lzh>1 .and. lzhl>1 ) write(0,*) 'radardbz: zh, zhl = ',an(ix,jy,kz,lzh),an(ix,jy,kz,lzhl)
               ENDIF
             ENDIF
          ENDIF

!         IF ( an(ix,jy,kz,lh) .gt. 1.e-4 .and. 
!     &        dbz(ix,jy,kz) .le. 0.0 ) THEN
!          write(0,*) 'dbz = ',dbz(ix,jy,kz)
!          write(0,*) 'Hail intercept: ',xcnoh,ix,kz
!          write(0,*) 'Hail,snow q: ',an(ix,jy,kz,lh),an(ix,jy,kz,ls)
!          write(0,*) 'Hail,snow c: ',an(ix,jy,kz,lnh),an(ix,jy,kz,lns)
!          write(0,*) 'dtmps,dtmph = ',dtmps,dtmph
!         ENDIF
        IF ( .not. dtmp(ix,kz) .lt. 1.e30 .or. dbz(ix,jy,kz) > 190.0 ) THEN
!        IF ( ix == 31 .and. kz == 20 .and. jy == 23 ) THEN
!          write(0,*) 'my_rank = ',my_rank
          write(0,*) 'ix,jy,kz = ',ix,jy,kz
          write(0,*) 'dbz = ',dbz(ix,jy,kz)
          write(0,*) 'db, zhdryc = ',db(ix,jy,kz),zhdryc
          write(0,*) 'Hail intercept: ',xcnoh,ix,kz
          write(0,*) 'Hail,snow q: ',an(ix,jy,kz,lh),an(ix,jy,kz,ls)
          write(0,*) 'graupel density hwdn = ',hwdn
          write(0,*) 'rain q: ',an(ix,jy,kz,lr)
          write(0,*) 'ice q: ',an(ix,jy,kz,li)
          IF ( lhl .gt. 1 ) write(0,*) 'Hail (lhl): ',an(ix,jy,kz,lhl)
          IF (ipconc .ge. 3 ) write(0,*) 'rain c: ',an(ix,jy,kz,lnr)
          IF ( lzr > 1 ) write(0,*) 'rain Z: ',an(ix,jy,kz,lzr)
          IF ( ipconc .ge. 5 ) THEN
          write(0,*) 'Hail,snow c: ',an(ix,jy,kz,lnh),an(ix,jy,kz,lns)
          IF ( lhl .gt. 1 ) write(0,*) 'Hail (lnhl): ',an(ix,jy,kz,lnhl)
          IF ( lzhl .gt. 1 ) THEN 
            write(0,*) 'Hail (lzhl): ',an(ix,jy,kz,lzhl)
            write(0,*) 'chl,xvhl,dhl = ',chl,xvhl,(xvhl*6./3.14159)**(1./3.)
            write(0,*) 'xvhlmn,xvhlmx = ',xvhlmn,xvhlmx
          ENDIF
          ENDIF
          write(0,*) 'chw,xvh = ', chw,xvh
          write(0,*) 'dtmps,dtmph,dadh,dadhl,dtmphl = ',dtmps,dtmph,dadh,dadhl,dtmphl
          write(0,*) 'dtmpr = ',dtmpr
          write(0,*) 'gtmp = ',gtmp(ix,kz),dtmp(ix,kz)
          IF ( .not. (dbz(ix,jy,kz) .gt. -100 .and. dbz(ix,jy,kz) .lt. 200 ) ) THEN
            write(0,*) 'dbz out of bounds! STOP!'
!            STOP
          ENDIF
         ENDIF

           
          ENDDO ! ix
         ENDDO ! kz
      ENDDO ! jy
            
      
      
      
!      write(0,*)  'na,lr = ',na,lr
      IF ( printyn .eq. 1 ) THEN
!      IF ( dbzmax .gt. dbzmin ) THEN
        write(iunit,*) 'maxdbz,ijk = ',dbzmax,imx,jmx,kmx
        write(iunit,*) 'qrw = ',an(imx,jmx,kmx,lr)
        
        IF ( lh .gt. 1 ) THEN
          write(iunit,*) 'qi  = ',an(imx,jmx,kmx,li)
          write(iunit,*) 'qsw = ',an(imx,jmx,kmx,ls)
          write(iunit,*) 'qhw = ',an(imx,jmx,kmx,lh)
          IF ( lhl .gt. 1 ) write(iunit,*) 'qhl = ',an(imx,jmx,kmx,lhl)
        ENDIF

      
      ENDIF
      
      
      RETURN
      END subroutine radardd02
      

! ##############################################################################
! ##############################################################################


! #####################################################################
! #####################################################################
!
! Subroutine for explicit cloud condensation and droplet nucleation
!
   SUBROUTINE NUCOND    &
     &  (nx,ny,nz,na,jyslab & 
     &  ,nor,norz,dtp & 
     &  ,dz3d & 
     &  ,t0,t9 & 
     &  ,an,dn,p2 & 
     &  ,pn,w & 
     &  ,axtra,io_flag &
     &  ,ssfilt,t00,t77,flag_qndrop  &
     & )


   implicit none

      integer :: nx,ny,nz,na
      integer :: nor,norz, jyslab ! ,nht,ngt,igsr
      real    :: dtp  ! time step
      logical :: flag_qndrop

      integer, parameter :: ng1 = 1


!
! external temporary arrays
!
      real t00(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t77(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

      real t0(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t1(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t3(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t4(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t5(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t6(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t7(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real t8(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real t9(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      

      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)  ! perturbation Pi
      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
!      real qv(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

      real ssfilt(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
      

      real pb(-norz+ng1:nz+norz)
      real pinit(-norz+ng1:nz+norz)

      real dz3d(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)

      
    ! local


      real axtra(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,nxtra)
      logical :: io_flag
      
      real :: dv

! 
!  declarations microphysics and for gather/scatter
!
      integer nxmpb,nzmpb,nxz
      integer mgs,ngs,numgs,inumgs
      parameter (ngs=500)
      integer ngscnt,igs(ngs),kgs(ngs)
      integer kgsp(ngs),kgsm(ngs)
      integer nsvcnt
      
      integer ix,kz,i,n, kp1
      integer :: jy, jgs
      integer ixb,ixe,jyb,jye,kzb,kze
    
      integer itile,jtile,ktile
      integer ixend,jyend,kzend,kzbeg
      integer nxend,nyend,nzend,nzbeg

!
! Variables for Ziegler warm rain microphysics
!      


      real ccnc(ngs), ccna(ngs), cnuc(ngs), cwnccn(ngs)
      real sscb  ! 'cloud base' SS threshold
      parameter ( sscb = 2.0 )
      integer idecss  ! flag to turn on (=1) decay of ssmax when no cloud or ice crystals
      parameter ( idecss = 1 )
      integer iba ! flag to do condensation/nucleation in 1st or 2nd loop
                  ! =0 to use ad to calculate SS
                  ! =1 to use an at end of main jy loop to calculate SS
      parameter (iba = 1)
      integer ifilt   ! =1 to filter ssat, =0 to set ssfilt=ssat
      parameter ( ifilt = 0 ) 
      real temp1,temp2 ! ,ssold
      real ssmax(ngs)       ! maximum SS experienced by a parcel
      real ssmx
      real dnnet,dqnet
!      real cnu,rnu,snu,cinu
!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
      real ventrx(ngs)
      real ventrxn(ngs)
      real volb, t2s
      real, parameter :: aa1 = 9.44e15, aa2 = 5.78e3  ! a1 in Ziegler

      real ec0, ex1, ft, rhoinv(ngs)
      
      real chw, g1, rd1

      real ac1,bc, taus, c1,d1,e1,f1,p380,tmp,tmp2 ! , sstdy, super
      real x,y,del,r,alpr
      double precision :: vent1,vent2
      real g1palp
      real bs
      real v1, v2
      real d1r, d1i, d1s, e1i
      integer nc ! condensation step
      real dtcon,dtcon1,dtcon2 ! condensation time step (dtcon*nc = dtp)
      real delta
      integer ltemq1,ltemq1m ! ,ltemq1m2
      real dqv,qv1,ss1,ss2,qvs1,dqvs,dtemp,dt1   ! temporaries for condensation

      real ssi1, ssi2, dqvi, dqvis, dqvii,qis1
      real dqvr, dqc, dqr, dqi, dqs
      real qv1m,qvs1m,ss1m,ssi1m,qis1m
      real cwmastmp 
      real  dcloud,dcloud2 ! ,as, bs
      real cn(ngs) 

      integer ltemq
      
      integer il

      real  es(ngs) ! ss(ngs),
!      real  eis(ngs)
      real ssf(ngs),ssfkp1(ngs),ssfkm1(ngs),ssat0(ngs)
      real ssfjp1(ngs),ssfjm1(ngs)
      real ssfip1(ngs),ssfim1(ngs)

      real supcb, supmx
      parameter (supcb=0.5,supmx=238.0)
      real r2dxm, r2dym, r2dzm
      real dssdz, dssdy, dssdx
!      real tqvcon
      real epsi,d
      parameter (epsi = 0.622, d = 0.266)
      real r1,qevap ! ,slv
      
      real vr,nrx,qr,z1,z2,rdi,alp,xnutmp,xnuc
      real ctmp, ccwtmp
      real f5, qvs0  ! Kessler condensation factor
      real    :: t0p1, t0p3
      real qvex
      
!      real, dimension(ngs) :: temp, tempc, elv, elf, els, pqs, theta, temg, temcg
      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
      real temp(ngs),tempc(ngs)
      real temg(ngs),temcg(ngs),theta(ngs),qvap(ngs) ! ,tembzg(ngs)
      real temgx(ngs),temcgx(ngs)
      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
      real felv(ngs),felf(ngs),fels(ngs)
      real felvcp(ngs),felvpi(ngs)
      real gamw(ngs),gams(ngs)   !   qciavl(ngs),
      real tsqr(ngs),ssi(ngs),ssw(ngs)
      real cc3(ngs),cqv1(ngs),cqv2(ngs)
      real qcwtmp(ngs),qtmp

      real fvent(ngs) !,fraci(ngs),fracl(ngs)
      real fwvdf(ngs),ftka(ngs),fthdf(ngs)
      real fadvisc(ngs),fakvisc(ngs)
      real fci(ngs),fcw(ngs)
      real fschm(ngs),fpndl(ngs)

      real pres(ngs),pipert(ngs)
      real pk(ngs)
      real rho0(ngs),pi0(ngs)
      real rhovt(ngs)
      real thetap(ngs),theta0(ngs),qwvp(ngs),qv0(ngs)
      real thsave(ngs)
      real qss0(ngs)
      real fcqv1(ngs)
      real wvel(ngs),wvelkm1(ngs)

      real wvdf(ngs),tka(ngs)
      real advisc(ngs)

      real rwvent(ngs)
      

      real :: qx(ngs,lv:lhab)
      real :: cx(ngs,lc:lhab)
      real :: xv(ngs,lc:lhab)
      real :: xmas(ngs,lc:lhab)
      real :: xdn(ngs,lc:lhab)
      real :: xdia(ngs,lc:lhab,3)
      real :: alpha(ngs,lc:lhab)
      real :: zx(ngs,lr:lhab)


      logical zerocx(lc:lqmx)

      integer, parameter :: iunit = 0
      
      real :: frac, hwdn, tmpg
      
      real :: cvm,cpm,rmm

      real, parameter :: rovcp = rd/cp
      real, parameter ::      cpv = 1885.0       ! specific heat of water vapor at constant pressure
      
      integer :: kstag
      
      integer :: count
      

! -------------------------------------------------------------------------------
      itile = nx
      jtile = ny
      ktile = nz
      ixend = nx
      jyend = ny
      kzend = nz
      nxend = nx + 1
      nyend = ny + 1
      nzend = nz
      kzbeg = 1
      nzbeg = 1

      f5 = 237.3 * 17.27 * 2.5e6 / cp ! combined constants for rain condensation (Soong and Ogura 73)

       jy = 1
       kstag = 0
       pb(:) = 0.0
       pinit(:) = 0.0
      
      IF ( ipconc <= 1 .or. isedonly == 2 ) GOTO 2200

!
!  Ziegler nucleation 
!

      ssfilt(:,:,:) = 0.0
      ssmx = 0
      count = 0

      do kz = 1,nz-kstag
        do ix = 1,nx

         temp1 = an(ix,jy,kz,lt)*t77(ix,jy,kz)
          t0(ix,jy,kz) = temp1
          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
         ltemq = Min( nqsat, Max(1,ltemq) )

          c1 = t00(ix,jy,kz)*tabqvs(ltemq)

          ssfilt(ix,jy,kz) = 100.*(an(ix,jy,kz,lv)/c1 - 1.0)  ! from "new" values


        ENDDO
      ENDDO


!
!     jy = 1 ! working on a 2d slab
!!  VERY IMPORTANT:  SET jgs = jy

      jgs = jy

!
!..Gather microphysics
!
      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: Gather stage'

      nxmpb = 1
      nzmpb = 1
      nxz = nx*nz
      numgs = nxz/ngs + 1


      do 2000 inumgs = 1,numgs

      ngscnt = 0


      kzb = nzmpb
      kze = nz-kstag
 !     if (kzbeg .le. nzmpb .and. kzend .gt. nzmpb) kzb = nzmpb

      ixb = nxmpb
      ixe = itile
!      if (ixbeg .le. nxmpb .and. ixend .gt. nxmpb) ixb = nxmpb

      do kz = kzb,kze
      do ix = nxmpb,nx

      pqs(1) = 380.0/(pn(ix,jy,kz) + pb(kz))
      theta(1) = an(ix,jy,kz,lt)
      temg(1) = t0(ix,jy,kz)

      temcg(1) = temg(1) - tfr
      ltemq = (temg(1)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )
      qvs(1) = pqs(1)*tabqvs(ltemq)
      qis(1) = pqs(1)*tabqis(ltemq)

      qss(1) = qvs(1)


      if ( temg(1) .lt. tfr ) then
      end if
!
      if ( (temg(1) .gt. tfrh ) .and.  &
     &   ( an(ix,jy,kz,lv)  .gt. qss(1) .or. &
     &     an(ix,jy,kz,lc)  .gt. qxmin(lc)   .or.  &
     &     ( an(ix,jy,kz,lr)  .gt. qxmin(lr) .and. rcond == 2 )  &
     &     )) then
      ngscnt = ngscnt + 1
      igs(ngscnt) = ix
      kgs(ngscnt) = kz
      if ( ngscnt .eq. ngs ) goto 2100
      end if

      end do  !ix

      nxmpb = 1
      end do  !kz
!      if ( jy .eq. (ny-jstag) ) iend = 1
 2100 continue

      if ( ngscnt .eq. 0 ) go to 29998

      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: dbg = 8'
      
!      write(0,*) 'NUCOND: dbg = 8, ngscnt,ssmx = ',ngscnt,ssmx

      
      qx(:,:) = 0.0
      cx(:,:) = 0.0

      xv(:,:) = 0.0
      xmas(:,:) = 0.0

      IF ( imurain == 1 ) THEN
        alpha(:,lr) = alphar
      ELSEIF ( imurain == 3 ) THEN
        alpha(:,lr) = xnu(lr)
      ENDIF

!
!  define temporaries for state variables to be used in calculations
!
      DO mgs = 1,ngscnt
      qx(mgs,lv) = an(igs(mgs),jy,kgs(mgs),lv)
       DO il = lc,lhab
        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0)
       ENDDO

       qcwtmp(mgs) = qx(mgs,lc)


      theta0(mgs) = an(igs(mgs),jy,kgs(mgs),lt) !
      thetap(mgs) = 0.0
      theta(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
      qv0(mgs) =  qx(mgs,lv)
      qwvp(mgs) = qx(mgs,lv) - qv0(mgs)

       pres(mgs) = pn(igs(mgs),jy,kgs(mgs)) + pb(kgs(mgs))
       pipert(mgs) = p2(igs(mgs),jy,kgs(mgs))
       rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
       rhoinv(mgs) = 1.0/rho0(mgs)
       rhovt(mgs) = Sqrt(rho00/rho0(mgs))
       pi0(mgs) = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs))
       temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
!       pk(mgs) = t77(igs(mgs),jy,kgs(mgs)) ! ( pres(mgs) / poo ) ** cap
       pk(mgs)   = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs)) ! t77(igs(mgs),jy,kgs(mgs))
       temcg(mgs) = temg(mgs) - tfr
       qss0(mgs) = (380.0)/(pres(mgs))
       pqs(mgs) = (380.0)/(pres(mgs))
       ltemq = (temg(mgs)-163.15)/fqsat+1.5
       ltemq = Min( nqsat, Max(1,ltemq) )
       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
       qis(mgs) = pqs(mgs)*tabqis(ltemq)
!
        qvap(mgs) = max( (qwvp(mgs) + qv0(mgs)), 0.0 )
        es(mgs) = 6.1078e2*tabqvs(ltemq)
        qss(mgs) = qvs(mgs)


        temgx(mgs) = min(temg(mgs),313.15)
        temgx(mgs) = max(temgx(mgs),233.15)
        felv(mgs) = 2500837.367 * (273.15/temgx(mgs))**((0.167)+(3.67e-4)*temgx(mgs))
!
        IF ( eqtset <= 1 ) THEN
          felvcp(mgs) = felv(mgs)*cpi
        ELSE ! equation set 2 in cm1
          tmp = qx(mgs,li)+qx(mgs,ls)+qx(mgs,lh)
          IF ( lhl > 1 ) tmp = tmp + qx(mgs,lhl)
          cvm = cv+cvv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
                                  +cpigb*(tmp)
          cpm = cp+cpv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
                                  +cpigb*(tmp)
          rmm=rd+rw*qx(mgs,lv)
          
          IF ( eqtset == 2 ) THEN

           felvcp(mgs) = (felv(mgs)-rw*temg(mgs))/cvm

          ELSE
            felvcp(mgs) = (felv(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
            felvpi(mgs) = pi0(mgs)*rovcp*(felv(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm
          ENDIF

        ENDIF

        temcgx(mgs) = min(temg(mgs),273.15)
        temcgx(mgs) = max(temcgx(mgs),223.15)
        temcgx(mgs) = temcgx(mgs)-273.15
        felf(mgs) = 333690.6098 + (2030.61425)*temcgx(mgs) - (10.46708312)*temcgx(mgs)**2
!
        fels(mgs) = felv(mgs) + felf(mgs)
        fcqv1(mgs) = 4098.0258*felv(mgs)*cpi

      wvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)* &
     &  (101325.0/(pb(kgs(mgs)) + pn(igs(mgs),jgs,kgs(mgs))))                            ! diffusivity of water vapor, Hall and Pruppacher (76)
      advisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* &
     &  (temg(mgs)/296.0)**(1.5)                         ! dynamic viscosity (SMT; see Beard & Pruppacher 71)
      tka(mgs) = tka0*advisc(mgs)/advisc1                 ! thermal conductivity


      ENDDO



!
! load concentrations
!
      if ( ipconc .ge. 1 ) then
       do mgs = 1,ngscnt
        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
       end do
      end if
      if ( ipconc .ge. 2 ) then
       do mgs = 1,ngscnt
        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
        cwnccn(mgs) = cwccn*rho0(mgs)/rho00
        cn(mgs) = 0.0
        IF ( lccn .gt. 1 ) THEN
          ccnc(mgs) = an(igs(mgs),jy,kgs(mgs),lccn)
        ELSE
          ccnc(mgs) = cwnccn(mgs)
        ENDIF
        IF ( lccna > 1 ) THEN
          ccna(mgs) = an(igs(mgs),jy,kgs(mgs),lccna)
        ELSE
          IF ( lccn > 1 ) THEN
            ccna(mgs) = cwnccn(mgs) - ccnc(mgs)
          ELSE
            ccna(mgs) = cx(mgs,lc) ! approximation of number of activated ccn
          ENDIF
        ENDIF
       end do
      end if
      if ( ipconc .ge. 3 ) then
       do mgs = 1,ngscnt
        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
       end do
      end if

!        cnuc(1:ngscnt) = cwccn*rho0(mgs)/rho00*(1. - renucfrac) + ccnc(1:ngscnt)*renucfrac
       DO mgs = 1,ngscnt
        cnuc(mgs) = Max(ccnc(mgs),cwnccn(mgs))*(1. - renucfrac) + ccnc(mgs)*renucfrac
       ENDDO

!  Set density
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: Set density'

      do mgs = 1,ngscnt
        xdn(mgs,lc) = xdn0(lc)
        xdn(mgs,lr) = xdn0(lr)
      end do

      ventrx(:) = ventr
      ventrxn(:) = ventrn
      


!       write(0,*) 'NUCOND: Set ssf variables, ssmxinit =',ssmxinit
      ssmx = 0.0
      DO mgs = 1,ngscnt
      
      kp1 = Min(nz, kgs(mgs)+1 )
      wvel(mgs) = (0.5)*(w(igs(mgs),jgs,kp1) & 
     &                  +w(igs(mgs),jgs,kgs(mgs)))
      wvelkm1(mgs) = (0.5)*(w(igs(mgs),jgs,kgs(mgs)) & 
     &                  +w(igs(mgs),jgs,Max(1,kgs(mgs)-1)))

      ssat0(mgs)  = ssfilt(igs(mgs),jgs,kgs(mgs))
      ssf(mgs)    = ssfilt(igs(mgs),jgs,kgs(mgs))
!      ssmx = Max( ssmx, ssf(mgs) )

      
      ssfkp1(mgs) = ssfilt(igs(mgs),jgs,Min(nz-1,kgs(mgs)+1))
      ssfkm1(mgs) = ssfilt(igs(mgs),jgs,Max(1,kgs(mgs)-1))


      ENDDO



!
!  cloud water variables
!

      if ( ndebug .gt. 0 )write(0,*) 'ICEZVD_DR: Set cloud water variables'

      do mgs = 1,ngscnt
      xv(mgs,lc) = 0.0
      IF ( ipconc .ge. 2 .and. cx(mgs,lc) .gt. 1.0e6 ) THEN
        xmas(mgs,lc) = &
     &    min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),cwmasn),cwmasx )
        xv(mgs,lc) = xmas(mgs,lc)/xdn(mgs,lc)
      ELSE
       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 0.01 ) THEN
        xmas(mgs,lc) = &
     &     min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),xdn(mgs,lc)*xvmn(lc)), &
     &      xdn(mgs,lc)*xvmx(lc) )

        cx(mgs,lc) = qx(mgs,lc)*rho0(mgs)/xmas(mgs,lc)

       ELSEIF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .le. 0.01 ) THEN
        xmas(mgs,lc) = xdn(mgs,lc)*4.*pi/3.*(5.0e-6)**3
        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)

       ELSE
        xmas(mgs,lc) = cwmasn
       ENDIF
      ENDIF
      xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**c1f3


      end do
!
! rain
!
      do mgs = 1,ngscnt
      if ( qx(mgs,lr) .gt. qxmin(lr) ) then

      if ( ipconc .ge. 3 ) then
        xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*Max(1.0e-9,cx(mgs,lr)))
!      parameter( xvmn(lr)=2.8866e-13, xvmx(lr)=4.1887e-9 )  ! mks
        IF ( xv(mgs,lr) .gt. xvmx(lr) ) THEN
          xv(mgs,lr) = xvmx(lr)
          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmx(lr)*xdn(mgs,lr))
        ELSEIF ( xv(mgs,lr) .lt. xvmn(lr) ) THEN
          xv(mgs,lr) = xvmn(lr)
          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmn(lr)*xdn(mgs,lr))
        ENDIF

        xmas(mgs,lr) = xv(mgs,lr)*xdn(mgs,lr)
        xdia(mgs,lr,3) = (xmas(mgs,lr)*cwc1)**(1./3.) ! xdia(mgs,lr,1)
        IF ( imurain == 3 ) THEN
!          xdia(mgs,lr,1) = (6.*pii*xv(mgs,lr)/(alpha(mgs,lr)+1.))**(1./3.)
          xdia(mgs,lr,1) = xdia(mgs,lr,3) ! formulae for Ziegler (1985) use mean volume diameter, not lambda**(-1)
        ELSE ! imurain == 1, Characteristic diameter (1/lambda)
          xdia(mgs,lr,1) = (6.*piinv*xv(mgs,lr)/((alpha(mgs,lr)+3.)*(alpha(mgs,lr)+2.)*(alpha(mgs,lr)+1.)))**(1./3.)
        ENDIF
!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)

! Inverse exponential version:
!        xdia(mgs,lr,1) =
!     >  (qx(mgs,lr)*rho0(mgs)
!     > /(pi*xdn(mgs,lr)*cx(mgs,lr)))**(0.333333)
      ELSE
        xdia(mgs,lr,1) = &
     &  (qx(mgs,lr)*rho0(mgs)/(pi*xdn(mgs,lr)*cno(lr)))**(0.25)
      end if
      else
        xdia(mgs,lr,1) = 1.e-9
!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)
      end if

      end do


!
!  Ventilation coefficients

      do mgs = 1,ngscnt


      fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* & 
     &  (temg(mgs)/296.0)**(1.5)

      fakvisc(mgs) = fadvisc(mgs)*rhoinv(mgs)

      fwvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)* & 
     &  (101325.0/(pres(mgs)))
      
      fschm(mgs) = (fakvisc(mgs)/fwvdf(mgs))

      fvent(mgs) = (fschm(mgs)**(1./3.)) * (fakvisc(mgs)**(-0.5))

      end do
!
!
!  Ziegler nucleation 
!
!
! cloud evaporation, condensation, and nucleation
!  sqsat -> qss(mgs)

      DO mgs=1,ngscnt
        dcloud = 0.0
        IF ( temg(mgs) .le. tfrh ) THEN
         CYCLE
        ENDIF

      IF( ssat0(mgs) .GT. 0. .OR. ssf(mgs) .GT. 0. ) GO TO 620
!6/4      IF( qvap(mgs) .EQ. qss(mgs) ) GO TO 631
!
!.... EVAPORATION. QV IS LESS THAN qss(mgs).
!.... EVAPORATE CLOUD FIRST
!
      IF ( qx(mgs,lc) .LE. 0. ) GO TO 631
!.... CLOUD EVAPORATION.
! convert input 'cp' to cgs
      R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felv(mgs)/ &
     &            (cp*(temg(mgs) - cbw)**2))
      QEVAP= Min( qx(mgs,lc), R1*(qss(mgs)-qvap(mgs)) )


      IF ( qx(mgs,lc) .LT. QEVAP ) THEN ! GO TO 63
        qwvp(mgs) = qwvp(mgs) + qx(mgs,lc)
        thetap(mgs) = thetap(mgs) - felv(mgs)*qx(mgs,lc)/(cp*pi0(mgs))
        IF ( io_flag .and. nxtra > 1 ) THEN
           axtra(igs(mgs),jy,kgs(mgs),1) = -qx(mgs,lc)/dtp
        ENDIF
        qx(mgs,lc) = 0.
        cx(mgs,lc) = 0.
      ELSE
        qwvp(mgs) = qwvp(mgs) + QEVAP
        qx(mgs,lc) = qx(mgs,lc) - QEVAP
        IF ( qx(mgs,lc) .le. 0. ) cx(mgs,lc) = 0.
        thetap(mgs) = thetap(mgs) - felv(mgs)*QEVAP/(CP*pi0(mgs))
        IF ( io_flag .and. nxtra > 1 ) THEN
           axtra(igs(mgs),jy,kgs(mgs),1) = -QEVAP/dtp
        ENDIF

      ENDIF

      GO TO 631


  620 CONTINUE

!.... CLOUD CONDENSATION

        IF ( qx(mgs,lc) .GT. qxmin(lc) .and. cx(mgs,lc) .ge. 1. ) THEN



!       ac1 =  xdn(mgs,lc)*elv(kgs(mgs))**2*epsi/
!     :        (tka(kgs(mgs))*rw*temg(mgs)**2)
! took out xdn factor because it cancels later...
       ac1 =  felv(mgs)**2/(tka(mgs)*rw*temg(mgs)**2)


!       bc = xdn(mgs,lc)*rw*temg(mgs)/
!     :       (epsi*wvdf(kgs(mgs))*es(mgs))
! took out xdn factor because it cancels later...
       bc =   rw*temg(mgs)/(wvdf(mgs)*es(mgs))

!       bs = rho0(mgs)*((rd*temg(mgs)/(epsi*es(mgs)))+
!     :             (epsi*elv(kgs(mgs))**2/(pres(mgs)*temg(mgs)*cp)))

!       taus = Min(dtp, xdn(mgs,lc)*rho0(mgs)*(ac1+bc)/
!     :        (4*pi*0.89298*BS*0.5*xdia(mgs,lc,1)*cx(mgs,lc)*xdn(mgs,lc)))

!
      IF ( ssf(mgs) .gt. 0.0 .or. ssat0(mgs) .gt. 0.0 ) THEN
       IF ( ny .le. 2 ) THEN
!        write(0,*)  'undershoot: ',ssf(mgs),
!     :   ( (qx(mgs,lv) - dcloud)/c1 - 1.0)*100.
       ENDIF



       IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN

         IF ( xdia(mgs,lc,1) .le. 0.0 ) THEN
          xmas(mgs,lc) = cwmasn
          xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**c1f3
         ENDIF
        d1 = (1./(ac1 + bc))*4.0*pi*ventc &
     &        *0.5*xdia(mgs,lc,1)*cx(mgs,lc)*rhoinv(mgs)

       ELSE
         d1 = 0.0
       ENDIF

       IF ( rcond .eq. 2 .and. qx(mgs,lr) .gt. qxmin(lr) .and. cx(mgs,lr) > 1.e-9 ) THEN
          IF ( imurain == 3 ) THEN
           IF ( izwisventr == 1 ) THEN
            rwvent(mgs) = ventrx(mgs)*(1.6 + 124.9*(1.e-3*rho0(mgs)*qx(mgs,lr))**.2046)
           ELSE ! izwisventr = 2
!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
          rwvent(mgs) =   &
     &  (0.78*ventrx(mgs) + 0.308*ventrxn(mgs)*fvent(mgs)   &
     &   *Sqrt((ar*rhovt(mgs)))   &
     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
           ENDIF

          ELSE ! imurain == 1

           IF ( iferwisventr == 1 ) THEN
             alpr = Min(alpharmax,alpha(mgs,lr) )
!             alpr = alpha(mgs,lr)
             x =  1. + alpr

              tmp = 1 + alpr
              i = Int(dgami*(tmp))
              del = tmp - dgam*i
              g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

              tmp = 2.5 + alpr + 0.5*bx(lr)
              i = Int(dgami*(tmp))
              del = tmp - dgam*i
              y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp ! ratio of gamma functions

         vent1 = dble(xdia(mgs,lr,1))**(-2. - alpr)
         vent2 = dble(1./xdia(mgs,lr,1) + 0.5*fx(lr))**dble(2.5+alpr+0.5*bx(lr))
        
        
        rwvent(mgs) =    &
     &    0.78*x +    &
     &    0.308*fvent(mgs)*y*   &
     &            Sqrt(ax(lr)*rhovt(mgs))*(vent1/vent2)

           ELSEIF ( iferwisventr == 2 ) THEN
          
!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
            x =  1. + alpha(mgs,lr)

            rwvent(mgs) =   &
     &        (0.78*x + 0.308*ventrxn(mgs)*fvent(mgs)   &
     &         *Sqrt((ar*rhovt(mgs)))   &
     &         *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )

          
          ENDIF ! iferwisventr
          
       ENDIF ! imurain

       d1r = (1./(ac1 + bc))*4.0*pi*rwvent(mgs) & 
     &        *0.5*xdia(mgs,lr,1)*cx(mgs,lr)*rhoinv(mgs)
       ELSE
       d1r = 0.0
       ENDIF
       
       
       e1  = felvcp(mgs)/(pi0(mgs))
       f1 = pk(mgs) ! (pres(mgs)/poo)**cap

!
!  fifth trial to see what happens:
!
       ltemq = (temg(mgs)-163.15)/fqsat+1.5
       ltemq = Min( nqsat, Max(1,ltemq) )
       ltemq1 = ltemq
       temp1 = temg(mgs)
       p380 = 380.0/pres(mgs)

!       taus = Max( 0.05*dtp, Min(taus, 0.25*dtp ) )
!       nc = NInt(dtp/Min(1.0,0.5*taus))
!       dtcon = dtp/float(nc)
       ss1 = qx(mgs,lv)/qvs(mgs)
       ss2 = ss1
       temp2 = temp1
       qv1 = qx(mgs,lv)
       qvs1 = qvs(mgs)
       qis1 = qis(mgs)
       dt1 = 0.0


!          dtcon = Max(dtcon,0.2)
!          nc = Nint(dtp/dtcon)

       ltemq1 = ltemq
! want to start out with a small time step to handle the steep slope
! and fast changes, then can switch to a larger step (dtcon2) for the
! rest of the big time step.
! base the initial time step (dtcon1) on the slope (delta)
       IF ( Abs(ss1 - 1.0) .gt. 1.e-5 ) THEN
         delta = 0.5*(qv1-qvs1)/(d1*(ss1 - 1.0))
       ELSE
         delta = 0.1*dtp
       ENDIF
! delta is the extrapolated time to get halfway from qv1 to qvs1
! want at least 5 time steps to the halfway point, so multiply by 0.2
! for the initial time step
       dtcon1 = Min(0.05,0.2*delta)
       nc = Max(5,2*NInt( (dtp-4.0*dtcon1)/delta))
       dtcon2 = (dtp-4.0*dtcon1)/nc

       n = 1
       dt1 = 0.0
       nc = 0
       dqc = 0.0
       dqr = 0.0
       dqi = 0.0
       dqs = 0.0
       dqvii = 0.0
       dqvis = 0.0

       RK2c: DO WHILE ( dt1 .lt. dtp )
          nc = 0
          IF ( n .le. 4 ) THEN
            dtcon = dtcon1
          ELSE
            dtcon = dtcon2
          ENDIF
 609       dqv  = -(ss1 - 1.)*d1*dtcon
           dqvr = -(ss1 - 1.)*d1r*dtcon
            dtemp = -0.5*e1*f1*(dqv + dqvr)
!          write(0,*) 'RK2c dqv1 = ',dqv
! calculate midpoint values:
           ltemq1m = ltemq1 + Nint(dtemp*fqsat + 0.5)
           IF ( ltemq1m .lt. 1 .or. ltemq1m .gt. nqsat ) THEN
             write(0,*) 'STOP in nucond line 1192 '
             write(0,*) ' ltemq1m,icond = ',ltemq1m,icond
             write(0,*) ' dtemp,e1,f1,dqv,dqvr = ', dtemp,e1,f1,dqv,dqvr
             write(0,*) ' d1,d1r,dtcon,ss1 = ',d1,d1r,dtcon,ss1
             write(0,*) ' dqc, dqr = ',dqc,dqr
             write(0,*) ' qv,qc,qr = ',qx(mgs,lv)*1000.,qx(mgs,lc)*1000.,qx(mgs,lr)*1000.
             write(0,*) ' i, j, k = ',igs(mgs),jy,kgs(mgs)
             write(0,*) ' dtcon1,dtcon2,delta = ',dtcon1,dtcon2,delta
             write(0,*) ' nc,dtp = ',nc,dtp
             write(0,*) ' rwvent,xdia,crw,ccw = ', rwvent(mgs),xdia(mgs,lr,1),cx(mgs,lr),cx(mgs,lc)
             write(0,*) ' fvent,alphar = ',fvent(mgs),alpha(mgs,lr)
             write(0,*) ' xvr,xmasr,xdnr,cwc1 = ',xv(mgs,lr),xmas(mgs,lr),xdn(mgs,lr),cwc1
           ENDIF
            dqvs = dtemp*p380*dtabqvs(ltemq1m)
            qv1m = qv1 + dqv + dqvr
!          qv1mr = qv1r + dqvr

            qvs1m = qvs1 + dqvs
            ss1m = qv1m/qvs1m

    ! check for undersaturation when no ice is present, if so, then reduce time step
          IF ( ss1m .lt. 1.  .and. (dqvii + dqvis) .eq. 0.0 ) THEN
            dtcon = (0.5*dtcon)
            IF ( dtcon .ge. dtcon1 ) THEN
             GOTO 609
            ELSE
             EXIT
            ENDIF
          ENDIF
! calculate full step:
          dqv  = -(ss1m - 1.)*d1*dtcon
          dqvr = -(ss1m - 1.)*d1r*dtcon


!          write(0,*) 'RK2a dqv1m = ',dqv
          dtemp = -e1*f1*(dqv + dqvr)
          ltemq1 = ltemq1 + Nint(dtemp*fqsat + 0.5)
           IF ( ltemq1 .lt. 1 .or. ltemq1 .gt. nqsat ) THEN
             write(0,*) 'STOP in nucond line 1230 '
             write(0,*) ' ltemq1m,icond = ',ltemq1m,icond
             write(0,*) ' dtemp,e1,dqv,dqvr = ', dtemp,e1,dqv,dqvr
           ENDIF
          dqvs = dtemp*p380*dtabqvs(ltemq1)

          qv1 = qv1 + dqv + dqvr

          dqc = dqc - dqv
          dqr = dqr - dqvr

          qvs1 = qvs1 + dqvs
          ss1 = qv1/qvs1
          temp1 = temp1 + dtemp
          IF ( temp2 .eq. temp1 .or. ss2 .eq. ss1 .or.  &
     &           ss1 .eq. 1.00 .or.  &
     &      ( n .gt. 10 .and. ss1 .lt. 1.0005 ) ) THEN
!           write(0,*) 'RK2c break'
           EXIT
          ELSE
           ss2 = ss1
           temp2 = temp1
           dt1 = dt1 + dtcon
           n = n + 1
          ENDIF
       ENDDO RK2c


        dcloud = dqc ! qx(mgs,lv) - qv1
        thetap(mgs) = thetap(mgs) + e1*(DCLOUD + dqr)
        IF ( eqtset > 2 ) THEN
           pipert(mgs) = pipert(mgs) + felvpi(mgs)*(DCLOUD + dqr)
        ENDIF
        IF ( io_flag .and. nxtra > 1 ) THEN
           axtra(igs(mgs),jy,kgs(mgs),1) = DCLOUD/dtp
           axtra(igs(mgs),jy,kgs(mgs),2) = axtra(igs(mgs),jy,kgs(mgs),2) + dqr/dtp
        ENDIF
        qwvp(mgs) = qwvp(mgs) - (DCLOUD + dqr)
        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
        qx(mgs,lr) = qx(mgs,lr) + dqr
!        t9(igs(mgs),jy,kgs(mgs)) = t9(igs(mgs),jy,kgs(mgs)) + (DCLOUD + dqr)/dtp*felv(mgs)/(cp*pi0(mgs)) !* &
!!     &                 dx*dy*dz3d(igs(mgs),jy,kgs(mgs))


        theta(mgs) = thetap(mgs) + theta0(mgs)
        temg(mgs) = theta(mgs)*f1
        ltemq = (temg(mgs)-163.15)/fqsat+1.5
        ltemq = Min( nqsat, Max(1,ltemq) )
        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
!        es(mgs) = 6.1078e2*tabqvs(ltemq)

!

      ENDIF  ! dcloud .gt. 0.


      ELSE  ! qc .le. qxmin(lc)

!        IF ( ssf(mgs) .gt. 0.0 .and. .not. flag_qndrop ) THEN ! flag_qndrop turns off primary nucleation when using wrf-chem with progn=1
        IF ( ssf(mgs) .gt. 0.0 ) THEN ! .and.  ssmax(mgs) .lt. sscb ) THEN ! except that wrf-chem does not seem to initialize qc for activated aerosols, so keep this, after all

          IF ( iqcinit == 1 ) THEN

         qvs0   = 380.*exp(17.27*(temg(mgs)-273.)/(temg(mgs)- 36.))/pk(mgs)

         dcloud = Max(0.0, (qx(mgs,lv)-qvs0) / (1.+qvs0*f5/(temg(mgs)-36.)**2) )

          ELSEIF ( iqcinit == 3 ) THEN
              R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felvcp(mgs)/ & 
     &             ((temg(mgs) - cbw)**2))
            DCLOUD=R1*(qvap(mgs) - qvs(mgs))  ! KW model adjustment; 
                              ! this will put mass into qc if qv > sqsat exists
          
          ELSEIF ( iqcinit == 2 ) THEN
!              R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felv(mgs)/
!     :             (cp*(temg(mgs) - cbw)**2))
!            DCLOUD=R1*(qvap(mgs) - qvs(mgs))  ! KW model adjustment; 
                              ! this will put mass into qc if qv > sqsat exists
         ssmx = ssmxinit

          IF ( ssf(mgs) > ssmx ) THEN
           CALL QVEXCESS(ngs,mgs,qwvp,qv0,qx(1,lc),pres,thetap,theta0,dcloud, & 
     &      pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ssmx,pk,ngscnt)
          ELSE
            dcloud = 0.0
          ENDIF
         ENDIF
        ELSE
            dcloud = 0.0
        ENDIF

        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
        qwvp(mgs) = qwvp(mgs) - DCLOUD
        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
        IF ( io_flag .and. nxtra > 1 ) THEN
           axtra(igs(mgs),jy,kgs(mgs),1) = DCLOUD/dtp
        ENDIF
        theta(mgs) = thetap(mgs) + theta0(mgs)
        temg(mgs) = theta(mgs)*pk(mgs) !( pres(mgs) / poo ) ** cap
!        temg(mgs) = theta2temp( theta(mgs), pres(mgs) )
        ltemq = (temg(mgs)-163.15)/fqsat+1.5
        ltemq = Min( nqsat, Max(1,ltemq) )
        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
!        es(mgs) = 6.1078e2*tabqvs(ltemq)

!.... S. TWOMEY (1959)
! Note: get here if there is no previous cloud water and w > 0.
      cn(mgs) = 0.0
      
      IF ( ncdebug .ge. 1 ) THEN
        write(iunit,*) 'at 613: ',qx(mgs,lc),cx(mgs,lc),wvel(mgs),ssmax(mgs),kgs(mgs)
      ENDIF
      
      IF (  .not. flag_qndrop ) THEN ! { only calculate mass change when using wrf-chem

      
!      IF ( ssmax(mgs) .lt. sscb .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
      IF ( dcloud .gt. qxmin(lc) .and. wvel(mgs) > 0.0) THEN
!       CN(mgs) =   CCNE*wvel(mgs)**cnexp ! *Min(1.0,1./dtp) ! 0.3465
       CN(mgs) =   CCNE0*cnuc(mgs)**(2./(2.+cck))*wvel(mgs)**cnexp ! *Min(1.0,1./dtp) ! 0.3465
        IF ( ny .le. 2 .and. cn(mgs) .gt. 0.0    &
     &                    .and. ncdebug .ge. 1 ) THEN 
          write(iunit,*) 'CN: ',cn(mgs)*1.e-6, cx(mgs,lc)*1.e-6, qx(mgs,lc)*1.e3,   &
     &       wvel(mgs), dcloud*1.e3
          IF ( cn(mgs) .gt. 1.0 ) write(iunit,*) 'cwrad = ',   &
     &       1.e6*(rho0(mgs)*qx(mgs,lc)/cn(mgs)*cwc1)**c1f3,   &
     &   igs(mgs),kgs(mgs),temcg(mgs),    &
     &   1.e3*an(igs(mgs),jgs,kgs(mgs)-1,lc)
        ENDIF
        IF ( iccwflg .eq. 1 ) THEN
          cn(mgs) = Min(cwccn*rho0(mgs)/rho00, Max(cn(mgs),   &
     &       rho0(mgs)*qx(mgs,lc)/(xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3)))
        ENDIF
      ELSE
       cn(mgs) = 0.0
       dcloud = 0.0
!          cn(mgs) = Min(cwccn,    &
!     &       rho0(mgs)*dcloud/(xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3) )
      ENDIF

      IF ( cn(mgs) .gt. 0.0 ) THEN
       IF ( cn(mgs) .gt. ccnc(mgs) ) THEN
         cn(mgs) = ccnc(mgs)
!         ccnc(mgs) = 0.0
       ENDIF
!      cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
      ccna(mgs) = ccna(mgs) + cn(mgs)
      ENDIF

!       write(91,*) 'nuc1: cn, ix, kz = ',cn(mgs),igs(mgs),kgs(mgs),wvel(mgs),cnexp,ccnc(mgs)

      IF( CN(mgs) .GT. cx(mgs,lc) ) cx(mgs,lc) = CN(mgs)
      IF( cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .le. qxmin(lc) ) THEN
        cx(mgs,lc) = 0.
      ELSE
        cx(mgs,lc) = Min(cx(mgs,lc),rho0(mgs)*Max(0.0,qx(mgs,lc))/cwmasn)
      ENDIF
      
      ENDIF ! }.not. flag_qndrop

        GOTO 613
        
        END IF ! qc .gt. 0.

!        ES=EES(PIB(K)*PT)
!        SQSAT=EPSI*ES/(PB(K)*1000.-ES)

!.... CLOUD NUCLEATION
!      T=PIB(K)*PT
!      ES=1.E3*PB(K)*QV/EPSI

      IF ( wvel(mgs) .le. 0. ) GO TO 616
      IF ( cx(mgs,lc) .le. 0. )  GO TO 613                             !TWOMEY (1959) Nucleation
      IF ( kzbeg-1+kgs(mgs) .GT. 1 .and. qx(mgs,lc) .le. qxmin(lc)) GO TO 613  !TWOMEY (1959) Nucleation
      IF ( kzbeg-1+kgs(mgs) .eq. 1 .and. wvel(mgs) .gt. 0. ) GO TO 613         !TWOMEY (1959) Nucleation
!.... ATTEMPT ZIEGLER CLOUD NUCLEATION IN CLOUD INTERIOR UNLESS...
  616 IF ( ssf(mgs) .LE. SUPCB .AND. wvel(mgs) .GT. 0. ) GO TO 631 !... weakly saturated updraft
      IF ( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 .AND.  &
     &    (ssfkp1(mgs) .GE. SUPMX .OR. &
     &     ssf(mgs)    .GE. SUPMX .OR. &
     &     ssfkm1(mgs) .GE. SUPMX)) GO TO 631                      !... too much vapour
      IF (ssf(mgs) .LT. 1.E-10 .OR. ssf(mgs) .GE. SUPMX) GO TO 631 !... at the extremes for ss

!
! get here if ( qc > 0 and ss > supcb) or (w < 0)
!

      if (ndebug .gt. 0) write(0,*) "ICEZVD_DR: Entered Ziegler Cloud Nucleation" !mpidebug

      DSSDZ=0.
      r2dzm=0.50/dz3d(igs(mgs),jy,kgs(mgs))
      IF ( irenuc >= 0 .and. .not. flag_qndrop) THEN ! turn off nucleation when flag_qndrop (using WRF-CHEM for activation)

      IF ( irenuc /= 2 ) THEN !{

        IF ( kzend == nzend ) THEN
          t0p3 = t0(igs(mgs),jgs,Min(kze,kgs(mgs)+3))
          t0p1 = t0(igs(mgs),jgs,Min(kze,kgs(mgs)+1))
        ELSE
          t0p3 = t0(igs(mgs),jgs,kgs(mgs)+3)
          t0p1 = t0(igs(mgs),jgs,kgs(mgs)+1)
        ENDIF

      IF ( ( ssf(mgs) .gt. ssmax(mgs) .or.  irenuc .eq. 1 ) &
     &   .and.  ( ( lccn .lt. 1 .and.  &
     &            cx(mgs,lc) .lt. cwccn*(Min(1.0,rho0(mgs)))) .or. &
     &    ( lccn .gt. 1 .and. ccnc(mgs) .gt. 0. )   ) &
     &    ) THEN
      IF( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 &
     &  .and. ssf(mgs) .gt. 0.0 &
     &  .and. ssfkp1(mgs) .LT. SUPMX .and. ssfkp1(mgs) .ge. 0.0  &
     &  .AND. ssfkm1(mgs) .LT. SUPMX .AND. ssfkm1(mgs) .ge. 0.0  &
     &  .AND. ssfkp1(mgs) .gt. ssfkm1(mgs)  &
     &  .and. t0p3 .gt. 233.2) THEN
          DSSDZ = (ssfkp1(mgs) - ssfkm1(mgs))*R2DZM
!
! otherwise check for cloud base condition with updraft:
!
        ELSEIF( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 &
!        IF( kgs(mgs) .GT. 1 .AND. kgs(mgs) .LT. NZ-1 &
     &  .and. ssf(mgs) .gt. 0.0  .and. wvel(mgs) .gt. 0.0 &
     &  .and. ssfkp1(mgs) .gt. 0.0   &
     &  .AND. ssfkm1(mgs) .le. 0.0 .and. wvelkm1(mgs) .gt. 0.0 &
     &  .AND. ssf(mgs) .gt. ssfkm1(mgs)  &
     &  .and. t0p1 .gt. 233.2) THEN
         DSSDZ = 2.*(ssf(mgs) - ssfkm1(mgs))*R2DZM  ! 1-sided difference
        ENDIF

       ENDIF
!
!CLZ  IF(wijk.LE.0.) CN=CCN*ssfilt(ix,jy,kz)**CCK
! note: CCN -> cwccn, DELT -> dtp
      c1 = Max(0.0, rho0(mgs)*(qx(mgs,lv) - qss(mgs))/ &
     &        (xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3))
      IF ( lccn .lt. 1 ) THEN
       CN(mgs) = cwccn*rho0(mgs)/rho00*CCK*ssf(mgs)**CCKM*dtp*   &
     & Max(0.0,    &
     &         (wvel(mgs)*DSSDZ) )      ! probably the vertical gradient dominates
      ELSE
      CN(mgs) =  &
     &    Min(ccnc(mgs), cnuc(mgs)*CCK*ssf(mgs)**CCKM*dtp*   &
     & Max(0.0,    &
     &         ( wvel(mgs)*DSSDZ) )  )
!      IF ( cn(mgs) .gt. 0 ) ccnc(mgs) = ccnc(mgs) - cn(mgs)
      ENDIF

      IF ( cn(mgs) .gt. 0.0 ) THEN
       IF ( ccnc(mgs) .lt. 5.e7 .and. cn(mgs) .ge. 5.e7 ) THEN
          cn(mgs) = 5.e7
          ccnc(mgs) = 0.0
       ELSEIF ( cn(mgs) .gt. ccnc(mgs) ) THEN
         cn(mgs) = ccnc(mgs)
         ccnc(mgs) = 0.0
       ENDIF
      cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
      ENDIF

      ELSEIF ( irenuc == 2 ) THEN !} { 
      ! simple Twomey scheme
!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
       CN(mgs) =   CCNE0*cnuc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp ! *Min(1.0,1./dtp) ! 0.3465
!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
               ! Philips, Donner et al. 2007, but results in too much limitation of
               ! nucleation
       CN(mgs) = Min(cn(mgs), ccnc(mgs))
       cn(mgs) = Min(cn(mgs), 0.5*dqc/cwmasn) ! limit the nucleation mass to half of the condensation mass
       
       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
       
       ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
       
      ENDIF ! }

      ccna(mgs) = ccna(mgs) + cn(mgs)

      ENDIF ! irenuc >= 0 .and. .not. flag_qndrop

      IF( cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .LE. qxmin(lc)) cx(mgs,lc)=0.
      GO TO 631
!.... NUCLEATION ON CLOUD INFLOW BOUNDARY POINT

  613 CONTINUE

  631  CONTINUE

!
! Check for supersaturation greater than ssmx and adjust down
!
       ssmx = 1.9
       qv1 = qv0(mgs) + qwvp(mgs)
       qvs1 = qvs(mgs)
       
!       IF ( flag_qndrop .and. do_satadj_for_wrfchem ) ssmx = 1.04 ! set lower threshold for progn=1 when using WRF-CHEM

       IF ( qv1 .gt. (ssmx*qvs1) ) THEN
! use line below to disable saturation adjustment when flag_qndrop is true
!       IF ( qv1 .gt. (ssmx*qvs1) .and. .not. flag_qndrop ) THEN
        
         ss1 = qv1/qvs1

        ssmx = 100.*(ssmx - 1.0)
        
        qvex = 0.0

        CALL QVEXCESS(ngs,mgs,qwvp,qv0,qx(1,lc),pres,thetap,theta0,qvex,   &
     &    pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ssmx,pk,ngscnt)



        IF ( qvex .gt. 0.0 ) THEN
        thetap(mgs) = thetap(mgs) + felvcp(mgs)*qvex/(pi0(mgs))
        IF ( io_flag .and. nxtra > 1 ) THEN
           axtra(igs(mgs),jy,kgs(mgs),1) = axtra(igs(mgs),jy,kgs(mgs),1) + qvex/dtp
        ENDIF
        qwvp(mgs) = qwvp(mgs) - qvex
        qx(mgs,lc) = qx(mgs,lc) + qvex
        IF ( .not. flag_qndrop) THEN
        cn(mgs) = Min( Max(ccnc(mgs),cwnccn(mgs)), rho0(mgs)*qvex/Max( cwmasn5, xmas(mgs,lc) )  )
        ccnc(mgs) = Max( 0.0, ccnc(mgs) - cn(mgs) )
        cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
        ENDIF
        
!        write(iunit,*) 'theta = ',theta0(mgs) + thetap(mgs)

!        temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** cap

        ENDIF

       
       ENDIF

!
! Calculate droplet volume and check if it is within bounds.
!  Adjust if necessary
!  
!      if (ndebug .gt. 0) write(0,*) "ICEZVD_DR: check droplet volume" 


!      cx(mgs,lc) = Min( cwnccn(mgs), cx(mgs,lc) )
      IF( cx(mgs,lc) > cxmin .AND. qx(mgs,lc) .GT. qxmin(lc)) THEN
!        SVC(mgs) = rho0(mgs)*qx(mgs,lc)/(cx(mgs,lc)*xdn(mgs,lc))
        xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/(cx(mgs,lc))
        
       IF (  xmas(mgs,lc) < cwmasn .or.  xmas(mgs,lc) > cwmasx ) THEN
        xmas(mgs,lc) = Min( xmas(mgs,lc), cwmasx )
        xmas(mgs,lc) = Max( xmas(mgs,lc), cwmasn )
        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)
       ENDIF
      ENDIF


!      IF( cx(mgs,lc) .GT. 10.e6 .AND. qx(mgs,lc) .GT. qxmin(lc) ) GO TO 681
!        ccwtmp = cx(mgs,lc)
!        cwmastmp = xmas(mgs,lc)
!       xmas(mgs,lc) = Max(xmas(mgs,lc), cwmasn)
!       IF (qx(mgs,lc) .GT. qxmin(lc) .AND. cx(mgs,lc) .le. 0.) THEN
!          cx(mgs,lc) = Min(0.5*cwccn,rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc))
!          xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/cx(mgs,lc)
!       ENDIF
!      IF (cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .GT. qxmin(lc))    &
!     &        xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/cx(mgs,lc)
!      IF (qx(mgs,lc) .GT. qxmin(lc) .AND. xmas(mgs,lc) .LT. cwmasn)    &
!     &          xmas(mgs,lc) = cwmasn
!      IF (qx(mgs,lc) .GT. qxmin(lc) .AND. xmas(mgs,lc) .GT. cwmasx)    &
!     &    xmas(mgs,lc) = cwmasx
!      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
!        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/Max(cwmasn,xmas(mgs,lc))
!      ENDIF
!        
!
! 681  CONTINUE

        
      IF ( ipconc .ge. 3 .and. rcond == 2 ) THEN

        
        IF (cx(mgs,lr) .GT. 0. .AND. qx(mgs,lr) .GT. qxmin(lr))    &
     &       xv(mgs,lr)=rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
        IF (xv(mgs,lr) .GT. xvmx(lr)) xv(mgs,lr) = xvmx(lr)
        IF (xv(mgs,lr) .LT. xvmn(lr)) xv(mgs,lr) = xvmn(lr)

      ENDIF



      ENDDO ! mgs


! ################################################################
      DO mgs=1,ngscnt
      IF ( ssf(mgs) .gt. ssmax(mgs)    &
     &  .and. ( idecss .eq. 0 .or. qx(mgs,lc) .gt. qxmin(lc)) ) THEN
        ssmax(mgs) = ssf(mgs)
      ENDIF
      ENDDO
!

      do mgs = 1,ngscnt
      an(igs(mgs),jy,kgs(mgs),lt) = theta0(mgs) + thetap(mgs)
      an(igs(mgs),jy,kgs(mgs),lv) =  qv0(mgs) + qwvp(mgs)
!      tmp3d(igs(mgs),jy,kgs(mgs)) = tmp3d(igs(mgs),jy,kgs(mgs)) + t9(igs(mgs),jy,kgs(mgs)) !  pi0(mgs) ! wvdf(mgs) ! ssf(mgs) ! cn(mgs)
!
      IF ( eqtset > 2 ) THEN
        p2(igs(mgs),jy,kgs(mgs)) = pipert(mgs)
      ENDIF

       if ( ido(lc) .eq. 1 )  then
        an(igs(mgs),jy,kgs(mgs),lc) = qx(mgs,lc) +    &
     &    min( an(igs(mgs),jy,kgs(mgs),lc), 0.0 )
!        qx(mgs,lc) = an(igs(mgs),jy,kgs(mgs),lc)
       end if
!

       if ( ido(lr) .eq. 1 .and. rcond == 2 )  then
        an(igs(mgs),jy,kgs(mgs),lr) = qx(mgs,lr) +    &
     &    min( an(igs(mgs),jy,kgs(mgs),lr), 0.0 )
!        qx(mgs,lr) = an(igs(mgs),jy,kgs(mgs),lr)
       end if



       IF (  ipconc .ge. 2 ) THEN
        an(igs(mgs),jy,kgs(mgs),lnc) = Max(cx(mgs,lc) , 0.0)
        IF ( lccn .gt. 1 ) THEN
          an(igs(mgs),jy,kgs(mgs),lccn) = Max(0.0,  ccnc(mgs) )
        ENDIF
       ENDIF
       IF (  ipconc .ge. 3 .and. rcond == 2 ) THEN
        an(igs(mgs),jy,kgs(mgs),lnr) = Max(cx(mgs,lr) , 0.0)
       ENDIF
      end do


29998 continue


      if ( kz .gt. nz-1 .and. ix .ge. nx) then
        if ( ix .ge. nx ) then
         go to 2200 ! exit gather scatter
        else
         nzmpb = kz
        endif
      else
        nzmpb = kz
      end if

      if ( ix .ge. nx ) then
        nxmpb = 1
        nzmpb = kz+1
      else
       nxmpb = ix+1
      end if

 2000 continue ! inumgs
 2200 continue
!
!  end of gather scatter (for this jy slice)


!#ifdef COMMAS
!    GOTO 9999
!#endif

! Redistribute inappreciable cloud particles and charge
!
! Redistribution everywhere in the domain...
!
      frac = 1.0 ! 0.25 ! 1.0 ! 0.2
!
!  alternate test version for ipconc .ge. 3
!  just vaporize stuff to prevent noise in the number concentrations


      do kz = 1,nz
!      do jy = 1,1
      do ix = 1,nx
      
      zerocx(:) = .false.
      DO il = lc,lhab
       IF ( iresetmoments == 1 .or. iresetmoments == il ) THEN
        IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) < cxmin )
        IF ( lz(il) > 1 ) zerocx(il) = ( zerocx(il) .or. an(ix,jy,kz,lz(il)) < zxmin )
       ELSE
        IF ( il == lc ) THEN
          IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) <= 0 ) .and. .not. flag_qndrop ! don't reset if progn=1 (WRF-CHEM)
        ELSE
         IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) <= 0 )
        ENDIF
       ENDIF
      ENDDO

      IF ( lhl .gt. 1 ) THEN
      
      
      if ( an(ix,jy,kz,lhl) .lt. frac*qxmin(lhl) .or. zerocx(lhl) ) then

!        IF ( an(ix,jy,kz,lhl) .gt. 0 ) THEN
          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lhl)
          an(ix,jy,kz,lhl) = 0.0
!        ENDIF

        IF ( ipconc .ge. 5 ) THEN ! .and. an(ix,jy,kz,lnh) .gt. 0.0 ) THEN
          an(ix,jy,kz,lnhl) = 0.0
        ENDIF

        IF ( lvhl .gt. 1 ) THEN
           an(ix,jy,kz,lvhl) = 0.0
        ENDIF

        IF ( lhlw .gt. 1 ) THEN
           an(ix,jy,kz,lhlw) = 0.0
        ENDIF
      
        IF ( lzhl .gt. 1 ) THEN
           an(ix,jy,kz,lzhl) = 0.0
        ENDIF

      ELSE
       IF ( lvol(lhl) .gt. 1 ) THEN  ! check density
        IF ( an(ix,jy,kz,lvhl) .gt. 0.0 ) THEN
         tmp = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
        ELSE 
         tmp = 0.5*( xdnmn(lhl) + xdnmx(lhl) )
          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
        ENDIF

! DEBUG
!          tmp = 850.
!          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
!        IF ( an(ix,jy,kz,lhl) .gt. 1.0e-3 ) THEN
!          write(iunit,*) 'HAILdr: dn,q,c,v = ',tmp,an(ix,jy,kz,lhl)*1000.,
!     :       an(ix,jy,kz,lnhl), an(ix,jy,kz,lvhl)
!          write(iunit,*) 'lvhl = ',lvhl
!        ENDIF


        IF ( tmp .gt. xdnmx(lhl) .or. tmp .lt. xdnmn(lhl) ) THEN
          tmp = Min( xdnmx(lhl), Max( xdnmn(lhl) , tmp ) )
          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
        ENDIF
        
       ENDIF
       
       
!  CHECK INTERCEPT
       IF ( ipconc == 5 .and.  an(ix,jy,kz,lhl) .gt. qxmin(lhl) .and.  alphahl .le. 0.1 .and. lnhl .gt. 1 .and. lzhl == 0 ) THEN
       
         IF ( lvhl .gt. 1 ) THEN
           hwdn = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
         ELSE
           hwdn = xdn0(lhl)
         ENDIF
           tmp = (hwdn*an(ix,jy,kz,lnhl))/(dn(ix,jy,kz)*an(ix,jy,kz,lhl))
           tmpg = an(ix,jy,kz,lnhl)*(tmp*(3.14159))**(1./3.)
           IF ( tmpg .lt. cnohlmn ) THEN
             tmp = ( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lhl))*(3.14159))**(1./3.)
              an(ix,jy,kz,lnhl) = (cnohlmn/tmp)**(3./4.)
           ENDIF
       
       ENDIF
!      ELSE  ! check mean size here?

      end if



      ENDIF !lhl


      if ( an(ix,jy,kz,lh) .lt. frac*qxmin(lh) .or. zerocx(lh) ) then

!        IF ( an(ix,jy,kz,lh) .gt. 0 ) THEN
          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lh)
          an(ix,jy,kz,lh) = 0.0
!        ENDIF

        IF ( ipconc .ge. 5 ) THEN ! .and. an(ix,jy,kz,lnh) .gt. 0.0 ) THEN
          an(ix,jy,kz,lnh) = 0.0
        ENDIF

        IF ( lvh .gt. 1 ) THEN
           an(ix,jy,kz,lvh) = 0.0
        ENDIF
      
        IF ( lhw .gt. 1 ) THEN
           an(ix,jy,kz,lhw) = 0.0
        ENDIF
      
        IF ( lzh .gt. 1 ) THEN
           an(ix,jy,kz,lzh) = 0.0
        ENDIF

      ELSE
       IF ( lvol(lh) .gt. 1 ) THEN  ! check density
        IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
         tmp = dn(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
        ELSE
         tmp = rho_qh
          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
        ENDIF

        IF (  tmp .lt. xdnmn(lh) ) THEN
          tmp = Max( xdnmn(lh), tmp )
          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
        ENDIF

        IF ( tmp .gt. xdnmx(lh) .and. lhw .le. 0 ) THEN ! no liquid allowed on graupel
          tmp = Min( xdnmx(lh), tmp )
          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
        ELSEIF ( tmp .gt. xdnmx(lh) .and. lhw .gt. 1 ) THEN  ! allow for liquid on graupel
          IF ( tmp .gt. xdnmx(lh) .and. an(ix,jy,kz,lhw) .lt. qxmin(lh) ) THEN
            tmp = Min( xdnmx(lh), tmp )
            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
          ELSEIF ( tmp .gt. xdnmx(lr) ) THEN
            tmp =  xdnmn(lr)
            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
          ENDIF
        ENDIF

        IF ( lhw .gt. 1 ) THEN ! check if basically pure water
          IF ( an(ix,jy,kz,lhw) .gt. 0.98*an(ix,jy,kz,lh) ) THEN
           tmp = xdnmx(lr)
           an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
          ENDIF
        ENDIF
        
       ENDIF

!  CHECK INTERCEPT
       IF ( ipconc == 5 .and.  an(ix,jy,kz,lh) .gt. qxmin(lh) .and.  alphah .le. 0.1 .and. lnh .gt. 1 .and. lzh == 0 ) THEN
       
         IF ( lvh .gt. 1 ) THEN
           IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
             hwdn = dn(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
           ELSE
             hwdn = xdn0(lh)
           ENDIF
           hwdn = Max( xdnmn(lh), hwdn )
         ELSE
           hwdn = xdn0(lh)
         ENDIF
           tmp = (hwdn*an(ix,jy,kz,lnh))/(dn(ix,jy,kz)*an(ix,jy,kz,lh))
           tmpg = an(ix,jy,kz,lnh)*(tmp*(3.14159))**(1./3.)
           IF ( tmpg .lt. cnohmn ) THEN
!           tmpg = an(ix,jy,kz,lnh)*( (hwdn*an(ix,jy,kz,lnh))/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
!           tmpg = an(ix,jy,kz,lnh)**(4./3.)*( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
             tmp = ( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
              an(ix,jy,kz,lnh) = (cnohmn/tmp)**(3./4.)
           ENDIF
       
       ENDIF
        
      end if


      if ( an(ix,jy,kz,ls) .lt.  frac*qxmin(ls)  .or. zerocx(ls)  & ! .or.  an(ix,jy,kz,lns) .lt. 0.1 ! .and.
     &         ) then
      IF ( t0(ix,jy,kz) .lt. 273.15 ) THEN
!        IF ( an(ix,jy,kz,ls) .gt. 0 ) THEN
          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,ls)
          an(ix,jy,kz,ls) = 0.0
!        ENDIF
      
        IF ( ipconc .ge. 4 ) THEN ! .and. an(ix,jy,kz,lns) .gt. 0.0  ) THEN ! 
!          an(ix,jy,kz,lni) = an(ix,jy,kz,lni) + an(ix,jy,kz,lns)
          an(ix,jy,kz,lns) = 0.0
        ENDIF
        
        IF ( lvs .gt. 1 ) THEN
           an(ix,jy,kz,lvs) = 0.0
        ENDIF

        IF ( lsw .gt. 1 ) THEN
           an(ix,jy,kz,lsw) = 0.0
        ENDIF

      ELSE
!        IF ( an(ix,jy,kz,ls) .gt. 0 ) THEN
          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,ls)
          an(ix,jy,kz,ls) = 0.0
!        ENDIF

        IF ( lvs .gt. 1 ) THEN
           an(ix,jy,kz,lvs) = 0.0
        ENDIF

        IF ( lsw .gt. 1 ) THEN
           an(ix,jy,kz,lsw) = 0.0
        ENDIF

        IF ( ipconc .ge. 4 ) THEN ! .and. an(ix,jy,kz,lns) .gt. 0.0  ) THEN ! 
!          an(ix,jy,kz,lnr) = an(ix,jy,kz,lnr) + an(ix,jy,kz,lns)
          an(ix,jy,kz,lns) = 0.0
        ENDIF

      ENDIF
      

      ELSEIF ( lvol(ls) .gt. 1 ) THEN  ! check density
        IF ( an(ix,jy,kz,lvs) .gt. 0.0 ) THEN
          tmp = dn(ix,jy,kz)*an(ix,jy,kz,ls)/an(ix,jy,kz,lvs)
          IF ( tmp .gt. xdnmx(ls) .or. tmp .lt. xdnmn(ls) ) THEN
            tmp = Min( xdnmx(ls), Max( xdnmn(ls), tmp ) )
            an(ix,jy,kz,lvs) = dn(ix,jy,kz)*an(ix,jy,kz,ls)/tmp
          ENDIF
        ELSE
          tmp = rho_qs
          an(ix,jy,kz,lvs) = dn(ix,jy,kz)*an(ix,jy,kz,ls)/tmp
        ENDIF


      end if


      if ( an(ix,jy,kz,lr) .lt. frac*qxmin(lr)  .or. zerocx(lr)  &
     &  ) then
        an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lr)
        an(ix,jy,kz,lr) = 0.0
        IF ( ipconc .ge. 3 ) THEN
!          an(ix,jy,kz,lnc) = an(ix,jy,kz,lnc) + an(ix,jy,kz,lnr)
          an(ix,jy,kz,lnr) = 0.0
        ENDIF
        
      end if

!
!  for qci
!
      IF ( an(ix,jy,kz,li) .le. frac*qxmin(li) .or. zerocx(li)   & ! .or.  an(ix,jy,kz,lni) .lt. 0.1
     &    ) THEN
      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,li)
      an(ix,jy,kz,li)= 0.0
       IF ( ipconc .ge. 1 ) THEN
         an(ix,jy,kz,lni) = 0.0
       ENDIF
      ENDIF

!
!  for qcw
!

      IF ( an(ix,jy,kz,lc) .le. frac*qxmin(lc) .or. zerocx(lc)   &
     &       ) THEN
      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lc)
      an(ix,jy,kz,lc)= 0.0
       IF ( ipconc .ge. 2 ) THEN
        IF ( lccn .gt. 1 ) THEN
         an(ix,jy,kz,lccn) =     &
     &       an(ix,jy,kz,lccn) + Max(0.0,an(ix,jy,kz,lnc))
        ENDIF
         an(ix,jy,kz,lnc) = 0.0

       ENDIF

      ENDIF

      end do
!      end do
      end do
      
      
      IF ( ndebug .ge. 1 ) write(6,*) 'END OF ICEZVD_DR'
!
!
   
   
   9999 RETURN
   
   END SUBROUTINE NUCOND


! #####################################################################
! #####################################################################


!
! Things to do:
!
!  Test using exponential formulation for rain fall speed.  If there is little change
!  from the quadratic, it would be less complicated to use.
!
!  Contact nucleation needs to be fixed up to be similar to Cotton et al. 1986 and Meyers et al 1992.
!
! The following are done?
!
!  Fix Rain evaporation for gamma function (ipconc >= 3)
!
!  convert cloud ice to snow as in Ferrier 1994 (change only mass in cloud ice),
!    then can try turning off direct conversion from cloud ice to graupel and rimed ice
!
!  look at an iterative check on overdepletion;  need to be careful with two-moment
!
!  check ice supersaturation in two-moment.  Getting enough deposition, or need 
!      to do sat adj. when cloud droplets are all gone?
!
!  
!
! new comment
!
! Fix use of gt for SWM IN FALLOUT ROUTINES
!
!  How to remove hl for ipconc=5?  Need to preprocess?
!
!   When the charging rates are moved to a subroutine, need to move the
!   call to be after the wet growth calculations -- or at least the 
!   splashing stuff.  Think about this....
!
!  Think about what to do with cracif
!
!    Replace qv0 with qx(mgs,lv)? No. qv0 is base val
!
! Need to look at limiting supersaturation to 1 or so by nucleation/condensation
!
!  put in temperature-dependent function for homogeneous freezing
!
!c--------------------------------------------------------------------------
!
!
!--------------------------------------------------------------------------
!

      subroutine nssl_2mom_gs   &
     &  (nx,ny,nz,na,jyslab  &
     &  ,nor,norz          &
     &  ,dtp,gz       &
     &  ,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9      &
     &  ,an,dn,p2                  &
     &  ,pn,w,iunit                   &
     &  ,t00,t77,                             &
     &   ventr,ventc,c1sw,jgs,ido,    &
     &   xdnmx,xdnmn,               &
!     &   ln,ipc,lvol,lz,lliq,   &
     &   cdx,                              &
     &   xdn0,tmp3d  &
     & ,timevtcalc,axtra,io_flag  &
     & ,rainprod2d, evapprod2d &
     & ,elec,its,ids,ide,jds,jde &
     & )


!
!--------------------------------------------------------------------------
!                                
!     Ziegler 1985 parameterized microphysics (also Zrnic et al. 1993)
!     1)  cloud water
!     2)  rain
!     3)  column ice 
!     6)  snow
!     11) graupel/hail
!
!--------------------------------------------------------------------------
!
! Notes:
!
!  4/27/2009: allows for liquid water to be advected on snow and graupel particles using flag "mixedphase"
!
!  3/14/2007: (APS) added qproc temp to make microphysic process timeseries
!
!  10/17/2006: added flag (iehw) to select how to calculate ehw
!
!  10/5/2006: switched chacr to integrated version rather than assuming that average rain
!             drop mass does not change.  This acts to reduce rain size somewhat via graupel
!             collection.
!             Use Mason data for ehw, with scaling toward ehw=1 as air density decreases.
!
!  10/3/2006: Turned off Meyers nucleation for T > -5 (can turn on with imeyers5 flag)
!             Turned off contact nucleation in updrafts
!
!  7/24/2006:  Turned on Meyers nucleation for -5 < T < 0
!
!  5/12/2006:  Converted qsacw/csacw and qsaci/csaci to Z93
!
!  5/12/2006:  Put a threshold on Bigg rain freezing.  If the frozen drops
!              have an average volume less than xvhmn, then the drops are put
!              into snow instead of graupel/hail.
!
!              Fixed bug when vapor deposition was limited.
!
!  5/13/2006:  Note that qhacr has a large effect, but Z85 did not include it.
!              Turned off qsacr (set to zero).
!
!  9/14/2007: erm: recalculate vx(lh) after setting xdn(lh) in case xdn was out of allowed range.
!             added parameter rimc3 for minimum rime density.  Default value set at 170. kg/m**3
!             instead of previous use of 100.  (Farley, 1987)
!
!--------------------------------------------------------------------------
!
!  general declarations
!
!--------------------------------------------------------------------------
!
!
!


      implicit none
!
!      integer icond 
!      parameter ( icond = 2 )

      integer, parameter :: ng1 = 1

      integer nx,ny,nz,na,nba,nv
      integer nor,norz,istag,jstag,kstag ! ,nht,ngt,igsr
      integer iwrite
      real dtp,dx,dy,dz

      logical, intent(in) :: io_flag

      integer itile,jtile,ktile
      integer ixbeg,jybeg
      integer ixend,jyend,kzend,kzbeg
      integer nxend,nyend,nzend,nzbeg
      integer :: my_rank = 0
      integer, parameter :: myprock = 1, nprock = 1
      real rainprod2d(-nor+1:nx+nor,-norz+ng1:nz+norz)
      real evapprod2d(-nor+1:nx+nor,-norz+ng1:nz+norz)


      real axtra(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,nxtra)

      real :: galpharaut
      
      integer jyslab,its,ids,ide,jds,jde ! domain boundaries
      integer, intent(in) :: iunit !,iunit0
      real qvex
      integer iraincv, icgxconv
      parameter ( iraincv = 1, icgxconv = 1)
      real ffrz

      real qcitmp,cirdiatmp ! ,qiptmp,qirtmp
      real ccwtmp,ccitmp ! ,ciptmp,cirtmp
      real cpqc,cpci ! ,cpip,cpir
      real cpqc0,cpci0 ! ,cpip0,cpir0
      real scfac ! ,cpip1
      
      double precision dp1
      
      double precision frac, frach, xvfrz
      
      double precision :: timevtcalc
      double precision :: dpt1,dpt2
            
      
      logical, parameter :: usegamxinf = .false.
      logical, parameter :: usegamxinf2 = .true.
!      real rar  ! rime accretion rate as calculated from qxacw


! a few vars for time-split fallout      
      real vtmax
      integer n,ndfall
      
      double precision chgneg,chgpos,sctot
      
      real temgtmp

      real pb(-norz+ng1:nz+norz)
      real pinit(-norz+ng1:nz+norz)

      real gz(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz) ! dz
      
      real qimax,xni0,roqi0


      real dv

      real dtptmp
      integer itest,nidx,id1,jd1,kd1
      parameter (itest=1)
      parameter (nidx=10)
      parameter (id1=1,jd1=1,kd1=1)
      integer ierr
      integer iend

      integer ix,kz, il, ic, ir, icp1, irp1, ip1,jp1,kp1
      integer :: jy
      integer i,j,k,i1
      integer kzb,kze
      real slope1, slope2
      real x1, x2, x3
      real eps,eps2
      parameter (eps=1.e-20,eps2=1.e-5)
!
!  Other elec. vars
!
      real  temele
      real  trev
      
      logical ldovol, ishail, ltest
!
!
!  wind indicies
!
      integer mu,mv,mw
      parameter (mu=1,mv=2,mw=3)
!
!  conversion parameters
!
      integer mqcw,mqxw,mtem,mrho,mtim
      parameter (mqcw=21,mqxw=21,mtem=21,mrho=5,mtim=6)

      real xftim,xftimi,yftim, xftem,yftem, xfqcw,yfqcw, xfqxw,yfqxw
      parameter (xftim=0.05,xftimi = 1./xftim,yftim=1.)
      parameter (xftem=0.5,yftem=1.)
      parameter (xfqcw=2000.,yfqcw=1.)
      parameter (xfqxw=2000.,yfqxw=1.)
      real dtfac
      parameter ( dtfac = 1.0 )
      integer ido(lc:lqmx)

!      integer iexy(lc:lqmx,lc:lqmx)
!      integer ieswi, ieswir, ieswip, ieswc, ieswr
!      integer ieglsw, iegli, ieglir, ieglip, ieglc, ieglr
!      integer iegmsw, iegmi, iegmir, iegmip, iegmc, iegmr
!      integer ieghsw, ieghi, ieghir, ieghip, ieghc, ieghr
!      integer iefwsw, iefwi, iefwir, iefwip, iefwc, iefwr
!      integer iehwsw, iehwi, iehwir, iehwip, iehwc, iehwr
!      integer iehlsw, iehli, iehlir, iehlip, iehlc, iehlr
!      real delqnsa, delqxsa, delqnsb, delqxsb, delqnia, delqxia
!      real delqnra, delqxra

       real delqnxa(lc:lqmx)
       real delqxxa(lc:lqmx)
!
! external temporary arrays
!
      real t00(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t77(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)

      real t0(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t1(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t2(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t3(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t4(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t5(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t6(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t7(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t8(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
      real t9(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)

      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)  ! perturbation Pi
      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
      real an(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,na)
      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)

      real tmp3d(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)

! 
!  declarations microphyscs and for gather/scatter
!
      integer nxmpb,nzmpb,nxz
      integer jgs,mgs,ngs,numgs
      parameter (ngs=500) !500)
      integer, parameter :: ngsz = 500
      integer ntt
      parameter (ntt=300)

      real dvmgs(ngs)
      
      integer ngscnt,igs(ngs),kgs(ngs)
      integer kgsp(ngs),kgsm(ngs),kgsm2(ngs)
      integer ncuse
      parameter (ncuse=0)
      integer il0(ngs),il5(ngs),il2(ngs),il3(ngs)
!      integer il1m(ngs),il2m(ngs),il3m(ngs),il4m(ngs),il5m(ngs)
!
      real tdtol,temsav,tfrcbw,tfrcbi
      real, parameter :: thnuc = 235.15
!
!  Ice Multiplication Arrays.
!
      real  fimt1(ngs),fimta(ngs),fimt2(ngs) !,qmul1(ngs),qmul2(ngs)
      real xcwmas
!
!
! Variables for Ziegler warm rain microphysics
!      


      real ccnc(ngs),ccin(ngs),cina(ngs),ccna(ngs)
      real cwnccn(ngs)
      real sscb  ! 'cloud base' SS threshold
      parameter ( sscb = 2.0 )
      integer idecss  ! flag to turn on (=1) decay of ssmax when no cloud or ice crystals
      parameter ( idecss = 1 )
      integer iba ! flag to do condensation/nucleation in 1st or 2nd loop
                  ! =0 to use ad to calculate SS
                  ! =1 to use an at end of main jy loop to calculate SS
      parameter (iba = 1)
      integer ifilt   ! =1 to filter ssat, =0 to set ssfilt=ssat
      parameter ( ifilt = 0 ) 
      real temp1,temp2 ! ,ssold
      real :: mwat, mice, dice, mwshed, fwmax, fw, mwcrit, massfactor
      real, parameter :: shedalp = 3.  ! set 3 for maximum mass diameter, 4 for mass-weighted diameter
      real ssmax(ngs)       ! maximum SS experienced by a parcel
      real ssmx
      real dnnet,dqnet
!      real cnu,rnu,snu,cinu
!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
      real bfnu, bfnu0, bfnu1
      parameter ( bfnu0 = (rnu + 2.0)/(rnu + 1.0)  )
      real ventr, ventc
      real volb, aa1, aa2
      double precision t2s, xdp
      double precision xl2p(ngs),rb(ngs)
      parameter ( aa1 = 9.44e15, aa2 = 5.78e3 ) ! a1 in Ziegler
! snow parameters:
      real cexs, cecs
      parameter ( cexs = 0.1, cecs = 0.5 )
      real rvt      ! ratio of collection kernels (Zrnic et al, 1993)
      parameter ( rvt = 0.104 )
      real kfrag    ! rate coefficent for collisional splintering (Schuur & Rutledge 00b)
      parameter ( kfrag = 1.0e-6 )
      real mfrag    ! assumed ice fragment mass for collisional splintering (Schuur & Rutledge 00b)
      parameter ( mfrag = 1.0e-10)
      double precision cautn(ngs), rh(ngs), nh(ngs)
      real ex1, ft, rhoinv(ngs)
      double precision ec0(ngs)
      
      real ac1,bc, taus, c1,d1,e1,f1,p380,tmp,tmp1,tmp2,tmp3,tmp4 ! , sstdy, super
      real ratio, delx, dely
      real dbigg,volt
      real chgtmp,fac
      real x,y,del,r,rtmp,alpr
      double precision :: vent1,vent2
      real g1palp,g4palp
      real fqt !charge separation as fn of temperature from Dong and Hallett 1992
      real bs
      real v1, v2
      real d1r, d1i, d1s, e1i
      real c1sw   ! integration factor for snow melting with snu = -0.8
      real, parameter :: vr1mm = 5.23599e-10 ! volume of 1mm diameter sphere (m**3)
      real, parameter :: vr3mm = 5.23599e-10*(3.0/1.)**3   ! volume of a 3 mm diameter sphere (m**3) (Rasmussen et al. 1984b, JAS)
      real, parameter :: vr4p5mm = 5.23599e-10*(4.5/1.)**3 ! volume of 4.5mm diameter sphere (m**3) (Rasmussen et al. 1984b, JAS)
      real vmlt,vshd
      real rhosm
      parameter ( rhosm = 500. )
      integer nc ! condensation step
      real dtcon,dtcon1,dtcon2 ! condensation time step (dtcon*nc = dtp)
      real delta
      integer ltemq1,ltemq1m ! ,ltemq1m2
      real dqv,qv1,ss1,ss2,qvs1,dqvs,dtemp,dt1   ! temporaries for condensation
      real ssi1, ssi2, dqvi, dqvis, dqvii,qis1
      real dqvr, dqc, dqr, dqi, dqs
      real qv1m,qvs1m,ss1m,ssi1m,qis1m
      real cwmastmp
      real  dcloud,dcloud2 ! ,as, bs
      real cn(ngs)
      double precision xvc, xvr
      real mwfac
!      real  es(ngs) ! ss(ngs),
!      real  eis(ngs)

      real rwmasn,rwmasx

      real vgra,vfrz
      parameter ( vgra = 0.523599*(1.0e-3)**3 )
     
      real epsi,d
      parameter (epsi = 0.622, d = 0.266)
      real r1,qevap ! ,slv
      
      real vr,nrx,chw,g1,qr,z,z1,rdi,alp,xnutmp,xnuc,g1r,rd1,rdia
      
      real, parameter :: rhofrz = 900.   ! density of graupel from newly-frozen rain
      real, parameter :: rimedens = 500. ! default rime density

!      real svc(ngs)  !  droplet volume
!
!  contact freezing nucleation
!
      real raero,kaero !assumd aerosol radius, thermal conductivity
      parameter ( raero = 3.e-7, kaero = 5.39e-3 )
      real kb   ! Boltzman constant  J K-1
      parameter (kb = 1.3807e-23)
      
      real knud(ngs),knuda(ngs) !knudsen number and correction factor
      real gtp(ngs)  !G(T,p) = 1/(a' + b')  Cotton 72b
      real dfar(ngs) !aerosol diffusivity
      real fn1(ngs),fn2(ngs),fnft(ngs)
      
      real ccia(ngs)
      real ctfzbd(ngs),ctfzth(ngs),ctfzdi(ngs)
!
!  misc
!
      real ni,nr,d0
      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
      real tempc(ngs)
      real temg(ngs),temcg(ngs),theta(ngs),qvap(ngs) 
      real temgkm1(ngs), temgkm2(ngs)
      real temgx(ngs),temcgx(ngs)
      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
      real elv(ngs),elf(ngs),els(ngs)
      real tsqr(ngs),ssi(ngs),ssw(ngs)
      real qcwtmp(ngs),qtmp,qtot(ngs) 
      real qcond(ngs)
      real ctmp, sctmp
      real cimasn,cimasx,ccimx
      real pid4
      real cs,ds,gf7,gf6,gf5,gf4,gf3,gf2,gf1
      real gf73rds, gf83rds
      real gamice73fac, gamsnow73fac
      real gf43rds, gf53rds
      real gamma
      real aradcw,bradcw,cradcw,dradcw,cwrad,rwrad,rwradmn
      parameter ( rwradmn = 50.e-6 )
      real dh0
      
      real clionpmx,clionnmx
      parameter (clionpmx=1.e9,clionnmx=1.e9) ! Takahashi 84
!
!  other arrays

      real fwet1(ngs),fwet2(ngs)   
      real fmlt1(ngs),fmlt2(ngs)  
      real fvds(ngs),fvce(ngs),fiinit(ngs) 
      real fvent(ngs),fraci(ngs),fracl(ngs)
!
      real fai(ngs),fav(ngs),fbi(ngs),fbv(ngs)
      real felv(ngs),fels(ngs),felf(ngs)
      real felvcp(ngs),felscp(ngs),felfcp(ngs)
      real felvpi(ngs),felspi(ngs),felfpi(ngs)
      real felvs(ngs),felss(ngs)      !   ,felfs(ngs)
      real fwvdf(ngs),ftka(ngs),fthdf(ngs)
      real fadvisc(ngs),fakvisc(ngs)
      real fci(ngs),fcw(ngs)
      real fschm(ngs),fpndl(ngs)
      real fgamw(ngs),fgams(ngs)
      real fcqv1(ngs),fcqv2(ngs),fcc3(ngs) 
      
      real cvm,cpm,rmm

      real, parameter :: rovcp = rd/cp
      real, parameter ::      cpv = 1885.0       ! specific heat of water vapor at constant pressure
!
      real fcci(ngs), fcip(ngs)
!
      real :: sfm1(ngs),sfm2(ngs)
      real :: gfm1(ngs),gfm2(ngs)
      real :: hfm1(ngs),hfm2(ngs)

      logical :: wetsfc(ngs),wetsfchl(ngs)
      logical :: wetgrowth(ngs), wetgrowthhl(ngs)

       real qitmp(ngs)
       
      real rzxh(ngs), rzxhl(ngs), rzxhlh(ngs)
      real rzxs(ngs)
      real axh(ngs),bxh(ngs),axhl(ngs),bxhl(ngs)
      real vt2ave(ngs)

      real ::  qx(ngs,lv:lhab)
      real ::  qxw(ngs,ls:lhab)
      real ::  cx(ngs,lc:lhab)
      real ::  cxmxd(ngs,lc:lhab)
      real ::  qxmxd(ngs,lv:lhab)
      real ::  scx(ngs,lc:lhab)
      real ::  xv(ngs,lc:lhab)
      real ::  vtxbar(ngs,lc:lhab,3)
      real ::  xmas(ngs,lc:lhab)
      real ::  xdn(ngs,lc:lhab)
      real ::  xdia(ngs,lc:lhab,3)
      real ::  rarx(ngs,ls:lhab)
      real ::  vx(ngs,li:lhab)
      real ::  rimdn(ngs,li:lhab)
      real ::  raindn(ngs,li:lhab)
      real ::  alpha(ngs,lc:lhab)
      real ::  dab0lh(ngs,lc:lhab,lr:lhab)
      real ::  dab1lh(ngs,lc:lhab,lr:lhab)
      
      real :: galphrout
      
      real ventrx(ngs)
      real ventrxn(ngs)
      real g1shr, alphashr
      real g1mlr, alphamlr
      
!
      real swvent(ngs),hwvent(ngs),rwvent(ngs),hlvent(ngs),hwventy(ngs),hlventy(ngs)
      integer, parameter :: ndiam = 10
      integer :: numdiam
      real hwvent0(ndiam+3),hlvent0 ! 0 to d1
      real hwvent1,hlvent1 ! d1 to infinity
      real hwvent2,hlvent2 ! d2 to infinity
      real gama0,gamb0
      real gama1,gamb1
      real gama2,gamb2
      real, parameter :: mltdiam1 = 9.0e-3, mltdiam2 = 19.0e-3, mltdiam3 = 200.0e-3, mltdiam05 = 4.5e-3
      real :: mltdiam(ndiam+3)
      real mltmass1inv,mltmass2inv, mltmass1cgs, mltmass2cgs
      real qhmlr0, qhmlr05, qhmlr1, qhmlr2, qhmlr12
      real qhlmlr0, qhlmlr05, qhlmlr1, qhlmlr2, qhlmlr12
      real qxd1, cxd1 ! mass and number up to mltdiam1
      real qxd05, cxd05 ! mass and number up to mltdiam1/2
      
      real :: qxd(ndiam+3), cxd(ndiam+3), qhml(ndiam+3), qhml0(ndiam+3)
      real :: dqxd(ndiam+3), dcxd(ndiam+3), dqhml(ndiam+3)
      
      
      real civent(ngs)
!
      real xmascw(ngs)
      real xdnmx(lc:lhab), xdnmn(lc:lhab)
      real dnmx
      real :: xdiamxmas(ngs,lc:lhab)
!
      real cilen(ngs) ! ,ciplen(ngs)
!
!
      real rwcap(ngs),swcap(ngs)
      real hwcap(ngs)
      real hlcap(ngs)
      real cicap(ngs)

      real qvimxd(ngs)
      real qimxd(ngs),qcmxd(ngs),qrmxd(ngs),qsmxd(ngs),qhmxd(ngs),qhlmxd(ngs)
      real cimxd(ngs),ccmxd(ngs),crmxd(ngs),csmxd(ngs),chmxd(ngs)
      real cionpmxd(ngs),cionnmxd(ngs)
      real clionpmxd(ngs),clionnmxd(ngs)


      real elec(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz) ! Ez (elecsave)

!
!
      ! Hallett-Mossop arrays
      real chmul1(ngs),chlmul1(ngs),csmul1(ngs),csmul(ngs)
      real qhmul1(ngs),qhlmul1(ngs),qsmul1(ngs),qsmul(ngs)
      
      ! splinters from drop freezing
      real csplinter(ngs),qsplinter(ngs)
      real csplinter2(ngs),qsplinter2(ngs)
!
!
!  concentration arrays...
!
      real :: chlcnh(ngs), vhlcnh(ngs), vhlcnhl(ngs)
      real cracif(ngs), ciacrf(ngs)
      real cracr(ngs)

!
      real ciint(ngs), crfrz(ngs), crfrzf(ngs), crfrzs(ngs)
      real cicint(ngs)
      real cipint(ngs)
      real ciacw(ngs), cwacii(ngs) 
      real ciacr(ngs), craci(ngs)
      real csacw(ngs)
      real csacr(ngs)
      real csaci(ngs),   csacs(ngs)
      real cracw(ngs) 
      real chacw(ngs), chacr(ngs)
      real :: chlacw(ngs) ! = 0.0
      real chaci(ngs), chacs(ngs)
!
      real :: chlacr(ngs)
      real :: chlaci(ngs), chlacs(ngs)
      real crcnw(ngs) 
      real cidpv(ngs),cisbv(ngs)
      real cimlr(ngs)

      real chlsbv(ngs), chldpv(ngs)
      real chlmlr(ngs), chlmlrr(ngs) 
      real chlshr(ngs), chlshrr(ngs)

      real chdpv(ngs),chsbv(ngs)
      real chmlr(ngs),chcev(ngs)
      real chmlrr(ngs)
      real chshr(ngs), chshrr(ngs)

      real csdpv(ngs),cssbv(ngs)
      real csmlr(ngs),cscev(ngs)
      real csshr(ngs)

      real crcev(ngs)
      real crshr(ngs)
!
!
! arrays for w-ac-x ;  x-ac-w
!
!
!
      real qrcnw(ngs), qwcnr(ngs)
      real zrcnw(ngs),zracr(ngs),zracw(ngs),zrcev(ngs)


      real qracw(ngs) ! qwacr(ngs),
      real qiacw(ngs) !, qwaci(ngs)

      real qsacw(ngs) ! ,qwacs(ngs),
      real qhacw(ngs) ! qwach(ngs),
      real :: qhlacw(ngs) ! = 0.0
      real vhacw(ngs), vsacw(ngs), vhlacw(ngs), vhlacr(ngs)

!
      real qsacws(ngs)

!
!  arrays for x-ac-r and r-ac-x; 
!
      real qsacr(ngs),qracs(ngs)
      real qhacr(ngs),qhacrmlr(ngs) ! ,qrach(ngs)
      real vhacr(ngs), zhacr(ngs), zhacrf(ngs), zrach(ngs), zrachl(ngs)
      real qiacr(ngs),qraci(ngs)
      
      real ziacr(ngs)

      real qracif(ngs),qiacrf(ngs),qiacrs(ngs),ciacrs(ngs)

      real :: qhlacr(ngs),qhlacrmlr(ngs) ! = 0.0
      real qsacrs(ngs) !,qracss(ngs)
!
!  ice - ice interactions
!
      real qsaci(ngs)
      real qhaci(ngs)
      real qhacs(ngs)

      real :: csaci0(ngs) ! collision rate only
      real :: chaci0(ngs) ! collision rate only
      real :: chacs0(ngs) ! collision rate only
      real :: chlaci0(ngs) ! = 0.0
      real :: chlacs0(ngs) ! = 0.0

      real :: qsaci0(ngs) ! collision rate only
      real :: qhaci0(ngs) ! collision rate only
      real :: qhacs0(ngs) ! collision rate only
      real :: qhlaci0(ngs) ! = 0.0
      real :: qhlacs0(ngs) ! = 0.0

      real :: qhlaci(ngs) ! = 0.0
      real :: qhlacs(ngs) ! = 0.0
!
!  conversions
!
      real qrfrz(ngs) ! , qirirhr(ngs)
      real zrfrz(ngs), zrfrzf(ngs)
      real ziacrf(ngs), zhcnsh(ngs), zhcnih(ngs)
      real zhacw(ngs), zhacs(ngs), zhaci(ngs)
      real zhmlr(ngs), zhdsv(ngs), zhsbv(ngs), zhlcnh(ngs), zhshr(ngs)
      real zhmlrtmp,zhmlr0inf,zhlmlr0inf
      real zhmlrr(ngs),zhlmlrr(ngs),zhshrr(ngs),zhlshrr(ngs)
      real zsmlr(ngs), zsmlrr(ngs), zsshr(ngs)
      real zhcns(ngs), zhcni(ngs)
      real zhwdn(ngs) ! change in Z due to density changes
      real zhldn(ngs) ! change in Z due to density changes

      real zhlacw(ngs), zhlacs(ngs), zhlacr(ngs)
      real zhlmlr(ngs), zhldsv(ngs), zhlsbv(ngs), zhlshr(ngs)

      
      real vrfrzf(ngs), viacrf(ngs)
      real qrfrzs(ngs), qrfrzf(ngs)
      real qwfrz(ngs), qwctfz(ngs)
      real cwfrz(ngs), cwctfz(ngs)
      real qwfrzc(ngs), qwctfzc(ngs)
      real cwfrzc(ngs), cwctfzc(ngs)
      real qwfrzp(ngs), qwctfzp(ngs)
      real cwfrzp(ngs), cwctfzp(ngs)
      real xcolmn(ngs), xplate(ngs)
      real ciihr(ngs), qiihr(ngs)
      real cicichr(ngs), qicichr(ngs)
      real cipiphr(ngs), qipiphr(ngs)
      real qscni(ngs), cscni(ngs), cscnis(ngs)
      real qscnvi(ngs), cscnvi(ngs), cscnvis(ngs)
      real qhcns(ngs), chcns(ngs), chcnsh(ngs), vhcns(ngs)
      real qscnh(ngs), cscnh(ngs), vscnh(ngs)
      real qhcni(ngs), chcni(ngs), chcnih(ngs), vhcni(ngs)
      real qiint(ngs),qipipnt(ngs),qicicnt(ngs)
      real cninm(ngs),cnina(ngs),cninp(ngs),wvel(ngs),wvelkm1(ngs)
      real tke(ngs)
      real uvel(ngs),vvel(ngs)
!
      real qidpv(ngs),qisbv(ngs) ! qicnv(ngs),qievv(ngs),
      real qimlr(ngs),qidsv(ngs),qidsvp(ngs) ! ,qicev(ngs)

!
      real qfdpv(ngs),qfsbv(ngs) ! qfcnv(ngs),qfevv(ngs),
      real qfmlr(ngs),qfdsv(ngs) ! ,qfcev(ngs)
      real qfwet(ngs),qfdry(ngs),qfshr(ngs)
      real qfshrp(ngs)
!
      real :: qhldpv(ngs), qhlsbv(ngs) ! qhlcnv(ngs),qhlevv(ngs),
      real :: qhlmlr(ngs), qhldsv(ngs) 
      real :: qhlwet(ngs), qhldry(ngs), qhlshr(ngs) 
!
      real :: qrfz(ngs),qsfz(ngs),qhfz(ngs),qhlfz(ngs)
!
      real qhdpv(ngs),qhsbv(ngs) ! qhcnv(ngs),qhevv(ngs),
      real qhmlr(ngs),qhdsv(ngs),qhcev(ngs),qhcndv(ngs),qhevv(ngs)
      real qhmlrlg(ngs),qhlmlrlg(ngs) ! melting from the larger diameters
      real qhlcev(ngs), chlcev(ngs)
      real qhwet(ngs),qhdry(ngs),qhshr(ngs)
      real qhshrp(ngs)
      real qhshh(ngs) !accreted water that remains on graupel
      real qhmlh(ngs) !melt water that remains on graupel
      real qhfzh(ngs) !water that freezes on mixed-phase graupel
      real qhlfzhl(ngs) !water that freezes on mixed-phase hail

      real vhfzh(ngs) ! change in volume from water that freezes on mixed-phase graupel
      real vhlfzhl(ngs) !  change in volume from water that freezes on mixed-phase hail

      real vhshdr(ngs) !accreted water that leaves on graupel (mixedphase)
      real vhlshdr(ngs) !accreted water that leaves on hail (mixedphase)
      real vhmlr(ngs) !melt water that leaves graupel (single phase)
      real vhlmlr(ngs) !melt water that leaves hail (single phase)
      real vhsoak(ngs) !  aquired water that seeps into graupel.
      real vhlsoak(ngs) !  aquired water that seeps into hail.
!
      real qsdpv(ngs),qssbv(ngs) ! qscnv(ngs),qsevv(ngs),
      real qsmlr(ngs),qsdsv(ngs),qscev(ngs),qscndv(ngs),qsevv(ngs)
      real qswet(ngs),qsdry(ngs),qsshr(ngs)
      real qsshrp(ngs)
      real qsfzs(ngs)
!
!
      real qipdpv(ngs),qipsbv(ngs)
      real qipmlr(ngs),qipdsv(ngs)
!
      real qirdpv(ngs),qirsbv(ngs)
      real qirmlr(ngs),qirdsv(ngs),qirmlw(ngs)
!
      real qgldpv(ngs),qglsbv(ngs)
      real qglmlr(ngs),qgldsv(ngs)
      real qglwet(ngs),qgldry(ngs),qglshr(ngs)
      real qglshrp(ngs)
!
      real qgmdpv(ngs),qgmsbv(ngs)
      real qgmmlr(ngs),qgmdsv(ngs)
      real qgmwet(ngs),qgmdry(ngs),qgmshr(ngs)
      real qgmshrp(ngs)
      real qghdpv(ngs),qghsbv(ngs)
      real qghmlr(ngs),qghdsv(ngs) 
      real qghwet(ngs),qghdry(ngs),qghshr(ngs)
      real qghshrp(ngs)
!
      real qrztot(ngs),qrzmax(ngs),qrzfac(ngs)
      real qrcev(ngs)
      real qrshr(ngs)
      real fsw(ngs),fhw(ngs),fhlw(ngs) !liquid water fractions
      real qhcnf(ngs) 
      real :: qhlcnh(ngs) ! = 0.0
      real qhcngh(ngs),qhcngm(ngs),qhcngl(ngs)
      
      real :: qhcnhl(ngs), chcnhl(ngs), zhcnhl(ngs), vhcnhl(ngs) ! conversion of low-density hail back to graupel

      real eiw(ngs),eii(ngs),eiri(ngs),eipir(ngs)
      real erw(ngs),esw(ngs),eglw(ngs),eghw(ngs),efw(ngs)
      real ehxw(ngs),ehlw(ngs),egmw(ngs),ehw(ngs)
      real err(ngs),esr(ngs),eglr(ngs),eghr(ngs),efr(ngs)
      real ehxr(ngs),ehlr(ngs),egmr(ngs) 
      real eri(ngs),esi(ngs),egli(ngs),eghi(ngs),efi(ngs)
      real ehxi(ngs),ehli(ngs),egmi(ngs),ehi(ngs) 
      real ers(ngs),ess(ngs),egls(ngs),eghs(ngs),efs(ngs),ehs(ngs)
      real ehscnv(ngs)
      real ehxs(ngs),ehls(ngs),egms(ngs),egmip(ngs) 

      real ehsclsn(ngs),ehiclsn(ngs)
      real ehlsclsn(ngs),ehliclsn(ngs)
      real esiclsn(ngs)

      real :: ehs_collsn = 0.5, ehi_collsn = 1.0
      real :: ehls_collsn = 1.0, ehli_collsn = 1.0
      real :: esi_collsn = 1.0
      
      real ew(8,6)
      real cwr(8,2)  ! radius and inverse of interval
      data cwr / 2.0, 3.0, 4.0, 6.0,  8.0,  10.0, 15.0,  20.0 , & ! radius
     &           1.0, 1.0, 0.5, 0.5,  0.5,   0.2,  0.2,  1.  /   ! inverse of interval
      integer icwr(ngs), igwr(ngs), irwr(ngs), ihlr(ngs)
      real grad(6,2) ! graupel radius and inverse of interval
      data grad / 100., 200., 300., 400., 600., 1000.,   &
     &            1.e-2,1.e-2,1.e-2,5.e-3,2.5e-3, 1.    /
!droplet radius: 2     3     4     6     8    10    15    20
      data ew /0.03, 0.07, 0.17, 0.41, 0.58, 0.69, 0.82, 0.88,  & ! 100
!     :         0.07, 0.13, 0.27, 0.48, 0.65, 0.73, 0.84, 0.91,  ! 150
     &         0.10, 0.20, 0.34, 0.58, 0.70, 0.78, 0.88, 0.92,  & ! 200
     &         0.15, 0.31, 0.44, 0.65, 0.75, 0.83, 0.96, 0.91,  & ! 300
     &         0.17, 0.37, 0.50, 0.70, 0.81, 0.87, 0.93, 0.96,  & ! 400
     &         0.17, 0.40, 0.54, 0.71, 0.83, 0.88, 0.94, 0.98,  & ! 600
     &         0.15, 0.37, 0.52, 0.74, 0.82, 0.88, 0.94, 0.98 / ! 1000
!     :         0.11, 0.34, 0.49, 0.71, 0.83, 0.88, 0.94, 0.95 / ! 1400


      real da0lr(ngs)
      real da0lh(ngs)
      real da0lhl(ngs)
      
      real va0 (lc:lqmx)          ! collection coefficients from Seifert 2005
      real vab0(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
      real vab1(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
      real va1 (lc:lqmx)          ! collection coefficients from Seifert 2005
      real ehip(ngs),ehlip(ngs),ehlir(ngs)
      real erir(ngs),esir(ngs),eglir(ngs),egmir(ngs),eghir(ngs)
      real efir(ngs),ehir(ngs),eirw(ngs),eirir(ngs),ehr(ngs)
      real erip(ngs),esip(ngs),eglip(ngs),eghip(ngs)
      real efip(ngs),eipi(ngs),eipw(ngs),eipip(ngs)
!
!  arrays for production terms
!
      real ptotal(ngs) ! , pqtot(ngs)
!
      real pqcwi(ngs),pqcii(ngs),pqrwi(ngs)
      real pqswi(ngs),pqhwi(ngs),pqwvi(ngs)
      real pqgli(ngs),pqghi(ngs),pqfwi(ngs)
      real pqgmi(ngs),pqhli(ngs) ! ,pqhxi(ngs)
      real pqiri(ngs),pqipi(ngs) ! pqwai(ngs),
      real pqlwsi(ngs),pqlwhi(ngs),pqlwhli(ngs)
      
      real pvhwi(ngs), pvhwd(ngs)
      real pvhli(ngs), pvhld(ngs)
      real pvswi(ngs), pvswd(ngs)
!
      real pqcwd(ngs),pqcid(ngs),pqrwd(ngs)
      real pqswd(ngs),pqhwd(ngs),pqwvd(ngs)
      real pqgld(ngs),pqghd(ngs),pqfwd(ngs)
      real pqgmd(ngs),pqhld(ngs) ! ,pqhxd(ngs)
      real pqird(ngs),pqipd(ngs) ! pqwad(ngs),
      real pqlwsd(ngs),pqlwhd(ngs),pqlwhld(ngs)
!
!      real pqxii(ngs,nhab),pqxid(ngs,nhab)
!
      real  pctot(ngs)
      real  pcipi(ngs), pcipd(ngs)
      real  pciri(ngs), pcird(ngs)
      real  pccwi(ngs), pccwd(ngs)
      real  pccii(ngs), pccid(ngs)
      real  pccin(ngs)
      real  pcrwi(ngs), pcrwd(ngs)
      real  pcswi(ngs), pcswd(ngs)
      real  pchwi(ngs), pchwd(ngs)
      real  pchli(ngs), pchld(ngs)
      real  pcfwi(ngs), pcfwd(ngs)
      real  pcgli(ngs), pcgld(ngs)
      real  pcgmi(ngs), pcgmd(ngs)
      real  pcghi(ngs), pcghd(ngs)

      real  pzrwi(ngs), pzrwd(ngs)
      real  pzhwi(ngs), pzhwd(ngs)
      real  pzhli(ngs), pzhld(ngs)
      real  pzswi(ngs), pzswd(ngs)

!
!  other arrays
!
      real dqisdt(ngs) !,advisc(ngs) !dqwsdt(ngs), ,schm(ngs),pndl(ngs)

      real qss0(ngs)

      real qsacip(ngs)
      real pres(ngs),pipert(ngs)
      real pk(ngs)
      real rho0(ngs),pi0(ngs)
      real rhovt(ngs),sqrtrhovt
      real thetap(ngs),theta0(ngs),qwvp(ngs),qv0(ngs)
      real thsave(ngs)
      real ptwfzi(ngs),ptimlw(ngs)
      real psub(ngs),pvap(ngs),pfrz(ngs),ptem(ngs),pmlt(ngs),pevap(ngs),pdep(ngs)
      
      real cnostmp(ngs)   ! for diagnosed snow intercept
!
!  iholef = 1 to do hole filling technique version 1
!  which uses all hydrometerors to do hole filling of all hydrometeors
!  iholef = 2 to do hole filling technique version 2
!  which uses an individual hydrometeror species to do hole
!  filling of a species of a hydrometeor
!
!  iholen = interval that hole filling is done
!
      integer  iholef
      integer  iholen
      parameter (iholef = 1)
      parameter (iholen = 1)
      real  cqtotn,cqtotn1
      real  cctotn
      real  citotn
      real  crtotn
      real  cstotn
      real  cvtotn
      real  cftotn
      real  cgltotn
      real  cghtotn
      real  chtotn
      real  cqtotp,cqtotp1
      real  cctotp
      real  citotp
      real  ciptotp
      real  crtotp
      real  cstotp
      real  cvtotp
      real  cftotp
      real  chltotp
      real  cgltotp
      real  cgmtotp
      real  cghtotp
      real  chtotp
      real  cqfac
      real  ccfac
      real  cifac
      real  cipfac
      real  crfac
      real  csfac
      real  cvfac
      real  cffac
      real  cglfac
      real  cghfac
      real  chfac
      
      real ssifac, qvapor
!
!   Miscellaneous variables
!
      integer ireadqf,lrho,lqsw,lqgl,lqgm ,lqgh 
      integer lqrw
      real vt
      real arg  ! gamma is a function
      real erbnd1, fdgt1, costhe1
      real qeps
      real dyi2,dzi2,cp608,bta1,cnit,dragh,dnz00,pii
      real qccrit,gf4br,gf4ds,gf4p5, gf3ds, gf1ds,gr

      
      real xdn0(lc:lhab)
      real xdn_new,drhodt
      
      integer l ,ltemq,inumgs, idelq

      real brz,arz,temq

      real ssival,tqvcon
      real cdx(lc:lhab)
      real cnox
      real cval,aval,eval,fval,gval ,qsign,ftelwc,qconkq
      real qconm,qconn,cfce15,gf8,gf4i,gf3p5,gf1a,gf1p5,qdiff,argrcnw
      real c4,bradp,bl2,bt2,dtrh,hrifac, hdia0,hdia1,civenta,civentb
      real civentc,civentd,civente,civentf,civentg,cireyn,xcivent
      real cipventa,cipventb,cipventc,cipventd,cipreyn,cirventa
      real cirventb
      integer igmrwa,igmrwb,igmswa, igmswb,igmfwa,igmfwb,igmhwa,igmhwb
      real rwventa ,rwventb,swventa,swventb,fwventa,fwventb,fwventc
      real hwventa,hwventb
      real    hwventc, hlventa, hlventb,  hlventc
      real  glventa, glventb, glventc
      real   gmventa, gmventb,  gmventc, ghventa, ghventb, ghventc
      real  dzfacp,  dzfacm,  cmassin,  cwdiar 
      real  rimmas, rhobar
      real   argtim, argqcw, argqxw, argtem
      real   frcswsw, frcswgl, frcswgm, frcswgh, frcswfw, frcswsw1
      real   frcglgl, frcglgm, frcglgh,  frcglfw, frcglgl1
      real   frcgmgl, frcgmgm, frcgmgh,  frcgmfw, frcgmgm1
      real   frcghgl, frcghgm, frcghgh,  frcghfw,  frcghgh1
      real   frcfwgl, frcfwgm, frcfwgh, frcfwfw,  frcfwfw1
      real   frcswrsw, frcswrgl,  frcswrgm,  frcswrgh, frcswrfw
      real   frcswrsw1
      real   frcrswsw, frcrswgl, frcrswgm, frcrswgh, frcrswfw
      real  frcrswsw1
      real  frcglrgl, frcglrgm, frcglrgh,  frcglrfw, frcglrgl1
      real  frcrglgl
      real  frcrglgm,  frcrglgh, frcrglfw, frcrglgl1
      real  frcgmrgl, frcgmrgm, frcgmrgh, frcgmrfw,  frcgmrgm1
      real  frcrgmgl, frcrgmgm,  frcrgmgh, frcrgmfw, frcrgmgm1
      real  sum,  qweps,  gf2a, gf4a, dqldt, dqidt, dqdt
      real frcghrgl, frcghrgm, frcghrgh, frcghrfw, frcghrgh1, frcrghgl
      real frcrghgm, frcrghgh,  frcrghfw, frcrghgh1
      real    a1,a2,a3,a4,a5,a6
      real   gamss
      real cdw, cdi, denom1, denom2, delqci1, delqip1
      real cirtotn,  ciptotn, cgmtotn, chltotn,  cirtotp
      real  cgmfac, chlfac,  cirfac
      integer igmhla, igmhlb, igmgla, igmglb, igmgma,  igmgmb
      integer igmgha, igmghb
      integer idqis, item, itim0 
      integer  iqgl, iqgm, iqgh, iqrw, iqsw 
      integer  itertd, ia
      
      integer :: infdo
      
      real tau, ewtmp
      
      integer cntnic_noliq
      real     q_noliqmn, q_noliqmx
      real     scsacimn, scsacimx
      
      double precision :: dtpinv
      
!   arrays for temporary bin space


      real :: qaacw ! combined qsacw-qhacw for WSM6 variation



!
! ####################################################################
!
!  Start routine
!
! ####################################################################



!

       pb(:) = 0.0
       pinit(:) = 0.0
      itile = nx
      jtile = ny
      ktile = nz
      ixend = nx
      jyend = ny
      kzend = nz
      nxend = nx + 1
      nyend = ny + 1
      nzend = nz
      kzbeg = 1
      nzbeg = 1

      istag = 0
      jstag = 0
      kstag = 1


!
!  slope intercepts
!

      IF ( ngs .lt. nz ) THEN
!       write(0,*) 'Error in ICEZVD: Must have ngs .ge. nz!'
!       STOP
      ENDIF

      cntnic_noliq = 0
      q_noliqmn = 0.0
      q_noliqmx = 0.0
      scsacimn = 0.0
      scsacimx = 0.0

      ldovol = .false.

      DO il = lc,lhab
        ldovol = ldovol .or. ( lvol(il) .gt. 1 )
      ENDDO


!      DO il = lc,lhab
!        write(iunit,*) 'delqnxa(',il,') = ',delqnxa(il)
!      ENDDO
      
!
!  density maximums and minimums
!

!
!  Set terminal velocities...
!    also set drag coefficients
!

      dtpinv = 1.d0/dtp

!

!
!  electricity constants
!
!  mixing ratio epsilon
!
      qeps  = 1.0e-20

!  rebound efficiency (erbnd)
!
!
!
!  constants
!

      cp608 = 0.608
      aradcw = -0.27544
      bradcw = 0.26249e+06
      cradcw = -1.8896e+10
      dradcw = 4.4626e+14
      bta1 = 0.6
      cnit = 1.0e-02
      dragh = 0.60
      dnz00 = 1.225
!      cs = 4.83607122
!      ds = 0.25
!  new values for  cs and ds
      cs = 12.42
      ds = 0.42
      pii = piinv ! 1./pi
      pid4 = pi/4.0 
!      qscrit = 6.0e-04
      gf1 = 1.0 ! gamma(1.0)
      gf1p5 = 0.8862269255  ! gamma(1.5)
      gf2 = 1.0 ! gamma(2.0)
      gf3 = 2.0 ! gamma(3.0)
      gf3p5 = 3.32335097 ! gamma(3.5)
      gf4 = 6.00 ! gamma(4.0)
      gf5 = 24.0 ! gamma(5.0)
      gf6 = 120.0 ! gamma(6.0)
      gf7 = 720.0 ! gamma(7.0)
      gf4br = 17.837861981813607 ! gamma(4.0+br)
      gf4ds = 10.41688578110938 ! gamma(4.0+ds)
      gf4p5 = 11.63172839656745 ! gamma(4.0+0.5)
      gf3ds = 3.0458730354120997 ! gamma(3.0+ds)
      gf1ds = 0.8863557896089221 ! gamma(1.0+ds)
      gr = 9.8
      gf43rds = 0.8929795116 ! gamma(4./3.)
      gf53rds = 0.9027452930 ! gamma(5./3.)
      gf73rds = 1.190639349 ! gamma(7./3.)
      gf83rds = 1.504575488 ! gamma(8./3.)
      
      gamice73fac =  (gamma(7./3. + cinu))**3/ (gamma(1. + cinu)**3 * (1. + cinu)**4)
      gamsnow73fac =  (gamma(7./3. + snu))**3/ (gamma(1. + snu)**3 * (1. + snu)**4)
!
!  constants
!
!
!  general constants for microphysics
!
      brz = 100.0
      arz = 0.66
      
      bfnu1 = (4. + alphar)*(5. + alphar)*(6. + alphar)/ &
     &       ((1. + alphar)*(2. + alphar)*(3. + alphar))

       galpharaut = (6.+alpharaut)*(5.+alpharaut)*(4.+alpharaut)/ &
     &             ((3.+alpharaut)*(2.+alpharaut)*(1.+alpharaut))
      
      vfrz = 0.523599*(dfrz)**3 
      vmlt = Min(xvmx(lr), 0.523599*(dmlt)**3 )
      vshd = Min(xvmx(lr), 0.523599*(dshd)**3 )

     

      tdtol = 1.0e-05
      tfrcbw = tfr - cbw
      tfrcbi = tfr - cbi
!
!

!
!  cw constants in mks units
!
!      cwmasn = 4.25e-15  ! radius of 1.0e-6
      mwfac = 6.0**(1./3.)
      IF ( ipconc .ge. 2 ) THEN
!        cwmasn = xvmn(lc)*1000.
!        cwradn = 1.0e-6
!        cwmasx = xvmx(lc)*1000.
      ENDIF
        rwmasn = xvmn(lr)*1000.
        rwmasx = xvmx(lr)*1000.

!
!  ci constants in mks units
!
      cimasn = Min(cimas0, cimas1) ! 12 microns for  0.1871*(xmas(mgs,li)**(0.3429))
      cimasx = 1.0e-8   ! 338 microns
      ccimx = 5000.0e3   ! max of 5000 per liter

!
!  constants for paramerization
!
!
!  set save counter (number of saves):  nsvcnt
!
!      nsvcnt = 0
      iend = 0


!      timetd1 = etime(tarray)
!      timetd1 = tarray(1)

!
!***********************************************************
!  start jy loop
!***********************************************************
!

!      do 9999 jy = 1,ny-jstag
!
!  VERY IMPORTANT:  SET jy = jgs
!
      jy = jgs
     
     
!      t1(:,:,:) = 0
!      t2(:,:,:) = 0
!      t3(:,:,:) = 0
!      t4(:,:,:) = 0
!      t5(:,:,:) = 0
!      t6(:,:,:) = 0
!      t8(:,:,:) = 0
      
      IF ( ipconc < 2 ) THEN ! Make a copy of cloud droplet mixing ratio to use for homogeneous freezing
        DO kz = 1,nz
         DO ix = 1,itile
           t9(ix,jy,kz) = an(ix,jy,kz,lc)
         ENDDO
        ENDDO
      ENDIF
      
!
!..Gather microphysics  
!
      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: ENTER GATHER STAGE'


      
      nxmpb = 1
      nzmpb = 1
      nxz = itile*nz
      numgs = nxz/ngs + 1
!      write(0,*) 'ICEZVD_GS: ENTER GATHER STAGE: nx,nz,nxz,numgs,ngs = ',nx,nz,nxz,numgs,ngs

      do 1000 inumgs = 1,numgs
      ngscnt = 0
      
      do kz = nzmpb,nz
      do ix = nxmpb,itile

      pqs(1) = t00(ix,jy,kz)
!      pqs(kz) = t00(ix,jy,kz)

      theta(1) = an(ix,jy,kz,lt)
      temg(1) = t0(ix,jy,kz)
      temcg(1) = temg(1) - tfr
      tqvcon = temg(1)-cbw
      ltemq = (temg(1)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )
      qvs(1) = pqs(1)*tabqvs(ltemq)
      qis(1) = pqs(1)*tabqis(ltemq)

      qss(1) = qvs(1)

!      IF ( jy .eq. 1 .and. ix .eq. 24 ) THEN
!       write(91,*) 'kz,qv,th: ',kz,an(ix,jy,kz,lv),an(ix,jy,kz,lt),pqs(kz),tabqvs(ltemq),qvs(kz)
!      ENDIF

      if ( temg(1) .lt. tfr ) then
!      if( qcw(kz) .le. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
!     >  qss(kz) = qis(kz)
!      if( qcw(kz) .gt. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
!     >   qss(kz) = (qcw(kz)*qvs(kz) + qci(kz)*qis(kz)) /
!     >   (qcw(kz) + qci(kz))
      qss(1) = qis(1)
      else
!       IF ( an(ix,jy,kz,lv)  .gt. qss(kz) ) THEN
!       write(iunit,*) 'qss exceeded at ',ix,jy,kz,qss(kz),an(ix,jy,kz,lv),temg(kz)
!       write(iunit,*) 'other temg = ',theta(kz)*(pinit(kz)+p2(ix,jy,kz))
!       ENDIF
      end if
!
      ishail = .false.
      IF ( lhl > 1 ) THEN
        IF ( an(ix,jy,kz,lhl)  .gt. qxmin(lhl) ) ishail = .true.
      ENDIF
      
      if ( an(ix,jy,kz,lv)  .gt. qss(1) .or.   &
     &     an(ix,jy,kz,lc)  .gt. qxmin(lc)   .or.    &
     &     an(ix,jy,kz,li)  .gt. qxmin(li)   .or.   &
     &     an(ix,jy,kz,lr)  .gt. qxmin(lr)   .or.   &
     &     an(ix,jy,kz,ls)  .gt. qxmin(ls)   .or.   &
     &     an(ix,jy,kz,lh)  .gt. qxmin(lh)   .or.  ishail ) then
      ngscnt = ngscnt + 1
      igs(ngscnt) = ix
      kgs(ngscnt) = kz
      if ( ngscnt .eq. ngs ) goto 1100
      end if
      enddo !ix
      nxmpb = 1
      enddo !kz
 1100 continue

      if ( ngscnt .eq. 0 ) go to 9998

      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: dbg = 5'

!      write(0,*) 'allocating qc

      
      xv(:,:) = 0.0
      xmas(:,:) = 0.0
      vtxbar(:,:,:) = 0.0
      xdia(:,:,:) = 0.0
      raindn(:,:) = 900.
      cx(:,:) = 0.0
      alpha(:,:) = 0.0
      DO il = li,lhab
        DO mgs = 1,ngscnt
          rimdn(mgs,il)  = rimedens ! xdn0(il)
        ENDDO
      ENDDO
!
!  define temporaries for state variables to be used in calculations
!
      do mgs = 1,ngscnt
      kgsm(mgs) = max(kgs(mgs)-1,1)
      kgsp(mgs) = min(kgs(mgs)+1,nz-1)
      kgsm2(mgs) = Max(kgs(mgs)-2,1)
      theta0(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
      thetap(mgs) = an(igs(mgs),jy,kgs(mgs),lt) - theta0(mgs)
      theta(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
      qv0(mgs) = an(igs(mgs),jy,kgs(mgs),lv)
      qwvp(mgs) = an(igs(mgs),jy,kgs(mgs),lv)  - qv0(mgs) ! qv0(mgs) is full qv, so qwvp starts as zero!

      pres(mgs) = pn(igs(mgs),jy,kgs(mgs)) + pb(kgs(mgs))
      pipert(mgs) = p2(igs(mgs),jy,kgs(mgs))
      rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
      rhoinv(mgs) = 1.0/rho0(mgs)
      rhovt(mgs) = Sqrt(rho00/rho0(mgs))
      pi0(mgs) = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs))
      temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
      temgkm1(mgs) = t0(igs(mgs),jy,kgsm(mgs))
      temgkm2(mgs) = t0(igs(mgs),jy,kgsm2(mgs))
      pk(mgs)   = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs)) ! t77(igs(mgs),jy,kgs(mgs))
      temcg(mgs) = temg(mgs) - tfr
      qss0(mgs) = (380.0)/(pres(mgs))
      pqs(mgs) = (380.0)/(pres(mgs))
      ltemq = (temg(mgs)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )
      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
      qis(mgs) = pqs(mgs)*tabqis(ltemq)
!      es(mgs)  = 6.1078e2*tabqvs(ltemq)
!      eis(mgs) = 6.1078e2*tabqis(ltemq)
      cnostmp(mgs) = cno(ls)
!

      il5(mgs) = 0
      if ( temg(mgs) .lt. tfr ) then
      il5(mgs) = 1
      end if
      enddo !mgs
      
      IF ( ipconc < 1 .and. lwsm6 ) THEN
        DO mgs = 1,ngscnt
          tmp = Min( 0.0, temcg(mgs) )
          cnostmp(mgs) = Min( 2.e8, 2.e6*exp(0.12*tmp) )
        ENDDO
      ENDIF


!
! zero arrays that are used but not otherwise set (tm)
!
      do mgs = 1,ngscnt
         qhshr(mgs) = 0.0 
       end do
!
!  set temporaries for microphysics variables
!
      DO il = lv,lhab
      do mgs = 1,ngscnt
        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0) 
      ENDDO
      end do

      qxw(:,:) = 0.0



        scx(:,:) = 0.0
!
!  set shape parameters
!
      IF ( imurain == 1 ) THEN
        alpha(:,lr) = alphar
      ELSEIF ( imurain == 3 ) THEN
        alpha(:,lr) = xnu(lr)
      ENDIF
      
      alpha(:,li) = xnu(li)

      IF ( imusnow == 1 ) THEN
        alpha(:,ls) = alphas
      ELSEIF ( imusnow == 3 ) THEN
        alpha(:,ls) = xnu(ls)
      ENDIF
      
      DO il = lc,lhab
      do mgs = 1,ngscnt
        IF ( il .ge. lg ) alpha(mgs,il) = dnu(il)
        DO ic = lr,lhab
        dab0lh(mgs,il,ic) = dab0(ic,il)
        dab1lh(mgs,il,ic) = dab1(ic,il)
        ENDDO
      ENDDO
      end do
      
      
!      DO mgs = 1,ngscnt
        da0lh(:) = da0(lh)
        da0lr(:) = da0(lr)
        IF ( lzh < 1 .or. lzhl < 1 ) THEN
          rzxhlh(:) = rzhl/rz
        ELSEIF ( lzh > 1 .and. lzhl > 1 ) THEN
          rzxhlh(:) = 1.
        ENDIF
        IF ( lzr > 1 ) THEN
          rzxh(:) = 1.
          rzxhl(:) = 1.
        ELSE
          rzxh(:) = rz
          rzxhl(:) = rzhl
        ENDIF
        
        IF ( imurain == 1 .and. imusnow == 3 ) THEN
          rzxs(:) = rzs
        ELSEIF ( imurain == imusnow ) THEN
          rzxs(:) = 1.
        ENDIF
 !     ENDDO
      
      IF ( lhl .gt. 1 ) THEN
      DO mgs = 1,ngscnt
        da0lhl(mgs) = da0(lhl)
      ENDDO
      ENDIF
      
      ventrx(:) = ventr
      ventrxn(:) = ventrn

!
!  set concentrations
!
!      ssmax = 0.0
      
      
      
      if ( ipconc .ge. 1 ) then
       do mgs = 1,ngscnt
        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
        IF ( lcina .gt. 1 ) THEN
         cina(mgs) = an(igs(mgs),jy,kgs(mgs),lcina)
        ELSE
         cina(mgs) = cx(mgs,li)
        ENDIF
        IF ( lcin > 1 ) THEN
         ccin(mgs) = an(igs(mgs),jy,kgs(mgs),lcin)
        ENDIF
       end do
      end if
      if ( ipconc .ge. 2 ) then
       do mgs = 1,ngscnt
        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
!        cx(mgs,lc) = Min( ccwmx, cx(mgs,lc) )
        IF ( lss > 1 ) THEN
        ssmax(mgs) = an(igs(mgs),jy,kgs(mgs),lss)
        ENDIF
        IF ( lccn .gt. 1 ) THEN
         ccnc(mgs) = an(igs(mgs),jy,kgs(mgs),lccn)
        ELSE
         ccnc(mgs) = 0.0
        ENDIF
        IF ( lccna .gt. 1 ) THEN
         ccna(mgs) = an(igs(mgs),jy,kgs(mgs),lccna)
        ELSE
         ccna(mgs) = cx(mgs,lc)
        ENDIF
       end do
!       ELSE
!       cx(mgs,lc) = Abs(ccn)
      end if
      if ( ipconc .ge. 3 ) then
       do mgs = 1,ngscnt
        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
        IF ( qx(mgs,lr) .le. qxmin(lr) ) THEN
!          cx(mgs,lr) = 0.0
        ELSEIF ( cx(mgs,lr) .eq. 0.0 .and. qx(mgs,lr) .lt. 3.0*qxmin(lr) ) THEN
          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lr)
          qx(mgs,lr) = 0.0
        ELSE
          cx(mgs,lr) = Max( 1.e-9, cx(mgs,lr) )
        ENDIF
       end do
      end if
      if ( ipconc .ge. 4 ) then
       do mgs = 1,ngscnt
        cx(mgs,ls) = Max(an(igs(mgs),jy,kgs(mgs),lns), 0.0)
        IF ( qx(mgs,ls) .le. qxmin(ls) ) THEN
!          cx(mgs,ls) = 0.0
        ELSEIF ( cx(mgs,ls) .eq. 0.0 .and. qx(mgs,ls) .lt. 3.0*qxmin(ls) ) THEN
          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,ls)
          qx(mgs,ls) = 0.0
        ELSE
          cx(mgs,ls) = Max( 1.e-9, cx(mgs,ls) )

         IF ( ilimit .ge. ipc(ls) ) THEN
            tmp = (xdn0(ls)*cx(mgs,ls))/(rho0(mgs)*qx(mgs,ls))
            tmp2 = (tmp*(3.14159))**(1./3.)
            cnox = cx(mgs,ls)*(tmp2)
         IF ( cnox .gt. 3.0*cno(ls) ) THEN
           cx(mgs,ls) = 3.0*cno(ls)/tmp2
         ENDIF
         ENDIF
        ENDIF
       end do
      end if
      if ( ipconc .ge. 5 ) then
       do mgs = 1,ngscnt

        cx(mgs,lh) = Max(an(igs(mgs),jy,kgs(mgs),lnh), 0.0)
        IF ( qx(mgs,lh) .le. qxmin(lh) ) THEN
!          cx(mgs,lh) = 0.0
        ELSEIF ( cx(mgs,lh) .eq. 0.0 .and. qx(mgs,lh) .lt. 3.0*qxmin(lh) ) THEN
          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lh) 
          qx(mgs,lh) = 0.0
        ELSE
          cx(mgs,lh) = Max( 1.e-9, cx(mgs,lh) )
         IF ( ilimit .ge. ipc(lh) ) THEN
            tmp = (xdn0(lh)*cx(mgs,lh))/(rho0(mgs)*qx(mgs,lh))
            tmp2 = (tmp*(3.14159))**(1./3.)
            cnox = cx(mgs,lh)*(tmp2)
         IF ( cnox .gt. 3.0*cno(lh) ) THEN
           cx(mgs,lh) = 3.0*cno(lh)/tmp2
         ENDIF
         ENDIF
        ENDIF
       end do
      end if

      if ( lhl .gt. 1 .and. ipconc .ge. 5 ) then
       do mgs = 1,ngscnt

        cx(mgs,lhl) = Max(an(igs(mgs),jy,kgs(mgs),lnhl), 0.0)
        IF ( qx(mgs,lhl) .le. qxmin(lhl) ) THEN
          cx(mgs,lhl) = 0.0
        ELSEIF ( cx(mgs,lhl) .eq. 0.0 .and. qx(mgs,lhl) .lt. 3.0*qxmin(lhl) ) THEN
          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lhl) 
          qx(mgs,lhl) = 0.0
        ELSE
          cx(mgs,lhl) = Max( 1.e-9, cx(mgs,lhl) )
         IF ( ilimit .ge. ipc(lhl) ) THEN
            tmp = (xdn0(lhl)*cx(mgs,lhl))/(rho0(mgs)*qx(mgs,lhl))
            tmp2 = (tmp*(3.14159))**(1./3.)
            cnox = cx(mgs,lhl)*(tmp2)
         IF ( cnox .gt. 3.0*cno(lhl) ) THEN
           cx(mgs,lhl) = 3.0*cno(lhl)/tmp2
         ENDIF
         ENDIF
        ENDIF
       end do
      end if

!
! Set mean particle volume
!
      IF ( ldovol ) THEN
      
      vx(:,:) = 0.0
      
       DO il = li,lhab
        
        IF ( lvol(il) .ge. 1 ) THEN
        
          DO mgs = 1,ngscnt
            vx(mgs,il) = Max(an(igs(mgs),jy,kgs(mgs),lvol(il)), 0.0)
          ENDDO

        ENDIF

       ENDDO

      ENDIF





!
!  set factors
!
      do mgs = 1,ngscnt
!
      ssi(mgs) = qx(mgs,lv)/qis(mgs)
      ssw(mgs) = qx(mgs,lv)/qvs(mgs)
!
      tsqr(mgs) = temg(mgs)**2
!
      temgx(mgs) = min(temg(mgs),313.15)
      temgx(mgs) = max(temgx(mgs),233.15)
      felv(mgs) = 2500837.367 * (273.15/temgx(mgs))**((0.167)+(3.67e-4)*temgx(mgs))
!
      temcgx(mgs) = min(temg(mgs),273.15)
      temcgx(mgs) = max(temcgx(mgs),223.15)
      temcgx(mgs) = temcgx(mgs)-273.15

! felf = latent heat of fusion, fels = LH of sublimation, felv = LH of vaporization
      felf(mgs) = 333690.6098 + (2030.61425)*temcgx(mgs) - (10.46708312)*temcgx(mgs)**2
!
      fels(mgs) = felv(mgs) + felf(mgs)
!
      felvs(mgs) = felv(mgs)*felv(mgs)
      felss(mgs) = fels(mgs)*fels(mgs)
      
        IF ( eqtset <= 1 ) THEN
          felvcp(mgs) = felv(mgs)*cpi
          felscp(mgs) = fels(mgs)*cpi
          felfcp(mgs) = felf(mgs)*cpi
        ELSE
          
          ! equations from appendix in Bryan and Morrison (2012, MWR)
          ! note that rw is Rv in the paper, and rd is R.
          
          tmp = qx(mgs,li)+qx(mgs,ls)+qx(mgs,lh)
          IF ( lhl > 1 ) tmp = tmp + qx(mgs,lhl)
          cvm = cv+cvv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
                                  +cpigb*(tmp)

          IF ( eqtset == 2 ) THEN ! compact form from treating dT/dt = theta*d(pi)/dt + pi*d(theta)dt and then applied to theta assuming constant pi
          felvcp(mgs) = (felv(mgs)-rw*temg(mgs))/cvm
          felscp(mgs) = (fels(mgs)-rw*temg(mgs))/cvm
          felfcp(mgs) = felf(mgs)/cvm
          
          ELSE
           ! equivalent version that applies separate updates of latent heating to theta and pi, when both are returned.

          cpm = cp+cpv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
                                  +cpigb*(tmp)
          rmm=rd+rw*qx(mgs,lv)
          
          felvcp(mgs) = (felv(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
          felscp(mgs) = (fels(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
          felfcp(mgs) = felf(mgs)*cv/(cp*cvm)

          felvpi(mgs) = pi0(mgs)*rovcp*(felv(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm
          felspi(mgs) = pi0(mgs)*rovcp*(fels(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm 
          felfpi(mgs) = pi0(mgs)*rovcp*(felf(mgs)/(cvm*temg(mgs)))
          
          ENDIF

        ENDIF
!
      fgamw(mgs) = felvcp(mgs)/pi0(mgs)
      fgams(mgs) = felscp(mgs)/pi0(mgs)
!
      fcqv1(mgs) = 4098.0258*pi0(mgs)*fgamw(mgs)
      fcqv2(mgs) = 5807.6953*pi0(mgs)*fgams(mgs)
      fcc3(mgs) = felfcp(mgs)/pi0(mgs)
!
!  fwvdf = water vapor diffusivity
      fwvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)*(101325.0/(pres(mgs)))
!
! fadvisc = kinematic viscosity
      fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))*(temg(mgs)/296.0)**(1.5) ! dynamic visc.
!
      fakvisc(mgs) = fadvisc(mgs)*rhoinv(mgs) ! divide by rho_air to get kinematic visc. (note the 'k' vs. 'd')
!
      temcgx(mgs) = min(temg(mgs),273.15)
      temcgx(mgs) = max(temcgx(mgs),233.15)
      temcgx(mgs) = temcgx(mgs)-273.15
      fci(mgs) = (2.118636 + 0.007371*(temcgx(mgs)))*(1.0e+03)
!
      if ( temg(mgs) .lt. 273.15 ) then
      temcgx(mgs) = min(temg(mgs),273.15)
      temcgx(mgs) = max(temcgx(mgs),233.15)
      temcgx(mgs) = temcgx(mgs)-273.15
      fcw(mgs) = 4203.1548  + (1.30572e-2)*((temcgx(mgs)-35.)**2)   &
     &                 + (1.60056e-5)*((temcgx(mgs)-35.)**4)
      end if
      if ( temg(mgs) .ge. 273.15 ) then
      temcgx(mgs) = min(temg(mgs),308.15)
      temcgx(mgs) = max(temcgx(mgs),273.15)
      temcgx(mgs) = temcgx(mgs)-273.15
      fcw(mgs) = 4243.1688  + (3.47104e-1)*(temcgx(mgs)**2)
      end if
!
      ftka(mgs) = tka0*fadvisc(mgs)/advisc1  ! thermal conductivity: proportional to dynamic viscosity
      fthdf(mgs) = ftka(mgs)*cpi*rhoinv(mgs)
!
      fschm(mgs) = (fakvisc(mgs)/fwvdf(mgs))  ! Schmidt number
      fpndl(mgs) = (fakvisc(mgs)/fthdf(mgs))  ! Prandl number (not used)
!
      fai(mgs) = (fels(mgs)**2)/(ftka(mgs)*rw*temg(mgs)**2)
      fbi(mgs) = (1.0/(rho0(mgs)*fwvdf(mgs)*qis(mgs)))
      fav(mgs) = (felv(mgs)**2)/(ftka(mgs)*rw*temg(mgs)**2)
      fbv(mgs) = (1.0/(rho0(mgs)*fwvdf(mgs)*qvs(mgs)))
!
      end do
!
!
!   ice habit fractions
!
!
!
!  Set density
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set density'
!

      do mgs = 1,ngscnt
        xdn(mgs,li) = xdn0(li)
        xdn(mgs,lc) = xdn0(lc)
        xdn(mgs,lr) = xdn0(lr)
        xdn(mgs,ls) = xdn0(ls)
        xdn(mgs,lh) = xdn0(lh)
        IF ( lvol(ls) .gt. 1 ) THEN
         IF ( vx(mgs,ls) .gt. 0.0 .and. qx(mgs,ls) .gt. qxmin(ls) ) THEN
           xdn(mgs,ls) = Min( xdnmx(ls), Max( xdnmn(ls), rho0(mgs)*qx(mgs,ls)/vx(mgs,ls) ) )
         ENDIF
        ENDIF

        IF ( lvol(lh) .gt. 1 ) THEN
         IF ( vx(mgs,lh) .gt. 0.0 .and. qx(mgs,lh) .gt. qxmin(lh) ) THEN
           IF ( mixedphase ) THEN
           ELSE
             dnmx = xdnmx(lh)
           ENDIF
           xdn(mgs,lh) = Min( dnmx, Max( xdnmn(lh), rho0(mgs)*qx(mgs,lh)/vx(mgs,lh) ) )
           vx(mgs,lh) = rho0(mgs)*qx(mgs,lh)/xdn(mgs,lh)
         ENDIF
        ENDIF

        IF ( lhl .gt. 1 ) THEN

          xdn(mgs,lhl) = xdn0(lhl)

          IF ( lvol(lhl) .gt. 1 ) THEN
           IF ( vx(mgs,lhl) .gt. 0.0 .and. qx(mgs,lhl) .gt. qxmin(lhl) ) THEN

           IF ( mixedphase .and. lhlw > 1 ) THEN
           ELSE
             dnmx = xdnmx(lhl)
           ENDIF

             xdn(mgs,lhl) = Min( dnmx, Max( xdnmn(lhl), rho0(mgs)*qx(mgs,lhl)/vx(mgs,lhl) ) )
             vx(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/xdn(mgs,lhl)
           ENDIF
          ENDIF

        ENDIF

! adjust density for wet snow and graupel (Ferrier 94)
! (aps): for the time being, do not adjust density until we keep track of fully melted snow/graupel
!
!        IF (mixedphase) THEN
          IF (qsdenmod) THEN
           IF(fsw(mgs) .gt. 0.01) THEN
            xdn(mgs,ls) = (1.-fsw(mgs))*rho_qs + fsw(mgs)*rho_qr        !Ferrier: 100./(1.-fsw(mgs))
            IF(fsw(mgs) .eq. 1.) xdn(mgs,ls) = rho_qr   ! fsw = 1 means it's liquid water, yo!
           ENDIF
          ENDIF

          IF (qhdenmod) THEN
!          IF(fhw(mgs) .gt. 0.01) THEN
!           IF(fhw(mgs) .lt. 1.) xdn(mgs,lh) = rho_qh / (1. - fhw(mgs))       !Ferrier: 400./(1.-fsw(mgs))
!           IF(fhw(mgs) .eq. 1.) xdn(mgs,lh) = rho_qr   ! fhw = 1 means it's liquid water, yo!
!          ENDIF
          ENDIF
!        ENDIF

      end do


!
!  set some values for ice nucleation
!
      do mgs = 1,ngscnt
      kp1 = Min(nz, kgs(mgs)+1 )
      wvel(mgs) = (0.5)*(w(igs(mgs),jgs,kp1)   &
     &                  +w(igs(mgs),jgs,kgs(mgs)))

      
        wvelkm1(mgs) = (0.5)*(w(igs(mgs),jgs,kgs(mgs))   &
     &                    +w(igs(mgs),jgs,kgsm(mgs)))
      cninm(mgs) = t7(igs(mgs),jgs,kgsm(mgs))
      cnina(mgs) = t7(igs(mgs),jgs,kgs(mgs))
      cninp(mgs) = t7(igs(mgs),jgs,kgsp(mgs))
      end do

!
!  Set a couple of cloud variables...
!

!      SUBROUTINE setvt(ngscnt,qx,qxmin,cx,rho0,rhovt,xdia,cno,
!     :                 xmas,xdn,xvmn,xvmx,xv,cdx,
!     :                 ipconc,ndebug)
!      SUBROUTINE setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno, &
!     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,            &
!     &                 ipconc1,ndebug1,ngs,nz,kgs,cwnccn,fadvisc,   &
!     &                 cwmasn,cwmasx,cwradn,cnina,cimna,cimxa,      &
!     &                 itype1a,itype2a,temcg,infdo,alpha)


      infdo = 0
      IF ( io_flag .and. nxtra > 1 ) infdo = 1

      call setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno,cnostmp,   &
     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,   &
     &                 ipconc,ndebug,ngs,nz,kgs,fadvisc,   &
     &                 cwmasn,cwmasx,cwradn,cnina,cimn,cimx,   &
     &                 itype1,itype2,temcg,infdo,alpha,0,axh,bxh,axhl,bxhl)


       IF ( lwsm6 .and. ipconc == 0 ) THEN
         tmp = Max(qxmin(lh), qxmin(ls))
         DO mgs = 1,ngscnt
           sum = qx(mgs,lh) + qx(mgs,ls)
           IF ( sum > tmp ) THEN
             vt2ave(mgs) = (qx(mgs,lh)*vtxbar(mgs,lh,1) + qx(mgs,ls)*vtxbar(mgs,ls,1))/sum
           ELSE
             vt2ave(mgs) = 0.0
           ENDIF
         ENDDO
       ENDIF


!
!  Set number concentrations (need xdia from setvt)
!
      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set concentration'
      IF ( ipconc .lt. 1 ) THEN
         cina(1:ngscnt) = cx(1:ngscnt,li)
      ENDIF
      if ( ipconc .lt. 5 ) then
      do mgs = 1,ngscnt


      IF ( ipconc .lt. 3 ) THEN
!      cx(mgs,lr) = 0.0
      if ( qx(mgs,lr) .gt. qxmin(lh) )  then
!      cx(mgs,lr) = cno(lr)*xdia(mgs,lr,1)
!      xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
      end if
      ENDIF

      IF ( ipconc .lt. 4 ) THEN
!      tmp = cx(mgs,ls)
!      cx(mgs,ls) = 0.0
      if ( qx(mgs,ls) .gt. qxmin(ls) )  then
!      cx(mgs,ls) = cno(ls)*xdia(mgs,ls,1)
!      xv(mgs,ls) = rho0(mgs)*qx(mgs,ls)/(xdn(mgs,ls)*cx(mgs,ls))
      end if
      ENDIF ! ( ipconc .lt. 4 )

      IF ( ipconc .lt. 5 ) THEN


!      cx(mgs,lh) = 0.0
      if ( qx(mgs,lh) .gt. qxmin(lh) )  then
!      cx(mgs,lh) = cno(lh)*xdia(mgs,lh,1)
!      xv(mgs,lh) = Max(xvmn(lh), rho0(mgs)*qx(mgs,lh)/(xdn(mgs,lh)*cx(mgs,lh)) )
!      xdia(mgs,lh,3) = (xv(mgs,lh)*6./pi)**(1./3.) 
      end if

      ENDIF ! ( ipconc .lt. 5 )

      end do
      end if
      
      IF ( ipconc .ge. 2 ) THEN
      DO mgs = 1,ngscnt
        rb(mgs) = 0.5*xdia(mgs,lc,1)*((1./(1.+cnu)))**(1./6.)
        xl2p(mgs) = Max(0.0d0, 2.7e-2*xdn(mgs,lc)*cx(mgs,lc)*xv(mgs,lc)*   &
     &           ((0.5e20*rb(mgs)**3*xdia(mgs,lc,1))-0.4) )
        IF ( rb(mgs) .gt. 3.51e-6 ) THEN
!          rh(mgs) = Max( 0.5d0*xdia(mgs,lc,1), 6.3d-4/(1.d6*(rb(mgs) - 3.5d-6)) )
          rh(mgs) = Max( 41.d-6, 6.3d-4/(1.d6*(rb(mgs) - 3.5d-6)) )
        ELSE
          rh(mgs) = 41.d-6
        ENDIF
        IF ( xl2p(mgs) .gt. 0.0 ) THEN
          nh(mgs) = 4.2d9*xl2p(mgs)
        ELSE
          nh(mgs) = 1.e30
        ENDIF
      ENDDO
      ENDIF
      
!
!
!              
!
!  maximum depletion tendency by any one source
!
!
      if( ndebug .ge. 0 ) THEN
!mpi!        write(0,*) 'Set depletion max/min1'
      endif
      do mgs = 1,ngscnt
      qvimxd(mgs) = 0.70*(qx(mgs,lv)-qis(mgs))/dtp ! depletion by all vap. dep to ice.
      qvimxd(mgs) = max(qvimxd(mgs), 0.0)
!      qimxd(mgs)  = 0.20*qx(mgs,li)/dtp
!      qcmxd(mgs)  = 0.20*qx(mgs,lc)/dtp
!      qrmxd(mgs)  = 0.20*qx(mgs,lr)/dtp
!      qsmxd(mgs)  = 0.20*qx(mgs,ls)/dtp
!      qhmxd(mgs)  = 0.20*qx(mgs,lh)/dtp

      frac = 0.1d0
      qimxd(mgs)  = frac*qx(mgs,li)/dtp
      qcmxd(mgs)  = frac*qx(mgs,lc)/dtp
      qrmxd(mgs)  = frac*qx(mgs,lr)/dtp
      qsmxd(mgs)  = frac*qx(mgs,ls)/dtp
      qhmxd(mgs)  = frac*qx(mgs,lh)/dtp
      IF ( lhl > 1 ) qhlmxd(mgs)  = frac*qx(mgs,lhl)/dtp
      end do
!
      if( ndebug .ge. 0 ) THEN
!mpi!        write(0,*) 'Set depletion max/min2'
      endif

      do mgs = 1,ngscnt
!
      if ( qx(mgs,lc) .le. qxmin(lc) ) then
      ccmxd(mgs)  = 0.20*cx(mgs,lc)/dtp
      else
      IF ( ipconc .ge. 2 ) THEN
        ccmxd(mgs)  = frac*cx(mgs,lc)/dtp
      ELSE
        ccmxd(mgs)  = frac*qx(mgs,lc)/(xmas(mgs,lc)*rho0(mgs)*dtp)
      ENDIF
      end if
!
      if ( qx(mgs,li) .le. qxmin(li) ) then
      cimxd(mgs)  = frac*cx(mgs,li)/dtp
      else
      IF ( ipconc .ge. 1 ) THEN
        cimxd(mgs)  = frac*cx(mgs,li)/dtp
      ELSE
        cimxd(mgs)  = frac*qx(mgs,li)/(xmas(mgs,li)*rho0(mgs)*dtp)
      ENDIF
      end if
!
!
      crmxd(mgs)  = 0.10*cx(mgs,lr)/dtp
      csmxd(mgs)  = frac*cx(mgs,ls)/dtp
      chmxd(mgs)  = frac*cx(mgs,lh)/dtp

      ccmxd(mgs)  = frac*cx(mgs,lc)/dtp
      cimxd(mgs)  = frac*cx(mgs,li)/dtp
      crmxd(mgs)  = frac*cx(mgs,lr)/dtp
      csmxd(mgs)  = frac*cx(mgs,ls)/dtp
      chmxd(mgs)  = frac*cx(mgs,lh)/dtp

      qxmxd(mgs,lv) = Max(0.0, 0.1*(qx(mgs,lv) - qvs(mgs))/dtp)

      DO il = lc,lhab
       qxmxd(mgs,il) = frac*qx(mgs,il)/dtp
       cxmxd(mgs,il) = frac*cx(mgs,il)/dtp
      ENDDO

      end do




! calculate maximum mass diameters

!
!
!  microphysics source terms (1/s) for mixing ratios 
!
!
!
!  Collection efficiencies:
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set collection efficiencies'
!
      do mgs = 1,ngscnt
!
!
!
      erw(mgs) = 0.0
      esw(mgs) = 0.0
      ehw(mgs) = 0.0
      ehlw(mgs) = 0.0
!      ehxw(mgs) = 0.0
!
      err(mgs) = 0.0
      esr(mgs) = 0.0
      il2(mgs) = 0
      il3(mgs) = 0
      ehr(mgs) = 0.0
      ehlr(mgs) = 0.0
!      ehxr(mgs) = 0.0
!
      eri(mgs) = 0.0
      esi(mgs) = 0.0
      ehi(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehi*ehiclsn
      ehli(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehli*ehliclsn
!      ehxi(mgs) = 0.0
!
      ers(mgs) = 0.0
      ess(mgs) = 0.0
      ehs(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehs*ehsclsn
      ehls(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehls*ehlsclsn
      ehscnv(mgs) = 0.0
!      ehxs(mgs) = 0.0
!
      eiw(mgs) = 0.0
      eii(mgs) = 0.0

      ehsclsn(mgs) = 0.0
      ehiclsn(mgs) = 0.0
      ehlsclsn(mgs) = 0.0
      ehliclsn(mgs) = 0.0
      esiclsn(mgs) = 0.0


      icwr(mgs) = 1
      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
       cwrad = 0.5*xdia(mgs,lc,1)
      DO il = 1,8
         IF ( cwrad .ge. 1.e-6*cwr(il,1) ) icwr(mgs) = il
      ENDDO
      ENDIF


      irwr(mgs) = 1
      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
         rwrad = 0.5*xdia(mgs,lr,3)  ! changed to mean volume diameter (10/6/06)
      DO il = 1,6
         IF ( rwrad .ge. 1.e-6*grad(il,1) ) irwr(mgs) = il
      ENDDO
      ENDIF


      igwr(mgs) = 1
!      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
!         rwrad = 0.5*xdia(mgs,lr,1)
! setting erw = 1 always, so now use igwr for graupel
      IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
         rwrad = 0.5*xdia(mgs,lh,3)  ! changed to mean volume diameter (10/6/06)
      DO il = 1,6
         IF ( rwrad .ge. 1.e-6*grad(il,1) ) igwr(mgs) = il
      ENDDO
      ENDIF

      IF ( lhl .gt. 1 ) THEN ! hail is turned on
      ihlr(mgs) = 1
      IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
         rwrad = 0.5*xdia(mgs,lhl,3)  ! changed to mean volume diameter (10/6/06)
      DO il = 1,6
         IF ( rwrad .ge. 1.e-6*grad(il,1) ) ihlr(mgs) = il
      ENDDO
      ENDIF
      ENDIF

!
!
!  Ice-Ice: Collection (cxc) efficiencies
!
!
      if ( qx(mgs,li) .gt. qxmin(li) ) then
!      IF ( ipconc .ge. 14 ) THEN
!       eii(mgs)=0.1*exp(0.1*temcg(mgs))
!       if ( temg(mgs) .lt. 243.15 .and. qx(mgs,lc) .gt. 1.e-6 ) then
!        eii(mgs)=0.1
!       end if
!      
!      ELSE
        eii(mgs) = exp(0.025*Min(temcg(mgs),0.0))  ! alpha1 from LFO83 (21)
!      ENDIF
      if ( temg(mgs) .gt. 273.15 ) eii(mgs) = 1.0
      end if
!
!
!
!  Ice-cloud water: Collection (cxc) efficiencies
!
!
      eiw(mgs) = 0.0
      if ( qx(mgs,li).gt.qxmin(li) .and. qx(mgs,lc).gt.qxmin(lc) ) then
      if (xdia(mgs,lc,1).gt.15.0e-06 .and. xdia(mgs,li,1).gt.30.0e-06) then
! erm 5/10/2007 test following change:
!      if (xdia(mgs,lc,1).gt.12.0e-06 .and. xdia(mgs,li,1).gt.50.0e-06) then
      eiw(mgs) = 0.5
      end if
      if ( temg(mgs) .ge. 273.15 ) eiw(mgs) = 0.0
      end if
!
!
!
!  Rain: Collection (cxc) efficiencies
!
!
      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lc).gt.qxmin(lc) ) then

       IF ( lnr .gt. 1 ) THEN
       erw(mgs) = 1.0

       ELSE

!      cwrad = 0.5*xdia(mgs,lc,1)
!      erw(mgs) =
!     >  min((aradcw + cwrad*(bradcw + cwrad*
!     <  (cradcw + cwrad*(dradcw)))), 1.0)
!       IF ( xdia(mgs,lc,1) .lt. 2.4e-06 .or. xdia(mgs,lr,1) .le. 50.0e-6 ) THEN
!          erw(mgs)=0.0
!       ENDIF
!       erw(mgs) = ew(icwr(mgs),igwr(mgs))
! interpolate along droplet radius
       ic = icwr(mgs)
       icp1 = Min( 8, ic+1 )
       ir = irwr(mgs)
       irp1 = Min( 6, ir+1 )
       cwrad = 0.5*xdia(mgs,lc,3)
       rwrad = 0.5*xdia(mgs,lr,3)
       
       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)

!       write(iunit,*) 'slop1: ',slope1,slope2,ew(ic,ir),cwr(ic,2)

       x1 = ew(ic,  ir) + slope1*Max(0.0, (cwrad - cwr(ic,1)) )
       x2 = ew(icp1,ir) + slope2*Max(0.0, (cwrad - cwr(ic,1)) )

       slope1 = (x2 - x1)*grad(ir,2)

       erw(mgs) = Max(0.0, x1 + slope1*Max(0.0, (rwrad - grad(ir,1)) ))

!       write(iunit,*) 'erw: ',erw(mgs),1.e6*cwrad,1.e6*rwrad,ic,ir,x1,x2
!       write(iunit,*)

       erw(mgs) = Max(0.0, erw(mgs) )
       IF ( rwrad .lt. 50.e-6 ) THEN
         erw(mgs) = 0.0
       ELSEIF (  rwrad .lt. 100.e-6 ) THEN  ! linear change from zero at 50 to erw at 100 microns
         erw(mgs) = erw(mgs)*(rwrad - 50.e-6)/50.e-6
       ENDIF

       ENDIF
      end if
      IF ( cx(mgs,lc) .le. 0.0 ) erw(mgs) = 0.0
!
      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lr).gt.qxmin(lr) ) then
      err(mgs)=1.0
      end if
!
      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,ls).gt.qxmin(ls) ) then
      ers(mgs)=1.0
      end if
!
      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,li).gt.qxmin(li) ) then
!        IF ( vtxbar(mgs,lr,1) .gt. vtxbar(mgs,li,1) .and.
!     :       xdia(mgs,lr,3) .gt. 200.e-6 .and. xdia(mgs,li,3) .gt. 100.e-6 ) THEN
         eri(mgs) = eri0
!      cwrad = 0.5*xdia(mgs,li,3)
!      eri(mgs) =
!     >  1.0*min((aradcw + cwrad*(bradcw + cwrad*
!     <  (cradcw + cwrad*(dradcw)))), 1.0)
!         ENDIF
!       if ( xdia(mgs,li,1) .lt. 10.e-6 ) eri(mgs)=0.0
       if ( xdia(mgs,li,3) .lt. 40.e-6 ) eri(mgs)=0.0
      end if
!
!
!  Snow aggregates: Collection (cxc) efficiencies
!
! Modified by ERM with a linear function for small droplets and large
! snow agg. based numerical data from Wang and Ji (1992) in P&K 1997, which
! allows collection of very small droplets, albeit at low efficiency.  But slow
! fall speeds of snow make up for the efficiency.
!
      esw(mgs) = 0.0
      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,lc).gt.qxmin(lc) ) then
        esw(mgs) = 0.5
        if ( xdia(mgs,lc,1) .gt. 15.e-6 .and. xdia(mgs,ls,1) .gt. 100.e-6) then
          esw(mgs) = 0.5
        ELSEIF ( xdia(mgs,ls,1) .ge. 500.e-6 ) THEN
          esw(mgs) = Min(0.5, 0.05 + (0.8-0.05)/(40.e-6)*xdia(mgs,lc,1) )
        ENDIF
      end if
!
      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,lr).gt.qxmin(lr)  &
     &     .and. temg(mgs) .lt. tfr - 1.   &
     &                               ) then
      esr(mgs)=Exp(-(40.e-6)**3/xv(mgs,lr))*Exp(-40.e-6/xdia(mgs,ls,1))
      IF ( qx(mgs,ls) < 1.e-4 .and. qx(mgs,lr) < 1.e-4 ) il2(mgs) = 1
      end if
      
      IF ( ipconc < 3 .and. temg(mgs) < tfr .and. qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lr) < 1.e-4 ) THEN
        il3(mgs) = 1
      ENDIF
!
!      if ( qx(mgs,ls).gt.qxmin(ls) ) then
      if ( temcg(mgs) < 0.0 ) then
            
      IF ( ipconc .lt. 4 .or. temcg(mgs) < esstem1 ) THEN
        ess(mgs) = 0.0
!        ess(mgs)=0.1*exp(0.1*min(temcg(mgs),0.0))
!        ess(mgs)=min(0.1,ess(mgs))
      ELSE
        IF ( temcg(mgs) > esstem1 .and. temcg(mgs) < esstem2 ) THEN  ! only nonzero for T > -25
        ess(mgs) = ess0*Exp(ess1*(esstem2) )*(temcg(mgs) - esstem1)/5. ! linear ramp up from zero at -25 to value at -20
        ELSEIF ( temcg(mgs) >= esstem2 ) THEN
        ess(mgs) = ess0*Exp(ess1*Min( temcg(mgs), 0.0 ) )
        ENDIF
      ENDIF
      end if
!
      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,li).gt.qxmin(li) ) then
       esiclsn(mgs) = esi_collsn
!      IF ( ipconc .lt. 4 ) THEN
      IF ( ipconc < 1 .and. lwsm6 ) THEN
        esi(mgs) = exp(0.7*min(temcg(mgs),0.0))
      ELSE
        esi(mgs)=0.1*exp(0.1*min(temcg(mgs),0.0))
        esi(mgs)=min(0.1,esi(mgs))
      ENDIF
      IF ( ipconc .le. 3 ) THEN
       esi(mgs) =  exp(0.025*min(temcg(mgs),0.0)) ! LFO
!       esi(mgs) =  Min(0.5, exp(0.025*min(temcg(mgs),0.0)) ) ! LFO
!       esi(mgs)=0.5*exp(0.1*min(temcg(mgs),0.0))  ! 10ice
      ENDIF
!      ELSE ! zrnic/ziegler 1993
!      esi(mgs)= 0.1 ! 0.5*exp(0.1*min(temcg(mgs),0.0))
!      ENDIF
      if ( temg(mgs) .gt. 273.15 ) esi(mgs) = 0.0
      end if
!
!
!
!
!  Graupel: Collection (cxc) efficiencies
!
!
       xmascw(mgs) = xmas(mgs,lc)
      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lc).gt.qxmin(lc) ) then
       ehw(mgs) = 1.0
       IF ( iehw .eq. 0 ) THEN
       ehw(mgs) = ehw0  ! default value is 1.0
       ELSEIF ( iehw .eq. 1 .or. iehw .eq. 10 ) THEN
      cwrad = 0.5*xdia(mgs,lc,1)
      ehw(mgs) = Min( ehw0,    &
     &  ewfac*min((aradcw + cwrad*(bradcw + cwrad*   &
     &  (cradcw + cwrad*(dradcw)))), 1.0) )
      
       ELSEIF ( iehw .eq. 2 .or. iehw .eq. 10 ) THEN
       ic = icwr(mgs)
       icp1 = Min( 8, ic+1 )
       ir = igwr(mgs)
       irp1 = Min( 6, ir+1 )
       cwrad = 0.5*xdia(mgs,lc,1)
       rwrad = 0.5*xdia(mgs,lh,3)  ! changed to mean volume diameter
       
       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
 
!        write(iunit,*) 'slop1: ',slope1,slope2,ew(ic,ir),cwr(ic,2)

       x1 = ew(ic,  ir) + slope1*Max(0.0, (cwrad - cwr(ic,1)) )
       x2 = ew(icp1,ir) + slope2*Max(0.0, (cwrad - cwr(ic,1)) )
       
       slope1 = (x2 - x1)*grad(ir,2)
       
       tmp = Max( 0.0, Min( 1.0, x1 + slope1*Max(0.0, (rwrad - grad(ir,1)) ) ) )
       ehw(mgs) = Min( ehw(mgs), tmp )

!       write(iunit,*) 'ehw: ',ehw(mgs),1.e6*cwrad,1.e6*rwrad,ic,ir,x1,x2
!       write(iunit,*)

!       ehw(mgs) = Max( 0.2, ehw(mgs) )
!  assume that ehw = 1 for zero air resistance (rho0 = 0.0) and extrapolate toward that
!      ehw(mgs) = ehw(mgs) + (ehw(mgs) - 1.0)*(rho0(mgs) - rho00)/rho00
!      ehw(mgs) = ehw(mgs) + (1.0 - ehw(mgs))*((Max(0.0,rho00 - rho0(mgs)))/rho00)**2

       ELSEIF ( iehw .eq. 3 .or. iehw .eq. 10 ) THEN ! use fraction of droplets greater than dmincw diameter
         tmp = Exp(- (dmincw/xdia(mgs,lc,1))**3)
         xmascw(mgs) = xmas(mgs,lc) + xdn0(lc)*(pi*dmincw**3/6.0) ! this is the average mass of the droplets with d > dmincw
         ehw(mgs) = Min( ehw(mgs), tmp )
       ELSEIF ( iehw .eq. 4 .or. iehw .eq. 10 ) THEN ! Cober and List 1993
         tmp =  &
     &   2.0*xdn(mgs,lc)*vtxbar(mgs,lh,1)*(0.5*xdia(mgs,lc,1))**2 &
     &  /(9.0*fadvisc(mgs)*0.5*xdia(mgs,lh,3))
         tmp = Max( 1.5, Min(10.0, tmp) )
         ehw(mgs) = Min( ehw(mgs), 0.55*Log10(2.51*tmp) )
       ENDIF
      if ( xdia(mgs,lc,1) .lt. 2.4e-06 ) ehw(mgs)=0.0

       ehw(mgs) = Min( ehw0, ehw(mgs) )
       
       IF ( ibfc == -1 .and. temcg(mgs) < -41.0 ) THEN
        ehw(mgs) = 0.0
       ENDIF 

      end if
!
      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lr).gt.qxmin(lr)    &
!     &     .and. temg(mgs) .lt. tfr    &
     &                               ) then
!      ehr(mgs) = Exp(-(40.e-6)**3/xv(mgs,lr))*Exp(-40.e-6/xdia(mgs,lh,1))
      ehr(mgs) = 1.0
       ehr(mgs) = Min( ehr0, ehr(mgs) )
      end if
!
      IF ( qx(mgs,ls).gt.qxmin(ls) ) THEN
        IF ( ipconc .ge. 4 ) THEN
        ehscnv(mgs) = ehs0*exp(ehs1*min(temcg(mgs),0.0)) ! for 2-moment, used as default for ehs and ehls. Otherwise not used for snow->graupel conversion
        ELSE
        ehscnv(mgs) = exp(0.09*min(temcg(mgs),0.0))
        ENDIF
        if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lc) > qxmin(lc)  ) then
          ehsclsn(mgs) = ehs_collsn
          IF ( xdia(mgs,ls,3) < 40.e-6 ) THEN
            ehsclsn(mgs) = 0.0
          ELSEIF ( xdia(mgs,ls,3) < 150.e-6 ) THEN
            ehsclsn(mgs) =  ehs_collsn*(xdia(mgs,ls,3) - 40.e-6)/(150.e-6 - 40.e-6)
          ELSE
            ehsclsn(mgs) = ehs_collsn
          ENDIF
!          ehs(mgs) = ehscnv(mgs)*Min(1.0, Max(0., xdn(mgs,lh) - xdnmn(lh)*1.2)/xdnmn(lh)  ) ! shut off qhacs as graupel goes to lowest density
          ehs(mgs) = ehscnv(mgs)*Min(1.0, Max(0.0,xdn(mgs,lh) - 300.)/300.  ) ! shut off qhacs as graupel goes to low density
          ehs(mgs) = Min(ehs(mgs),ehsmax)
        end if
      ENDIF
!
      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,li).gt.qxmin(li) ) then
      ehiclsn(mgs) = ehi_collsn
      ehi(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
      ehi(mgs) = Min( ehimax, Max( ehi(mgs), ehimin ) )
      if ( temg(mgs) .gt. 273.15 ) ehi(mgs) = 0.0
      end if


!
!
!  Hail: Collection (cxc) efficiencies
!
!
      IF ( lhl .gt. 1 ) THEN

      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lc).gt.qxmin(lc) ) then
       IF ( iehw == 3 ) iehlw = 3
       IF ( iehw == 4 ) iehlw = 4
       ehlw(mgs) = ehlw0
       IF ( iehlw .eq. 0 ) THEN
       ehlw(mgs) = ehlw0  ! default value is 1.0
       ELSEIF ( iehlw .eq. 1 .or. iehlw .eq. 10 ) THEN
      cwrad = 0.5*xdia(mgs,lc,1)
      ehlw(mgs) = Min( ehlw0,    &
     &  ewfac*min((aradcw + cwrad*(bradcw + cwrad*   &
     &  (cradcw + cwrad*(dradcw)))), 1.0) )
      
       ELSEIF ( iehlw .eq. 2 .or. iehlw .eq. 10 ) THEN
       ic = icwr(mgs)
       icp1 = Min( 8, ic+1 )
       ir = ihlr(mgs)
       irp1 = Min( 6, ir+1 )
       cwrad = 0.5*xdia(mgs,lc,1)
       rwrad = 0.5*xdia(mgs,lhl,3)  ! changed to mean volume diameter
       
       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
       
       x1 = ew(ic,  ir) + slope1*(cwrad - cwr(ic,1))
       x2 = ew(icp1,ir) + slope2*(cwrad - cwr(ic,1))
       
       slope1 = (x2 - x1)*grad(ir,2)
       
       tmp = Max( 0.0, Min( 1.0, x1 + slope1*(rwrad - grad(ir,1)) ) )
         ehlw(mgs) = Min( ehlw(mgs), tmp )
       ehlw(mgs) = Min( ehlw0, ehlw(mgs) )
!       ehw(mgs) = Max( 0.2, ehw(mgs) )
!  assume that ehw = 1 for zero air resistance (rho0 = 0.0) and extrapolate toward that
!      ehw(mgs) = ehw(mgs) + (ehw(mgs) - 1.0)*(rho0(mgs) - rho00)/rho00
!      ehlw(mgs) = ehlw(mgs) + (1.0 - ehlw(mgs))*((Max(0.0,rho00 - rho0(mgs)))/rho00)**2

       ELSEIF ( iehlw .eq. 3 .or. iehlw .eq. 10 ) THEN ! use fraction of droplets greater than 15 micron diameter
         tmp = Exp(- (dmincw/xdia(mgs,lc,1))**3)
         ehlw(mgs) = Min( ehlw(mgs), tmp )
       ELSEIF ( iehlw .eq. 4 .or. iehlw .eq. 10 ) THEN ! Cober and List 1993
         tmp =  &
     &   2.0*xdn(mgs,lc)*vtxbar(mgs,lhl,1)*(0.5*xdia(mgs,lc,1))**2 &
     &  /(9.0*fadvisc(mgs)*0.5*xdia(mgs,lhl,3))
         tmp = Max( 1.5, Min(10.0, tmp) )
         ehlw(mgs) = Min( ehlw(mgs), 0.55*Log10(2.51*tmp) )
       ENDIF
      if ( xdia(mgs,lc,1) .lt. 2.4e-06 ) ehlw(mgs)=0.0
       ehlw(mgs) = Min( ehlw0, ehlw(mgs) )

       IF ( ibfc == -1 .and. temcg(mgs) < -41.0 ) THEN 
        ehlw(mgs) = 0.0
       ENDIF 

      end if
!
      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lr).gt.qxmin(lr)    &
!     &     .and. temg(mgs) .lt. tfr    &
     &                               ) then
        ehlr(mgs) = 1.0
       ehlr(mgs) = Min( ehlr0, ehlr(mgs) )
      end if
!
      IF ( qx(mgs,ls).gt.qxmin(ls) ) THEN
        if ( qx(mgs,lhl).gt.qxmin(lhl)  ) then
          ehlsclsn(mgs) = ehls_collsn
          ehls(mgs) = ehscnv(mgs)
          ehls(mgs) = Min(ehls(mgs),ehsmax)
        end if
      ENDIF
!
      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,li).gt.qxmin(li) ) then
      ehliclsn(mgs) = ehli_collsn
      ehli(mgs)=eii0hl*exp(eii1hl*min(temcg(mgs),0.0))
      ehli(mgs) = Min( ehimax, Max( ehli(mgs), ehimin ) )
      if ( temg(mgs) .gt. 273.15 ) ehli(mgs) = 1.0
      end if


      ENDIF ! lhl .gt. 1

      ENDDO  ! mgs loop for collection efficiencies

!
!
!
!  Set flags for plates vs. columns
!
!
      do mgs = 1,ngscnt
!
      xplate(mgs) = 0.0
      xcolmn(mgs) = 1.0
!
!      if ( temcg(mgs) .lt. 0. .and. temcg(mgs) .ge. -4. ) then
!      xplate(mgs) = 1.0
!      xcolmn(mgs) = 0.0
!      end if
!c
!      if ( temcg(mgs) .lt. -4. .and. temcg(mgs) .ge. -9. ) then
!      xplate(mgs) = 0.0
!      xcolmn(mgs) = 1.0
!      end if
!c
!      if ( temcg(mgs) .lt. -9. .and. temcg(mgs) .ge. -22.5 ) then
!      xplate(mgs) = 1.0
!      xcolmn(mgs) = 0.0
!      end if
!c
!      if ( temcg(mgs) .lt. -22.5 .and. temcg(mgs) .ge. -90. ) then
!      xplate(mgs) = 0.0
!      xcolmn(mgs) = 1.0
!      end if
!
      end do
!
!
!
!  Collection growth equations....
!
!
      if (ndebug .gt. 0 ) write(0,*) 'Collection: rain collects xxxxx'
!
      do mgs = 1,ngscnt
      qracw(mgs) =  0.0
      IF ( qx(mgs,lr) .gt. qxmin(lr) .and. erw(mgs) .gt. 0.0 ) THEN
      IF ( ipconc .lt. 3 ) THEN
       IF ( erw(mgs) .gt. 0.0 .and. qx(mgs,lr) .gt. 1.e-7 ) THEN
       vt = (ar*(xdia(mgs,lc,1)**br))*rhovt(mgs)
       qracw(mgs) =    &
     &   (0.25)*pi*erw(mgs)*qx(mgs,lc)*cx(mgs,lr) &
!     >  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,lc,1))   &
     &  *Max(0.0, vtxbar(mgs,lr,1)-vt)   &
     &  *(  gf3*xdia(mgs,lr,2)    &
     &    + 2.0*gf2*xdia(mgs,lr,1)*xdia(mgs,lc,1)    &
     &    + gf1*xdia(mgs,lc,2) )
!       qracw(mgs) = 0.0
!      write(iunit,*) 'qracw,cx =',qracw(mgs),1.e6*xdia(mgs,lr,1),erw(mgs)
!      write(iunit,*) 'qracw,cx =',qracw(mgs),cx(mgs,lc),kgs(mgs),cx(mgs,lr),1.e6*xdia(mgs,lr,1),vtxbar(mgs,lr,1),vt
!      write(iunit,*) 'vtr: ',vtxbar(mgs,lr,1), ar*gf4br/6.0*xdia(mgs,lr,1)**br, rhovt(mgs),
!     :         ar*gf4br/6.0*xdia(mgs,lr,1)**br * rhovt(mgs)
       ENDIF
      ELSE

      IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN 
       rwrad = 0.5*xdia(mgs,lr,3)
        IF ( rwrad .gt. rh(mgs) ) THEN ! .or. cx(mgs,lr) .gt. nh(mgs) ) THEN
         IF ( rwrad .gt. rwradmn ) THEN
!      DM1CCC=A2*XNC*XNR*XVC*(((CNU+2.)/(CNU+1.))*XVC+XVR)       ! (A12)
!     NOTE: Result is independent of imurain, assumes mucloud = 3
           qracw(mgs) = erw(mgs)*aa2*cx(mgs,lr)*cx(mgs,lc)*xmas(mgs,lc)*   &
     &        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,lr))/rho0(mgs) !*rhoinv(mgs)
         ELSE

          IF ( imurain == 3 ) THEN

!      DM1CCC=A1*XNC*XNR*(((CNU+3.)*(CNU+2.)/(CNU+1.)**2)*XVC**3+ ! (A14)
!     1 ((RNU+2.)/(RNU+1.))*XVC*XVR**2)

!           qracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*xdn(mgs,lc)*   &
!     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**3/(cnu + 1.)**2 +    &
!     &         (alpha(mgs,lr) + 2.)*xv(mgs,lc)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.))/rho0(mgs) !*rhoinv(mgs)
! save multiplies by converting cx*xdn*xv/rho0 to qx
           qracw(mgs) = aa1*cx(mgs,lr)*qx(mgs,lc)*   &
     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.)**2 +    &
     &         (alpha(mgs,lr) + 2.)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.)) 
           
           ELSE ! imurain == 1

           qracw(mgs) = aa1*cx(mgs,lr)*qx(mgs,lc)*   &
     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.)**2 +    &
     &         (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)*xv(mgs,lr)**2/ &
     &          ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.))) 
           
           ENDIF
           
         ENDIF
        ENDIF
        ENDIF
       ENDIF
!       qracw(mgs) = Min(qracw(mgs), qx(mgs,lc))
       qracw(mgs) = Min(qracw(mgs), qcmxd(mgs))
       ENDIF
      end do
!
      do mgs = 1,ngscnt
      qraci(mgs) = 0.0
      craci(mgs) = 0.0
      IF ( eri(mgs) .gt. 0.0 .and. iacr .ge. 1 .and. xdia(mgs,lr,3) .gt. 2.*rwradmn ) THEN
        IF ( ipconc .ge. 3 ) THEN

           tmp = eri(mgs)*aa2*cx(mgs,lr)*cx(mgs,li)*   &
     &        ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,lr))

        qraci(mgs) = Min( qxmxd(mgs,li), tmp*xmas(mgs,li)*rhoinv(mgs) )
        craci(mgs) = Min( cxmxd(mgs,li), tmp )

!       vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +
!     :            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
!
!          qraci(mgs) = 0.25*pi*eri(mgs)*cx(mgs,lr)*qx(mgs,li)*vt*
!     :         (  da0(lr)*xdia(mgs,lr,3)**2 +
!     :            dab1(lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +
!     :            da1(li)*xdia(mgs,li,3)**2 )
!
!
!       vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +
!     :            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
!
!          craci(mgs) = 0.25*pi*eri(mgs)*cx(mgs,lr)*cx(mgs,li)*vt*
!     :         (  da0(lr)*xdia(mgs,lr,3)**2 +
!     :            dab0(lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +
!     :            da0(li)*xdia(mgs,li,3)**2 )
!
!          qraci(mgs) = Min( qraci(mgs), qxmxd(mgs,li) )
!          craci(mgs) = Min( craci(mgs), cxmxd(mgs,li) )

        ELSE
          qraci(mgs) =    &
     &     min(   &
     &     (0.25)*pi*eri(mgs)*qx(mgs,li)*cx(mgs,lr)   &
     &    *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))   &
     &    *(  gf3*xdia(mgs,lr,2)    &
     &      + 2.0*gf2*xdia(mgs,lr,1)*xdia(mgs,li,1)    &
     &      + gf1*xdia(mgs,li,2) )     &
     &    , qimxd(mgs))
        ENDIF
      if ( temg(mgs) .gt. 268.15 ) then
      qraci(mgs) = 0.0
      end if
      ENDIF
      end do
!
      do mgs = 1,ngscnt
      qracs(mgs) =  0.0
      IF ( ers(mgs) .gt. 0.0 .and. ipconc < 3 ) THEN
       IF ( lwsm6 .and. ipconc == 0 ) THEN
         vt = vt2ave(mgs)
       ELSE
         vt = vtxbar(mgs,ls,1)
       ENDIF
      qracs(mgs) =      &
     &   min(     &
     &   ((0.25)*pi/gf4)*ers(mgs)*qx(mgs,ls)*cx(mgs,lr)     &
     &  *abs(vtxbar(mgs,lr,1)-vt)     &
     &  *(  gf6*gf1*xdia(mgs,ls,2)     &
     &    + 2.0*gf5*gf2*xdia(mgs,ls,1)*xdia(mgs,lr,1)      &
     &    + gf4*gf3*xdia(mgs,lr,2) )      &
     &  , qsmxd(mgs))
      ENDIF
      end do

!
!
      if (ndebug .gt. 0 ) write(0,*) 'Collection: snow collects xxxxx'
!
      do mgs = 1,ngscnt
      qsacw(mgs) =  0.0
      csacw(mgs) =  0.0
      vsacw(mgs) =  0.0
      IF ( esw(mgs) .gt. 0.0 ) THEN

       IF ( ipconc .ge. 4 ) THEN
!      QSACC=CECS*RVT*A2*XNC*XNS*XVC*ROS*
!     *    (((CNU+2.)/(CNU+1.))*XVC+XVS)/RO

!        tmp = esw(mgs)*rvt*aa2*cx(mgs,ls)*cx(mgs,lc)*
!     :        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))
        tmp = 1.0*rvt*aa2*cx(mgs,ls)*cx(mgs,lc)*   &
     &        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))

        qsacw(mgs) = Min( qxmxd(mgs,lc), tmp*xmas(mgs,lc)*rhoinv(mgs) )
        csacw(mgs) = Min( cxmxd(mgs,lc), tmp )

          IF ( lvol(ls) .gt. 1 ) THEN
             IF ( temg(mgs) .lt. 273.15) THEN
             rimdn(mgs,ls) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
     &                *((0.60)*vtxbar(mgs,ls,1))   &
     &                /(temg(mgs)-273.15))**(rimc2)
             rimdn(mgs,ls) = Min( Max( rimc3, rimdn(mgs,ls) ), rimc4 )
             ELSE
             rimdn(mgs,ls) = 1000.
             ENDIF

           vsacw(mgs) = rho0(mgs)*qsacw(mgs)/rimdn(mgs,ls)

          ENDIF


!        qsacw(mgs) = cecs*aa2*cx(mgs,ls)*cx(mgs,lc)*xmas(mgs,lc)*
!     :        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))*rhoinv(mgs)
       ELSE
!      qsacw(mgs) =
!     >   min(
!     >   ((0.25)*pi)*esw(mgs)*qx(mgs,lc)*cx(mgs,ls)
!     >  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,lc,1))
!     >  *(  gf3*xdia(mgs,ls,2)
!     >    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,lc,1)
!     >    + gf1*xdia(mgs,lc,2) )
!     <  , qcmxd(mgs))

            vt = abs(vtxbar(mgs,ls,1)-vtxbar(mgs,lc,1))

          qsacw(mgs) = 0.25*pi*esw(mgs)*cx(mgs,ls)*qx(mgs,lc)*vt*   &
     &         (  da0(ls)*xdia(mgs,ls,3)**2 +     &
     &            dab1(ls,lc)*xdia(mgs,ls,3)*xdia(mgs,lc,3) +    &
     &            da1(lc)*xdia(mgs,lc,3)**2 )
        qsacw(mgs) = Min( qsacw(mgs), qxmxd(mgs,ls) )
        csacw(mgs) = rho0(mgs)*qsacw(mgs)/xmas(mgs,lc)
       ENDIF
      ENDIF
      end do
!
!
      do mgs = 1,ngscnt
      qsaci(mgs) = 0.0
      csaci(mgs) = 0.0
      csaci0(mgs) = 0.0
      IF ( ipconc .ge. 4 ) THEN
      IF ( esi(mgs) .gt. 0.0 .or. ( ipelec > 0 .and. esiclsn(mgs) > 0.0 )) THEN
!      QSCOI=CEXS*RVT*A2*XNCI*XNS*XVCI*ROS*
!     *  (((CINU+2.)/(CINU+1.))*VCIP+XVS)/RO

        tmp = esiclsn(mgs)*rvt*aa2*cx(mgs,ls)*cx(mgs,li)*   &
     &        ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,ls))

        qsaci(mgs) = Min( qxmxd(mgs,li), esi(mgs)*tmp*xmas(mgs,li)*rhoinv(mgs) )
        csaci0(mgs) = tmp
        csaci(mgs) = Min(cxmxd(mgs,li), esi(mgs)*tmp )

!      qsaci(mgs) =
!     >   min(
!     >   ((0.25)*pi)*esi(mgs)*qx(mgs,li)*cx(mgs,ls)
!     >  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,li,1))
!     >  *(  gf3*xdia(mgs,ls,2)
!     >    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,li,1)
!     >    + gf1*xdia(mgs,li,2) )
!     <  , qimxd(mgs))
      ENDIF
      ELSE ! 
      IF ( esi(mgs) .gt. 0.0 ) THEN
         qsaci(mgs) =    &
     &   min(   &
     &   ((0.25)*pi)*esi(mgs)*qx(mgs,li)*cx(mgs,ls)   &
     &  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,li,1))   &
     &  *(  gf3*xdia(mgs,ls,2)    &
     &    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,li,1)    &
     &    + gf1*xdia(mgs,li,2) )     &
     &  , qimxd(mgs))
      ENDIF
      ENDIF
      end do
!
!
!
      do mgs = 1,ngscnt
      qsacr(mgs) = 0.0
      qsacrs(mgs) = 0.0
      csacr(mgs) = 0.0
      IF ( esr(mgs) .gt. 0.0 ) THEN
      IF ( ipconc .ge. 3 ) THEN
!       vt = Sqrt((vtxbar(mgs,ls,1)-vtxbar(mgs,lr,1))**2 + 
!     :            0.04*vtxbar(mgs,ls,1)*vtxbar(mgs,lr,1) )
!       qsacr(mgs) = esr(mgs)*cx(mgs,ls)*vt*
!     :     qx(mgs,lr)*0.25*pi*
!     :      (3.02787*xdia(mgs,lr,2) + 
!     :       3.30669*xdia(mgs,ls,1)*xdia(mgs,lr,1) + 
!     :       2.*xdia(mgs,ls,2))
!        qsacr(mgs) = Min( qsacr(mgs), qrmxd(mgs) )
!        csacr(mgs) = qsacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
!        csacr(mgs) = min(csacr(mgs),crmxd(mgs))
      ELSE
       IF ( lwsm6 .and. ipconc == 0 ) THEN
         vt = vt2ave(mgs)
       ELSE
         vt = vtxbar(mgs,ls,1)
       ENDIF
       
       qsacr(mgs) =   &
     &   min(   &
     &   ((0.25)*pi/gf4)*esr(mgs)*qx(mgs,lr)*cx(mgs,ls)   &
     &  *abs(vtxbar(mgs,lr,1)-vt)   &
     &  *(  gf6*gf1*xdia(mgs,lr,2)   &
     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,ls,1)    &
     &    + gf4*gf3*xdia(mgs,ls,2) )    &
     &  , qrmxd(mgs))
      ENDIF
      ENDIF
      end do
!
!
!
      if (ndebug .gt. 0 ) write(0,*) 'Collection: graupel collects xxxxx'
!
      do mgs = 1,ngscnt
      qhacw(mgs) = 0.0
      rarx(mgs,lh) = 0.0
      vhacw(mgs) = 0.0
      vhsoak(mgs) = 0.0
      zhacw(mgs) = 0.0
      
      IF ( .false. ) THEN
        vtmax = (gz(igs(mgs),jgs,kgs(mgs))/dtp)
        vtxbar(mgs,lh,1) = Min( vtmax, vtxbar(mgs,lh,1))
        vtxbar(mgs,lh,2) = Min( vtmax, vtxbar(mgs,lh,2))
        vtxbar(mgs,lh,3) = Min( vtmax, vtxbar(mgs,lh,3))
      ENDIF
      IF ( ehw(mgs) .gt. 0.0 ) THEN

        IF ( ipconc .ge. 2 ) THEN

        IF ( .false. ) THEN  
        qhacw(mgs) = (ehw(mgs)*qx(mgs,lc)*cx(mgs,lh)*pi*   &
     &    abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))*   &
     &    (2.0*xdia(mgs,lh,1)*(xdia(mgs,lh,1) +    &
     &         xdia(mgs,lc,1)*gf73rds) +    &
     &      xdia(mgs,lc,2)*gf83rds))/4.     
     
         ELSE  ! using Seifert coefficients
            vt = abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1)) 

          qhacw(mgs) = 0.25*pi*ehw(mgs)*cx(mgs,lh)*qx(mgs,lc)*vt*   &
     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
     &            dab1lh(mgs,lc,lh)*xdia(mgs,lh,3)*xdia(mgs,lc,3) +    &
     &            da1(lc)*xdia(mgs,lc,3)**2 ) 
         
         ENDIF
          qhacw(mgs) = Min( qhacw(mgs), 0.5*qx(mgs,lc)/dtp )
        
         IF ( lzh .gt. 1 ) THEN
          tmp = qx(mgs,lh)/cx(mgs,lh)
          
!!          g1 = (6.0 + alpha(mgs,lh))*(5.0 + alpha(mgs,lh))*(4.0 + alpha(mgs,lh))/
!!     :         ((3.0 + alpha(mgs,lh))*(2.0 + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))
!          alp = Max( 1.0, alpha(mgs,lh)+1. )
!          g1 = (6.0 + alp)*(5.0 + alp)*(4.0 + alp)/
!     :         ((3.0 + alp)*(2.0 + alp)*(1.0 + alp))
!          zhacw(mgs) =  g1*(6.*rho0(mgs)/(pi*1000.))**2*( 2.*( qx(mgs,lh)/cx(mgs,lh)) * qhacw(mgs) )
         ENDIF
        
        ELSE
         qhacw(mgs) =    &
     &   min(   &
     &   ((0.25)*pi)*ehw(mgs)*qx(mgs,lc)*cx(mgs,lh)   &
     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))   &
     &  *(  gf3*xdia(mgs,lh,2)    &
     &    + 2.0*gf2*xdia(mgs,lh,1)*xdia(mgs,lc,1)    &
     &    + gf1*xdia(mgs,lc,2) )     &
     &    , 0.5*qx(mgs,lc)/dtp)
!     <  , qxmxd(mgs,lc))
!     <  , qcmxd(mgs))
       
       
         IF ( lwsm6 .and. qsacw(mgs) > 0.0 .and.  qhacw(mgs) > 0.0) THEN
           qaacw = ( qx(mgs,ls)*qsacw(mgs) + qx(mgs,lh)*qhacw(mgs) )/(qx(mgs,ls) + qx(mgs,lh))
!           qaacw = Min( qaacw, 0.5*(qsacw(mgs) + qhacw(mgs) ) )
           qsacw(mgs) = qaacw
           qhacw(mgs) = qaacw
         ENDIF
         
       ENDIF

          IF ( lvol(lh) .gt. 1 .or. lhl .gt. 1 ) THEN ! calculate rime density for graupel volume and/or for graupel conversion to hail
             
             IF ( temg(mgs) .lt. 273.15) THEN
             rimdn(mgs,lh) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
     &                *((0.60)*vtxbar(mgs,lh,1))   &
     &                /(temg(mgs)-273.15))**(rimc2)
             rimdn(mgs,lh) = Min( Max( hdnmn, rimc3, rimdn(mgs,lh) ), rimc4 )
             ELSE
             rimdn(mgs,lh) = 1000.
             ENDIF
             
             IF ( lvol(lh) > 1 ) vhacw(mgs) = rho0(mgs)*qhacw(mgs)/rimdn(mgs,lh)

          ENDIF
      
        IF ( qx(mgs,lh) .gt. qxmin(lh) .and. ipelec .ge. 1 ) THEN
         rarx(mgs,lh) =     &
     &    qhacw(mgs)*1.0e3*rho0(mgs)/((pi/2.0)*xdia(mgs,lh,2)*cx(mgs,lh))
        ENDIF
      
      ENDIF  
      end do   
!
!
      do mgs = 1,ngscnt
      qhaci(mgs) = 0.0
      qhaci0(mgs) = 0.0
      IF ( ehi(mgs) .gt. 0.0 ) THEN
       IF (  ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))**2 +    &
     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,li,1) )

          qhaci0(mgs) = 0.25*pi*ehiclsn(mgs)*cx(mgs,lh)*qx(mgs,li)*vt*   &
     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
     &            dab1lh(mgs,li,lh)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
     &            da1(li)*xdia(mgs,li,3)**2 ) 
          qhaci(mgs) = Min( ehi(mgs)*qhaci0(mgs), qimxd(mgs) )
       ELSE
        qhaci(mgs) =    &
     &  min(   &
     &  ((0.25)*pi)*ehi(mgs)*ehiclsn(mgs)*qx(mgs,li)*cx(mgs,lh)   &
     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))   &
     &  *(  gf3*xdia(mgs,lh,2)    &
     &    + 2.0*gf2*xdia(mgs,lh,1)*xdia(mgs,li,1)    &
     &    + gf1*xdia(mgs,li,2) )     &
     &  , qimxd(mgs))
       ENDIF
      ENDIF
      end do   
!
!
      do mgs = 1,ngscnt
      qhacs(mgs) = 0.0
      qhacs0(mgs) = 0.0
      IF ( ehs(mgs) .gt. 0.0 ) THEN
       IF ( ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))**2 +    &
     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,ls,1) )

          qhacs0(mgs) = 0.25*pi*ehsclsn(mgs)*cx(mgs,lh)*qx(mgs,ls)*vt*   &
     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
     &            dab1lh(mgs,ls,lh)*xdia(mgs,lh,3)*xdia(mgs,ls,3) +    &
     &            da1(ls)*xdia(mgs,ls,3)**2 ) 
      
          qhacs(mgs) = Min( ehs(mgs)*qhacs0(mgs), qsmxd(mgs) )

       ELSE
         qhacs(mgs) =   &
     &   min(   &
     &   ((0.25)*pi/gf4)*ehs(mgs)*ehsclsn(mgs)*qx(mgs,ls)*cx(mgs,lh)   &
     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))   &
     &  *(  gf6*gf1*xdia(mgs,ls,2)   &
     &    + 2.0*gf5*gf2*xdia(mgs,ls,1)*xdia(mgs,lh,1)   &
     &    + gf4*gf3*xdia(mgs,lh,2) )   &
     &  , qsmxd(mgs))
        ENDIF
      ENDIF
      end do   
!
      do mgs = 1,ngscnt
      qhacr(mgs) = 0.0
      qhacrmlr(mgs) = 0.0
      vhacr(mgs) = 0.0
      chacr(mgs) = 0.0
      zhacr(mgs) = 0.0
      IF ( temg(mgs) .gt. tfr ) raindn(mgs,lh) = 1000.0

      IF ( ehr(mgs) .gt. 0.0 ) THEN
      IF ( ipconc .ge. 3 ) THEN
       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lr,1))**2 +    &
     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lr,1) )
!       qhacr(mgs) = ehr(mgs)*cx(mgs,lh)*vt*
!     :     qx(mgs,lr)*0.25*pi*
!     :      (3.02787*xdia(mgs,lr,2) + 
!     :       3.30669*xdia(mgs,lh,1)*xdia(mgs,lr,1) + 
!     :       2.*xdia(mgs,lh,2))
     
       qhacr(mgs) = 0.25*pi*ehr(mgs)*cx(mgs,lh)*qx(mgs,lr)*vt*   &
     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
     &            dab1lh(mgs,lr,lh)*xdia(mgs,lh,3)*xdia(mgs,lr,3) +    &
     &            da1(lr)*xdia(mgs,lr,3)**2 )
!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'qhacr= ',qhacr(mgs),tmp
!!        qhacr(mgs) = Min( qhacr(mgs), qrmxd(mgs) )
!!        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
!!        chacr(mgs) = min(chacr(mgs),crmxd(mgs))

        qhacr(mgs) = Min( qhacr(mgs), qxmxd(mgs,lr) )

        IF ( temg(mgs) > tfr ) THEN
          qhacrmlr(mgs) = qhacr(mgs)
          qhacr(mgs) = 0.0
        ELSE
!        chacr(mgs) = Min( qhacr(mgs)*rho0(mgs)/xmas(mgs,lr), cxmxd(mgs,lr) )

!       chacr(mgs) = ehr(mgs)*cx(mgs,lh)*vt*
!     :     cx(mgs,lr)*0.25*pi*
!     :      (0.69874*xdia(mgs,lr,2) +
!     :       1.24001*xdia(mgs,lh,1)*xdia(mgs,lr,1) +
!     :       2.*xdia(mgs,lh,2))

!        chacr(mgs) = 0.25*pi*ehr(mgs)*cx(mgs,lh)*cx(mgs,lr)*vt*
!     :         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +
!     :            dab0lh(mgs,lr)*xdia(mgs,lh,3)*xdia(mgs,lr,3) +
!     :            da0(lr)*xdia(mgs,lr,3)**2 )

!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'chacr= ',chacr(mgs),tmp

        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
        chacr(mgs) = min(chacr(mgs),crmxd(mgs))

      IF ( lzh .gt. 1 ) THEN
          tmp = qx(mgs,lh)/cx(mgs,lh)

!          g1 = (6.0 + alpha(mgs,lh))*(5.0 + alpha(mgs,lh))*(4.0 + alpha(mgs,lh))/
!     :         ((3.0 + alpha(mgs,lh))*(2.0 + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))
!          alp = Max( 1.0, alpha(mgs,lh)+1. )
!          g1 = (6.0 + alp)*(5.0 + alp)*(4.0 + alp)/
!     :         ((3.0 + alp)*(2.0 + alp)*(1.0 + alp))
!        zhacr(mgs) =  g1*(6.*rho0(mgs)/(pi*1000.))**2*( 2.*( tmp ) * qhacr(mgs) - tmp**2 * chacr(mgs) )
!        zhacr(mgs) =  g1*(6.*rho0(mgs)/(pi*xdn(mgs,lh)))**2*( 2.*( tmp ) * qhacr(mgs) )
      ENDIF
      ENDIF ! temg > tfr
      
      ELSE
       IF ( lwsm6 .and. ipconc == 0 ) THEN
         vt = vt2ave(mgs)
       ELSE
         vt = vtxbar(mgs,lh,1)
       ENDIF

      qhacr(mgs) =   &
     &   min(   &
     &   ((0.25)*pi/gf4)*ehr(mgs)*qx(mgs,lr)*cx(mgs,lh)   &
     &  *abs(vt-vtxbar(mgs,lr,1))   &
     &  *(  gf6*gf1*xdia(mgs,lr,2)   &
     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,lh,1)   &
     &    + gf4*gf3*xdia(mgs,lh,2) )   &
     &  , qrmxd(mgs))
      
        IF ( temg(mgs) > tfr ) THEN
          qhacrmlr(mgs) = qhacr(mgs)
          qhacr(mgs) = 0.0
        ENDIF
      
      ENDIF
        IF ( lvol(lh) .gt. 1 ) THEN
         vhacr(mgs) = rho0(mgs)*qhacr(mgs)/raindn(mgs,lh)
        ENDIF
      ENDIF
      end do

!
!
      if (ndebug .gt. 0 ) write(0,*) 'Collection: hail collects xxxxx'
!

      do mgs = 1,ngscnt
      qhlacw(mgs) = 0.0
      vhlacw(mgs) = 0.0
      vhlsoak(mgs) = 0.0
      IF ( lhl > 1 .and. .true.) THEN
        vtmax = (gz(igs(mgs),jgs,kgs(mgs))/dtp)
        vtxbar(mgs,lhl,1) = Min( vtmax, vtxbar(mgs,lhl,1))
        vtxbar(mgs,lhl,2) = Min( vtmax, vtxbar(mgs,lhl,2))
        vtxbar(mgs,lhl,3) = Min( vtmax, vtxbar(mgs,lhl,3))
      ENDIF

      IF ( lhl > 0 ) THEN
      rarx(mgs,lhl) = 0.0
      ENDIF

      IF ( lhl .gt. 1 .and. ehlw(mgs) .gt. 0.0 ) THEN


!        IF ( ipconc .ge. 2 ) THEN

            vt = abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))

          qhlacw(mgs) = 0.25*pi*ehlw(mgs)*cx(mgs,lhl)*qx(mgs,lc)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab1lh(mgs,lc,lhl)*xdia(mgs,lhl,3)*xdia(mgs,lc,3) +    &
     &            da1(lc)*xdia(mgs,lc,3)**2 )


          qhlacw(mgs) = Min( qhlacw(mgs), 0.5*qx(mgs,lc)/dtp )

          IF ( lvol(lhl) .gt. 1 ) THEN

             IF ( temg(mgs) .lt. 273.15) THEN
             rimdn(mgs,lhl) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
     &                *((0.60)*vtxbar(mgs,lhl,1))   &
     &                /(temg(mgs)-273.15))**(rimc2)
             rimdn(mgs,lhl) = Min( Max( hldnmn, rimc3, rimdn(mgs,lhl) ), rimc4 )
             ELSE
             rimdn(mgs,lhl) = 1000.
             ENDIF

             vhlacw(mgs) = rho0(mgs)*qhlacw(mgs)/rimdn(mgs,lhl)

          ENDIF


        IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. ipelec .ge. 1 ) THEN
         rarx(mgs,lhl) =     &
     &    qhlacw(mgs)*1.0e3*rho0(mgs)/((pi/2.0)*xdia(mgs,lhl,2)*cx(mgs,lhl))
        ENDIF

      ENDIF
      end do

      qhlaci(:) = 0.0
      qhlaci0(:) = 0.0
      IF ( lhl .gt. 1  ) THEN
      do mgs = 1,ngscnt
      IF ( ehli(mgs) .gt. 0.0 ) THEN
       IF (  ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))**2 +    &
     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,li,1) )

          qhlaci0(mgs) = 0.25*pi*ehliclsn(mgs)*cx(mgs,lhl)*qx(mgs,li)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab1lh(mgs,li,lhl)*xdia(mgs,lhl,3)*xdia(mgs,li,3) +    &
     &            da1(li)*xdia(mgs,li,3)**2 )
        ! qhlaci(mgs) = Min( qhlaci(mgs), qimxd(mgs) )
          qhlaci(mgs) = Min( ehli(mgs)*qhlaci0(mgs), qimxd(mgs) )
       ENDIF
      ENDIF
      end do
      ENDIF
!
      qhlacs(:) = 0.0
      qhlacs0(:) = 0.0
      IF ( lhl .gt. 1 ) THEN
      do mgs = 1,ngscnt
      IF ( ehls(mgs) .gt. 0.0) THEN
       IF ( ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))**2 +    &
     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,ls,1) )

          qhlacs0(mgs) = 0.25*pi*ehlsclsn(mgs)*cx(mgs,lhl)*qx(mgs,ls)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab1lh(mgs,ls,lhl)*xdia(mgs,lhl,3)*xdia(mgs,ls,3) +    &
     &            da1(ls)*xdia(mgs,ls,3)**2 )

          qhlacs(mgs) = Min( ehls(mgs)*qhlacs0(mgs), qsmxd(mgs) )
        ENDIF
      ENDIF
      end do
      ENDIF


      do mgs = 1,ngscnt
      qhlacr(mgs) = 0.0
      qhlacrmlr(mgs) = 0.0
      chlacr(mgs) = 0.0
      vhlacr(mgs) = 0.0
      IF ( lhl .gt. 1 .and. temg(mgs) .gt. tfr ) raindn(mgs,lhl) = 1000.0

      IF ( lhl .gt. 1 .and. ehlr(mgs) .gt. 0.0 ) THEN
      IF ( ipconc .ge. 3 ) THEN
       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,lr,1))**2 +    &
     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,lr,1) )

       qhlacr(mgs) = 0.25*pi*ehlr(mgs)*cx(mgs,lhl)*qx(mgs,lr)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab1lh(mgs,lr,lhl)*xdia(mgs,lhl,3)*xdia(mgs,lr,3) +    &
     &            da1(lr)*xdia(mgs,lr,3)**2 )
!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'qhacr= ',qhacr(mgs),tmp
!!        qhacr(mgs) = Min( qhacr(mgs), qrmxd(mgs) )
!!        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
!!        chacr(mgs) = min(chacr(mgs),crmxd(mgs))

        qhlacr(mgs) = Min( qhlacr(mgs), qxmxd(mgs,lr) )

     
        qhlacrmlr(mgs) = qhlacr(mgs)
        IF ( temg(mgs) > tfr ) THEN
        qhlacr(mgs) = 0.0
        ELSE
        chlacr(mgs) = 0.25*pi*ehlr(mgs)*cx(mgs,lhl)*cx(mgs,lr)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab0(lhl,lr)*xdia(mgs,lhl,3)*xdia(mgs,lr,3) +    &
     &            da0(lr)*xdia(mgs,lr,3)**2 )

        chlacr(mgs) = min(chlacr(mgs),crmxd(mgs))

        IF ( lvol(lhl) .gt. 1 ) THEN
         vhlacr(mgs) = rho0(mgs)*qhlacr(mgs)/raindn(mgs,lhl)
        ENDIF
        ENDIF
      ENDIF
      ENDIF
      end do



!
!
!
!
!      if (ndebug .gt. 0 ) write(0,*) 'Collection: Cloud collects xxxxx'

      if (ndebug .gt. 0 ) write(0,*) 'Collection: cloud ice collects xxxx2'
!
      do mgs = 1,ngscnt
      qiacw(mgs) = 0.0
      IF ( eiw(mgs) .gt. 0.0 ) THEN

       vt = Sqrt((vtxbar(mgs,li,1)-vtxbar(mgs,lc,1))**2 +    &
     &            0.04*vtxbar(mgs,li,1)*vtxbar(mgs,lc,1) )

          qiacw(mgs) = 0.25*pi*eiw(mgs)*cx(mgs,li)*qx(mgs,lc)*vt*   &
     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
     &            dab1(li,lc)*xdia(mgs,li,3)*xdia(mgs,lc,3) +    &
     &            da1(lc)*xdia(mgs,lc,3)**2 )

       qiacw(mgs) = Min( qiacw(mgs), qxmxd(mgs,lc) )
      ENDIF
      end do
!
!
      if (ndebug .gt. 0 ) write(0,*) 'Collection: cloud ice collects xxxx8'
!
      do mgs = 1,ngscnt
      qiacr(mgs) = 0.0
      qiacrf(mgs) = 0.0
      qiacrs(mgs) = 0.0
      ciacrs(mgs) = 0.0
      ciacr(mgs) = 0.0
      ciacrf(mgs) = 0.0
      viacrf(mgs) = 0.0
      csplinter(mgs) = 0.0
      qsplinter(mgs) = 0.0
      csplinter2(mgs) = 0.0
      qsplinter2(mgs) = 0.0
      IF ( iacr .ge. 1 .and. eri(mgs) .gt. 0.0    &
     &     .and. temg(mgs) .le. 270.15 ) THEN
      IF ( ipconc .ge. 3 ) THEN
       ni = 0.0
         IF ( xdia(mgs,li,1) .ge. 10.e-6 ) THEN
          ni = ni + cx(mgs,li)*Exp(- (40.e-6/xdia(mgs,li,1))**3 )
         ENDIF
       IF ( imurain == 1 ) THEN ! gamma of diameter
           IF ( iacrsize /= 4 ) THEN
           IF ( iacrsize .eq. 1 ) THEN
             ratio = 500.e-6/xdia(mgs,lr,1)
           ELSEIF ( iacrsize .eq. 2 ) THEN
             ratio = 300.e-6/xdia(mgs,lr,1)
           ELSEIF ( iacrsize .eq. 3 ) THEN
             ratio = 40.e-6/xdia(mgs,lr,1)
           ELSEIF ( iacrsize .eq. 5 ) THEN
             ratio = 150.e-6/xdia(mgs,lr,1)
           ENDIF
           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
           delx = ratio - float(i)*dqiacrratio
           dely = alpha(mgs,lr) - float(j)*dqiacralpha
           ip1 = Min( i+1, nqiacrratio )
           jp1 = Min( j+1, nqiacralpha )

           ! interpolate along x, i.e., ratio
           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
           
           ! interpolate along alpha
           
           nr = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)
           
           ! interpolate along x, i.e., ratio; 
           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
           
           ! interpolate along alpha; 
           
           qr = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)
           
           ELSE ! iacrsize == 4 : use all
             nr = cx(mgs,lr)
             qr = qx(mgs,lr)
           ENDIF

          vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +     &
     &            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )

          qiacr(mgs) = 0.25*pi*eri(mgs)*ni*qr*vt*   &
     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
     &            dab1lh(mgs,lr,li)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
     &            da1(lr)*xdia(mgs,lr,3)**2 ) 
          
          qiacr(mgs) = Min( qrmxd(mgs), qiacr(mgs) )
          

          ciacr(mgs) = 0.25*pi*eri(mgs)*ni*nr*vt*   &
     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
     &            dab0lh(mgs,lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +    &
     &            da0(lr)*xdia(mgs,lr,3)**2 ) 

          ciacr(mgs) = Min( crmxd(mgs), ciacr(mgs) )
          
!          write(iunit,*) 'qiacr: ',cx(mgs,lr),nr,qx(mgs,lr),qr,qiacr(mgs),ciacr(mgs)
!          write(iunit,*) 'xdia r li = ',xdia(mgs,lr,3),xdia(mgs,li,3),xdia(mgs,lr,1),xdia(mgs,li,1)
!          write(iunit,*) 'i,j,ratio = ',i,j,ciacrratio(i,j),qiacrratio(i,j)
!          write(iunit,*) 'ni,ci = ',ni,cx(mgs,li),qx(mgs,li)

       ELSEIF ( imurain == 3 ) THEN ! gamma of volume
!   Set nr to the number of drops greater than 40 microns.
         arg = 1000.*xdia(mgs,lr,3)
!         nr = cx(mgs,lr)*gaml02( arg )
!        IF ( iacr .eq. 1 ) THEN
         IF ( ipconc .ge. 3 ) THEN
           IF ( iacrsize .eq. 1 ) THEN
            nr = cx(mgs,lr)*gaml02d500( arg )  ! number greater than 500 microns in diameter
           ELSEIF ( iacrsize .eq. 2 .or. iacrsize .eq. 5 ) THEN
            nr = cx(mgs,lr)*gaml02d300( arg )  ! number greater than 300 microns in diameter
           ELSEIF ( iacrsize .eq. 3 ) THEN
            nr = cx(mgs,lr)*gaml02( arg ) ! number greater than 40 microns in diameter
           ELSEIF ( iacrsize .eq. 4 ) THEN
            nr = cx(mgs,lr) ! all raindrops
           ENDIF
         ELSE
         nr = cx(mgs,lr)*gaml02( arg )
         ENDIF
!        ELSEIF ( iacr .eq. 2 ) THEN
!         nr = cx(mgs,lr)*gaml02d300( arg )  ! number greater than 300 microns in diameter
!        ENDIF
       IF ( ni .gt. 0.0 .and. nr .gt. 0.0 ) THEN
       d0 = xdia(mgs,lr,3)
       qiacr(mgs) = xdn(mgs,lr)*rhoinv(mgs)*   &
     &     (0.217239*(0.522295*(d0**5) +    &
     &      49711.81*(d0**6) -    &
     &      1.673016e7*(d0**7)+    &
     &      2.404471e9*(d0**8) -    &
     &      1.22872e11*(d0**9))*ni*nr)
      qiacr(mgs) = Min( qrmxd(mgs), qiacr(mgs) )
      ciacr(mgs) =   &
     &   (0.217239*(0.2301947*(d0**2) +    &
     &      15823.76*(d0**3) -    &
     &      4.167685e6*(d0**4) +    &
     &      4.920215e8*(d0**5) -    &
     &      2.133344e10*(d0**6))*ni*nr)
      ciacr(mgs) = Min( crmxd(mgs), ciacr(mgs) )
!      ciacr(mgs) = qiacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
      ENDIF
      ENDIF
       IF ( iacr .eq. 1 .or. iacr .eq. 3 ) THEN
         ciacrf(mgs) = Min(ciacr(mgs), qiacr(mgs)/(1.0*vr1mm*1000.0)*rho0(mgs) ) ! *rzxh(mgs)
       ELSEIF ( iacr .eq. 2 ) THEN
         ciacrf(mgs) = ciacr(mgs) ! *rzxh(mgs)
       ELSEIF ( iacr .eq. 4 ) THEN
         ciacrf(mgs) = Min(ciacr(mgs), qiacr(mgs)/(1.0*vfrz*1000.0)*rho0(mgs) ) ! *rzxh(mgs)
       ELSEIF ( iacr .eq. 5 ) THEN
         ciacrf(mgs) = ciacr(mgs)*rzxh(mgs)
       ENDIF 
!      crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*27.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
       ENDIF
      
      
      ELSE ! single-moment rain
      qiacr(mgs) =    &
     &  min(        &
     &   ((0.25/gf4)*pi)*eri(mgs)*cx(mgs,li)*qx(mgs,lr)   &
     &  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))   &
     &  *(  gf6*gf1*xdia(mgs,lr,2)    &
     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,li,1)    &
     &    + gf4*gf3*xdia(mgs,li,2) )     &
     &  , qrmxd(mgs))
      ENDIF
!      if ( temg(mgs) .gt. 268.15 ) then
!      qiacr(mgs) = 0.0
!      ciacr(mgs) = 0.0
!      end if

      IF ( ipconc .ge. 1 ) THEN
        IF ( nsplinter .ge. 0 ) THEN
          csplinter(mgs) = nsplinter*ciacr(mgs)
        ELSE
          csplinter(mgs) = -nsplinter*ciacrf(mgs)
        ENDIF
        qsplinter(mgs) = Min(0.1*qiacr(mgs), csplinter(mgs)*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
      ENDIF
      
      frach = 1.0
           IF ( ibiggsnow == 2 .or. ibiggsnow == 3 ) THEN
           IF ( ciacr(mgs) > qxmin(lh) ) THEN
           xvfrz = rho0(mgs)*qiacr(mgs)/(ciacr(mgs)*900.) ! mean volume of frozen drops; 900. for frozen drop density
           frach = 0.5 *(1. +  Tanh(0.2e12 *( xvfrz - 1.15*xvmn(lh))))

             qiacrs(mgs) = (1.-frach)*qiacr(mgs)
             ciacrs(mgs) = (1.-frach)*ciacr(mgs) ! *rzxh(mgs)
           
           ENDIF
           ENDIF

      qiacrf(mgs) = frach*qiacr(mgs)
      ciacrf(mgs) = frach*ciacrf(mgs)

      IF ( lvol(lh) > 1 ) THEN
         viacrf(mgs) = rho0(mgs)*qiacrf(mgs)/rhofrz
      ENDIF
      
      end do
!
!
!
!

! snow aggregation here
      if ( ipconc .ge. 4 ) then !
      do mgs = 1,ngscnt
      csacs(mgs) = 0.0
      IF ( qx(mgs,ls) > qxmin(ls) .and. ess(mgs) .gt. 0.0 .and. xv(mgs,ls) < 0.25*xvmx(ls) ) THEN
      csacs(mgs) = rvt*aa2*ess(mgs)*cx(mgs,ls)**2*xv(mgs,ls)
      csacs(mgs) = min(csacs(mgs),csmxd(mgs))
      ENDIF
      end do
      end if
!
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 11'
      if ( ipconc .ge. 2 .or. ipelec .ge. 9 ) then
      do mgs = 1,ngscnt
      ciacw(mgs) = 0.0
      IF ( eiw(mgs) .gt. 0.0 ) THEN

        ciacw(mgs) = qiacw(mgs)*rho0(mgs)/xmas(mgs,lc)
      ciacw(mgs) = min(ciacw(mgs),ccmxd(mgs))
      ENDIF
      end do
      end if

      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 18'
      if ( ipconc .ge. 2 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt
       cracw(mgs) = 0.0
       cracr(mgs) = 0.0
       ec0(mgs) = 1.e9
      IF ( qx(mgs,lc) .gt. qxmin(lc) .and. qx(mgs,lr) .gt. qxmin(lr)    &
     &      .and. qracw(mgs) .gt. 0.0 ) THEN

       IF ( ipconc .lt. 3 ) THEN
        IF ( erw(mgs) .gt. 0.0 ) THEN
        cracw(mgs) =   &
     &   ((0.25)*pi)*erw(mgs)*cx(mgs,lc)*cx(mgs,lr)   &
     &  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,lc,1))   &
     &  *(  gf1*xdia(mgs,lc,2)   &
     &    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lr,1)   &
     &    + gf3*xdia(mgs,lr,2) )
        ENDIF
       ELSE ! IF ( ipconc .ge. 3 .and. 
        IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN  !{
        IF ( 0.5*xdia(mgs,lr,3) .gt. rh(mgs) ) THEN ! { .or. cx(mgs,lr) .gt. nh(mgs) 
!        IF ( qx(mgs,lc) .gt. qxmin(lc) .and. qx(mgs,lr) .gt. qxmin(lr) ) THEN
          IF ( 0.5*xdia(mgs,lr,3) .gt. rwradmn ) THEN ! r > 50.e-6 
!          DM0CCC=A2*XNC*XNR*(XVC+XVR)                               ! (A11)
!         NOTE: murain drops out, so same result for imurain = 1 and 3
            cracw(mgs) = aa2*cx(mgs,lr)*cx(mgs,lc)*(xv(mgs,lc) + xv(mgs,lr))
          ELSE
            IF ( imurain == 3 ) THEN
!          DM0CCC=A1*XNC*XNR*(((CNU+2.)/(CNU+1.))*XVC**2+((RNU+2.)/(RNU+1.))*XVR**2) ! (A13)
            cracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*   &
     &          ((cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.) +    &
     &          (alpha(mgs,lr) + 2.)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.))
            ELSE ! imurain == 1 USE CP00 for rain DSD in diameter
            cracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*   &
     &          ((cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.) +    &
     &          (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)*xv(mgs,lr)**2/  &
     &             ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.)) )
            ENDIF ! imurain
          ENDIF
        ENDIF ! } rh
        ENDIF ! } dmrauto
       ENDIF ! ipconc
      ENDIF ! qc > qcmin & qr > qrmin
        
! Rain self collection (cracr) and break-up (factor of ec0)
!
!       
        ec0(mgs) = 2.e9
        IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
        rwrad = 0.5*xdia(mgs,lr,3)
        IF ( xdia(mgs,lr,3) .gt. 2.0e-3 ) THEN
          ec0(mgs) = 0.0
          cracr(mgs) = 0.0
        ELSE
         IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN 
          IF ( xdia(mgs,lr,3) .lt. 6.1e-4 ) THEN
            ec0(mgs) = 1.0
          ELSE
            ec0(mgs) = Exp(-50.0*(50.0*(xdia(mgs,lr,3) - 6.0e-4)))
          ENDIF
          

          IF ( rwrad .ge. 50.e-6 ) THEN
              cracr(mgs) = ec0(mgs)*aa2*cx(mgs,lr)**2*xv(mgs,lr)
          ELSE
            IF ( imurain == 3 ) THEN
             cracr(mgs) = ec0(mgs)*aa1*(cx(mgs,lr)*xv(mgs,lr))**2*   &
     &                   (alpha(mgs,lr) + 2.)/(alpha(mgs,lr) + 1.)
            ELSE ! imurain == 1
             cracr(mgs) = ec0(mgs)*aa1*(cx(mgs,lr)*xv(mgs,lr))**2*   &
     &                   (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)/ &
     &                  ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.))
              
            ENDIF
          ENDIF
!          cracr(mgs) = Min(cracr(mgs),crmxd(mgs))
         ENDIF
        ENDIF
        ENDIF

!      cracw(mgs) = min(cracw(mgs),ccmxd(mgs))
      end do
      end if
!
!
!
!  Graupel
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22ii'
      chacw(:) = 0.0
      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt

      IF ( ipconc .ge. 5 ) THEN
       IF ( qhacw(mgs) .gt. 0.0 .and. xmas(mgs,lc) .gt. 0.0 ) THEN

!  This is the explict version of chacw, which turns out to be very close to the
!  approximation that the droplet size does not change, to within a few percent.
!  This may _not_ be the case for cnu other than zero!
!          chacw(mgs) = (ehw(mgs)*cx(mgs,lc)*cx(mgs,lh)*(pi/4.)*
!     :    abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))*
!     :    (2.0*xdia(mgs,lh,1)*(xdia(mgs,lh,1) +
!     :         xdia(mgs,lc,1)*gf43rds) +
!     :      xdia(mgs,lc,2)*gf53rds))

!          chacw(mgs) = Min( chacw(mgs), 0.6*cx(mgs,lc)/dtp )

!        chacw(mgs) = qhacw(mgs)*rho0(mgs)/xmas(mgs,lc)
        chacw(mgs) = qhacw(mgs)*rho0(mgs)/xmascw(mgs)
!        chacw(mgs) = min(chacw(mgs),cxmxd(mgs,lc))
        chacw(mgs) = Min( chacw(mgs), 0.5*cx(mgs,lc)/dtp )
       ELSE
        qhacw(mgs) = 0.0
       ENDIF
      ELSE
      chacw(mgs) =   &
     &   ((0.25)*pi)*ehw(mgs)*cx(mgs,lc)*cx(mgs,lh)   &
     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))   &
     &  *(  gf1*xdia(mgs,lc,2)   &
     &    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lh,1)   &
     &    + gf3*xdia(mgs,lh,2) )
      chacw(mgs) = min(chacw(mgs),0.5*cx(mgs,lc)/dtp)
!      chacw(mgs) = min(chacw(mgs),cxmxd(mgs,lc))
!      chacw(mgs) = min(chacw(mgs),ccmxd(mgs))
      ENDIF
      end do
      end if
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
      chaci(:) = 0.0
      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt
      IF ( ehi(mgs) .gt. 0.0 .or. ( ehiclsn(mgs) > 0.0 .and. ipelec > 0 )) THEN
       IF ( ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))**2 +    &
     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,li,1) )

          chaci0(mgs) = 0.25*pi*ehiclsn(mgs)*cx(mgs,lh)*cx(mgs,li)*vt*   &
     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
     &            dab0lh(mgs,li,lh)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
     &            da0(li)*xdia(mgs,li,3)**2 )

       ELSE
        chaci0(mgs) =   &
     &   ((0.25)*pi)*ehiclsn(mgs)*cx(mgs,li)*cx(mgs,lh)   &
     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))   &
     &  *(  gf1*xdia(mgs,li,2)   &
     &    + 2.0*gf2*xdia(mgs,li,1)*xdia(mgs,lh,1)   &
     &    + gf3*xdia(mgs,lh,2) )
        ENDIF

        chaci(mgs) = min(ehi(mgs)*chaci0(mgs),cimxd(mgs))
       ENDIF
      end do
      end if
!
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22nn'
      chacs(:) = 0.0
      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt
      IF ( ehs(mgs) .gt. 0 ) THEN
       IF ( ipconc .ge. 5 .or. ( ehsclsn(mgs) > 0.0 .and. ipelec > 0 ) ) THEN

       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))**2 +    &
     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,ls,1) )

          chacs0(mgs) = 0.25*pi*ehsclsn(mgs)*cx(mgs,lh)*cx(mgs,ls)*vt*   &
     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
     &            dab0lh(mgs,ls,lh)*xdia(mgs,lh,3)*xdia(mgs,ls,3) +    &
     &            da0(ls)*xdia(mgs,ls,3)**2 )

       ELSE
      chacs0(mgs) =   &
     &   ((0.25)*pi)*ehsclsn(mgs)*cx(mgs,ls)*cx(mgs,lh)   &
     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))   &
     &  *(  gf3*gf1*xdia(mgs,ls,2)   &
     &    + 2.0*gf2*gf2*xdia(mgs,ls,1)*xdia(mgs,lh,1)   &
     &    + gf1*gf3*xdia(mgs,lh,2) )
      ENDIF
      chacs(mgs) = min(ehs(mgs)*chacs0(mgs),csmxd(mgs))
      ENDIF
      end do
      end if


!
!
!  Hail
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22ii'
      chlacw(:) = 0.0
      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt

      IF ( lhl .gt. 1 .and. ipconc .ge. 5 ) THEN
       IF ( qhlacw(mgs) .gt. 0.0 .and. xmas(mgs,lc) .gt. 0.0 ) THEN

!  This is the explict version of chacw, which turns out to be very close to the
!  approximation that the droplet size does not change, to within a few percent.
!  This may _not_ be the case for cnu other than zero!
!          chlacw(mgs) = (ehlw(mgs)*cx(mgs,lc)*cx(mgs,lhl)*(pi/4.)*
!     :    abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))*
!     :    (2.0*xdia(mgs,lhl,1)*(xdia(mgs,lhl,1) +
!     :         xdia(mgs,lc,1)*gf43rds) +
!     :      xdia(mgs,lc,2)*gf53rds))

!          chlacw(mgs) = Min( chlacw(mgs), 0.6*cx(mgs,lc)/dtp )

!        chlacw(mgs) = qhlacw(mgs)*rho0(mgs)/xmas(mgs,lc)
        chlacw(mgs) = qhlacw(mgs)*rho0(mgs)/xmascw(mgs)
!        chlacw(mgs) = min(chlacw(mgs),cxmxd(mgs,lc))
        chlacw(mgs) = Min( chlacw(mgs), 0.5*cx(mgs,lc)/dtp )
       ELSE
        qhlacw(mgs) = 0.0
       ENDIF
!      ELSE
!      chlacw(mgs) =
!     >   ((0.25)*pi)*ehlw(mgs)*cx(mgs,lc)*cx(mgs,lhl)
!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))
!     >  *(  gf1*xdia(mgs,lc,2)
!     >    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lhl,1)
!     >    + gf3*xdia(mgs,lhl,2) )
!      chlacw(mgs) = min(chlacw(mgs),0.5*cx(mgs,lc)/dtp)
!      chlacw(mgs) = min(chlacw(mgs),cxmxd(mgs,lc))
!      chlacw(mgs) = min(chlacw(mgs),ccmxd(mgs))
      ENDIF
      end do
      end if
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
      chlaci(:) = 0.0
      chlaci0(:) = 0.0
      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt
      IF ( lhl .gt. 1 .and. ( ehli(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehliclsn(mgs) > 0.0) )  ) THEN
       IF ( ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))**2 +    &
     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,li,1) )

          chlaci0(mgs) = 0.25*pi*ehliclsn(mgs)*cx(mgs,lhl)*cx(mgs,li)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab0(lhl,li)*xdia(mgs,lhl,3)*xdia(mgs,li,3) +    &
     &            da0(li)*xdia(mgs,li,3)**2 )

!       ELSE
!        chlaci(mgs) =
!     >   ((0.25)*pi)*ehli(mgs)*cx(mgs,li)*cx(mgs,lhl)
!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))
!     >  *(  gf1*xdia(mgs,li,2)
!     >    + 2.0*gf2*xdia(mgs,li,1)*xdia(mgs,lhl,1)
!     >    + gf3*xdia(mgs,lhl,2) )
        ENDIF

        chlaci(mgs) = min(ehli(mgs)*chlaci0(mgs),cimxd(mgs))
       ENDIF
      end do
      end if
!
!
      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22jj'
      chlacs(:) = 0.0
      chlacs0(:) = 0.0
      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
      do mgs = 1,ngscnt
      IF ( lhl .gt. 1 .and. ( ehls(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehlsclsn(mgs) > 0.0) ) ) THEN
       IF ( ipconc .ge. 5 ) THEN

       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))**2 +    &
     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,ls,1) )

          chlacs0(mgs) = 0.25*pi*ehlsclsn(mgs)*cx(mgs,lhl)*cx(mgs,ls)*vt*   &
     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
     &            dab0(lhl,ls)*xdia(mgs,lhl,3)*xdia(mgs,ls,3) +    &
     &            da0(ls)*xdia(mgs,ls,3)**2 )

!       ELSE
!      chlacs(mgs) =
!     >   ((0.25)*pi)*ehls(mgs)*cx(mgs,ls)*cx(mgs,lhl)
!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))
!     >  *(  gf3*gf1*xdia(mgs,ls,2)
!     >    + 2.0*gf2*gf2*xdia(mgs,ls,1)*xdia(mgs,lhl,1)
!     >    + gf1*gf3*xdia(mgs,lhl,2) )
      ENDIF
      chlacs(mgs) = min(ehls(mgs)*chlacs0(mgs),csmxd(mgs))
      ENDIF
      end do
      end if

!
! Ziegler (1985) autoconversion
!
!
      IF ( ipconc .ge. 2 .and. ircnw /= -1) THEN ! DTD: added flag for autoconversion.  If -1, turns off autoconversion
      if (ndebug .gt. 0 ) write(0,*) 'conc 26a'
      
      DO mgs = 1,ngscnt
        zrcnw(mgs) = 0.0
        qrcnw(mgs) = 0.0
        crcnw(mgs) = 0.0
        cautn(mgs) = 0.0
      ENDDO
      
      DO mgs = 1,ngscnt
!      qracw(mgs) = 0.0
!      cracw(mgs) = 0.0
       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 1000. .and. temg(mgs) .gt. tfrh+4.) THEN
       ! .and. w(igs(mgs),jgs,kgs(mgs)) > 5.0) THEN ! DTD: added w threshold for testing                                                                                                            
         volb = xv(mgs,lc)*(1./(1.+CNU))**(1./2.)
         cautn(mgs) = Min(ccmxd(mgs),   &
     &      ((CNU+2.)/(CNU+1.))*aa1*cx(mgs,lc)**2*xv(mgs,lc)**2)
         cautn(mgs) = Max( 0.0d0, cautn(mgs) )
         IF ( rb(mgs) .le. 7.51d-6 ) THEN
           t2s = 1.d30
!           cautn(mgs) = 0.0
         ELSE
!         XL2P=2.7E-2*XNC*XVC*((1.E12*RB**3*RC)-0.4)
         
!        T2S=3.72E-3/(((1.E4*RB)-7.5)*XNC*XVC) 
!           t2s = 3.72E-3/(((1.e6*rb)-7.5)*cx(mgs,lc)*xv(mgs,lc))
!           t2s = 3.72/(((1.e6*rb(mgs))-7.5)*rho0(mgs)*qx(mgs,lc))
           t2s = 3.72/(1.e6*(rb(mgs)-7.500d-6)*rho0(mgs)*qx(mgs,lc))

           qrcnw(mgs) = Max( 0.0d0, xl2p(mgs)/(t2s*rho0(mgs)) )
           crcnw(mgs) = Max( 0.0d0, Min(3.5e9*xl2p(mgs)/t2s,0.5*cautn(mgs)) )
           
           IF ( dmrauto == 0 ) THEN
             IF ( qx(mgs,lr)*rho0(mgs) > 1.2*xl2p(mgs) .and. cx(mgs,lr) > cxmin ) THEN ! Cohard and Pinty (2000a) switch over from (18) to (19)
               crcnw(mgs) = cx(mgs,lr)/qx(mgs,lr)*qrcnw(mgs)
             ENDIF
           ELSEIF ( dmrauto == 1  .and. cx(mgs,lr) > cxmin) THEN
             IF ( qx(mgs,lr) > qxmin(lr) ) THEN
               tmp = qrcnw(mgs)*cx(mgs,lr)/qx(mgs,lr)
               crcnw(mgs) = Min(tmp,crcnw(mgs) )
             ENDIF
           ELSEIF ( dmrauto == 2  .and. cx(mgs,lr) > cxmin) THEN
               tmp = crcnw(mgs)
               tmp2 = qrcnw(mgs)*cx(mgs,lr)/qx(mgs,lr)
               ! try mass-weighted average of old and new Dmr
               crcnw(mgs) = (tmp*qrcnw(mgs)+tmp2*qx(mgs,lr))/(qrcnw(mgs)+qx(mgs,lr))
           ELSEIF ( dmrauto == 3  .and. cx(mgs,lr) > cxmin) THEN ! adapted from MY/CP code
              tmp = Max( 2.d0*rh(mgs), dble( xdia(mgs,lr,3) ) )
              crcnw(mgs) = rho0(mgs)*qrcnw(mgs)/(pi/6.*1000.*tmp**3)
           ENDIF
           
           IF ( crcnw(mgs) < 1.e-30 ) qrcnw(mgs) = 0.0

!           IF (  crcnw(mgs) .gt. cautn(mgs) .and. crcnw(mgs) .gt. 1.0 )
!     :          THEN
!             write(0,*)  'crcnw,cautn ',crcnw(mgs)/cautn(mgs),
!     :          crcnw(mgs),cautn(mgs),igs(mgs),kgs(mgs),t2s,qx(mgs,lr)
!             write(0,*)  '            ',qx(mgs,lc),cx(mgs,lc),0.5e6*xdia(mgs,lc,1)
!             write(0,*)  '            ',rho0(mgs)*qrcnw(mgs)/crcnw(mgs),
!     :         1.e6*(( 3/(4.*pi))*rho0(mgs)*qrcnw(mgs)/
!     :       (crcnw(mgs)*xdn(mgs,lr)))**(1./3.),rh(mgs)*1.e6,rwrad(mgs)
!           ELSEIF ( crcnw(mgs) .gt. 1.0 .and. cautn(mgs) .gt. 0.) THEN
!             write(0,*)  'crcnw,cautn ',crcnw(mgs)/cautn(mgs),
!     :          crcnw(mgs),cautn(mgs),igs(mgs),kgs(mgs),t2s
!             write(0,*)  '            ',rho0(mgs)*qrcnw(mgs)/crcnw(mgs),
!     :  1.e6*(( 3*pi/4.)*rho0(mgs)*qrcnw(mgs)/
!     :   (crcnw(mgs)*xdn(mgs,lr)))**(1./3.)
!           ENDIF
!           crcnw(mgs) = Min(cautn(mgs),3.5e9*xl2p(mgs)/t2s)

!           IF ( qrcnw(mgs) .gt. 0.3e-2 ) THEN
!            write(0,*)  'QRCNW'
!            write(0,*)  qrcnw(mgs),crcnw(mgs),cautn(mgs)
!            write(0,*)  xl2p,t2s,rho0(mgs),xv(mgs,lc),cx(mgs,lc),qx(mgs,lc)
!            write(0,*)  rb,0.5*xdia(mgs,lc,1),mgs,igs(mgs),kgs(mgs)
!           ENDIF
!           qrcnw(mgs) = Min(qrcnw(mgs),qcmxd(mgs))
         ENDIF


       ENDIF
      ENDDO



      ELSE

!
!  Berry 1968 auto conversion for rain (Orville & Kopp 1977)
!
!
      if ( ircnw .eq. 4 ) then
      do mgs = 1,ngscnt
!      sconvmix(lcw,mgs) = 0.0
      qrcnw(mgs) =  0.0
      qdiff = max((qx(mgs,lc)-qminrncw),0.0)
      if ( qdiff .gt. 0.0 .and. xdia(mgs,lc,1) .gt. 20.0e-6 ) then
      argrcnw =   &
     &  ((1.2e-4)+(1.596e-12)*(cx(mgs,lc)*1.0e-6)   &
     &  /(cwdisp*qdiff*1.0e-3*rho0(mgs)))
      qrcnw(mgs) = (rho0(mgs)*1e-3)*(qdiff**2)/argrcnw
!      sconvmix(lcw,mgs) = max(sconvmix(lcw,mgs),0.0)
      qrcnw(mgs) = (max(qrcnw(mgs),0.0))
      end if
      end do

      ENDIF
!
!
!
!  Berry 1968 auto conversion for rain (Ferrier 1994)
!
!
      if ( ircnw .eq. 5 ) then
      do mgs = 1,ngscnt
      qrcnw(mgs) = 0.0
      qrcnw(mgs) =  0.0
      qccrit = (pi/6.)*(cx(mgs,lc)*cwdiap**3)*xdn(mgs,lc)/rho0(mgs)
      qdiff = max((qx(mgs,lc)-qccrit),0.)
      if ( qdiff .gt. 0.0 .and. cx(mgs,lc) .gt. 1.0 ) then
      argrcnw = &
!     >  ((1.2e-4)+(1.596e-12)*cx(mgs,lc)/(cwdisp*rho0(mgs)*qdiff))   &
     &  ((1.2e-4)+(1.596e-12)*cx(mgs,lc)*1.0e-3/(cwdisp*rho0(mgs)*qdiff))
      qrcnw(mgs) = &
!     >  timflg(mgs)*rho0(mgs)*(qdiff**2)/argrcnw   &
     &  1.0e-3*rho0(mgs)*(qdiff**2)/argrcnw
      qrcnw(mgs) = Min(qxmxd(mgs,lc), (max(qrcnw(mgs),0.0)) )

!      write(iunit,*) 'qrcnw,cx =',qrcnw(mgs),cx(mgs,lc),mgs,1.e3*qx(mgs,lc),cno(lr)
      end if
      end do
      end if

!
!
!  kessler auto conversion for rain.
!
      if ( ircnw .eq. 2 ) then
      do mgs = 1,ngscnt
      qrcnw(mgs) = 0.0
      qrcnw(mgs) = (0.001)*max((qx(mgs,lc)-qminrncw),0.0)
      end do
      end if
!
!  c4 = pi/6
!  c1 = 0.12-0.32 for colorado storms...typically 0.3-0.4
!  berry reinhart type conversion (proctor 1988)
!
      if ( ircnw .eq. 1 ) then
      do mgs = 1,ngscnt
      qrcnw(mgs) = 0.0
      c1 = 0.2
      c4 = pi/(6.0)
      bradp =    &
     & (1.e+06) * ((c1/(0.38))**(1./3.)) * (xdia(mgs,lc,1)*(0.5))
      bl2 =   &
     & (0.027) * ((100.0)*(bradp**3)*(xdia(mgs,lc,1)*(0.5)) - (0.4))
      bt2 = (bradp -7.5) / (3.72)
      qrcnw(mgs) = 0.0
      if ( bl2 .gt. 0.0 .and. bt2 .gt. 0.0 ) then
      qrcnw(mgs) = bl2 * bt2 * rho0(mgs)   &
     &  * qx(mgs,lc) * qx(mgs,lc)
      end if
      end do
      end if



      ENDIF  !  ( ipconc .ge. 2 )

!
!
!
!  Bigg Freezing of Rain
!
      if (ndebug .gt. 0 ) write(0,*) 'conc 27a'
      qrfrz(:) = 0.0
      qrfrzs(:) = 0.0
      qrfrzf(:) = 0.0
      vrfrzf(:) = 0.0
      crfrz(:) = 0.0
      crfrzs(:) = 0.0
      crfrzf(:) = 0.0
      zrfrz(:)  = 0.0
      zrfrzf(:)  = 0.0
      qwcnr(:) = 0.0
      
      IF ( .not. ( ipconc == 0 .and. lwsm6 ) ) THEN
      
      do mgs = 1,ngscnt 
      if ( qx(mgs,lr) .gt. qxmin(lr) .and. temcg(mgs) .lt. -5. .and. ibiggopt > 0 ) then
!      brz = 100.0
!      arz = 0.66
       IF ( ipconc .lt. 3 ) THEN
       qrfrz(mgs) =    &
     &  min(   &
     &  (20.0)*(pi**2)*brz*(xdn(mgs,lr)/rho0(mgs))   &
     &   *cx(mgs,lr)*(xdia(mgs,lr,1)**6)   &
     &   *(exp(max(-arz*temcg(mgs), 0.0))-1.0)   &
     &  , qrmxd(mgs))
        qrfrzf(mgs) = qrfrz(mgs)

!       ELSEIF ( ipconc .ge. 3 .and. xv(mgs,lr) .gt. 1.1*xvmn(lr) ) THEN
       ELSEIF ( ipconc .ge. 3 ) THEN
!         tmp = brz*cx(mgs,lr)*(Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
!         crfrz(mgs) = xv(mgs,lr)*tmp

         frach = 1.0d0
         
!         IF ( ibiggopt == 2 .and. imurain == 1 .and. lzr < 1 ) THEN ! lzr check because results are weird for 3-moment
         IF ( ibiggopt == 2 .and. imurain == 1 ) THEN !
         ! integrate from Bigg diameter (for given supercooling Ts) to infinity
           
           volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b
                                               ! volt is given in cm**3, so convert to m**3
           dbigg = (6./pi* volt )**(1./3.) 
           
           ! perhaps should also test that W > V_t_dbigg, i.e., that drops the size of dbigg are being lifted and cooled. 
           
             ratio = dbigg/xdia(mgs,lr,1)
           
           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
!           j = Int(Max(0.0,Min(15.,alpha(mgs,lr))))
           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
           delx = ratio - float(i)*dqiacrratio
           dely = alpha(mgs,lr) - float(j)*dqiacralpha
           ip1 = Min( i+1, nqiacrratio )
           jp1 = Min( j+1, nqiacralpha )

           ! interpolate along x, i.e., ratio; 
           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
           
           ! interpolate along alpha; 
           
           crfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)/dtp
           
           ! interpolate along x, i.e., ratio; 
           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
           
           ! interpolate along alpha; 
           
           qrfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)/dtp
           
           
           
           IF ( dbigg < Min(dfrz,dhmn) .and. ( ibiggsnow == 1 .or. ibiggsnow == 3 ) ) THEN ! convert some to snow or ice crystals
            ! temporarily store qrfrz and crfrz in snow terms
            crfrzs(mgs) = qrfrz(mgs)
            qrfrzs(mgs) = crfrz(mgs)


           ! recalculate using dhmn for ratio
           ratio = Min(dfrz,dhmn)/xdia(mgs,lr,1)
           
           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
!           j = Int(Max(0.0,Min(15.,alpha(mgs,lr))))
           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
           delx = ratio - float(i)*dqiacrratio
           dely = alpha(mgs,lr) - float(j)*dqiacralpha
           ip1 = Min( i+1, nqiacrratio )
           jp1 = Min( j+1, nqiacralpha )

           ! interpolate along x, i.e., ratio; 
           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
           
           ! interpolate along alpha; 
           
           crfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)/dtp
           
           ! interpolate along x, i.e., ratio; 
           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
           
           ! interpolate along alpha; 
           
           qrfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)/dtp

           ! now subtract off the difference
            crfrzs(mgs) = crfrzs(mgs) - crfrz(mgs)
            qrfrzs(mgs) = qrfrzs(mgs) - qrfrz(mgs)

           
           ELSE
            crfrzs(mgs) = 0.0
            qrfrzs(mgs) = 0.0
           ENDIF
           
           IF ( (qrfrzs(mgs) + qrfrz(mgs))*dtp > qx(mgs,lr) ) THEN
             fac = ( qrfrzs(mgs) + qrfrz(mgs) )*dtp/qx(mgs,lr)
             qrfrz(mgs) = fac*qrfrz(mgs)
             qrfrzs(mgs) = fac*qrfrzs(mgs)
             qrfrzf(mgs) = fac*qrfrzf(mgs)
             crfrz(mgs) = fac*crfrz(mgs)
             crfrzs(mgs) = fac*crfrzs(mgs)
             crfrzf(mgs) = fac*crfrzf(mgs)
           ENDIF
!           IF ( (crfrzs(mgs) + crfrz(mgs))*dtp > cx(mgs,lr) ) THEN
!             fac = ( crfrzs(mgs) + crfrz(mgs) )*dtp/cx(mgs,lr)
!             crfrz(mgs) = fac*crfrz(mgs)
!             crfrzs(mgs) = fac*crfrzs(mgs)
!           ENDIF
           
           qrfrzf(mgs) = qrfrz(mgs)
           crfrzf(mgs) = crfrz(mgs)
           
           qrfrz(mgs) = qrfrzf(mgs) + qrfrzs(mgs)
           crfrz(mgs) = crfrzf(mgs) + crfrzs(mgs)

           
         ELSE ! ibiggopt == 1 
         
         tmp = xv(mgs,lr)*brz*cx(mgs,lr)*(Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
         IF ( .false. .and. tmp .gt. cxmxd(mgs,lr) ) THEN ! {
!           write(iunit,*) 'Bigg Freezing problem!',mgs,igs(mgs),kgs(mgs)
!           write(iunit,*)  'tmp, cx(lr), xv = ',tmp, cx(mgs,lr), xv(mgs,lr), (Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
!           write(iunit,*)  'qr,temcg = ',qx(mgs,lr)*1000.,temcg(mgs)
           crfrz(mgs) = cxmxd(mgs,lr) ! cx(mgs,lr)/dtp
           qrfrz(mgs) = qxmxd(mgs,lr) ! qx(mgs,lr)/dtp
!           STOP
         ELSE ! } {
         crfrz(mgs) = tmp
 !        crfrzfmx = cx(mgs,lr)*Exp(-4./3.*pi*(40.e-6)**3/xv(mgs,lr))
 !        IF ( crfrz(mgs) .gt. crfrzmx ) THEN
 !          crfrz(mgs) = crfrzmx
 !          qrfrz(mgs) = bfnu*xmas(mgs,lr)*rhoinv(mgs)*crfrzmx
 !          qwcnr(mgs) = cx(mgs,lr) - crfrzmx
 !        ELSE
         IF ( lzr < 1 ) THEN
           IF ( imurain == 3 ) THEN
             bfnu = bfnu0
           ELSE !imurain == 1
             bfnu = bfnu1
           ENDIF
         ELSE
 !         bfnu = 1.0 ! (alpha(mgs,lr)+2.0)/(alpha(mgs,lr)+1.)
           IF ( imurain == 3 ) THEN
             bfnu = (alpha(mgs,lr)+2.0)/(alpha(mgs,lr)+1.)
           ELSE !imurain == 1
!             bfnu = bfnu1
            bfnu = (4. + alpha(mgs,lr))*(5. + alpha(mgs,lr))*(6. + alpha(mgs,lr))/  &
     &            ((1. + alpha(mgs,lr))*(2. + alpha(mgs,lr))*(3. + alpha(mgs,lr)))
!            bfnu = 1.
           ENDIF
         ENDIF 
         qrfrz(mgs) = bfnu*xmas(mgs,lr)*rhoinv(mgs)*crfrz(mgs)

         qrfrz(mgs) = Min( qrfrz(mgs), 1.*qx(mgs,lr)/dtp ) ! qxmxd(mgs,lr) 
         crfrz(mgs) = Min( crfrz(mgs), 1.*cx(mgs,lr)/dtp ) !cxmxd(mgs,lr) 
         qrfrz(mgs) = Min( qrfrz(mgs), qx(mgs,lr) )
         qrfrzf(mgs) = qrfrz(mgs)
         ENDIF !}

         
         
         
         IF ( crfrz(mgs) .gt. qxmin(lh) ) THEN
!          IF ( xdia(mgs,lr,1) .lt. 200.e-6 ) THEN
!           IF ( xv(mgs,lr) .lt. xvmn(lh) ) THEN
           
           IF ( ibiggsnow == 1 .or. ibiggsnow == 3 ) THEN
           xvfrz = rho0(mgs)*qrfrz(mgs)/(crfrz(mgs)*900.) ! mean volume of frozen drops; 900. for frozen drop density
           frach = 0.5 *(1. +  Tanh(0.2e12 *( xvfrz - 1.15*xvmn(lh))))

             qrfrzs(mgs) = (1.-frach)*qrfrz(mgs)
             crfrzs(mgs) = (1.-frach)*crfrz(mgs) ! *rzxh(mgs)
!             qrfrzf(mgs) = frach*qrfrz(mgs)
           
           ENDIF
           
           IF ( ipconc .ge. 14 .and. 1.e-3*rho0(mgs)*qrfrz(mgs)/crfrz(mgs) .lt. xvmn(lh) ) THEN
             qrfrzs(mgs) = qrfrz(mgs)
             crfrzs(mgs) = crfrz(mgs) ! *rzxh(mgs)
           ELSE
!           crfrz(mgs) = Min( crfrz(mgs), 0.1*cx(mgs,lr)/dtp ) ! cxmxd(mgs,lr) )
!           qrfrz(mgs) = Min( qrfrz(mgs), 0.1*qx(mgs,lr)/dtp ) ! qxmxd(mgs,lr) )
             qrfrzf(mgs) = frach*qrfrz(mgs)
!             crfrzf(mgs) = Min( qrfrz(mgs)*rho0(mgs)/(xdn(mgs,lh)*vgra), crfrz(mgs) )
            IF ( ibfr .le. 1 ) THEN
             crfrzf(mgs) = frach*Min(crfrz(mgs), dble(qrfrz(mgs)/(bfnu*1.0*vr1mm*1000.0)*rho0(mgs)) ) ! rzxh(mgs)*crfrz(mgs)
            ELSEIF ( ibfr .eq. 5 ) THEN
             crfrzf(mgs) = frach*Min(crfrz(mgs), dble(qrfrz(mgs)/(bfnu*vfrz*1000.0)*rho0(mgs)) )*rzxh(mgs)  !*crfrz(mgs)
            ELSEIF ( ibfr .eq. 2 ) THEN
             crfrzf(mgs) = frach*Min(crfrz(mgs), dble(qrfrz(mgs)/(bfnu*vfrz*1000.0)*rho0(mgs)) ) ! rzxh(mgs)*crfrz(mgs)
            ELSEIF ( ibfr .eq. 6 ) THEN
             crfrzf(mgs) = frach*Max(crfrz(mgs), dble(qrfrz(mgs)/(bfnu*9.*xv(mgs,lr)*1000.0)*rho0(mgs)) ) ! rzxh(mgs)*crfrz(mgs)
            ELSE
             crfrzf(mgs) = frach*crfrz(mgs)
            ENDIF
!             crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*xvmn(lh)*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
!            IF ( lz(lr) > 1 .and. lz(lh) > 1 ) THEN
!              crfrzf(mgs) = crfrz(mgs)
!            ENDIF
            
           ENDIF
!         crfrz(mgs) = Min( cxmxd(mgs,lr), rho0(mgs)*qrfrz(mgs)/xmas(mgs,lr) )
         ELSE
          crfrz(mgs) = 0.0
          qrfrz(mgs) = 0.0
         ENDIF

         ENDIF ! ibiggopt

          IF ( lvol(lh) .gt. 1 ) THEN
           vrfrzf(mgs) = rho0(mgs)*qrfrzf(mgs)/rhofrz
          ENDIF

        
        IF ( nsplinter .ne. 0 ) THEN
          IF ( nsplinter .gt. 0 ) THEN
            tmp = nsplinter*crfrz(mgs)
          ELSE
            tmp = -nsplinter*crfrzf(mgs)
          ENDIF
          csplinter2(mgs) = tmp
          qsplinter2(mgs) = Min(0.1*qrfrz(mgs), tmp*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel

!          csplinter(mgs) = csplinter(mgs) + tmp
!          qsplinter(mgs) = qsplinter(mgs) + Min(0.1*qrfrz(mgs), tmp*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
        ENDIF
!         IF ( temcg(mgs) .lt. -31.0 ) THEN
!           qrfrz(mgs) = qx(mgs,lr)/dtp + qrcnw(mgs)
!           qrfrzf(mgs) = qrfrz(mgs)
!           crfrz(mgs) = cx(mgs,lr)/dtp + crcnw(mgs)
!           crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*1.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
!         ENDIF
!         qrfrz(mgs) = 6.0*xdn(mgs,lr)*xv(mgs,lr)**2*tmp*rhoinv(mgs)
!         qrfrz(mgs) = Min( qrfrz(mgs), ffrz*qrmxd(mgs) )
!         crfrz(mgs) = Min( crmxd(mgs), ffrz*crfrz(mgs))
!         crfrz(mgs) = Min(crmxd(mgs),qrfrz(mgs)*rho0(mgs)/xmas(mgs,lr))
       ENDIF
!      if ( temg(mgs) .gt. 268.15 ) then
      else
!      end if
      end if
      end do
      
      ENDIF
!
!  Homogeneous freezing of cloud drops to ice crystals
!  following Bigg (1953) and Ferrier (1994).
!
      if (ndebug .gt. 0 ) write(0,*) 'conc 25b'
      do mgs = 1,ngscnt
      qwfrz(mgs) = 0.0
      cwfrz(mgs) = 0.0
      qwfrzc(mgs) = 0.0
      cwfrzc(mgs) = 0.0
      qwfrzp(mgs) = 0.0
      cwfrzp(mgs) = 0.0
      IF ( ibfc .ge. 1 .and. temg(mgs) < 268.15 ) THEN
!      if ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 1.  .and.   &
!     &     .not. (ipconc .ge. 2 .and. xdia(mgs,lc,1) .lt. 10.e-6) ) then
      if ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. cxmin ) THEN
      IF ( ipconc < 2 ) THEN
      qwfrz(mgs) = ((2.0)*(brz)/(xdn(mgs,lc)*cx(mgs,lc)))   &
     &  *(exp(max(-arz*temcg(mgs), 0.0))-1.0)   &
     &  *rho0(mgs)*(qx(mgs,lc)**2)
      qwfrz(mgs) = max(qwfrz(mgs), 0.0)
      qwfrz(mgs) = min(qwfrz(mgs),qcmxd(mgs))
         cwfrz(mgs) = qwfrz(mgs)*rho0(mgs)/xmas(mgs,li)
       ELSEIF ( ipconc .ge. 2 ) THEN
         IF ( xdia(mgs,lc,3) > 0.e-6 ) THEN
          volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b
                                               ! volt is given in cm**3, so factor of 1.e-6 to convert to m**3
!           dbigg = (6./pi* volt )**(1./3.) 

         cwfrz(mgs) = cx(mgs,lc)*Exp(-volt/xv(mgs,lc))/dtp ! number of droplets with volume greater than volt
!turn off limit so that all can freeze at low temp
!!!       cwfrz(mgs) = Min(cwfrz(mgs),ccmxd(mgs))

         qwfrz(mgs) = cwfrz(mgs)*xdn0(lc)*rhoinv(mgs)*(volt + xv(mgs,lc))
!         cwfrz(mgs) = cx(mgs,lc)*qwfrz(mgs)/qx(mgs,lc) ! reset number frozen to same fraction as mass. This makes 
                                                       ! sure that cwfrz and qwfrz are consistent and prevents 
                                                       ! spurious creation of ice crystals.
!         IF ( temg(mgs) < tfrh - 3 ) THEN
!          cwfrz(mgs) = cx(mgs,lc)
!          qwfrz(mgs) = qx(mgs,lc)
!         ENDIF
!         IF ( qwfrz(mgs) > 0.5*qx(mgs,lc) ) THEN
!           write(0,*) 'Problem with qwfrz(mgs): qwfrz,temcg,volt,xv,cx = ',qwfrz(mgs),qx(mgs,lc),temcg(mgs),volt,xv(mgs,lc),cx(mgs,lc),cwfrz(mgs)
!           STOP
!         ENDIF
!turn off limit so that all can freeze at low temp
!!!         qwfrz(mgs) = Min( qwfrz(mgs), qxmxd(mgs,lc) )
         ENDIF
       ENDIF
      if ( temg(mgs) .gt. 268.15 ) then
      qwfrz(mgs) = 0.0
      cwfrz(mgs) = 0.0
      end if
      end if
      ENDIF
!
      if ( xplate(mgs) .eq. 1 ) then
      qwfrzp(mgs) = qwfrz(mgs)
      cwfrzp(mgs) = cwfrz(mgs)
      end if
!
      if ( xcolmn(mgs) .eq. 1 ) then
      qwfrzc(mgs) = qwfrz(mgs)
      cwfrzc(mgs) = cwfrz(mgs)
      end if
!
!     qwfrzp(mgs) = 0.0
!     qwfrzc(mgs) = qwfrz(mgs)
!
      end do
!
!
!  Contact freezing nucleation:  factor is to convert from L-1
!  T < -2C:  via Meyers et al. JAM July, 1992 (31, 708-721)
!
      if (ndebug .gt. 0 ) write(0,*) 'conc 25a'
      do mgs = 1,ngscnt

       ccia(mgs) = 0.0

       cwctfz(mgs) = 0.0
       qwctfz(mgs) = 0.0
       ctfzbd(mgs) = 0.0
       ctfzth(mgs) = 0.0
       ctfzdi(mgs) = 0.0

       cwctfzc(mgs) = 0.0
       qwctfzc(mgs) = 0.0
       cwctfzp(mgs) = 0.0
       qwctfzp(mgs) = 0.0

       IF ( icfn .ge. 1 ) THEN

       IF ( temg(mgs) .lt. 271.15  .and. qx(mgs,lc) .gt. qxmin(lc)) THEN

!       find available # of ice nuclei & limit value to max depletion of cloud water

        IF ( icfn .ge. 2 ) THEN
         ccia(mgs) = exp( 4.11 - (0.262)*temcg(mgs) )  ! in m-3, see Walko et al. 1995
         !ccia(mgs) = Min(cwctfz(mgs), ccmxd(mgs) )

!       now find how many of these collect cloud water to form IN
!       Cotton et al 1986

         knud(mgs) = 2.28e-5 * temg(mgs) / ( pres(mgs)*raero ) !Walko et al. 1995
         knuda(mgs) = 1.257 + 0.4*exp(-1.1/knud(mgs))          !Pruppacher & Klett 1997 eqn 11-16
         gtp(mgs) = 1. / ( fai(mgs) + fbi(mgs) )               !Byers 65 / Cotton 72b
         dfar(mgs) = kb*temg(mgs)*(1.+knuda(mgs)*knud(mgs))/(6.*pi*fadvisc(mgs)*raero) !P&K 1997 eqn 11-15
         fn1(mgs) = 2.*pi*xdia(mgs,lc,1)*cx(mgs,lc)*ccia(mgs)
         fn2(mgs) = -gtp(mgs)*(ssw(mgs)-1.)*felv(mgs)/pres(mgs)
         fnft(mgs) = 0.4*(1.+1.45*knud(mgs)+0.4*knud(mgs)*exp(-1./knud(mgs)))*(ftka(mgs)+2.5*knud(mgs)*kaero)      &
     &              / ( (1.+3.*knud(mgs))*(2*ftka(mgs)+5.*knud(mgs)*kaero+kaero) )


!      Brownian diffusion
         ctfzbd(mgs) = fn1(mgs)*dfar(mgs)

!      Thermophoretic contact nucleation
         ctfzth(mgs) = fn1(mgs)*fn2(mgs)*fnft(mgs)/rho0(mgs)

!      Diffusiophoretic contact nucleation
         ctfzdi(mgs) = fn1(mgs)*fn2(mgs)*rw*temg(mgs)/(felv(mgs)*rho0(mgs))

         cwctfz(mgs) = max( ctfzbd(mgs) + ctfzth(mgs) + ctfzdi(mgs) , 0.)

!      Sum of the contact nucleation processes
!         IF ( cx(mgs,lc) .gt. 50.e6) write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs)
!         IF ( wvel(mgs) .lt. -0.05 ) write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs),cx(mgs,lc)*1e-6,wvel(mgs)
!         IF ( ssw(mgs) .lt. 1.0 .and. cx(mgs,lc) .gt. 1.e6 .and. cwctfz(mgs) .gt. 1. ) THEN
!          write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs),cx(mgs,lc)*1e-6,wvel(mgs),fn1(mgs),fn2(mgs)
!          write(6,*) 'more = ',nstep,ssw(mgs),dfar(mgs),gtp(mgs),felv(mgs),pres(mgs)
!         ENDIF

        ELSEIF ( icfn .eq. 1 ) THEN
         IF ( wvel(mgs) .lt. -0.05 ) THEN ! older kludgy version
           cwctfz(mgs) = cfnfac*exp( (-2.80) - (0.262)*temcg(mgs) )
           cwctfz(mgs) = Min((1.0e3)*cwctfz(mgs), ccmxd(mgs) )  !convert to m-3
         ENDIF
        ENDIF   ! icfn

        IF ( ipconc .ge. 2 ) THEN
         cwctfz(mgs) = Min( cwctfz(mgs)/dtp, ccmxd(mgs) )
         qwctfz(mgs) = xmas(mgs,lc)*cwctfz(mgs)/rho0(mgs)
        ELSE
         qwctfz(mgs) = (cimasn)*cwctfz(mgs)/(dtp*rho0(mgs))
         qwctfz(mgs) = max(qwctfz(mgs), 0.0)
         qwctfz(mgs) = min(qwctfz(mgs),qcmxd(mgs))
        ENDIF

!
        if ( xplate(mgs) .eq. 1 ) then
         qwctfzp(mgs) = qwctfz(mgs)
         cwctfzp(mgs) = cwctfz(mgs)
        end if
!
        if ( xcolmn(mgs) .eq. 1 ) then
         qwctfzc(mgs) = qwctfz(mgs)
         cwctfzc(mgs) = cwctfz(mgs)
        end if
!
!     qwctfzc(mgs) = qwctfz(mgs)
!     qwctfzp(mgs) = 0.0
!
       end if

       ENDIF ! icfn

      end do
!
!
!
! Hobbs-Rangno ice enhancement (Ferrier, 1994)
!
      if (ndebug .gt. 0 ) write(0,*) 'conc 23a'
      dtrh = 300.0
      hrifac = (1.e-3)*((0.044)*(0.01**3))
      do mgs = 1,ngscnt
      ciihr(mgs) = 0.0
      qiihr(mgs) = 0.0
      cicichr(mgs) = 0.0
      qicichr(mgs) = 0.0
      cipiphr(mgs) = 0.0
      qipiphr(mgs) = 0.0
      IF ( ihrn .ge. 1 ) THEN
      if ( qx(mgs,lc) .gt. qxmin(lc) ) then
      if ( temg(mgs) .lt. 273.15 ) then
!      write(iunit,'(3(1x,i3),3(1x,1pe12.5))')
!     : igs(mgs),jgs,kgs(mgs),cx(mgs,lc),rho0(mgs),qx(mgs,lc)
!      write(iunit,'(1pe15.6)')
!     :  log(cx(mgs,lc)*(1.e-6)/(3.0)),
!     :  ((1.e-3)*rho0(mgs)*qx(mgs,lc)),
!     :  (cx(mgs,lc)*(1.e-6)),
!     : ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)),
!     : (alog(cx(mgs,lc)*(1.e-6)/(3.0)) *
!     >  ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)))

      IF ( Log(cx(mgs,lc)*(1.e-6)/(3.0)) .gt. 0.0 ) THEN
      ciihr(mgs) = ((1.69e17)/dtrh)   &
     & *(log(cx(mgs,lc)*(1.e-6)/(3.0)) *   &
     &  ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)))**(7./3.)
      ciihr(mgs) = ciihr(mgs)*(1.0e6)
      qiihr(mgs) = hrifac*ciihr(mgs)/rho0(mgs)
      qiihr(mgs) = max(qiihr(mgs), 0.0)
      qiihr(mgs) = min(qiihr(mgs),qcmxd(mgs))
      ENDIF
!
      if ( xplate(mgs) .eq. 1 ) then
      qipiphr(mgs) = qiihr(mgs)
      cipiphr(mgs) = ciihr(mgs)
      end if
!
      if ( xcolmn(mgs) .eq. 1 ) then
      qicichr(mgs) = qiihr(mgs)
      cicichr(mgs) = ciihr(mgs)
      end if
!
!     qipiphr(mgs) = 0.0
!     qicichr(mgs) = qiihr(mgs)
!
      end if
      end if
      ENDIF ! ihrn
      end do
!
!
!
!  simple frozen rain to hail conversion.  All of the
!  frozen rain larger than 5.0e-3 m in diameter are converted
!  to hail.  This is done by considering the equation for
!  frozen rain mixing ratio:
!
!
!  qfw = [ cno(lf) * pi * fwdn / (6 rhoair) ]
!
!         /inf
!      *  |     fwdia*3 exp(-dia/fwdia) d(dia)
!         /Do
!
!  The amount to be reclassified as hail is the integral above from
!  Do to inf where Do is 5.0e-3 m.
!
!
!  qfauh = [ cno(lf) * pi * fwdn / (6 rhoair) ]
!
!


      hdia0 = 300.0e-6
      do mgs = 1,ngscnt
      qscnvi(mgs) = 0.0
      cscnvi(mgs) = 0.0
      cscnvis(mgs) = 0.0
!      IF ( .false. ) THEN
!      IF ( temg(mgs) .lt. tfr .and. ssi(mgs) .gt. 1.01 .and. qx(mgs,li) .gt. qxmin(li) ) THEN
      IF ( temg(mgs) .lt. tfr .and. qx(mgs,li) .gt. qxmin(li) ) THEN
        IF ( ipconc .ge. 4 .and. .false. ) THEN
         if ( cx(mgs,li) .gt. 10. .and. xdia(mgs,li,1) .gt. 50.e-6 ) then !{
         cirdiatmp =   &
     &  (qx(mgs,li)*rho0(mgs)   &
     & /(pi*xdn(mgs,li)*cx(mgs,li)))**(1./3.)
          IF ( cirdiatmp .gt. 100.e-6 ) THEN !{
          qscnvi(mgs) =   &
     &  ((pi*xdn(mgs,li)*cx(mgs,li)) / (6.0*rho0(mgs)*dtp))   &
     & *exp(-hdia0/cirdiatmp)   &
     & *( (hdia0**3) + 3.0*(hdia0**2)*cirdiatmp   &
     &  + 6.0*(hdia0)*(cirdiatmp**2) + 6.0*(cirdiatmp**3) )
      qscnvi(mgs) =   &
     &  min(qscnvi(mgs),qimxd(mgs))
          IF ( ipconc .ge. 4 ) THEN
            cscnvi(mgs) = Min( cimxd(mgs), cx(mgs,li)*Exp(-hdia0/cirdiatmp))
          ENDIF
         ENDIF  ! }
        end if ! }

       ELSEIF ( ipconc .lt. 4 ) THEN

        qscnvi(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
        qscnvi(mgs) = min(qscnvi(mgs),qxmxd(mgs,li))
        cscnvi(mgs) = qscnvi(mgs)*rho0(mgs)/xmas(mgs,li)
        cscnvis(mgs) = 0.5*cscnvi(mgs)

       ENDIF
      ENDIF
!      ENDIF
      end do

!
!  Ventilation coeficients
!
      do mgs = 1,ngscnt
      fvent(mgs) = (fschm(mgs)**(1./3.)) * (fakvisc(mgs)**(-0.5))
      end do
!
!
      if ( ndebug .gt. 0 ) write(0,*) 'civent'
!
      civenta = 1.258e4
      civentb = 2.331
      civentc = 5.662e4
      civentd = 2.373
      civente = 0.8241
      civentf = -0.042
      civentg = 1.70

      do mgs = 1,ngscnt
      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
      IF ( qx(mgs,li) .gt. qxmin(li) ) THEN
      cireyn =   &
     &  (civenta*xdia(mgs,li,1)**civentb   &
     &  +civentc*xdia(mgs,li,1)**civentd)   &
     &  /   &
     &  (civente*xdia(mgs,li,1)**civentf+civentg)
      xcivent = (fschm(mgs)**(1./3.))*((cireyn/fakvisc(mgs))**0.5)
      if ( xcivent .lt. 1.0 ) then
      civent(mgs) = 1.0 + 0.14*xcivent**2
      end if
      if ( xcivent .ge. 1.0 ) then
      civent(mgs) = 0.86 + 0.28*xcivent
      end if
      ELSE
       civent(mgs) = 0.0
      ENDIF
      ENDIF ! icond .eq. 1
      end do

!
!
      igmrwa = 100.0*2.0
      igmrwb = 100.*((5.0+br)/2.0)
      rwventa = (0.78)*gmoi(igmrwa)  ! 0.78
      rwventb = (0.308)*gmoi(igmrwb) ! 0.562825
      do mgs = 1,ngscnt
      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
        IF ( ipconc .ge. 3 ) THEN
          IF ( imurain == 3 ) THEN
           IF ( izwisventr == 1 ) THEN
            rwvent(mgs) = ventrx(mgs)*(1.6 + 124.9*(1.e-3*rho0(mgs)*qx(mgs,lr))**.2046)
           ELSE ! izwisventr = 2
!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
          rwvent(mgs) =   &
     &  (0.78*ventrx(mgs) + 0.308*ventrxn(mgs)*fvent(mgs)   &
     &   *Sqrt((ar*rhovt(mgs)))   &
     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
           ENDIF

          ELSE ! imurain == 1
       ! linear interpolation of complete gamma function
!        tmp = 2. + alpha(mgs,lr)
!        i = Int(dgami*(tmp))
!        del = tmp - dgam*i
!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        IF ( iferwisventr == 1 ) THEN

        alpr = Min(alpharmax,alpha(mgs,lr) )

        x =  1. + alpha(mgs,lr)

        IF ( lzr > 1 ) THEN ! 3 moment
        ELSE
         y = ventrxn(mgs)
        ENDIF

         vent1 = dble(xdia(mgs,lr,1))**(-2. - alpr)
         vent2 = dble(1./xdia(mgs,lr,1) + 0.5*fx(lr))**dble(2.5+alpr+0.5*bx(lr))
        
        
        rwvent(mgs) =    &
     &    0.78*x +    &
     &    0.308*fvent(mgs)*y*   &
     &            Sqrt(ax(lr)*rhovt(mgs))*(vent1/vent2)
       
        ELSEIF ( iferwisventr == 2 ) THEN
          
!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
         x =  1. + alpha(mgs,lr)

           rwvent(mgs) =   &
     &  (0.78*x + 0.308*ventrxn(mgs)*fvent(mgs)   &
     &   *Sqrt((ar*rhovt(mgs)))   &
     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )

          
          ENDIF ! iferwisventr
          
          ENDIF ! imurain
        ELSE
         rwvent(mgs) =   &
     &  (rwventa + rwventb*fvent(mgs)   &
     &   *Sqrt((ar*rhovt(mgs)))   &
     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
        ENDIF
      ELSE
       rwvent(mgs) = 0.0
      ENDIF
      end do
!
      igmswa = 100.0*2.0
      igmswb = 100.*((5.0+ds)/2.0)
      swventa = (0.78)*gmoi(igmswa)
      swventb = (0.308)*gmoi(igmswb)
      do mgs = 1,ngscnt
      IF ( qx(mgs,ls) .gt. qxmin(ls) ) THEN
      IF ( ipconc .ge. 4 ) THEN
      swvent(mgs) = 0.65 + 0.44*fvent(mgs)*Sqrt(vtxbar(mgs,ls,1)*xdia(mgs,ls,1))
      ELSE
! 10-ice version:
       swvent(mgs) =   &
     &  (swventa + swventb*fvent(mgs)   &
     &   *Sqrt((cs*rhovt(mgs)))   &
     &   *(xdia(mgs,ls,1)**((1.0+ds)/2.0)) )
      ENDIF
      ELSE
      swvent(mgs) = 0.0
      ENDIF
      end do
!
!

      igmhwa = 100.0*2.0
      igmhwb = 100.0*2.75
      hwventa = (0.78)*gmoi(igmhwa)
      hwventb = (0.308)*gmoi(igmhwb)
      hwventc = (4.0*gr/(3.0*cdx(lh)))**(0.25)
      do mgs = 1,ngscnt
      IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
       IF ( .false. .or. alpha(mgs,lh) .eq. 0.0 ) THEN
        hwvent(mgs) =   &
     &  ( hwventa + hwventb*hwventc*fvent(mgs)   &
     &    *((xdn(mgs,lh)/rho0(mgs))**(0.25))   &
     &    *(xdia(mgs,lh,1)**(0.75)))
       ELSE ! Ferrier 1994, eq. B.36
       ! linear interpolation of complete gamma function
!        tmp = 2. + alpha(mgs,lh)
!        i = Int(dgami*(tmp))
!        del = tmp - dgam*i
!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
        
! note that hwvent includes a division by Gamma(1+alpha), so Gamma(2+alpha)/Gamma(1+alpha) = 1 + alpha
! and g1palp = Gamma(1+alpha) divides into y
        x =  1. + alpha(mgs,lh)

        tmp = 1 + alpha(mgs,lh)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = 2.5 + alpha(mgs,lh) + 0.5*bxh(mgs)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp
        
        
        hwventy(mgs) = 0.308*fvent(mgs)*(xdia(mgs,lh,1)**(0.5 + 0.5*bxh(mgs)))*Sqrt(axh(mgs)*rhovt(mgs)) 
        hwvent(mgs) =    &
     &  ( 0.78*x +  y*hwventy(mgs) ) !   &
!     &    0.308*fvent(mgs)*y*(xdia(mgs,lh,1)**(0.5 + 0.5*bxh(mgs)))*   &
!     &            Sqrt(axh(mgs)*rhovt(mgs)) )
       
       ENDIF
      ELSE
      hwvent(mgs) = 0.0
      hwventy(mgs) = 0.0
      ENDIF
      end do
      
      hlvent(:) = 0.0
      hlventy(:) = 0.0

      IF ( lhl .gt. 1 ) THEN
      igmhwa = 100.0*2.0
      igmhwb = 100.0*2.75
      hwventa = (0.78)*gmoi(igmhwa)
      hwventb = (0.308)*gmoi(igmhwb)
      hwventc = (4.0*gr/(3.0*cdx(lhl)))**(0.25)
      do mgs = 1,ngscnt
      IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN

       IF ( .false. .or. alpha(mgs,lhl) .eq. 0.0 ) THEN
        hlvent(mgs) =   &
     &  ( hwventa + hwventb*hwventc*fvent(mgs)   &
     &    *((xdn(mgs,lhl)/rho0(mgs))**(0.25))   &
     &    *(xdia(mgs,lhl,1)**(0.75)))
       ELSE ! Ferrier 1994, eq. B.36
       ! linear interpolation of complete gamma function
!        tmp = 2. + alpha(mgs,lhl)
!        i = Int(dgami*(tmp))
!        del = tmp - dgam*i
!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

! note that hlvent includes a division by Gamma(1+alpha), so x = Gamma(2+alpha)/Gamma(1+alpha) = 1 + alpha
! and g1palp = Gamma(1+alpha) divides into y

        x =  1. + alpha(mgs,lhl)

        tmp = 1 + alpha(mgs,lhl)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami

        tmp = 2.5 + alpha(mgs,lhl) + 0.5*bxhl(mgs)
        i = Int(dgami*(tmp))
        del = tmp - dgam*i
        y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp ! ratio of gamma functions

        hlventy(mgs) = 0.308*fvent(mgs)*(xdia(mgs,lhl,1)**(0.5 + 0.5*bxhl(mgs)))*Sqrt(axhl(mgs)*rhovt(mgs)) 
        
        hlvent(mgs) =  0.78*x + y*hlventy(mgs)  !   &
!     &    0.308*fvent(mgs)*y*(xdia(mgs,lhl,1)**(0.5 + 0.5*bxhl(mgs)))*   &
!     &            Sqrt(axhl(mgs)*rhovt(mgs)))
!     :            Sqrt(xdn(mgs,lhl)*ax(lhl)*rhovt(mgs)/rg0))/tmp

        ENDIF
       ENDIF
      end do
      ENDIF

!
!
!
!  Wet growth constants
!
      do mgs = 1,ngscnt
      fwet1(mgs) =   &
     & (2.0*pi)*   &
     & ( felv(mgs)*fwvdf(mgs)*rho0(mgs)*(qss0(mgs)-qx(mgs,lv))   &
     &  -ftka(mgs)*temcg(mgs) )   &
     & / ( rho0(mgs)*(felf(mgs)+fcw(mgs)*temcg(mgs)) )
      fwet2(mgs) =   &
     &  (1.0)-fci(mgs)*temcg(mgs)   &
     & / ( felf(mgs)+fcw(mgs)*temcg(mgs) )
      end do
!
!  Melting constants
!
      do mgs = 1,ngscnt
      fmlt1(mgs) = (2.0*pi)*   &
     &  ( felv(mgs)*fwvdf(mgs)*(qss0(mgs)-qx(mgs,lv))   &
     &   -ftka(mgs)*temcg(mgs)/rho0(mgs) )    &
     &  / (felf(mgs))
      fmlt2(mgs) = -fcw(mgs)*temcg(mgs)/felf(mgs)
      end do
!
!  Vapor Deposition constants
!
      do mgs = 1,ngscnt
      fvds(mgs) =    &
     &  (4.0*pi/rho0(mgs))*(ssi(mgs)-1.0)*   &
     &  (1.0/(fai(mgs)+fbi(mgs)))
      end do
      do mgs = 1,ngscnt
      fvce(mgs) =    &
     &  (4.0*pi/rho0(mgs))*(ssw(mgs)-1.0)*   &
     &  (1.0/(fav(mgs)+fbv(mgs)))
      end do

!
!  deposition, sublimation, and melting of snow, graupel and hail
!
      qsmlr(:) = 0.0
      qimlr(:) = 0.0 ! this is not used. qi melts to qc way down in the code.
      qhmlr(:) = 0.0
      qhlmlr(:) = 0.0
      qhmlrlg(:) = 0.0
      qhlmlrlg(:) = 0.0
      qhfzh(:) = 0.0
      qhlfzhl(:) = 0.0
      vhfzh(:) = 0.0
      vhlfzhl(:) = 0.0
      qsfzs(:) = 0.0
      zsmlr(:) = 0.0
      zhmlr(:) = 0.0
      zhmlrr(:) = 0.0
      zhshr(:) = 0.0
      zhlmlr(:) = 0.0
      zhlshr(:) = 0.0

      zhshrr(:) = 0.0
      zhlmlrr(:) = 0.0
      zhlshrr(:) = 0.0

      csmlr(:) = 0.0
      chmlr(:) = 0.0
      chmlrr(:) = 0.0
      chlmlr(:) = 0.0
      chlmlrr(:) = 0.0

      if ( .not. mixedphase ) then !{
      do mgs = 1,ngscnt
!
      IF ( temg(mgs) .gt. tfr ) THEN
      
      IF (  qx(mgs,ls) .gt. qxmin(ls) ) THEN
      qsmlr(mgs) =   &
     &   min(   &
     &  (c1sw*fmlt1(mgs)*cx(mgs,ls)*swvent(mgs)*xdia(mgs,ls,1) ) & ! /rhosm    &
     &   , 0.0 )
      ENDIF
      
!       IF ( qx(mgs,ls) .gt. 0.1e-4 ) write(0,*) 'qsmlr: ',qsmlr(mgs),qx(mgs,ls),cx(mgs,ls),fmlt1(mgs),
!     :        temcg(mgs),swvent(mgs),xdia(mgs,ls,1),qss0(mgs)-qx(mgs,lv)
!      ELSE
!       qsmlr(mgs) = 0.0
!      ENDIF
! 10ice version:
!     >   min(
!     >  (fmlt1(mgs)*cx(mgs,ls)*swvent(mgs)*xdia(mgs,ls,1) +
!     >   fmlt2(mgs)*(qsacr(mgs)+qsacw(mgs)) )
!     <   , 0.0 )

      IF (  qx(mgs,lh) .gt. qxmin(lh) ) THEN

      IF ( ibinhmlr == 0 .or. lzh < 1 ) THEN
       qhmlr(mgs) =   &
     &   min(   &
     &  fmlt1(mgs)*cx(mgs,lh)*hwvent(mgs)*xdia(mgs,lh,1)   &
     &  + fmlt2(mgs)*(qhacrmlr(mgs)+qhacw(mgs))    &
     &   , 0.0 )
       ELSEIF ( ibinhmlr == 1 ) THEN ! use incomplete gamma functions to approximate the bin results

       ENDIF
       
       
       IF ( ivhmltsoak > 0 .and. qhmlr(mgs) < 0.0 .and. lvol(lh) > 1 .and. xdn(mgs,lh) .lt. xdnmx(lh) ) THEN
         ! act as if 100% of the meltwater were soaked into the graupel
           v1 = (1. - xdn(mgs,lh)/xdnmx(lh))*(vx(mgs,lh) + rho0(mgs)*qhmlr(mgs)/xdn(mgs,lh) )/(dtp) ! volume available for filling
           v2 = -1.0*rho0(mgs)*qhmlr(mgs)/xdnmx(lh)  ! volume of melted ice if it were refrozen in the matrix
           
           vhsoak(mgs) = Min(v1,v2)
           
       ENDIF

      ENDIF !  qx(mgs,lh) .gt. qxmin(lh)

      
      IF ( lhl .gt. 1  .and. lhlw < 1 ) THEN

       IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
         IF ( ibinhlmlr == 0  .or. lzhl < 1) THEN
       qhlmlr(mgs) =   &
     &   min(   &
     &  fmlt1(mgs)*cx(mgs,lhl)*hlvent(mgs)*xdia(mgs,lhl,1)   &
     &  + fmlt2(mgs)*(qhlacrmlr(mgs)+qhlacw(mgs))    &
     &   , 0.0 )

       ELSEIF ( ibinhlmlr == 1 ) THEN ! use incomplete gamma functions to approximate the bin results

        ENDIF ! ibinhlmlr


       IF ( ivhmltsoak > 0 .and.  qhlmlr(mgs) < 0.0 .and. lvol(lhl) > 1 .and. xdn(mgs,lhl) .lt. xdnmx(lhl) ) THEN
         ! act as if 50% of the meltwater were soaked into the graupel
           v1 = (1. - xdn(mgs,lhl)/xdnmx(lhl))*(vx(mgs,lhl) + rho0(mgs)*qhlmlr(mgs)/xdn(mgs,lhl) )/(dtp) ! volume available for filling
           v2 = -1.0*rho0(mgs)*qhlmlr(mgs)/xdnmx(lhl)  ! volume of melted ice if it were refrozen in the matrix
           
           vhlsoak(mgs) = Min(v1,v2)
           
       ENDIF
        
        ENDIF
       ENDIF

      ENDIF
      
!
!      qimlr(mgs)  = max( qimlr(mgs), -qimxd(mgs) ) 
!      qsmlr(mgs)  = max( qsmlr(mgs),  -qsmxd(mgs) ) 
! erm 5/10/2007 changed to next line:
      if ( .not. mixedphase ) qsmlr(mgs)  = max( qsmlr(mgs),  Min( -qsmxd(mgs), -0.7*qx(mgs,ls)*dtpinv ) ) 
      if ( .not. mixedphase ) qhmlr(mgs)  = max( qhmlr(mgs),  Min( -qhmxd(mgs), -0.5*qx(mgs,lh)*dtpinv ) ) 
!      qhmlr(mgs)  = max( max( qhmlr(mgs),  -qhmxd(mgs) ) , -0.5*qx(mgs,lh)/dtp ) !limits to 1/2 qh or max depletion
      qhmlh(mgs)  = 0.


      ! Rasmussen and Heymsfield say melt water remains on graupel up to 9 mm before shedding


      IF ( lhl .gt. 1 .and. lhlw < 1 ) qhlmlr(mgs)  = max( qhlmlr(mgs),  Min( -qxmxd(mgs,lhl), -0.5*qx(mgs,lhl)/dtp ) )

!
      end do

      endif  ! } not mixedphase
!
      if ( ipconc .ge. 1 ) then
      do mgs = 1,ngscnt
      cimlr(mgs)  = (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qimlr(mgs)

      IF ( .not. mixedphase ) THEN
      IF ( xdia(mgs,ls,1) .gt. 1.e-6 .and. -qsmlr(mgs) .ge. 0.5*qxmin(ls) .and. ipconc .ge. 4 ) THEN
!      csmlr(mgs)  = rho0(mgs)*qsmlr(mgs)/(xv(mgs,ls)*rhosm)
      csmlr(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)))*qsmlr(mgs)
      ELSEIF ( qx(mgs,ls) > qxmin(ls) ) THEN
      csmlr(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)))*qsmlr(mgs)
      ENDIF


!      IF ( xdia(mgs,lh,1) .gt. 1.e-6 .and. Abs(qhmlr(mgs)) .ge. qxmin(lh) ) THEN
!      chmlr(mgs) = rho0(mgs)*qhmlr(mgs)/(pi*xdn(mgs,lh)*xdia(mgs,lh,1)**3)  ! out of hail
!      chmlr(mgs) = Max( chmlr(mgs), -chmxd(mgs) )
!      ELSE
       chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhmlr(mgs)
!      ENDIF


     IF ( chmlr(mgs) < 0.0 ) THEN
      
      IF ( ihmlt .eq. 1 ) THEN
        chmlrr(mgs)  = Min( chmlr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vmlt) ) ! into rain 
      ELSEIF ( ihmlt .eq. 2 ) THEN
        IF ( xv(mgs,lh) .gt. 0.0 .and. chmlr(mgs) .lt. 0.0 ) THEN
!        chmlrr(mgs) = Min( chmlr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) ) ! into rain 
! guess what, this is the same as chmlr: rho0*qhmlr/xmas(lh) --> cx/qx = rho0/xmas
          IF(imltshddmr > 0) THEN
            ! DTD: If Dmg < sheddiam, then assume complete melting into
            ! maximal raindrop.  Between sheddiam and sheddiam0 mm, linearly ramp down to a 3 mm shed drop
            tmp = -rho0(mgs)*qhmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lh)*xv(mgs,lh))) ! Min of Maximum raindrop size/mean hail size
            tmp2 = -rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
            chmlrr(mgs) = tmp*(sheddiam0-xdia(mgs,lh,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lh,3)-sheddiam)/(sheddiam0-sheddiam)
            chmlrr(mgs) = -Max(tmp,Min(tmp2,chmlrr(mgs)))
          ELSE ! Old method
            chmlrr(mgs) =  rho0(mgs)*qhmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lh)*xv(mgs,lh)))  ! into rain 
          ENDIF
        ELSE
        chmlrr(mgs) = chmlr(mgs)
        ENDIF
      ELSEIF ( ihmlt .eq. 0 ) THEN
        chmlrr(mgs) = chmlr(mgs)
      ENDIF
      
      ENDIF ! chmlr(mgs) < 0.0

      IF ( lhl .gt. 1 .and. lhlw < 1 .and. .not. mixedphase .and. qhlmlr(mgs) < 0.0 ) THEN ! {
      
!      IF ( xdia(mgs,lhl,1) .gt. 1.e-6 .and. Abs(qhlmlr(mgs)) .ge. qxmin(lhl) ) THEN
!      chlmlr(mgs) = rho0(mgs)*qhlmlr(mgs)/(pi*xdn(mgs,lhl)*xdia(mgs,lhl,1)**3)  ! out of hail
!      chlmlr(mgs) = Max( chlmlr(mgs), -cxmxd(mgs,lhl) )
!      ELSE
      chlmlr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlmlr(mgs)
!      ENDIF
      
      IF ( ihmlt .eq. 1 ) THEN
        chlmlrr(mgs)  = Min( chlmlr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vmlt) ) ! into rain 
      ELSEIF ( ihmlt .eq. 2 ) THEN
        IF ( xv(mgs,lhl) .gt. 0.0 .and. chlmlr(mgs) .lt. 0.0 ) THEN
!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
!        chlmlrr(mgs) = Min( chlmlr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lhl)*xv(mgs,lhl)) ) ! into rain 
          IF(imltshddmr > 0) THEN
            tmp = -rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl))) ! Min of Maximum raindrop size/mean hail size
            tmp2 = -rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
            chlmlrr(mgs) = tmp*(20.e-3-xdia(mgs,lhl,3))/(20.e-3-sheddiam)+tmp2*(xdia(mgs,lhl,3)-sheddiam)/(20.e-3-sheddiam)
            chlmlrr(mgs) = -Max(tmp,Min(tmp2,chlmlrr(mgs)))
          ELSE
            chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
          ENDIF
        ELSE
        chlmlrr(mgs) = chlmlr(mgs)
        ENDIF
      ELSEIF ( ihmlt .eq. 0 ) THEN
        chlmlrr(mgs) = chlmlr(mgs)
      ENDIF
        
      ENDIF ! }

      ENDIF ! .not. mixedphase

! 10ice versions:
!      chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhmlr(mgs)
!      chmlrr(mgs) = chmlr(mgs)
      end do
      end if

!
!  deposition/sublimation of ice
!
      DO mgs = 1,ngscnt

      rwcap(mgs) = (0.5)*xdia(mgs,lr,1)
      swcap(mgs) = (0.5)*xdia(mgs,ls,1)
      hwcap(mgs) = (0.5)*xdia(mgs,lh,1)
      IF ( lhl .gt. 1 ) hlcap(mgs) = (0.5)*xdia(mgs,lhl,1)

      if ( qx(mgs,li).gt.qxmin(li) .and. xdia(mgs,li,1) .gt. 0.0 ) then
!
! from Cotton, 1972 (Part II)
!
        cilen(mgs)   = 0.4764*(xdia(mgs,li,1))**(0.958)
        cval = xdia(mgs,li,1)
        aval = cilen(mgs)
        eval = Sqrt(1.0-(aval**2)/(cval**2))
        fval = min(0.99,eval)
        gval = alog( abs( (1.+fval)/(1.-fval) ) )
        cicap(mgs) = cval*fval / gval
      ELSE
       cicap(mgs) = 0.0
      end if
      ENDDO
!
!
      qhldsv(:) = 0.0

      do mgs = 1,ngscnt
      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
        qidsv(mgs) =   &
     &    fvds(mgs)*cx(mgs,li)*civent(mgs)*cicap(mgs)
        qsdsv(mgs) =   &
     &    fvds(mgs)*cx(mgs,ls)*swvent(mgs)*swcap(mgs)
!        IF ( ny .eq. 2 .and. igs(mgs) .eq. 302 .and. temg(mgs) .le. tfrh+10 .and. qx(mgs,lv) .gt. qis(mgs)
!     :       .and. qx(mgs,li) .gt. qxmin(li) ) THEN
!         write(0,*) 'qidsv = ',nstep,kgs(mgs),qidsv(mgs),temg(mgs)-tfrh,100.*(qx(mgs,lv)/qis(mgs) - 1.),1.e6*xdia(mgs,li,1),
!     :            fvds(mgs),civent(mgs),cicap(mgs)
!        ENDIF
      ELSE
        qidsv(mgs) = 0.0
        qsdsv(mgs) = 0.0
      ENDIF
        qhdsv(mgs) =   &
     &    fvds(mgs)*cx(mgs,lh)*hwvent(mgs)*hwcap(mgs)

        IF ( lhl .gt. 1 ) qhldsv(mgs) = fvds(mgs)*cx(mgs,lhl)*hlvent(mgs)*hlcap(mgs)
!
!
      end do
!
      do mgs = 1,ngscnt
      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
!        qisbv(mgs) = max( min(qidsv(mgs), 0.0), -qimxd(mgs) )
!        qssbv(mgs) = max( min(qsdsv(mgs), 0.0), -qsmxd(mgs) )
! erm 5/10/2007:
        qisbv(mgs) = max( min(qidsv(mgs), 0.0),  Min( -qimxd(mgs), -0.7*qx(mgs,li)/dtp ) )
        qssbv(mgs) = max( min(qsdsv(mgs), 0.0),  Min( -qsmxd(mgs), -0.7*qx(mgs,ls)/dtp ) )
        qidpv(mgs) = Max(qidsv(mgs), 0.0)
        qsdpv(mgs) = Max(qsdsv(mgs), 0.0)
      ELSE
        qisbv(mgs) = 0.0
        qssbv(mgs) = 0.0
        qidpv(mgs) = 0.0
        qsdpv(mgs) = 0.0
      ENDIF

      qhsbv(mgs) = max( min(qhdsv(mgs), 0.0), -qhmxd(mgs) )


      qhdpv(mgs) = Max(qhdsv(mgs), 0.0)

      qhlsbv(mgs) = 0.0
      qhldpv(mgs) = 0.0
      IF ( lhl .gt. 1 ) THEN
        qhlsbv(mgs) = max( min(qhldsv(mgs), 0.0), -qxmxd(mgs,lhl) )
        qhldpv(mgs) = Max(qhldsv(mgs), 0.0)
      ENDIF

      temp1 = qidpv(mgs) + qsdpv(mgs) + qhdpv(mgs) + qhldpv(mgs)

      IF ( temp1 .gt. qvimxd(mgs) ) THEN

      frac = qvimxd(mgs)/temp1

      qidpv(mgs) = frac*qidpv(mgs)
      qsdpv(mgs) = frac*qsdpv(mgs)
      qhdpv(mgs) = frac*qhdpv(mgs)
      qhldpv(mgs) = frac*qhldpv(mgs)

!        IF ( ny .eq. 2 .and. igs(mgs) .eq. 302 .and. temg(mgs) .le. tfrh+10 .and. qx(mgs,lv) .gt. qis(mgs)
!     :       .and. qx(mgs,li) .gt. qxmin(li) ) THEN
!         write(0,*) 'qidpv,frac = ',kgs(mgs),qidpv(mgs),frac
!        ENDIF

      ENDIF

      end do
!
!
      if ( ipconc .ge. 1 ) then
      do mgs = 1,ngscnt
      cssbv(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*qssbv(mgs)
      cisbv(mgs)  = (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qisbv(mgs)
      chsbv(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhsbv(mgs)
      IF ( lhl .gt. 1 ) chlsbv(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlsbv(mgs)
      csdpv(mgs)  = 0.0 ! (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*qsdpv(mgs)
      cidpv(mgs) =  0.0 ! (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qidpv(mgs)
      chdpv(mgs)  = 0.0 ! (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhdpv(mgs)
      chldpv(mgs) = 0.0
      end do
      end if

!
!  Aggregation of crystals
!
      if (ndebug .gt. 0 ) write(0,*) 'conc 29a'
      do mgs = 1,ngscnt
      qscni(mgs) =  0.0
      cscni(mgs) = 0.0
      cscnis(mgs) = 0.0
      if ( ipconc .ge. 4 .and. iscni .ge. 1 .and. qx(mgs,li) .gt. qxmin(li) ) then
        IF ( iscni .eq. 1 ) THEN
         qscni(mgs) =    &
     &      pi*rho0(mgs)*((0.25)/(6.0))   &
     &      *eii(mgs)*(qx(mgs,li)**2)*(xdia(mgs,li,2))   &
     &      *vtxbar(mgs,li,1)/xmas(mgs,li)
         cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li))
         cscnis(mgs) = 0.5*cscni(mgs)
        ELSEIF ( iscni .eq. 2 .or. iscni .eq. 4 .or. iscni .eq. 5 ) THEN  ! Zeigler 1985/Zrnic 1993, sort of
          IF ( iscni .ne. 5 .and. qidpv(mgs) .gt. 0.0 .and.  xdia(mgs,li,3) .ge. 100.e-6 ) THEN
          ! convert larger crystals to snow
!            IF ( xdia(mgs,ls,3) .gt. xdia(mgs,li,3) ) THEN
!              qscni(mgs) = Max(0.1,xdia(mgs,li,3)/xdia(mgs,ls,3))*qidpv(mgs)
! erm 9/5/08 changed max to min
              qscni(mgs) = Min(0.5, xdia(mgs,li,3)/200.e-6)*qidpv(mgs)
!            ELSE
!              qscni(mgs) = 0.1*qidpv(mgs)
!            ENDIF
            cscni(mgs) = 0.5*Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/Max(xdn(mgs,ls)*xvsmn,xmas(mgs,li)))
!            cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li) )
!            IF ( xdia(mgs,ls,3) .le. 200.e-6 ) THEN
              cscnis(mgs) = cscni(mgs)
!            ELSE
!              cscnis(mgs) = 0.0
!            ENDIF
          ENDIF

           IF ( iscni .ne. 4 ) THEN
           ! crystal aggregation to become snow
! erm 9/5/08 commented second line and added xv to 1st line (zrnic et al 1993)
             tmp = ess(mgs)*rvt*aa2*cx(mgs,li)*cx(mgs,li)*xv(mgs,li)
!     :         ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,li))

!           csacs(mgs) = rvt*aa2*ess(mgs)*cx(mgs,ls)**2*xv(mgs,ls)

             qscni(mgs) = qscni(mgs) + Min( qxmxd(mgs,li), 2.0*tmp*xmas(mgs,li)*rhoinv(mgs) )
             cscni(mgs) = cscni(mgs) + Min( cxmxd(mgs,li), 2.0*tmp )
             cscnis(mgs) = cscnis(mgs) + Min( cxmxd(mgs,li), tmp )
           ENDIF
        ELSEIF ( iscni .eq. 3 ) THEN ! LFO
           qscni(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
           qscni(mgs) = min(qscni(mgs),qxmxd(mgs,li))
           cscni(mgs) = qscni(mgs)*rho0(mgs)/xmas(mgs,li)
           cscnis(mgs) = 0.5*cscni(mgs)
!           write(iunit,*) 'qscni, qi = ',qscni(mgs),qx(mgs,li),igs(mgs),kgs(mgs)
        ENDIF

      ELSEIF ( ipconc < 4 ) THEN ! LFO
           IF ( lwsm6 ) THEN
             qimax = rhoinv(mgs)*roqimax
             qscni(mgs) = Min(0.9d0*qx(mgs,li), Max( 0.d0, (qx(mgs,li) - qimax)*dtpinv ) )
           ELSE
             qscni(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
             qscni(mgs) = min(qscni(mgs),qxmxd(mgs,li))
           ENDIF
      else ! 10-ice version
      if ( qx(mgs,li) .gt. qxmin(li) ) then
          qscni(mgs) =    &
     &    pi*rho0(mgs)*((0.25)/(6.0))   &
     &    *eii(mgs)*(qx(mgs,li)**2)*(xdia(mgs,li,2))   &
     &    *vtxbar(mgs,li,1)/xmas(mgs,li)
         cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li))
        end if

      end if
      end do

!
!
!  compute dry growth rate of snow, graupel, and hail
!
      do mgs = 1,ngscnt
!
      qsdry(mgs)  = qsacr(mgs)    + qsacw(mgs)   &
     &            + qsaci(mgs)
!
      qhdry(mgs)  = qhaci(mgs)    + qhacs(mgs)   &
     &            + qhacr(mgs)   &
     &            + qhacw(mgs)
!
      qhldry(mgs) = 0.0
      IF ( lhl .gt. 1 ) THEN
      qhldry(mgs)  = qhlaci(mgs)    + qhlacs(mgs)   &
     &               + qhlacr(mgs)   &
     &               + qhlacw(mgs)
      ENDIF
      end do
!
!  set wet growth and shedding
!
      do mgs = 1,ngscnt
!
!      qswet(mgs) =
!     >  ( xdia(mgs,ls,1)*swvent(mgs)*cx(mgs,ls)*fwet1(mgs)
!     >  + fwet2(mgs)*(qsaci(mgs)+qsacir(mgs)
!     >               +qsacip(mgs)) )
!      qswet(mgs) = max( 0.0, qswet(mgs))
!
!      IF ( dnu(lh) .ne. 0. ) THEN
!        qhwet(mgs) = qhdry(mgs)
!      ELSE
        qhwet(mgs) =   &
     &    ( xdia(mgs,lh,1)*hwvent(mgs)*cx(mgs,lh)*fwet1(mgs)   &
     &   + fwet2(mgs)*(qhaci(mgs) + qhacs(mgs)) )
       qhwet(mgs) = max( 0.0, qhwet(mgs))
!      ENDIF

       qhlwet(mgs) = 0.0
       IF ( lhl .gt. 1 ) THEN
       qhlwet(mgs) =   &
     &    ( xdia(mgs,lhl,1)*hlvent(mgs)*cx(mgs,lhl)*fwet1(mgs)   &
     &   + fwet2(mgs)*(qhlaci(mgs) + qhlacs(mgs)) )
       qhlwet(mgs) = max( 0.0, qhlwet(mgs))
       ENDIF
!
!      qhlwet(mgs) = qhldry(mgs)

      end do
!
! shedding rate
!
      qsshr(:)  =  0.0
      qhshr(:)  =  0.0
      qhlshr(:) =  0.0
      qhshh(:)  =  0.0
      csshr(:)  =  0.0
      chshr(:)  =  0.0
      chlshr(:)  =  0.0
      chshrr(:)  =  0.0
      chlshrr(:)  =  0.0
      vhshdr(:)  = 0.0
      vhlshdr(:)  = 0.0
      wetsfc(:)  = .false.
      wetgrowth(:)  = .false.
      wetsfchl(:)  = .false.
      wetgrowthhl(:)  = .false.


      do mgs = 1,ngscnt
!
!
!
      qhshr(mgs)  = Min( 0.0, qhwet(mgs) - qhdry(mgs) )  ! water that freezes should never be more than what sheds
      


      qhlshr(mgs)  =  Min( 0.0, qhlwet(mgs) - qhldry(mgs) )

!
! limit wet growth to only higher density particles
!
      qsshr(mgs)  =  0.0
!
!
!  no shedding for temperatures < 243.15 
!
      if ( temg(mgs) .lt. 243.15 ) then
       qsshr(mgs)  =  0.0
       qhshr(mgs)  =  0.0
       qhlshr(mgs) =  0.0
       vhshdr(mgs)  = 0.0
       vhlshdr(mgs)  = 0.0
       wetsfc(mgs) = .false.
       wetgrowth(mgs) = .false.
       wetsfchl(mgs) = .false.
       wetgrowthhl(mgs) = .false.
      end if
!
!  shed all at temperatures > 273.15
!
      if ( temg(mgs) .gt. tfr ) then

       qsshr(mgs)   = -qsdry(mgs)
       qhlshr(mgs)  = -qhldry(mgs)

       qhshr(mgs)  = -qhdry(mgs)
       vhshdr(mgs)  = -vhacw(mgs) - vhacr(mgs)
       vhlshdr(mgs)  = -vhlacw(mgs)
       qhwet(mgs)  = 0.0
       qhlwet(mgs) = 0.0
      end if
!
!      if (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr  ) THEN
        wetsfc(mgs) =  (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) .or. ( qhmlr(mgs) < -qxmin(lh) .and.  temg(mgs) > tfr )
        wetgrowth(mgs) = (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr )
!      ENDIF

      if (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) THEN
        wetsfchl(mgs) = (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) .or. ( qhlmlr(mgs) < -qxmin(lhl) .and.  temg(mgs) > tfr )
        wetgrowthhl(mgs) = (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr )
      ENDIF

      end do
!
      if ( ipconc .ge. 1 ) then
      do mgs = 1,ngscnt
      csshr(mgs)  = 0.0 ! (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*Min(0.0,qsshr(mgs))
      chshr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhshr(mgs)
      IF ( temg(mgs) < tfr ) THEN
         chshrr(mgs) = Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn0(lr)*vshd) ) ! maximum of dshd from shedding
      ELSE
        IF(imltshddmr > 0) THEN
          ! DTD: If Dmg < sheddiam, then assume complete melting into
          ! maximal raindrop.  Between sheddiam and sheddiam0, linearly ramp down to a 3 mm shed drop
          tmp = -Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! limit to maximum size allowed for rain
          tmp2 = -rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
          chshrr(mgs) = tmp*(sheddiam0-xdia(mgs,lh,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lh,3)-sheddiam)/(sheddiam0-sheddiam)
          chshrr(mgs) = -Max(tmp,Min(tmp2,chshrr(mgs)))
        ELSE
         chshrr(mgs) = Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*Min(vr4p5mm,xvmx(lr))) ) ! limit to maximum size allowed for rain or 4.5mm diameter, whichever is smaller
!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
        ENDIF
      ENDIF
      chlshr(mgs) = 0.0
      chlshrr(mgs) = 0.0
      IF ( lhl .gt. 1 ) THEN 
         chlshr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlshr(mgs)
        IF ( temg(mgs) < tfr ) THEN
          chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn0(lr)*vshd) ) ! maximum of dshd from shedding
!         chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn0(lr)*vr1mm) ) ! maximum of 1mm drops from shedding
        ELSE
          IF(imltshddmr > 0) THEN
            ! DTD: If Dmg < sheddiam, then assume complete melting into
            ! maximal raindrop.  Between sheddiam and sheddiam0, linearly ramp down to a 3 mm shed drop
            tmp = -Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! limit to maximum size allowed for rain
            tmp2 = -rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
            chlshrr(mgs) = tmp*(sheddiam0-xdia(mgs,lhl,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lhl,3)-sheddiam)/(sheddiam0-sheddiam)
            chlshrr(mgs) = -Max(tmp,Min(tmp2,chlshrr(mgs)))
          ELSE
           chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*Min(vr4p5mm,xvmx(lr))) ) ! limit to 4.5mm diameter or maximum size allowed for rain, whichever is smaller
!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
          ENDIF
        ENDIF
      ENDIF
      end do
      end if



!
!  final decisions
!
      do mgs = 1,ngscnt
!
!  Snow
!
      if ( qsshr(mgs) .lt. 0.0 ) then
      qsdpv(mgs) = 0.0
      qssbv(mgs) = 0.0
      else
      qsshr(mgs) = 0.0
      end if
!
!     if ( qsdry(mgs) .lt. qswet(mgs) ) then
!     qswet(mgs) = 0.0
!     else
!     qsdry(mgs) = 0.0
!     end if
!

! zero the shedding rates when wet snow/graupel included.
! shedding of wet snow/graupel is calculated after summing other sources/sinks.
      if (mixedphase) then
        qsshr(mgs) = 0.0
        qhshr(mgs) = 0.0
        csshr(mgs) = 0.0
        chshr(mgs) = 0.0
        chshrr(mgs) = 0.0
        vhshdr(mgs) = 0.0
        IF ( lhlw > 1 ) THEN
          qhlshr(mgs) = 0.0
          vhlshdr(mgs) = 0.0
          chlshr(mgs) = 0.0
          chlshrr(mgs) = 0.0
        ENDIF
      end if

!  graupel
!
!
      if ( wetgrowth(mgs) .or. (mixedphase .and. fhw(mgs) .gt. 0.05 .and. temg(mgs) .gt. 243.15) ) then
      

! soaking (when not advected liquid water film with graupel)

        IF ( lvol(lh) .gt. 1 .and. .not. mixedphase) THEN
        ! rescale volumes to maximum density
         rimdn(mgs,lh) = xdnmx(lh)
         raindn(mgs,lh) = xdnmx(lh)
         vhacw(mgs) = qhacw(mgs)*rho0(mgs)/rimdn(mgs,lh)
         vhacr(mgs) = qhacr(mgs)*rho0(mgs)/raindn(mgs,lh)
!        IF ( lvol(lh) .gt. 1 .and. wetgrowth(mgs) ) THEN
         IF ( xdn(mgs,lh) .lt. xdnmx(lh) ) THEN
         ! soak some liquid into the graupel
!           v1 = xdnmx(lh)*vx(mgs,lh)/(xdn(mgs,lh)*dtp) ! volume available for filling
           v1 = (1. - xdn(mgs,lh)/xdnmx(lh))*vx(mgs,lh)/(dtp) ! volume available for filling
!            tmp = (vx(mgs,lh)/rho0(mgs))*(xdnmx(lh) - xdn(mgs,lh)) ! max mixing ratio of liquid water that can be added
           v2 = rho0(mgs)*qhwet(mgs)/xdnmx(lh)  ! volume of frozen accretion
           
           vhsoak(mgs) = Min(v1,v2)
           
         ENDIF

         vhshdr(mgs) = Min(0.0, rho0(mgs)*qhwet(mgs)/xdnmx(lh) - vhacw(mgs) - vhacr(mgs) )
         
        ELSEIF ( lvol(lh) .gt. 1  .and. mixedphase ) THEN
!         vhacw(mgs) = rho0(mgs)*qhacw(mgs)/xdn0(lr)
!         vhacr(mgs) = rho0(mgs)*qhacr(mgs)/xdn0(lr)
        ENDIF
        

      qhdpv(mgs) = 0.0
!      qhsbv(mgs) = 0.0
      chdpv(mgs) = 0.0
!      chsbv(mgs) = 0.0

! collection efficiency modification

      IF ( ehi(mgs) .gt. 0.0 ) THEN
        qhaci(mgs) = Min(qimxd(mgs),qhaci0(mgs))  ! effectively sets collection eff to 1
        chaci(mgs) = Min(cimxd(mgs),chaci0(mgs))  ! effectively sets collection eff to 1
      ENDIF
      IF ( ehs(mgs) .gt. 0.0 ) THEN
!        qhacs(mgs) = Min(qsmxd(mgs),qhacs(mgs)/ehs(mgs))  ! effectively sets collection eff to 1
        qhacs(mgs) = Min(qsmxd(mgs),qhacs0(mgs)) !/ehs(mgs)                   ! divide out the collection efficiency
        chacs(mgs) = Min(csmxd(mgs),chacs0(mgs)) !/ehs(mgs)                   ! divide out the collection efficiency
        ehs(mgs) = ehsmax ! 1.0 ! min(ehsfrac*ehs(mgs),ehsmax)            ! modify it
        qhacs(mgs) = Min(qsmxd(mgs),qhacs(mgs))   ! plug it back in
      ENDIF

! be sure to catch particles with wet surfaces but not in wet growth to turn off Hallett-Mossop
      wetsfc(mgs) = .true.

      else
!        qhshr(mgs) = 0.0
      end if
!
!
!  hail
!
!      if ( lhl .gt. 1 .and. qhlshr(mgs) .lt. 0.0 ) then
      if ( wetgrowthhl(mgs) .or. (mixedphase .and. fhlw(mgs) .gt. 0.05 .and. temg(mgs) .gt. 243.15) ) then
!      if ( wetgrowthhl(mgs) ) then
       

      qhldpv(mgs) = 0.0
!      qhlsbv(mgs) = 0.0
      chldpv(mgs) = 0.0
!      chlsbv(mgs) = 0.0




        IF ( lvol(lhl) .gt. 1  .and. .not. mixedphase ) THEN
!        IF ( lvol(lhl) .gt. 1 .and. wetgrowthhl(mgs) ) THEN

         rimdn(mgs,lhl) = xdnmx(lhl) 
         raindn(mgs,lhl) = xdnmx(lhl) 
         vhlacw(mgs) = qhlacw(mgs)*rho0(mgs)/rimdn(mgs,lhl)
         vhlacr(mgs) = qhlacr(mgs)*rho0(mgs)/raindn(mgs,lhl)

         IF ( xdn(mgs,lhl) .lt. xdnmx(lhl) ) THEN
         ! soak some liquid into the hail
!           v1 = xdnmx(lhl)*vx(mgs,lhl)/(xdn(mgs,lhl)*dtp) ! volume available for filling
           v1 = (1. - xdn(mgs,lhl)/xdnmx(lhl))*vx(mgs,lhl)/(dtp) ! volume available for filling
!            tmp = (vx(mgs,lhl)/rho0(mgs))*(xdnmx(lhl) - xdn(mgs,lhl)) ! max mixing ratio of liquid water that can be added
           v2 = rho0(mgs)*qhlwet(mgs)/xdnmx(lhl)  ! volume of frozen accretion
           IF ( v1 > v2 ) THEN ! all the frozen stuff fits in
             vhlsoak(mgs) = v2
           ELSE  ! fill up the available space
             vhlsoak(mgs) = v1
           ENDIF
!           vhlacw(mgs) = 0.0
!           vhlacr(mgs) = Max( 0.0, v2 - v1 )
         ELSE
           vhlsoak(mgs) = 0.0
!           vhlacw(mgs) = 0.0
!           vhlacr(mgs) = rho0(mgs)*qhlwet(mgs)/raindn(mgs,lhl)
         
         ENDIF

         vhlshdr(mgs) = Min(0.0, rho0(mgs)*qhlwet(mgs)/xdnmx(lhl) - vhlacw(mgs) - vhlacr(mgs) )


        ELSEIF ( lvol(lhl) .gt. 1  .and. mixedphase ) THEN
!         vhlacw(mgs) = rho0(mgs)*qhlacw(mgs)/xdn0(lr)
!         vhlacr(mgs) = rho0(mgs)*qhlacr(mgs)/xdn0(lr)
        ENDIF

      IF ( ehli(mgs) .gt. 0.0 ) THEN
        qhlaci(mgs) = Min(qimxd(mgs),qhlaci0(mgs))  ! effectively sets collection eff to 1
        chlaci(mgs) = Min(cimxd(mgs),chlaci0(mgs))  ! effectively sets collection eff to 1
      ENDIF

!      IF ( ehls(mgs) .gt. 0.0 ) THEN
!        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs(mgs)/ehls(mgs))
!      ENDIF
      IF ( ehls(mgs) .gt. 0.0 ) THEN
        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs0(mgs)) !/ehls(mgs)                   ! divide out the collection efficiency
        chlacs(mgs) = Min(csmxd(mgs),chlacs0(mgs)) !/ehls(mgs)                   ! divide out the collection efficiency
        ehls(mgs) = ehsmax ! 1.0 ! min(ehsfrac*ehs(mgs),ehsmax)            ! modify it
!        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs(mgs))   ! plug it back in
      ENDIF

      
!      qhlwet(mgs) = 1.0

! be sure to catch particles with wet surfaces but not in wet growth to turn off Hallett-Mossop
      wetsfchl(mgs) = .true.


      else
!      qhlshr(mgs) = 0.0
!      qhlwet(mgs) = 0.0
      end if


      end do
!
! Ice -> graupel conversion
!
      DO mgs = 1,ngscnt
      
      qhcni(mgs) = 0.0
      chcni(mgs) = 0.0
      chcnih(mgs) = 0.0
      vhcni(mgs) = 0.0
      
      IF ( iglcnvi .ge. 1 ) THEN
      IF ( temg(mgs) .lt. 273.0 .and. qiacw(mgs) - qidpv(mgs) .gt. 0.0 ) THEN
      
        
        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
     &                *((0.60)*vtxbar(mgs,li,1))   &
     &                /(temg(mgs)-273.15))**(rimc2)
        tmp = Min( Max( rimc3, tmp ), 900.0 )
        
        !  Assume that half the volume of the embryo is rime with density 'tmp'
        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
        !  V = 2*m/(rhoi + rhorime)
        
!        write(0,*)  'rime dens = ',tmp
        
        IF ( tmp .ge. 200.0 .or. iglcnvi >= 2 ) THEN
          r = Max( 0.5*(xdn(mgs,li) + tmp), xdnmn(lh) )
!          r = Max( r, 400. )
          qhcni(mgs) = (qiacw(mgs) - qidpv(mgs)) ! *float(iglcnvi)
          chcni(mgs) = cx(mgs,li)*qhcni(mgs)/qx(mgs,li)
!          chcnih(mgs) = rho0(mgs)*qhcni(mgs)/(1.6e-10)
          chcnih(mgs) = Min(chcni(mgs), rho0(mgs)*qhcni(mgs)/(r*xvmn(lh)) )
!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
          vhcni(mgs) = rho0(mgs)*qhcni(mgs)/r
        ENDIF
      
      ELSEIF ( iglcnvi == 3 ) THEN

       IF ( temg(mgs) .lt. 273.0 .and. qiacw(mgs)*dtp > 2.*qxmin(lh) .and. gamice73fac*xmas(mgs,li) > xdnmn(lh)*xvmn(lh) ) THEN
      
        
        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
     &                *((0.60)*vtxbar(mgs,li,1))   &
     &                /(temg(mgs)-273.15))**(rimc2)
        tmp = Min( Max( rimc3, tmp ), 900.0 )
        
        !  Assume that half the volume of the embryo is rime with density 'tmp'
        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
        !  V = 2*m/(rhoi + rhorime)
        
!        write(0,*)  'rime dens = ',tmp
        ! convert to particles with the mass of the mass-weighted diameter
      !  massofmwr = gamice73fac*xmas(mgs,li)
        
        IF ( tmp .ge. xdnmn(lh)  ) THEN
          r = Max( 0.5*(xdn(mgs,li) + tmp), xdnmn(lh) )
!          r = Max( r, 400. )
          qhcni(mgs) = 0.5*qiacw(mgs)
          chcni(mgs) = qhcni(mgs)/(gamice73fac*xmas(mgs,li))
          chcnih(mgs) = Min(chcni(mgs), rho0(mgs)*qhcni(mgs)/(r*xvmn(lh)) )
!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
          vhcni(mgs) = rho0(mgs)*qhcni(mgs)/r
        ENDIF
      
      ENDIF

      
      ENDIF
      ENDIF
      
      
      ENDDO
      
      
      qhlcnh(:) = 0.0
      chlcnh(:) = 0.0
      vhlcnh(:) = 0.0
      vhlcnhl(:) = 0.0
      zhlcnh(:) = 0.0

      qhcnhl(:) = 0.0
      chcnhl(:) = 0.0
      vhcnhl(:) = 0.0
      zhcnhl(:) = 0.0
      

      IF ( lhl .gt. 1  ) THEN
      
      IF ( ihlcnh == 1 ) THEN

!
!  Graupel (h) conversion to hail (hl) based on Milbrandt and Yau 2005b
!
      DO mgs = 1,ngscnt

!        IF ( lhl .gt. 1 .and. ipconc .ge. 5 .and. qx(mgs,lh) .gt. 1.0e-3 .and.
!     :        xdn(mgs,lh) .gt. 750. .and. qhshr(mgs) .lt. 0.0 .and.
!     :        xdia(mgs,lh,3) .gt. 1.e-3 ) THEN
        IF (  wetgrowth(mgs) .and. (xdn(mgs,lh) .gt. hldnmn .or. lvh < 1 ) .and.  & ! correct this when hail gets turned on
!        IF (  ( qhshr(mgs) .lt. 0.0 .or. rimdn(mgs,lh) .gt. 800. ) .and.   &
     &        rimdn(mgs,lh) .gt. 800. .and.   &
     &        xdia(mgs,lh,3) .gt. hlcnhdia .and. qx(mgs,lh) .gt. hlcnhqmin ) THEN
!     :        xdia(mgs,lh,3) .gt. 2.e-3 .and. qx(mgs,lh) .gt. 1.0e-3 ) THEN ! 0823.2008 erm test
!        IF ( xdia(mgs,lh,3) .gt. 1.e-3 ) THEN
        IF ( qhacw(mgs) .gt. 0.0 .and. qhacw(mgs) .gt. qhaci(mgs) .and. temg(mgs) .le. tfr-2.0 ) THEN
        ! dh0 is the diameter dividing wet growth from dry growth (Ziegler 1985), modified by MY05
!          dh0 = 0.01*(exp(temcg(mgs)/(1.1e4*(qx(mgs,lc)+qx(mgs,lr)) - 
!     :           1.3e3*qx(mgs,li) + 1.0e-3 ) ) - 1.0)
          x = (1.1e4*(rho0(mgs)*qx(mgs,lc)) - 1.3e3*rho0(mgs)*qx(mgs,li) + 1.0e-3 )
          IF ( x > 1.e-20 ) THEN
          arg = Min(70.0, (-temcg(mgs)/x )) ! prevent overflow of the exp function in 32 bit
          dh0 = 0.01*(exp(arg) - 1.0)
          ELSE
           dh0 = 1.e30
          ENDIF
!          dh0 = Max( dh0, 5.e-3 )
          
!         IF ( dh0 .gt. 0.0 ) write(0,*) 'dh0 = ',dh0
!         IF ( dh0 .gt. 1.0e-4 ) THEN
         IF ( xdia(mgs,lh,3)/dh0 .gt. 0.1 ) THEN 
!         IF ( xdia(mgs,lh,3) .lt. 20.*dh0 .and. dh0 .lt. 2.0*xdia(mgs,lh,3) ) THEN 
           tmp = qhacw(mgs) + qhacr(mgs) + qhaci(mgs) + qhacs(mgs)
!           qtmp = Min( 1.0, xdia(mgs,lh,3)/(2.0*dh0) )*(tmp)
           qtmp = Min( 100.0, xdia(mgs,lh,3)/(2.0*dh0) )*(tmp)
           IF ( .false. .and. qx(mgs,lhl) + qtmp*dtp .lt. 0.5e-3 ) THEN
             hdia1 = Max(dh0, xdia(mgs,lh,3) )
            qtmp = qtmp + Min(qxmxd(mgs,lh), Max( 0.0,   &
     &      ((pi*xdn(mgs,lh)*cx(mgs,lh)) / (6.0*rho0(mgs)*dtp))   &
     &      *exp(-hdia1/xdia(mgs,lh,1))   &
     &      *( (hdia1**3) + 3.0*(hdia1**2)*xdia(mgs,lh,1)   &
     &      + 6.0*(hdia1)*(xdia(mgs,lh,1)**2) + 6.0*(xdia(mgs,lh,1)**3) ) ) )

!c           qtmp = Min( qxmxd(mgs,lh), qtmp )
!c           tmp = tmp + Min( 0.5e-3/dtp, qtmp )
           ENDIF
!           write(0,*) 'dh0 = ',dh0,tmp,qx(mgs,lh)*1000.
!           qhlcnh(mgs) = Min( 0.5*(qx(mgs,lh))+tmp, xdia(mgs,lh,3)/(2.0*dh0)*(tmp) )
!           qhlcnh(mgs) = Min(  qxmxd(mgs,lh), xdia(mgs,lh,3)/(2.0*dh0)*(tmp) )
           qhlcnh(mgs) = Min(  qxmxd(mgs,lh), qtmp )
           
           IF ( ipconc .ge. 5 ) THEN
!           dh0 = Max( xdia(mgs,lh,3), Min( dh0, 5.e-3 ) ) ! don't create hail greater than 5mm diam. unless the graupel is larger
           dh0 = Min( dh0, 10.e-3 ) ! don't create hail greater than 10mm diam., which is the max graupel size
!           IF ( qx(mgs,lhl) > 0.1e-3 ) dh0 = xdia(mgs,lhl,3) ! when enough hail is established, don't dilute the size
           chlcnh(mgs) = Min( cxmxd(mgs,lh), rho0(mgs)*qhlcnh(mgs)/(pi*xdn(mgs,lh)*dh0**3/6.0) )
!           chlcnh(mgs) = Min( chlcnh(mgs), (1./8.)*rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) )
!           chlcnh(mgs) = Min( chlcnh(mgs), (1./2.)*rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) )
           r = rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh))  ! number of graupel particles at mean volume diameter
!           chlcnh(mgs) = Min( Max( 1./8.*r , chlcnh(mgs)), r )
!           chlcnh(mgs) = Min( chlcnh(mgs), r )
           chlcnh(mgs) = Max( chlcnh(mgs), r )
!           chlcnh(mgs) =  r 
           ENDIF
           
           vhlcnh(mgs) = rho0(mgs)*qhlcnh(mgs)/xdn(mgs,lh)
           vhlcnhl(mgs) = rho0(mgs)*qhlcnh(mgs)/Max(xdnmn(lhl), xdn(mgs,lh))
!           write(0,*) 'qhlcnh = ',qhlcnh(mgs)*1000.,chlcnh(mgs)
          ENDIF
!         write(0,*) 'graupel to hail conversion not complete! STOP!'
!         STOP
        ENDIF
        ENDIF
      
      ENDDO
      
      ELSEIF ( ihlcnh == 2 ) THEN ! 10-ice type conversion 

!
! Staka and Mansell (2005) type conversion -- assuming alphah = 0 for now!
!
!      hldia1 is set in micro_module and namelist
      do mgs = 1,ngscnt
!      qhlcnh(mgs) = 0.0
!      chlcnh(mgs) = 0.0
      if ( wetgrowth(mgs) .and. temg(mgs) .lt. tfr-5. .and. qx(mgs,lh) > qxmin(lh) ) then
      if ( qhacw(mgs).gt.1.e-6 .and. xdn(mgs,lh) > 700. ) then
      qhlcnh(mgs) =                                                   &
        ((pi*xdn(mgs,lh)*cx(mgs,lh)) / (6.0*rho0(mgs)*dtp))           &
       *exp(-hldia1/xdia(mgs,lh,1))                                    &
       *( (hldia1**3) + 3.0*(hldia1**2)*xdia(mgs,lh,1)                  &
        + 6.0*(hldia1)*(xdia(mgs,lh,1)**2) + 6.0*(xdia(mgs,lh,1)**3) )
      qhlcnh(mgs) =   min(qhlcnh(mgs),qhmxd(mgs))
      IF ( ipconc .ge. 5 ) THEN
        chlcnh(mgs) = Min( cxmxd(mgs,lh), cx(mgs,lh)*Exp(-hldia1/xdia(mgs,lh,1)))
!        chlcnh(mgs) = Min( cxmxd(mgs,lh), rho0(mgs)*qhlcnh(mgs)/(2.0*xmas(mgs,lh) ))
      ENDIF
           vhlcnh(mgs) = rho0(mgs)*qhlcnh(mgs)/xdn(mgs,lh)
           vhlcnhl(mgs) = rho0(mgs)*qhlcnh(mgs)/Max(xdnmn(lhl), xdn(mgs,lh))
      end if
      end if
      end do
      
      ENDIF
      
     ! convert low-density hail to graupel
      IF ( icvhl2h >= 1 ) THEN
      DO mgs = 1,ngscnt
        IF (  qx(mgs,lhl) > qxmin(lhl) .and. xdn(mgs,lhl) < 0.5*(xdnmn(lhl) + xdnmx(lhl)) ) THEN
          tmp = Min(0.95, 1. - 0.5*(1. + tanh(0.125*(xdn(mgs,lhl) - 1.01*xdnmn(lhl) )) ))
          qhcnhl(mgs) = tmp*qx(mgs,lhl)/dtp
          chcnhl(mgs) = cx(mgs,lhl)*qhcnhl(mgs)/qx(mgs,lhl)
          vhcnhl(mgs) = vx(mgs,lhl)*qhcnhl(mgs)/qx(mgs,lhl)
          
        ENDIF
      ENDDO
      
      ENDIF
      
      
      ENDIF ! lhl > 1


!
! Ziegler snow conversion to graupel
!
      DO mgs = 1,ngscnt

      qhcns(mgs) = 0.0
      chcns(mgs) = 0.0
      chcnsh(mgs) = 0.0
      vhcns(mgs) = 0.0

      qscnh(mgs) = 0.0
      cscnh(mgs) = 0.0
      vscnh(mgs) = 0.0

      IF ( ipconc .ge. 5 ) THEN

        IF ( temg(mgs) < tfr .and. qx(mgs,lh) .gt. qxmin(lh) .and. qhdpv(mgs) > qxmin(lh)*dtpinv  &
     &       .and. qhacw(mgs) < qxmin(lh)*dtpinv ) THEN
          IF ( xdn(mgs,lh) < 290. ) THEN
!          qscnh(mgs) = 2.*qhdpv(mgs)
!          cscnh(mgs) = cx(mgs,lh)*qscnh(mgs)/qx(mgs,lh)
!          vscnh(mgs) = rho0(mgs)*qscnh(mgs)/xdn(mgs,lh)
          ENDIF
        ENDIF


        IF ( qx(mgs,ls) .gt. qxmin(ls) .and. qsacw(mgs) .gt. 0.0 ) THEN

!      DATA VGRA/1.413E-2/  ! this is the volume (cm**3) of a 3mm diam. sphere
!    vgra = 1.4137e-8 m**3

!      DNNET=DNCNV-DNAGG
!      DQNET=QXCON+QSACC+SDEP
!
!      DNSCNV=EXP(-(ROS*XNS*VGRA/(RO*QI)))*((1.-(XNS*VGRA*ROS/
!     / (RO*QI)))*DNNET + (XNS**2*VGRA*ROS/(RO*QI**2))*DQNET)
!      IF(DNSCNV.LT.0.) DNSCNV=0.
!
!      QIHC=(ROS*VGRA/RO)*DNSCNV
!
!      QH=QH+DT*QIHC
!      QI=QI-DT*QIHC
!      XNH=XNH+DT*DNSCNV
!      XNS=XNS-DT*DNSCNV

        IF ( iglcnvs .eq. 1 ) THEN  ! Zrnic, Ziegler et al (1993)

        dnnet = cscnvis(mgs) + cscnis(mgs) - csacs(mgs)
        dqnet = qscnvi(mgs) + qscni(mgs) + qsacw(mgs) + qsdpv(mgs) + qssbv(mgs)

        a3 = 1./(rho0(mgs)*qx(mgs,ls))
        a1 = Exp( - xdn(mgs,ls)*cx(mgs,ls)*vgra*a3 )  ! EXP(-(ROS*XNS*VGRA/(RO*QI)))
! (1.-(XNS*VGRA*ROS/(RO*QI)))*DNNET
        a2 =  (1.-(cx(mgs,ls)*vgra*xdn(mgs,ls)*a3))*dnnet
! (XNS**2*VGRA*ROS/(RO*QI**2))*DQNET
        a4 = cx(mgs,ls)**2*vgra*xdn(mgs,ls)*a3/qx(mgs,ls)*dqnet

        chcns(mgs) = Max( 0.0, a1*(a2 + a4) )
        chcns(mgs) = Min( chcns(mgs), cxmxd(mgs,ls) )
        chcnsh(mgs) = chcns(mgs)

        qhcns(mgs) = Min( xdn(mgs,ls)*vgra*rhoinv(mgs)*chcns(mgs), qxmxd(mgs,ls) )
        vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),xdnmn(lh))
!        vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),400.)

        ELSEIF ( iglcnvs .ge. 2  ) THEN  ! treat like ice crystals, i.e., check for rime density (ERM)

          IF ( temg(mgs) .lt. 273.0 .and. ( qsacw(mgs) - qsdpv(mgs) .gt. 0.0 .or. &
              ( iglcnvs >= 3 .and. qsacw(mgs) > 2.*qxmin(lh) .and. gamsnow73fac*xmas(mgs,ls) > xdnmn(lh)*xvmn(lh)  ) ) ) THEN


        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
     &                *((0.60)*vtxbar(mgs,ls,1))   &
     &                /(temg(mgs)-273.15))**(rimc2)
        tmp = Min( Max( rimc3, tmp ), 900.0 )

        !  Assume that half the volume of the embryo is rime with density 'tmp'
        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
        !  V = 2*m/(rhoi + rhorime)

!        write(0,*)  'rime dens = ',tmp

        IF ( iglcnvs == 2 ) THEN
        IF ( tmp .ge. 200.0  ) THEN
          r = Max( 0.5*(xdn(mgs,ls) + tmp), xdnmn(lh) )
!          r = Max( r, 400. )
          qhcns(mgs) = (qsacw(mgs) - qsdpv(mgs))
          chcns(mgs) = cx(mgs,ls)*qhcns(mgs)/qx(mgs,ls)
!          chcnih(mgs) = rho0(mgs)*qhcni(mgs)/(1.6e-10)
          chcnsh(mgs) = Min(chcns(mgs), rho0(mgs)*qhcns(mgs)/(r*xvmn(lh)) )
!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
          vhcns(mgs) = rho0(mgs)*qhcns(mgs)/r
        ENDIF
        
        ELSEIF ( iglcnvs == 3 ) THEN
 
         ! convert to particles with the mass of the mass-weighted diameter
      !  massofmwr = gamice73fac*xmas(mgs,li)
        
        IF ( tmp .ge. xdnmn(lh)  ) THEN
          r = Max( 0.5*(xdn(mgs,ls) + tmp), xdnmn(lh) )
!          r = Max( r, 400. )
          qhcns(mgs) = 0.5*qsacw(mgs)
          chcns(mgs) = qhcns(mgs)/(gamsnow73fac*xmas(mgs,ls))
          chcnsh(mgs) = Min(chcns(mgs), rho0(mgs)*qhcns(mgs)/(r*xvmn(lh)) )
          vhcns(mgs) = rho0(mgs)*qhcns(mgs)/r
        ENDIF

        ENDIF

      ENDIF

        ENDIF


        ENDIF

       ELSE ! single moment lfo

        qhcns(mgs) = 0.001*ehscnv(mgs)*max((qx(mgs,ls)-6.e-4),0.0)
        qhcns(mgs) = min(qhcns(mgs),qxmxd(mgs,ls))
        IF ( lvol(lh) .ge. 1 ) vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),400.)

       ENDIF
      ENDDO
!
!
!  heat budget for rain---not all rain that collects ice can freeze
!
!
!
      if ( irwfrz .gt. 0 .and. .not. mixedphase) then
!
      do mgs = 1,ngscnt
!
!  compute total rain that freeze when it interacts with cloud ice
!
      qrztot(mgs) = qrfrz(mgs) + qiacr(mgs) + qsacr(mgs)
!
!  compute the maximum amount of rain that can freeze
!  Used to limit freezing to 4*qrmxd, but now allow all rain to freeze if possible
!
      qrzmax(mgs) =   &
     &  ( xdia(mgs,lr,1)*rwvent(mgs)*cx(mgs,lr)*fwet1(mgs) )
      qrzmax(mgs) = max(qrzmax(mgs), 0.0)
      qrzmax(mgs) = min(qrztot(mgs), qrzmax(mgs))
      qrzmax(mgs) = min(qx(mgs,lr)/dtp, qrzmax(mgs))

      IF ( temcg(mgs) < -30. ) THEN ! allow all to freeze if T < -30 because fwet becomes invalid (negative)
        qrzmax(mgs) = qx(mgs,lr)/dtp
      ENDIF
!      qrzmax(mgs) = min(4.*qrmxd(mgs), qrzmax(mgs))
!
!  compute the correction factor
!
!      IF ( qrztot(mgs) .gt. qxmin(lr) ) THEN
      IF ( qrztot(mgs) .gt. qrzmax(mgs) .and. qrztot(mgs) .gt. qxmin(lr) ) THEN
        qrzfac(mgs) = qrzmax(mgs)/(qrztot(mgs))
      ELSE
        qrzfac(mgs) = 1.0
      ENDIF
      qrzfac(mgs) = min(1.0, qrzfac(mgs))
!
      end do
!
!
! now correct the above sources
!
!
      do mgs = 1,ngscnt
      if ( temg(mgs) .le. 273.15 .and. qrzfac(mgs) .lt. 1.0 ) then
      qrfrz(mgs)   = qrzfac(mgs)*qrfrz(mgs)
      qrfrzs(mgs)  = qrzfac(mgs)*qrfrzs(mgs)
      qrfrzf(mgs)  = qrzfac(mgs)*qrfrzf(mgs)
      qiacr(mgs)   = qrzfac(mgs)*qiacr(mgs)
      qsacr(mgs)   = qrzfac(mgs)*qsacr(mgs)
      qiacrf(mgs)  = qrzfac(mgs)*qiacrf(mgs)
      qiacrs(mgs)  = qrzfac(mgs)*qiacrs(mgs)
      crfrz(mgs)   = qrzfac(mgs)*crfrz(mgs)
      crfrzf(mgs)  = qrzfac(mgs)*crfrzf(mgs)
      crfrzs(mgs)  = qrzfac(mgs)*crfrzs(mgs)
      ciacr(mgs)   = qrzfac(mgs)*ciacr(mgs)
      ciacrf(mgs)  = qrzfac(mgs)*ciacrf(mgs)
      ciacrs(mgs)  = qrzfac(mgs)*ciacrs(mgs)

      
       vrfrzf(mgs)  = qrzfac(mgs)*vrfrzf(mgs)
       viacrf(mgs)  = qrzfac(mgs)*viacrf(mgs)
      end if
      end do
!
!
!
      end if
!
!
!
!  evaporation of rain
!
!
!
      qrcev(:) = 0.0
      crcev(:) = 0.0


      do mgs = 1,ngscnt
!
      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN

      qrcev(mgs) =   &
     &  fvce(mgs)*cx(mgs,lr)*rwvent(mgs)*rwcap(mgs)*evapfac
! this line to allow condensation on rain:
      IF ( rcond .eq. 1 ) THEN
        qrcev(mgs) = min(qrcev(mgs), qxmxd(mgs,lv))
! this line to have evaporation only:
      ELSE
        qrcev(mgs) = min(qrcev(mgs), 0.0)
      ENDIF

      qrcev(mgs) = max(qrcev(mgs), -qrmxd(mgs))
!      if ( temg(mgs) .lt. 273.15 ) qrcev(mgs) = 0.0
      IF ( qrcev(mgs) .lt. 0. .and. lnr > 1 ) THEN
!        qrcev(mgs) =   -qrmxd(mgs)
!        crcev(mgs) = (rho0(mgs)/(xmas(mgs,lr)+1.e-20))*qrcev(mgs)
      crcev(mgs) = (cx(mgs,lr)/(qx(mgs,lr)))*qrcev(mgs)
      ELSE
         crcev(mgs) = 0.0
      ENDIF
!      if ( temg(mgs) .lt. 273.15 ) crcev(mgs) = 0.0
!
      ENDIF

      end do
!
! evaporation/condensation of wet graupel and snow
!
      qscev(:) = 0.0
      cscev(:) = 0.0
      qhcev(:) = 0.0
      chcev(:) = 0.0
      qhlcev(:) = 0.0
      chlcev(:) = 0.0

!
!
!
!  ICE MULTIPLICATION: Two modes (rimpa, and rimpb)
!  (following Cotton et al. 1986)
!
 
      chmul1(:) =  0.0
      chlmul1(:) =  0.0
      csmul1(:) = 0.0
!
      qhmul1(:) =  0.0
      qhlmul1(:) =  0.0
      qsmul1(:) =  0.0

      do mgs = 1,ngscnt
 
       ltest =  qx(mgs,lh) .gt. qxmin(lh)
       IF ( lhl > 1 )  ltest =  ltest .or. qx(mgs,lhl) .gt. qxmin(lhl)
       
      IF ( (itype1 .ge. 1 .or. itype2 .ge. 1 )   &
     &              .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
      if ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 271.15 ) then
       IF ( ipconc .ge. 2 ) THEN
        IF ( xv(mgs,lc) .gt. 0.0     &
     &     .and.  ltest &
!     .and. itype2 .ge. 2    &
     &       ) THEN
!
!  Ziegler et al. 1986 Hallett-Mossop process.  VSTAR = 7.23e-15 (vol of 12micron radius)
!
         ex1 = (1./250.)*Exp(-7.23e-15/xv(mgs,lc))
       IF ( itype2 .le. 2 ) THEN
         ft = Max(0.0,Min(1.0,-0.11*temcg(mgs)**2 - 1.1*temcg(mgs)-1.7))
       ELSE
        IF ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 267.15 ) THEN
          ft = 0.5
        ELSEIF (temg(mgs) .ge. 267.15 .and. temg(mgs) .le. 269.15 ) THEN
          ft = 1.0
        ELSEIF (temg(mgs) .ge. 269.15 .and. temg(mgs) .le. 271.15 ) THEN
          ft = 0.5
        ELSE 
          ft = 0.0
        ENDIF
       ENDIF
!        rhoinv = 1./rho0(mgs)
!        DNSTAR = ex1*cglacw(mgs)
        
       IF ( ft > 0.0 ) THEN
        
        IF ( itype2 > 0 ) THEN
         IF ( qx(mgs,lh) .gt. qxmin(lh) .and. (.not. wetsfc(mgs))  ) THEN
          chmul1(mgs) = ft*ex1*chacw(mgs)
!          chmul1(mgs) = Min( ft*ex1*chacw(mgs), ft*(30.*1.e+06)*rho0(mgs)*qhacw(mgs) ) ! 1.e+6 converts kg to mg; Saunders & Hosseini (2001) average of about 30 crystals per mg
          qhmul1(mgs) = cimas0*chmul1(mgs)*rhoinv(mgs)
         ENDIF
         IF ( lhl .gt. 1 ) THEN
           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs))  ) THEN
            chlmul1(mgs) = (ft*ex1*chlacw(mgs))
            qhlmul1(mgs) = cimas0*chlmul1(mgs)*rhoinv(mgs)
           ENDIF
         ENDIF
        ENDIF ! itype2

        IF ( itype1 > 0 ) THEN
         IF ( qx(mgs,lh) .gt. qxmin(lh) .and. (.not. wetsfc(mgs))  ) THEN
          tmp = ft*(3.5e+08)*rho0(mgs)*qhacw(mgs)
          chmul1(mgs) = chmul1(mgs) + tmp
          qhmul1(mgs) = qhmul1(mgs) + cimas0*tmp*rhoinv(mgs)
         ENDIF
         IF ( lhl .gt. 1 ) THEN
           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs)) ) THEN
            tmp = ft*(3.5e+08)*rho0(mgs)*qhlacw(mgs)
            chlmul1(mgs) = chlmul1(mgs) + tmp
            qhlmul1(mgs) = qhlmul1(mgs) + cimas0*tmp*rhoinv(mgs)
           ENDIF
         ENDIF
        ENDIF ! itype1
        
        ENDIF ! ft

        ENDIF ! xv(mgs,lc) .gt. 0.0 .and.

       ELSE ! ipconc .lt. 2
!
!  define the temperature function
!
      fimt1(mgs) = 0.0
!
! Cotton et al. (1986) version
!
      if ( temg(mgs) .ge. 268.15 .and. temg(mgs) .le. 270.15 ) then
        fimt1(mgs) = 1.0 -(temg(mgs)-268.15)/2.0
      elseif (temg(mgs) .le. 268.15 .and. temg(mgs) .ge. 265.15 ) then
        fimt1(mgs) = 1.0 +(temg(mgs)-268.15)/3.0
      ELSE 
        fimt1(mgs) = 0.0
      end if
!
! Ferrier (1994) version
!
      if ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 267.15 ) then
        fimt1(mgs) = 0.5
      elseif (temg(mgs) .ge. 267.15 .and. temg(mgs) .le. 269.15 ) then
        fimt1(mgs) = 1.0
      elseif (temg(mgs) .ge. 269.15 .and. temg(mgs) .le. 271.15 ) then
        fimt1(mgs) = 0.5
      ELSE 
        fimt1(mgs) = 0.0
      end if
!
!
!   type I:  350 splinters are formed for every 1e-3 grams of cloud
!            water accreted by graupel/hail (note converted to MKS units)
!            3.5e+8 has units of 1/kg
!
      IF ( itype1 .ge. 1 ) THEN
       fimta(mgs) = (3.5e+08)*rho0(mgs)
      ELSE
       fimta(mgs) = 0.0
      ENDIF

!
!
!   type II:  1 splinter formed for every 250 cloud droplets larger than
!             24 micons in diameter (12 microns in radius) accreted by
!             graupel/hail
!
!
      fimt2(mgs) = 0.0
      xcwmas = xmas(mgs,lc) * 1000.
!
      IF ( itype2 .ge. 1 ) THEN
      if ( xcwmas.lt.1.26e-9 ) then
        fimt2(mgs) = 0.0
      end if
      if ( xcwmas .le. 3.55e-9 .and. xcwmas .ge. 1.26e-9 ) then
        fimt2(mgs) = (2.27)*alog(xcwmas) + 13.39
      end if
      if ( xcwmas .gt. 3.55e-9 ) then
        fimt2(mgs) = 1.0
      end if

      fimt2(mgs) = min(fimt2(mgs),1.0)
      fimt2(mgs) = max(fimt2(mgs),0.0)
      
      ENDIF
!
!     qhmul2 = 0.0
!     qsmul2 = 0.0
!
!     qhmul2 =
!    >  (4.0e-03)*fimt1(mgs)*fimt2(mgs)*qhacw(mgs)
!     qsmul2 =
!    >  (4.0e-03)*fimt1(mgs)*fimt2(mgs)*qsacw(mgs)
!
!      cimas0 = (1.0e-12)
!      cimas0 = 2.5e-10
      IF ( .not. wetsfc(mgs) ) THEN
      chmul1(mgs) =  fimt1(mgs)*(fimta(mgs) +   &
     &                           (4.0e-03)*fimt2(mgs))*qhacw(mgs)
      ENDIF
!
      qhmul1(mgs) =  chmul1(mgs)*(cimas0/rho0(mgs))


         IF ( lhl .gt. 1 ) THEN
           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs)) ) THEN
            tmp = fimt1(mgs)*(fimta(mgs) +   &
     &                           (4.0e-03)*fimt2(mgs))*qhlacw(mgs)
            chlmul1(mgs) =  tmp
            qhlmul1(mgs) = cimas0*tmp*rhoinv(mgs)
           ENDIF
         ENDIF

!      qsmul1(mgs) =  csmul1(mgs)*(cimas0/rho0(mgs))
!
      ENDIF ! ( ipconc .ge. 2 )
      
      end if ! (in temperature range)
      
      ENDIF ! ( itype1 .eq. 1 .or. itype2 .eq. 1)
!
      end do
!
!
!
!     end if
!
!     end do
!
!
! ICE MULTIPLICATION FROM SNOW
!   Lo and Passarelli 82 / Willis and Heymsfield 89 / Schuur and Rutledge 00b
!   using kfrag as fragmentation rate (s-1) / 500 microns as char mean diam for max snow mix ratio
!
      csmul(:) = 0.0
      qsmul(:) = 0.0
      
      IF ( isnwfrac /= 0 ) THEN
      do mgs = 1,ngscnt
       IF (temg(mgs) .gt. 265.0) THEN !{
        if (xdia(mgs,ls,1) .gt. 100.e-6 .and. xdia(mgs,ls,1) .lt. 2.0e-3) then  ! equiv diameter 100microns to 2mm

        tmp = rhoinv(mgs)*pi*xdn(mgs,ls)*cx(mgs,ls)*(500.e-6)**3
        qsmul(mgs) = Max( kfrag*( qx(mgs,ls) - tmp ) , 0.0 )

        qsmul(mgs) = Min( qxmxd(mgs,li), qsmul(mgs) )
        csmul(mgs) = Min( cxmxd(mgs,li), rho0(mgs)*qsmul(mgs)/mfrag )

        endif
       ENDIF !}
      enddo
      ENDIF

!
!  frozen rain-rain interaction....
!
!
!
!
!  rain-ice interaction
!
!
      do mgs = 1,ngscnt
      qracif(mgs) = qraci(mgs)
      cracif(mgs) = craci(mgs)
!      ciacrf(mgs) = ciacr(mgs)
      end do
!
! 
!  vapor to pristine ice crystals   UP
!
!
!
!  compute the nucleation rate
!
!     do mgs = 1,ngscnt
!     idqis = 0
!     if ( ssi(mgs) .gt. 1.0 ) idqis = 1
!     fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
!     dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/
!    >  (1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
!     qidsvp(mgs) = dqisdt(mgs)
!     cnnt = min(cnit*exp(-temcg(mgs)*bta1),1.0e+09)
!     qiint(mgs) = 
!    >  il5(mgs)*idqis*(1.0/dtp)
!    <  *min((6.88e-13)*cnnt/rho0(mgs), 0.25*dqisdt(mgs)) 
!     end do
!
!  Meyers et al. (1992; JAS) and Ferrier (1994) primary ice nucleation
!
      cmassin = cimasn  ! 6.88e-13
      do mgs = 1,ngscnt
      qiint(mgs) = 0.0
      ciint(mgs) = 0.0
      qicicnt(mgs) = 0.0
      cicint(mgs) = 0.0
      qipipnt(mgs) = 0.0
      cipint(mgs) = 0.0
      IF ( icenucopt == 1 .or. icenucopt == -10 .or. icenucopt == -11 ) THEN
      if ( ( temg(mgs) .lt. 268.15 .or.  &
!     : ( imeyers5 .and. temg(mgs) .lt.  273.0) ) .and.    &
     & ( imeyers5 .and. temg(mgs) .lt.  272.0 .and. temgkm2(mgs) .lt. tfr) ) .and.    &
     &    ciintmx .gt. (cx(mgs,li))  &
!     :    .and. cninm(mgs) .gt. 0.   &
     &     ) then
      fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
      dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/   &
     &  (1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
!      qidsvp(mgs) = dqisdt(mgs)
      idqis = 0
      if ( ssi(mgs) .gt. 1.0 ) THEN
      idqis = 1 
      dzfacp = max( float(kgsp(mgs)-kgs(mgs)), 0.0 )
      dzfacm = max( float(kgs(mgs)-kgsm(mgs)), 0.0 )
      qiint(mgs) =   &
     &  idqis*il5(mgs)   &
     &  *(cmassin/rho0(mgs))   &
     &  *max(0.0,wvel(mgs))   &
     &  *max((cninp(mgs)-cninm(mgs)),0.0)/gz(igs(mgs),jgs,kgs(mgs))   &
     &  /((dzfacp+dzfacm))

      qiint(mgs) = min(qiint(mgs), max(0.25*dqisdt(mgs),0.0)) 
      ciint(mgs) = qiint(mgs)*rho0(mgs)/cmassin
!
! limit new crystals so it does not increase the current concentration
!  above ciintmx 20,000 per liter (2.e7 per m**3)
!
!      ciintmx = 1.e9
!      ciintmx = 1.e9
      IF ( icenucopt /= -10 ) THEN
      
        IF ( lcin > 1 ) THEN
          ciint(mgs) = Min(ciint(mgs), ccin(mgs))
          ccin(mgs) = ccin(mgs) - ciint(mgs)
          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
        ELSEIF ( lcina > 1 ) THEN
          ciint(mgs) = Max(0.0, Min( ciint(mgs), Min( cnina(mgs), ciintmx ) - cina(mgs) ))
          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
      
        ELSEIF ( icenucopt == 1 .and. ciint(mgs) .gt. (ciintmx - (cx(mgs,li)))) THEN
          ciint(mgs) = Max(0.0, ciintmx - (cx(mgs,li)) )
          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)

        ELSEIF ( icenucopt == -11 .and. dtp*ciint(mgs) .gt. ( cnina(mgs) - (cx(mgs,li)))) THEN
          ciint(mgs) = Max(0.0,  cnina(mgs) - (cx(mgs,li))*dtpinv )
          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)

        ENDIF
      ENDIF
      
      end if
      endif

      ELSEIF ( icenucopt == 2 .or. icenucopt == -1 .or. icenucopt == -2 ) THEN
      
        IF ( ( temg(mgs) .lt. 268.15 .and. ssw(mgs) > 0.999 ) .or. ssi(mgs) > 1.05 ) THEN
          IF ( lcin > 1 ) THEN
           ciint(mgs) = Min(cnina(mgs), ccin(mgs))
           ccin(mgs) = ccin(mgs) - ciint(mgs)
          ELSE
           ciint(mgs) = Max( 0.0, cnina(mgs) - cina(mgs) )
          ENDIF
          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)

          fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
          dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/(1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
          qiint(mgs) = min(qiint(mgs), max(0.25*dqisdt(mgs),0.0))
          ciint(mgs) = qiint(mgs)*rho0(mgs)/cmassin
        ENDIF
      
      
      
      ELSEIF ( icenucopt == 3 ) THEN
        IF (  temg(mgs) .lt. 268.15 ) THEN
          IF ( lcin > 1 ) THEN
           ciint(mgs) = Min(cnina(mgs), ccin(mgs))
           ccin(mgs) = ccin(mgs) - ciint(mgs)
          ELSE
           ciint(mgs) = Max( 0.0, cnina(mgs) - cina(mgs) )
          ENDIF
          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
        ENDIF

      ENDIF
!
      if ( xplate(mgs) .eq. 1 ) then
      qipipnt(mgs) = qiint(mgs)
      cipint(mgs) = ciint(mgs)
      end if
!
      if ( xcolmn(mgs) .eq. 1 ) then
      qicicnt(mgs) = qiint(mgs)
      cicint(mgs) = ciint(mgs)
      end if
!
!     qipipnt(mgs) = 0.0
!     qicicnt(mgs) = qiint(mgs)
!
      end do
!
! 

!
!  vapor to cloud droplets   UP
!
      if (ndebug .gt. 0 ) write(0,*) 'dbg = 8'
!
!
      if (ndebug .gt. 0 ) write(0,*) 'Collection: set 3-component'
!
!  time for riming....
!
!     rimtim = 240.0
!     dtrim = rimtim
!     xacrtim  = 120.0
!     tranfr = 0.50
!     tranfw = 0.50
!
!  coefficients for riming
!
!     rimc1 = 300.00
!     rimc2 = 0.44
!
! 
!  zero som arrays
!
!
      do mgs = 1,ngscnt
      qrshr(mgs) = 0.0
      qsshrp(mgs) = 0.0
      qhshrp(mgs) = 0.0
      end do
!
!
!  first sum all of the shed rain
!
!
      do mgs = 1,ngscnt
      qrshr(mgs) = qsshr(mgs) + qhshr(mgs) + qhlshr(mgs)
      crshr(mgs) = chshrr(mgs)/rzxh(mgs) + chlshrr(mgs)/rzxhl(mgs)
      IF ( ipconc .ge. 3 ) THEN
!       crshr(mgs) = Max(crshr(mgs), rho0(mgs)*qrshr(mgs)/(xdn(mgs,lr)*vr1mm) )
      ENDIF
      end do 
!
!
!

!
!
!
!
      IF ( ipconc .ge. 1 ) THEN
!
!
!  concentration production terms
!
!  YYY
!
!
!       DO mgs = 1,ngscnt
       pccwi(:) = 0.0
       pccwd(:) = 0.0
       pccii(:) = 0.0
       pccin(:) = 0.0
       pccid(:) = 0.0
       pcrwi(:) = 0.0
       pcrwd(:) = 0.0
       pcswi(:) = 0.0
       pcswd(:) = 0.0
       pchwi(:) = 0.0
       pchwd(:) = 0.0
       pchli(:) = 0.0
       pchld(:) = 0.0
!       ENDDO
!
!  Cloud ice
!
!      IF ( ipconc .ge. 1 ) THEN

      IF ( warmonly < 0.5 ) THEN
      do mgs = 1,ngscnt
      pccii(mgs) =   &
     &   il5(mgs)*cicint(mgs) &
!     >  +il5(mgs)*cidpv(mgs)
!     >  +il5(mgs)*(cwacii(mgs))   &
     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
     &  +cicichr(mgs))   &
     &  +chmul1(mgs)   &
     &  +chlmul1(mgs)    &
     &  + csplinter(mgs) + csplinter2(mgs)   &
!     >  + nsplinter*(crfrzf(mgs) + crfrz(mgs))
     &  +csmul(mgs)
      pccid(mgs) =   &
     &   il5(mgs)*(-cscni(mgs) - cscnvi(mgs) & ! - cwaci(mgs)   &
     &  -craci(mgs)    &
     &  -csaci(mgs)   &
     &  -chaci(mgs) - chlaci(mgs)   &
     &  -chcni(mgs))   &
     &  +il5(mgs)*cisbv(mgs)   &
     &  -(1.-il5(mgs))*cimlr(mgs)

      pccin(mgs) = ciint(mgs)
      end do
      ELSEIF ( warmonly < 0.8 ) THEN
      do mgs = 1,ngscnt
      
!      qiint(mgs) = 0.0
!      cicint(mgs) = 0.0
!      qicicnt(mgs) = 0.0
      
      pccii(mgs) =   &
     &   il5(mgs)*cicint(mgs)  &
     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
     &  +cicichr(mgs))   &
     &  +chmul1(mgs)   &
     &  +chlmul1(mgs)    &
     &  + csplinter(mgs) + csplinter2(mgs)   &
     &  +csmul(mgs)
      pccid(mgs) =   &
!     &   il5(mgs)*(-cscni(mgs) - cscnvi(mgs) & ! - cwaci(mgs)   &
!     &  -craci(mgs)    &
!     &  -csaci(mgs)   &
!     &  -chaci(mgs) - chlaci(mgs)   &
!     &  -chcni(mgs))   &
     &  +il5(mgs)*cisbv(mgs)   &
     &  -(1.-il5(mgs))*cimlr(mgs)

      pccin(mgs) = ciint(mgs)

      end do
      ENDIF ! warmonly

      
!      ENDIF ! ( ipconc .ge. 1 )
!
!  Cloud water
!
      IF ( ipconc .ge. 2 ) THEN
      
      do mgs = 1,ngscnt
      pccwi(mgs) =  (0.0) ! + (1-il5(mgs))*(-cirmlw(mgs))
      
      IF ( warmonly < 0.5 ) THEN
      pccwd(mgs) =    &
     &  - cautn(mgs) +   &
     &  il5(mgs)*(-ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
     &   )   &
     &  -cracw(mgs) -csacw(mgs)  -chacw(mgs) - chlacw(mgs)
      ELSEIF ( warmonly < 0.8 ) THEN
      pccwd(mgs) =    &
     &  - cautn(mgs) +   &
     &  il5(mgs)*(  &
     & -ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
     &   )   &
     &  -cracw(mgs) -chacw(mgs) -chlacw(mgs) 
      ELSE
      
!       tmp3d(igs(mgs),jy,kgs(mgs)) = crcnw(mgs)

!       cracw(mgs) = 0.0 ! turn off accretion
!       qracw(mgs) = 0.0
!       crcev(mgs) = 0.0 ! turn off evap
!       qrcev(mgs) = 0.0 ! turn off evap
!       cracr(mgs) = 0.0 ! turn off self collection
       
       
!       cautn(mgs) = 0.0 
!       crcnw(mgs) = 0.0
!       qrcnw(mgs) = 0.0

      pccwd(mgs) =    &
     &  - cautn(mgs) -cracw(mgs)
      ENDIF


      IF ( -pccwd(mgs)*dtp .gt. cx(mgs,lc) ) THEN
!       write(0,*) 'OUCH! pccwd(mgs)*dtp .gt. ccw(mgs) ',pccwd(mgs),cx(mgs,lc)
!       write(0,*) 'qc = ',qx(mgs,lc)
!       write(0,*) -ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)-cwfrzc(mgs)-cwctfzc(mgs)
!       write(0,*)  -cracw(mgs) -csacw(mgs)  -chacw(mgs)
!       write(0,*) - cautn(mgs)

       frac = -cx(mgs,lc)/(pccwd(mgs)*dtp)
       pccwd(mgs) = -cx(mgs,lc)/dtp

        ciacw(mgs)   = frac*ciacw(mgs)
        cwfrzp(mgs)  = frac*cwfrzp(mgs)
        cwctfzp(mgs) = frac*cwctfzp(mgs)
        cwfrzc(mgs)  = frac*cwfrzc(mgs)
        cwctfzc(mgs) = frac*cwctfzc(mgs)
        cwctfz(mgs) = frac*cwctfz(mgs)
        cracw(mgs)   = frac*cracw(mgs)
        csacw(mgs)   = frac*csacw(mgs)
        chacw(mgs)   = frac*chacw(mgs)
        cautn(mgs)   = frac*cautn(mgs)
       
        pccii(mgs) = pccii(mgs) - (1.-frac)*il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs))
        IF ( lhl .gt. 1 ) chlacw(mgs)   = frac*chlacw(mgs)

!       STOP
      ENDIF

      end do

      ENDIF ! ipconc

!
!  Rain
!
      IF ( ipconc .ge. 3 ) THEN

      do mgs = 1,ngscnt

      IF ( warmonly < 0.5 ) THEN
      pcrwi(mgs) = &
!     >   cracw(mgs) +    &
     &   crcnw(mgs)   &
     &  +(1-il5(mgs))*(   &
     &    -chmlrr(mgs)/rzxh(mgs)   &
     &    -chlmlrr(mgs)/rzxhl(mgs)   &
     &    -csmlr(mgs)/rzxs(mgs)     &
     &   - cimlr(mgs) )   &
     &  -crshr(mgs)             !null at this point when wet snow/graupel included
      pcrwd(mgs) =   &
     &   il5(mgs)*(-ciacr(mgs) - crfrz(mgs) ) & ! - cipacr(mgs))
!     >  -csacr(mgs)   &
     &  - chacr(mgs) - chlacr(mgs)   &
     &  +crcev(mgs)   &
     &  - cracr(mgs)
!     >  -il5(mgs)*ciracr(mgs)
      ELSEIF ( warmonly < 0.8 ) THEN
       pcrwi(mgs) = &
     &   crcnw(mgs)   &
     &  +(1-il5(mgs))*(   &
     &    -chmlrr(mgs)/rzxh(mgs)    &
     &    -chlmlrr(mgs)/rzxhl(mgs)   &
     &    -csmlr(mgs)     &
     &   - cimlr(mgs) )   &
     &  -crshr(mgs)             !null at this point when wet snow/graupel included
      pcrwd(mgs) =   &
     &   il5(mgs)*( - crfrz(mgs) ) & ! - cipacr(mgs))
     &  - chacr(mgs)    &
     &  - chlacr(mgs)    &
     &  +crcev(mgs)   &
     &  - cracr(mgs)
      ELSE
      pcrwi(mgs) =   &
     &   crcnw(mgs)
      pcrwd(mgs) =   &
     &  +crcev(mgs)   &
     &  - cracr(mgs)

!        tmp3d(igs(mgs),jy,kgs(mgs)) = vtxbar(mgs,lr,1) ! crcnw(mgs) ! (pcrwi(mgs) + pcrwd(mgs))
!        pcrwi(mgs) = 0.0
!        pcrwd(mgs) = 0.0
!        qrcnw(mgs) = 0.0

      ENDIF


      frac = 0.0
      IF ( -pcrwd(mgs)*dtp .gt. cx(mgs,lr) ) THEN
!       write(0,*) 'OUCH! pcrwd(mgs)*dtp .gt. crw(mgs) ',pcrwd(mgs)*dtp,cx(mgs,lr),mgs,igs(mgs),kgs(mgs)
!       write(0,*) -ciacr(mgs)
!       write(0,*) -crfrz(mgs)
!       write(0,*) -chacr(mgs)
!       write(0,*)  crcev(mgs)
!       write(0,*)  -cracr(mgs)

       frac =  -cx(mgs,lr)/(pcrwd(mgs)*dtp)
       pcrwd(mgs) = -cx(mgs,lr)/dtp

        ciacr(mgs) = frac*ciacr(mgs)
        ciacrf(mgs) = frac*ciacrf(mgs)
        ciacrs(mgs) = frac*ciacrs(mgs)
        crfrz(mgs) = frac*crfrz(mgs)
        crfrzf(mgs) = frac*crfrzf(mgs)
        crfrzs(mgs) = frac*crfrzs(mgs)
        chacr(mgs) = frac*chacr(mgs)
        crcev(mgs) = frac*crcev(mgs)
        cracr(mgs) = frac*cracr(mgs)

!       STOP
      ENDIF

      end do

      ENDIF


      IF ( warmonly < 0.5 ) THEN

!
!  Snow
!
      IF ( ipconc .ge. 4 ) THEN !

      do mgs = 1,ngscnt
      pcswi(mgs) =   &
     &   il5(mgs)*(cscnis(mgs) + cscnvis(mgs) )    &
     &  + ifrzs*crfrzs(mgs) &
     &  + ifrzs*ciacrs(mgs) &
     &  + cscnh(mgs)
      pcswd(mgs) = &
!     :  cracs(mgs)     &
     &  -chacs(mgs) - chlacs(mgs)   &
     &  -chcns(mgs)   &
     &  +(1-il5(mgs))*csmlr(mgs) + csshr(mgs) & ! + csshrp(mgs)
!     >  +il5(mgs)*(cssbv(mgs))   &
     &   + cssbv(mgs)   &
     &  - csacs(mgs)

      frac = 0.0
      IF ( imixedphase == 0 ) THEN
        IF ( cx(mgs,ls) + dtp*(pcswi(mgs) + pcswd(mgs)) < 0.0 ) THEN
         frac = (-cx(mgs,ls) + pcswi(mgs)*dtp)/(pcswd(mgs)*dtp)
         
           pqswd(mgs) = frac*pqswd(mgs)
           
           chacs(mgs)  = frac*chacs(mgs) 
           chlacs(mgs) = frac*chlacs(mgs)
           chcns(mgs)  = frac*chcns(mgs) 
           csmlr(mgs)  = frac*csmlr(mgs) 
           csshr(mgs)  = frac*csshr(mgs) 
           cssbv(mgs)  = frac*cssbv(mgs) 
           csacs(mgs)  = frac*csacs(mgs)
      
        ENDIF
      ENDIF


      pccii(mgs) =  pccii(mgs) &
     &  + (1. - ifrzs)*crfrzs(mgs) &
     &  + (1. - ifrzs)*ciacrs(mgs)

      end do

      ENDIF

!
!  Graupel
!
      IF ( ipconc .ge. 5 ) THEN !
      do mgs = 1,ngscnt
      pchwi(mgs) =   &
     &  +ifrzg*(crfrzf(mgs)   &
     & +il5(mgs)*(ciacrf(mgs) ))    &
     & + chcnsh(mgs) + chcnih(mgs) + chcnhl(mgs)

      pchwd(mgs) =   &
     &  (1-il5(mgs))*chmlr(mgs) &
!     >  + il5(mgs)*chsbv(mgs)   &
     &  + chsbv(mgs)   &
     &  - il5(mgs)*chlcnh(mgs) &
     &  - cscnh(mgs)
      end do
!

!
!  Hail
!
      IF ( lhl .gt. 1 ) THEN !
      do mgs = 1,ngscnt
      pchli(mgs) = (1.0-ifrzg)*(crfrzf(mgs) +il5(mgs)*(ciacrf(mgs) ))  &
     & + chlcnh(mgs) *rzxhlh(mgs)

      pchld(mgs) =   &
     &  (1-il5(mgs))*chlmlr(mgs)   &
!     >  + il5(mgs)*chlsbv(mgs)   &
     &  + chlsbv(mgs) - chcnhl(mgs)
      
!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
!       write(0,*) 'dr: pchli,pchld = ', pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
!      ENDIF
      end do
      
      ENDIF
!

      ENDIF ! (ipconc .ge. 5 )

      ELSEIF ( warmonly < 0.8 ) THEN

!
!  Graupel
!
      IF ( ipconc .ge. 5 ) THEN !
      do mgs = 1,ngscnt
      pchwi(mgs) =   &
     &  +ifrzg*(crfrzf(mgs) )

      pchwd(mgs) =   &
     &  (1-il5(mgs))*chmlr(mgs) &
     &  - il5(mgs)*chlcnh(mgs)
      end do
!
!  Hail
!
      IF ( lhl .gt. 1 ) THEN !
      do mgs = 1,ngscnt
      pchli(mgs) = (1.0-ifrzg)*(crfrzf(mgs) +il5(mgs)*(ciacrf(mgs) ))  &
     & + chlcnh(mgs) *rzxhl(mgs)/rzxh(mgs)

      pchld(mgs) =   &
     &  (1-il5(mgs))*chlmlr(mgs) !  &
!     >  + il5(mgs)*chlsbv(mgs)   &
!     &  + chlsbv(mgs)

!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
!       write(0,*) 'dr: pchli,pchld = ', pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
!      ENDIF
      end do

      ENDIF

      ENDIF ! ipconc >= 5

      ENDIF ! warmonly

!

!
!  Balance and checks for continuity.....within machine precision...
!
      do mgs = 1,ngscnt
      pctot(mgs)   = pccwi(mgs) +pccwd(mgs) +   &
     &               pccii(mgs) +pccid(mgs) +   &
     &               pcrwi(mgs) +pcrwd(mgs) +   &
     &               pcswi(mgs) +pcswd(mgs) +   &
     &               pchwi(mgs) +pchwd(mgs) +   &
     &               pchli(mgs) +pchld(mgs)
      end do
!
!
      ENDIF ! ( ipconc .ge. 1 )
!
!
!
!
!
!  GOGO
!  production terms for mass
!
!
       pqwvi(:) = 0.0
       pqwvd(:) = 0.0
       pqcwi(:) = 0.0
       pqcwd(:) = 0.0
       pqcii(:) = 0.0
       pqcid(:) = 0.0
       pqrwi(:) = 0.0
       pqrwd(:) = 0.0
       pqswi(:) = 0.0
       pqswd(:) = 0.0
       pqhwi(:) = 0.0
       pqhwd(:) = 0.0
       pqhli(:) = 0.0
       pqhld(:) = 0.0
       pqlwsi(:) = 0.0
       pqlwsd(:) = 0.0
       pqlwhi(:) = 0.0
       pqlwhd(:) = 0.0
       pqlwhli(:) = 0.0
       pqlwhld(:) = 0.0
!
!  Vapor
!
      IF ( warmonly < 0.5 ) THEN
      do mgs = 1,ngscnt
      pqwvi(mgs) =    &
     &  -Min(0.0, qrcev(mgs))   &
     &  -Min(0.0, qhcev(mgs))   &
     &  -Min(0.0, qhlcev(mgs))   &
     &  -Min(0.0, qscev(mgs))   &
!     >  +il5(mgs)*(-qhsbv(mgs) - qhlsbv(mgs) )   &
     &  -qhsbv(mgs) - qhlsbv(mgs)   &
     &  -qssbv(mgs)    &
     &  -il5(mgs)*qisbv(mgs)
      pqwvd(mgs) =     &
     &  -Max(0.0, qrcev(mgs))   &
     &  -Max(0.0, qhcev(mgs))   &
     &  -Max(0.0, qhlcev(mgs))   &
     &  -Max(0.0, qscev(mgs))   &
     &  +il5(mgs)*(-qiint(mgs)   &
     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
     &  -il5(mgs)*qidpv(mgs)
      end do

      ELSEIF ( warmonly < 0.8 ) THEN
      do mgs = 1,ngscnt
      pqwvi(mgs) =    &
     &  -Min(0.0, qrcev(mgs)) &
     &  -il5(mgs)*qisbv(mgs)
      pqwvd(mgs) =     &
     &  +il5(mgs)*(-qiint(mgs)   &
!     &  -qhdpv(mgs) ) & !- qhldpv(mgs))   &
     &  -qhdpv(mgs) - qhldpv(mgs))   &
!     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
     &  -Max(0.0, qrcev(mgs))     &
     &  -il5(mgs)*qidpv(mgs)
      end do

      ELSE
      do mgs = 1,ngscnt
      pqwvi(mgs) =    &
     &  -Min(0.0, qrcev(mgs))
      pqwvd(mgs) =     &
     &  -Max(0.0, qrcev(mgs))
      end do

      ENDIF ! warmonly
!
!  Cloud water
!
      do mgs = 1,ngscnt

      pqcwi(mgs) =  (0.0) + qwcnr(mgs)

      IF ( warmonly < 0.5 ) THEN
      pqcwd(mgs) =    &
     &  il5(mgs)*(-qiacw(mgs)-qwfrz(mgs)-qwctfz(mgs))   &
     &  -il5(mgs)*(qicichr(mgs))   &
     &  -qracw(mgs) -qsacw(mgs) -qrcnw(mgs) -qhacw(mgs) - qhlacw(mgs)  !&
!     &  -il5(mgs)*(qwfrzp(mgs))
      ELSEIF ( warmonly < 0.8 ) THEN
      pqcwd(mgs) =    &
     &  il5(mgs)*(-qiacw(mgs)-qwfrz(mgs)-qwctfz(mgs))   &
!     &  il5(mgs)*(-qwfrzc(mgs)-qwctfzc(mgs))   &
     &  -il5(mgs)*(qicichr(mgs))   &
     &  -qracw(mgs) -qrcnw(mgs) -qhacw(mgs) -qhlacw(mgs)
      ELSE
      pqcwd(mgs) =    &
     &  -qracw(mgs) - qrcnw(mgs)
      ENDIF

      IF ( pqcwd(mgs) .lt. 0.0 .and. -pqcwd(mgs)*dtp .gt. qx(mgs,lc) ) THEN

       frac = -Max(0.0,qx(mgs,lc))/(pqcwd(mgs)*dtp)
       pqcwd(mgs) = -qx(mgs,lc)/dtp

        qiacw(mgs)   = frac*qiacw(mgs)
!        qwfrzp(mgs)  = frac*qwfrzp(mgs)
!        qwctfzp(mgs) = frac*qwctfzp(mgs)
        qwfrzc(mgs)  = frac*qwfrzc(mgs)
        qwfrz(mgs)  = frac*qwfrz(mgs)
        qwctfzc(mgs) = frac*qwctfzc(mgs)
        qwctfz(mgs) = frac*qwctfz(mgs)
        qracw(mgs)   = frac*qracw(mgs)
        qsacw(mgs)   = frac*qsacw(mgs)
        qhacw(mgs)   = frac*qhacw(mgs)
        vhacw(mgs)   = frac*vhacw(mgs)
        qrcnw(mgs)   = frac*qrcnw(mgs)
        qwfrzp(mgs)  = frac*qwfrzp(mgs)
        IF ( lhl .gt. 1 ) THEN
          qhlacw(mgs)   = frac*qhlacw(mgs)
          vhlacw(mgs)   = frac*vhlacw(mgs)
        ENDIF
!        IF ( lzh .gt. 1 ) zhacw(mgs) = frac*zhacw(mgs)

!       STOP
      ENDIF
      

      end do
!
!  Cloud ice
!
      IF ( warmonly < 0.5 ) THEN

      do mgs = 1,ngscnt
      pqcii(mgs) =     &
     &   il5(mgs)*qicicnt(mgs)    &
     &  +il5(mgs)*qidpv(mgs)    &
     &  +il5(mgs)*qiacw(mgs)   & ! (qiacwi(mgs)+qwacii(mgs))   &
     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
     &  +il5(mgs)*(qicichr(mgs))   &
     &  +qsmul(mgs)               &
     &  +qhmul1(mgs) + qhlmul1(mgs)   &
     & + qsplinter(mgs) + qsplinter2(mgs)
!     > + cimas0*nsplinter*(crfrzf(mgs) + crfrz(mgs))/rho0(mgs)

      pqcid(mgs) =     &
     &   il5(mgs)*(-qscni(mgs) - qscnvi(mgs)    & ! -qwaci(mgs)    &
     &  -qraci(mgs)    &
     &  -qsaci(mgs) )   &
     &  -qhaci(mgs)   &
     &  -qhlaci(mgs)    &
     &  +il5(mgs)*qisbv(mgs)    &
     &  +(1.-il5(mgs))*qimlr(mgs)   &
     &  - qhcni(mgs)
      end do

      ELSEIF ( warmonly < 0.8 ) THEN

      do mgs = 1,ngscnt
      pqcii(mgs) =     &
     &   il5(mgs)*qicicnt(mgs)     &
     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
!     &  +il5(mgs)*(qicichr(mgs))   &
!     &  +qsmul(mgs)               &
     &  +qhmul1(mgs) + qhlmul1(mgs)   &
     & + qsplinter(mgs) + qsplinter2(mgs) &
     &  +il5(mgs)*qidpv(mgs)    &
     &  +il5(mgs)*qiacw(mgs)  ! & ! (qiacwi(mgs)+qwacii(mgs))   &
!     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
!     &  +il5(mgs)*(qicichr(mgs))   &
!     &  +qsmul(mgs)               &
!     &  +qhmul1(mgs) + qhlmul1(mgs)   &
!     & + qsplinter(mgs) + qsplinter2(mgs)

      pqcid(mgs) =     &
!     &   il5(mgs)*(-qscni(mgs) - qscnvi(mgs)    & ! -qwaci(mgs)    &
!     &  -qraci(mgs)    &
!     &  -qsaci(mgs) )   &
!     &  -qhaci(mgs)   &
!     &  -qhlaci(mgs)    &
     &  +il5(mgs)*qisbv(mgs)    &
     &  +(1.-il5(mgs))*qimlr(mgs)  ! &
!     &  - qhcni(mgs)
      end do

      ENDIF
!
!  Rain
!

      do mgs = 1,ngscnt
      IF ( warmonly < 0.5 ) THEN
      pqrwi(mgs) =     &
     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))   &
     &  +(1-il5(mgs))*(   &
     &    -qhmlr(mgs)                 &            !null at this point when wet snow/graupel included
     &    -qsmlr(mgs)  - qhlmlr(mgs)     &
     &    -qimlr(mgs))   &
     &    -qsshr(mgs)       &                      !null at this point when wet snow/graupel included
     &    -qhshr(mgs)       &                      !null at this point when wet snow/graupel included
     &    -qhlshr(mgs)
      pqrwd(mgs) =     &
     &  il5(mgs)*(-qiacr(mgs)-qrfrz(mgs))    &
     &  - qsacr(mgs) - qhacr(mgs) - qhlacr(mgs) - qwcnr(mgs)   &
     &  + Min(0.0,qrcev(mgs))
      ELSEIF ( warmonly < 0.8 ) THEN
      pqrwi(mgs) =     &
     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))   &
     &  +(1-il5(mgs))*(   &
     &    -qhmlr(mgs)                 &            !null at this point when wet snow/graupel included
     &    -qhshr(mgs)                 &           !null at this point when wet snow/graupel included
     &    -qhlmlr(mgs)                 &            !null at this point when wet snow/graupel included
     &    -qhlshr(mgs) )                           !null at this point when wet snow/graupel included
      pqrwd(mgs) =     &
     &  il5(mgs)*(-qrfrz(mgs))    &
     &   - qhacr(mgs)    &
     &   - qhlacr(mgs)    &
     &  + Min(0.0,qrcev(mgs))
      ELSE
      pqrwi(mgs) =     &
     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))
      pqrwd(mgs) =  Min(0.0,qrcev(mgs))
      ENDIF ! warmonly


 !      IF ( pqrwd(mgs) .lt. 0.0 .and. -(pqrwd(mgs) + pqrwi(mgs))*dtp .gt. qx(mgs,lr)  ) THEN
      IF ( pqrwd(mgs) .lt. 0.0 .and. -(pqrwd(mgs) + pqrwi(mgs))*dtp .gt. qx(mgs,lr)  ) THEN

       frac = (-qx(mgs,lr) + pqrwi(mgs)*dtp)/(pqrwd(mgs)*dtp)
!       pqrwd(mgs) = -qx(mgs,lr)/dtp  + pqrwi(mgs)

       pqwvi(mgs) = pqwvi(mgs)    &
     &  + Min(0.0, qrcev(mgs))   &
     &  - frac*Min(0.0, qrcev(mgs))
       pqwvd(mgs) =  pqwvd(mgs)   &
     &  + Max(0.0, qrcev(mgs))   &
     &  - frac*Max(0.0, qrcev(mgs))

       qiacr(mgs)  = frac*qiacr(mgs)
       qiacrf(mgs) = frac*qiacrf(mgs)
       qiacrs(mgs) = frac*qiacrs(mgs)
       viacrf(mgs) = frac*viacrf(mgs)
       qrfrz(mgs)  = frac*qrfrz(mgs) 
       qrfrzs(mgs) = frac*qrfrzs(mgs) 
       qrfrzf(mgs) = frac*qrfrzf(mgs)
       vrfrzf(mgs) = frac*vrfrzf(mgs)
       qsacr(mgs)  = frac*qsacr(mgs)
       qhacr(mgs)  = frac*qhacr(mgs)
       vhacr(mgs)  = frac*vhacr(mgs)
       qrcev(mgs)  = frac*qrcev(mgs)
       qhlacr(mgs) = frac*qhlacr(mgs)
       vhlacr(mgs) = frac*vhlacr(mgs)
!       qhcev(mgs)  = frac*qhcev(mgs)


      IF ( warmonly < 0.5 ) THEN
       pqrwd(mgs) =     &
     &  il5(mgs)*(-qiacr(mgs)-qrfrz(mgs) - qsacr(mgs))    &
     &  - qhacr(mgs) - qhlacr(mgs) - qwcnr(mgs)   &
     &  + Min(0.0,qrcev(mgs))
      ELSEIF ( warmonly < 0.8 ) THEN
      pqrwd(mgs) =     &
     &  il5(mgs)*(-qrfrz(mgs))    &
     &   - qhacr(mgs)    &
     &   - qhlacr(mgs)    &
     &  + Min(0.0,qrcev(mgs))
      ELSE
       pqrwd(mgs) =  Min(0.0,qrcev(mgs))
      ENDIF ! warmonly

!
! Resum for vapor since qrcev has changed
!
      IF ( qrcev(mgs) .ne. 0.0 ) THEN
       pqwvi(mgs) =    &
     &  -Min(0.0, qrcev(mgs))   &
     &  -Min(0.0, qhcev(mgs))   &
     &  -Min(0.0, qhlcev(mgs))   &
     &  -Min(0.0, qscev(mgs))   &
!     >  +il5(mgs)*(-qhsbv(mgs)  - qhlsbv(mgs) )   &
     &  -qhsbv(mgs)  - qhlsbv(mgs)   &
     &  -qssbv(mgs)    &
     &  -il5(mgs)*qisbv(mgs)
       pqwvd(mgs) =     &
     &  -Max(0.0, qrcev(mgs))   &
     &  -Max(0.0, qhcev(mgs))   &
     &  -Max(0.0, qhlcev(mgs))   &
     &  -Max(0.0, qscev(mgs))   &
     &  +il5(mgs)*(-qiint(mgs)   &
     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
     &  -il5(mgs)*qidpv(mgs)
       ENDIF


!       STOP
      ENDIF
      end do

      IF ( warmonly < 0.5 ) THEN

!
!  Snow
!
      do mgs = 1,ngscnt
      pqswi(mgs) =     &
     &   il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
     &   + qscnvi(mgs)                        &
     &   + ifrzs*(qiacrs(mgs) + qrfrzs(mgs))  &
     &   + il2(mgs)*qsacr(mgs))   &
     &   + il3(mgs)*(qiacrf(mgs)+qracif(mgs)) &
     &   + Max(0.0, qscev(mgs))   &
     &   + qsacw(mgs) + qscnh(mgs)
      pqswd(mgs) =    &
!     >  -qfacs(mgs) ! -qwacs(mgs)   &
     &  -qracs(mgs)*(1-il2(mgs)) -qhacs(mgs) - qhlacs(mgs)   &
     &  -qhcns(mgs)   &
     &  +(1-il5(mgs))*qsmlr(mgs) + qsshr(mgs)    &    !null at this point when wet snow included
!     >  +il5(mgs)*(qssbv(mgs))   &
     &  + (qssbv(mgs))   &
     &  + Min(0.0, qscev(mgs))  &
     &  -qsmul(mgs)
      
      
      IF ( imixedphase == 0 .and. pqswd(mgs) .lt. 0.0  ) THEN
        IF ( qx(mgs,ls) + dtp*(pqswi(mgs) + pqswd(mgs)) < 0.0 ) THEN
         frac = (-qx(mgs,ls) + pqswi(mgs)*dtp)/(pqswd(mgs)*dtp)
         
           pqswd(mgs) = frac*pqswd(mgs)
           
           qracs(mgs)  = frac*qracs(mgs) ! only used for single moment at this time
           qhacs(mgs)  = frac*qhacs(mgs) 
           qhlacs(mgs) = frac*qhlacs(mgs)
           qhcns(mgs)  = frac*qhcns(mgs) 
           qsmlr(mgs)  = frac*qsmlr(mgs) 
           qsshr(mgs)  = frac*qsshr(mgs) 
           qssbv(mgs)  = frac*qssbv(mgs) 
           qsmul(mgs)  = frac*qsmul(mgs) 
           IF ( qscev(mgs) < 0.0 ) qscev(mgs) = frac*qscev(mgs)

        ENDIF
      ENDIF
      
      pqcii(mgs) =  pqcii(mgs) &
     &  + (1. - ifrzs)*qrfrzs(mgs) &
     &  + (1. - ifrzs)*qiacrs(mgs)
      
      end do 
      
!
!  Graupel
!
      do mgs = 1,ngscnt
      pqhwi(mgs) =    &
     &  +il5(mgs)*ifrzg*(qrfrzf(mgs)  + (1-il3(mgs))*(qiacrf(mgs)+qracif(mgs)))   &
     &  + (1-il2(mgs))*(qracs(mgs) + qsacr(mgs))  &
     &  +il5(mgs)*(qhdpv(mgs))   &
     &  +Max(0.0, qhcev(mgs))   &
     &  +qhacr(mgs)+qhacw(mgs)   &
     &  +qhacs(mgs)+qhaci(mgs)   &
     &  + qhcns(mgs) + qhcni(mgs) + qhcnhl(mgs)
      pqhwd(mgs) =     &
     &   qhshr(mgs)                &    !null at this point when wet graupel included
     &  +(1-il5(mgs))*qhmlr(mgs)   &    !null at this point when wet graupel included
!     >  +il5(mgs)*qhsbv(mgs)   &
     &  + qhsbv(mgs)   &
     &  + Min(0.0, qhcev(mgs))   &
     &  -qhmul1(mgs) - qhlcnh(mgs) - qscnh(mgs)  &
     &  - qsplinter(mgs) - qsplinter2(mgs)
!     > - cimas0*nsplinter*(crfrzf(mgs) + crfrz(mgs))/rho0(mgs)
      end do

!
!  Hail
!
      IF ( lhl .gt. 1 ) THEN

      do mgs = 1,ngscnt
      pqhli(mgs) =    &
     &  +il5(mgs)*(qhldpv(mgs) + (1.0-ifrzg)*(qiacrf(mgs)+qrfrzf(mgs)  + qracif(mgs)))   &
     &  +Max(0.0, qhlcev(mgs))   &
     &  +qhlacr(mgs)+qhlacw(mgs)   &
     &  +qhlacs(mgs)+qhlaci(mgs)   &
     &  + qhlcnh(mgs)
      pqhld(mgs) =     &
     &   qhlshr(mgs)    &
     &  +(1-il5(mgs))*qhlmlr(mgs)    &
!     >  +il5(mgs)*qhlsbv(mgs)   &
     &  + qhlsbv(mgs)   &
     &  + Min(0.0, qhlcev(mgs))   &
     &  -qhlmul1(mgs) - qhcnhl(mgs)
      end do
      
      ENDIF ! lhl

      ELSEIF ( warmonly < 0.8 ) THEN
!
!  Graupel
!
      do mgs = 1,ngscnt
      pqhwi(mgs) =    &
     &  +il5(mgs)*ifrzg*(qrfrzf(mgs) )   &
     &  +il5(mgs)*(qhdpv(mgs))   &
     &  +qhacr(mgs)+qhacw(mgs)   
      pqhwd(mgs) =     &
     &   qhshr(mgs)                &    !null at this point when wet graupel included
     &  - qhlcnh(mgs)   &
     &  - qhmul1(mgs)   &
     &  - qsplinter(mgs) - qsplinter2(mgs) &
     &  +(1-il5(mgs))*qhmlr(mgs)        !null at this point when wet graupel included
       end do

!
!  Hail
!
      IF ( lhl .gt. 1 ) THEN

      do mgs = 1,ngscnt
      pqhli(mgs) =    &
     &  +il5(mgs)*(qhldpv(mgs) ) & ! + (1.0-ifrzg)*(qiacrf(mgs)+qrfrzf(mgs)  + qracif(mgs)))   &
     &  +qhlacr(mgs)+qhlacw(mgs)   &
!     &  +qhlacs(mgs)+qhlaci(mgs)   &
     &  + qhlcnh(mgs)
      pqhld(mgs) =     &
     &   qhlshr(mgs)    &
     &  +(1-il5(mgs))*qhlmlr(mgs)    &
!     >  +il5(mgs)*qhlsbv(mgs)   &
     &  + qhlsbv(mgs)   &
     &  -qhlmul1(mgs) - qhcnhl(mgs)

      end do

      ENDIF ! lhl

      ENDIF ! warmonly

!
!  Liquid water on snow and graupel
!

      vhmlr(:) = 0.0
      vhlmlr(:) = 0.0
      vhfzh(:) = 0.0
      vhlfzhl(:) = 0.0

      IF ( mixedphase ) THEN
      ELSE ! set arrays for non-mixedphase graupel
      
!        vhshdr(:) = 0.0
        vhmlr(:) = qhmlr(:) ! not actually volume, but treated as q in rate equation
!        vhsoak(:) = 0.0

!        vhlshdr(:) = 0.0
        vhlmlr(:) = qhlmlr(:) ! not actually volume, but treated as q in rate equation
!        vhlmlr(:) = rho0(:)*qhlmlr(:)/xdn(:,lhl) 
!        vhlsoak(:) = 0.0
      
      ENDIF  ! mixedphase



!
!  Snow volume
!
      IF ( lvol(ls) .gt. 1 ) THEN
      do mgs = 1,ngscnt
!      pvswi(mgs) = rho0(mgs)*( pqswi(mgs) )/xdn0(ls)

      pvswi(mgs) = rho0(mgs)*(    &
!aps     >   il5*qsfzs(mgs)/xdn(mgs,ls)   &
!aps     >  -il5*qsfzs(mgs)/xdn(mgs,lr)   &
     &  +il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
     &   + qscnvi(mgs) + (1. - ifrzs)*qiacrs(mgs) &
     &   + (1. - ifrzs)*qrfrzs(mgs)  &
     &  )/xdn0(ls)   &
     &    + (qsacr(mgs))/rimdn(mgs,ls) ) + vsacw(mgs)
!     >   + (qsacw(mgs) + qsacr(mgs))/rimdn(mgs,ls) )
      pvswd(mgs) = rho0(mgs)*( pqswd(mgs) )/xdn0(ls)  &
!     >  -qhacs(mgs)
!     >  -qhcns(mgs)
!     >  +(1-il5(mgs))*qsmlr(mgs) + qsshr(mgs)
!     >  +il5(mgs)*(qssbv(mgs))
     &   -rho0(mgs)*qsmul(mgs)/xdn0(ls)
!aps     >   +rho0(mgs)*(1-il5(mgs))*(
!aps     >             qsmlr(mgs)/xdn(mgs,ls)
!aps     >    +(qscev-qsmlr(mgs))/xdn(mgs,lr) )
      end do

!aps      IF (mixedphase) THEN
!aps        pvswd(mgs) = pvswd(mgs)
!aps     >   + rho0(mgs)*qsshr(mgs)/xdn(mgs,lr)
!aps      ENDIF

      ENDIF
!
!  Graupel volume
!
      IF ( lvol(lh) .gt. 1 ) THEN
      DO mgs = 1,ngscnt
!      pvhwi(mgs) = rho0(mgs)*( (pqhwi(mgs) )/xdn0(lh) )

!      pvhwi(mgs) = rho0(mgs)*( (pqhwi(mgs) - il5(mgs)*qrfrzf(mgs) )/xdn0(lh) !
!     :  +  il5(mgs)*qrfrzf(mgs)/rhofrz )

      pvhwi(mgs) = rho0(mgs)*(   &
     &  +il5(mgs)*( qracif(mgs))/rhofrz   &
!erm     >  + il5(mgs)*qhfzh(mgs)/rhofrz !aps: or use xdnmx(lh)?   &
     &  + (  il5(mgs)*qhdpv(mgs)   &
     &     + qhacs(mgs) + qhaci(mgs) )/xdnmn(lh) )   &
     &  +   rho0(mgs)*Max(0.0, qhcev(mgs))/1000.   & ! only used in mixed phase: evaporation of liquid water coating
!     >     + qhacs(mgs) + qhaci(mgs) )/xdn0(ls) )   &
     &  + vhcns(mgs)   &
     &  + vhacr(mgs) + vhacw(mgs)  + vhfzh(mgs)   & ! qhacw(mgs)/rimdn(mgs,lh)
!     >  + vhfrh(mgs)   &
     &  + vhcni(mgs) + ifrzg*(viacrf(mgs) + vrfrzf(mgs))
!     >  +qhacr(mgs)/raindn(mgs,lh) + qhacw(mgs)/rimdn(mgs,lh)
      
!      pvhwd(mgs) = rho0(mgs)*(pqhwd(mgs) )/xdn0(lh)

      pvhwd(mgs) = rho0(mgs)*(   &
!     >   qhshr(mgs)/xdn0(lr)   &
!     >  - il5(mgs)*qhfzh(mgs)/xdn(mgs,lr)   &
     &  +( (1-il5(mgs))*vhmlr(mgs)    &
!     >     +il5(mgs)*qhsbv(mgs)   &
     &     + qhsbv(mgs)   &
     &     + Min(0.0, qhcev(mgs))   &
     &     -qhmul1(mgs) )/xdn(mgs,lh) )   &
     &  - vhlcnh(mgs) + vhshdr(mgs) - vhsoak(mgs) - vscnh(mgs)

!      IF (mixedphase) THEN
!       pvhwd(mgs) = pvhwd(mgs) 
!     >  + rho0(mgs)*qhshr(mgs)/xdn(mgs,lh) !xdn(mgs,lr)
!      ENDIF

      IF ( .false. .and. ny .eq. 2 .and. kgs(mgs) .eq. 9 .and. igs(mgs) .eq. 19 ) THEN

      write(iunit,*)
      write(iunit,*)   'Graupel at ',igs(mgs),kgs(mgs)
!
      write(iunit,*)   il5(mgs)*qrfrzf(mgs), qrfrzf(mgs) - qrfrz(mgs)
      write(iunit,*)   il5(mgs)*qiacrf(mgs)
      write(iunit,*)   il5(mgs)*qracif(mgs)
      write(iunit,*)   'qhcns',qhcns(mgs)
      write(iunit,*)   'qhcni',qhcni(mgs)
      write(iunit,*)   il5(mgs)*(qhdpv(mgs))
      write(iunit,*)   'qhacr ',qhacr(mgs)
      write(iunit,*)   'qhacw', qhacw(mgs)
      write(iunit,*)   'qhacs', qhacs(mgs)
      write(iunit,*)   'qhaci', qhaci(mgs)
      write(iunit,*)   'pqhwi = ',pqhwi(mgs)
      write(iunit,*)
      write(iunit,*) 'qhcev',qhcev(mgs)
      write(iunit,*)
      write(iunit,*)   'qhshr',qhshr(mgs)
      write(iunit,*)  'qhmlr', (1-il5(mgs))*qhmlr(mgs)
      write(iunit,*)   'qhsbv', qhsbv(mgs)
      write(iunit,*)   'qhlcnh',-qhlcnh(mgs)
      write(iunit,*)   'qhmul1',-qhmul1(mgs)
      write(iunit,*)   'pqhwd = ', pqhwd(mgs)
      write(iunit,*)
      write(iunit,*)  'Volume'
      write(iunit,*)
      write(iunit,*)  'pvhwi',pvhwi(mgs)
      write(iunit,*)   'vhcns', vhcns(mgs)
      write(iunit,*)  'vhacr,vhacw',vhacr(mgs), vhacw(mgs) ! qhacw(mgs)/rimdn(mgs,lh)
      write(iunit,*)  'vhcni',vhcni(mgs)
      write(iunit,*)
      write(iunit,*)  'pvhwd',pvhwd(mgs)
      write(iunit,*)  'vhlcnh,vhshdr,vhsoak ', vhlcnh(mgs),  vhshdr(mgs), vhsoak(mgs)
      write(iunit,*)  'vhmlr', vhmlr(mgs)
      write(iunit,*)
!      write(iunit,*)
!      write(iunit,*)
!      write(iunit,*)
      write(iunit,*)  'Concentration'
      write(iunit,*)   pchwi(mgs),pchwd(mgs)
      write(iunit,*)  crfrzf(mgs)
      write(iunit,*)  chcns(mgs)
      write(iunit,*)  ciacrf(mgs)


      ENDIF


      ENDDO

      ENDIF
!
!
!

!
!  Hail volume
!
      IF ( lhl .gt. 1 ) THEN
      IF ( lvol(lhl) .gt. 1 ) THEN
      DO mgs = 1,ngscnt

      pvhli(mgs) = rho0(mgs)*(   &
     &  + (  il5(mgs)*qhldpv(mgs)   &
!     &  +    Max(0.0, qhlcev(mgs))   &
!     &     + qhlacs(mgs) + qhlaci(mgs) )/xdnmn(lhl) )   & ! xdn0(ls) )   &
     &     + qhlacs(mgs) + qhlaci(mgs) )/xdnmn(lh) )   &  ! yes, this is 'lh' on purpose
     &  +   rho0(mgs)*Max(0.0, qhlcev(mgs))/1000.   &
     &  + vhlcnhl(mgs) + (1.0-ifrzg)*(viacrf(mgs) + vrfrzf(mgs))  & 
     &  + vhlacr(mgs) + vhlacw(mgs) + vhlfzhl(mgs) ! qhlacw(mgs)/rimdn(mgs,lhl)
      
      pvhld(mgs) = rho0(mgs)*(   &
     &  +(  qhlsbv(mgs)   &
     &     + Min(0.0, qhlcev(mgs))   &
     &     -qhlmul1(mgs) )/xdn(mgs,lhl) ) &
!     &   + vhlmlr(mgs)                    &
     &   + rho0(mgs)*(1-il5(mgs))*vhlmlr(mgs)/xdn(mgs,lhl)  &
     &   + vhlshdr(mgs) - vhlsoak(mgs)


      ENDDO
      
      ENDIF
      ENDIF


      if ( ndebug .ge. 1 ) then
      do mgs = 1,ngscnt
!
      ptotal(mgs) = 0.
      ptotal(mgs) = ptotal(mgs)    &
     &  + pqwvi(mgs) + pqwvd(mgs)   &
     &  + pqcwi(mgs) + pqcwd(mgs)   &
     &  + pqcii(mgs) + pqcid(mgs)   &
     &  + pqrwi(mgs) + pqrwd(mgs)   &
     &  + pqswi(mgs) + pqswd(mgs)   &
     &  + pqhwi(mgs) + pqhwd(mgs)   &
     &  + pqhli(mgs) + pqhld(mgs)
!

      if ( ( (ndebug .ge. 1  ) .and. abs(ptotal(mgs)) .gt. eqtot )   &
!      if ( (  abs(ptotal(mgs)) .gt. eqtot )
!     :    .or. pqswi(mgs)*dtp .gt. 1.e-3
!     :    .or. pqhwi(mgs)*dtp .gt. 1.e-3
!     :     .or. dtp*(pqrwi(mgs)+pqrwd(mgs)) .gt. 10.0e-3
!     :     .or. dtp*(pccii(mgs)+pccid(mgs)) .gt. 1.e7
!     :     .or. dtp*(pcipi(mgs)+pcipd(mgs)) .gt. 1.e7    &
     &  .or.  .not. (ptotal(mgs) .lt. 1.0 .and.   &
     &            ptotal(mgs) .gt. -1.0)    ) then
      write(iunit,*) 'YIKES! ','ptotal1',mgs,igs(mgs),jgs,   &
     &       kgs(mgs),ptotal(mgs)

      write(iunit,*) 't7: ', t7(igs(mgs),jgs,kgs(mgs))
      write(iunit,*)  'cci,ccw,crw,rdia: ',cx(mgs,li),cx(mgs,lc),cx(mgs,lr),0.5*xdia(mgs,lr,1)
      write(iunit,*)  'qc,qi,qr : ',qx(mgs,lc),qx(mgs,li),qx(mgs,lr)
      write(iunit,*)  'rmas, qrcalc : ',xmas(mgs,lr),xmas(mgs,lr)*cx(mgs,lr)/rho0(mgs)
      write(iunit,*)  'vti,vtc,eiw,vtr: ',vtxbar(mgs,li,1),vtxbar(mgs,lc,1),eiw(mgs),vtxbar(mgs,lr,1)
      write(iunit,*)  'cidia,cwdia,qcmxd: ', xdia(mgs,li,1),xdia(mgs,lc,1),qcmxd(mgs)
      write(iunit,*)  'snow: ',qx(mgs,ls),cx(mgs,ls),swvent(mgs),vtxbar(mgs,ls,1),xdia(mgs,ls,1)
      write(iunit,*)  'graupel: ',qx(mgs,lh),cx(mgs,lh),hwvent(mgs),vtxbar(mgs,lh,1),xdia(mgs,lh,1)
      IF ( lhl .gt. 1 ) write(iunit,*)  'hail: ',qx(mgs,lhl),cx(mgs,lhl),hlvent(mgs),vtxbar(mgs,lhl,1),xdia(mgs,lhl,1)


      write(iunit,*)  'li: ',xdia(mgs,li,1),xdia(mgs,li,2),xmas(mgs,li),qx(mgs,li),   &
     &         vtxbar(mgs,li,1)


      write(iunit,*)  'rain cx,xv : ',cx(mgs,lr),xv(mgs,lr)
      write(iunit,*)  'temcg = ', temcg(mgs)

      write(iunit,*)  pqwvi(mgs) ,pqwvd(mgs)
      write(iunit,*)  pqcwi(mgs) ,pqcwd(mgs)
      write(iunit,*)  pqcii(mgs) ,pqcid(mgs)
      write(iunit,*)  pqrwi(mgs) ,pqrwd(mgs)
      write(iunit,*)  pqswi(mgs) ,pqswd(mgs)
      write(iunit,*)  pqhwi(mgs) ,pqhwd(mgs)
      write(iunit,*)  pqhli(mgs) ,pqhld(mgs)
      write(iunit,*) 'END OF OUTPUT OF SOURCE AND SINK'

!
!  print production terms
!
      write(iunit,*)
      write(iunit,*)   'Vapor'
!
      write(iunit,*)   -Min(0.0,qrcev(mgs))
      write(iunit,*)   -il5(mgs)*qhsbv(mgs)
      write(iunit,*)   -il5(mgs)*qhlsbv(mgs)
      write(iunit,*)   -il5(mgs)*qssbv(mgs)
      write(iunit,*)   -il5(mgs)*qisbv(mgs)
      write(iunit,*)    'pqwvi= ', pqwvi(mgs)
      write(iunit,*)   -Max(0.0,qrcev(mgs))
      write(iunit,*)   -Max(0.0,qhcev(mgs))
      write(iunit,*)   -Max(0.0,qhlcev(mgs))
      write(iunit,*)   -Max(0.0,qscev(mgs))
      write(iunit,*)   -il5(mgs)*qiint(mgs)
      write(iunit,*)   -il5(mgs)*qhdpv(mgs)
      write(iunit,*)   -il5(mgs)*qhldpv(mgs)
      write(iunit,*)   -il5(mgs)*qsdpv(mgs)
      write(iunit,*)   -il5(mgs)*qidpv(mgs)
      write(iunit,*)    'pqwvd = ', pqwvd(mgs)
!
      write(iunit,*)
      write(iunit,*)   'Cloud ice'
!
      write(iunit,*)   il5(mgs)*qicicnt(mgs)
      write(iunit,*)   il5(mgs)*qidpv(mgs)
      write(iunit,*)   il5(mgs)*qiacw(mgs)
      write(iunit,*)   il5(mgs)*qwfrz(mgs)
      write(iunit,*)   il5(mgs)*qwctfz(mgs)
      write(iunit,*)   il5(mgs)*qicichr(mgs)
      write(iunit,*)   qhmul1(mgs)
      write(iunit,*)   qhlmul1(mgs)
      write(iunit,*)   'pqcii = ', pqcii(mgs)
      write(iunit,*)   -il5(mgs)*qscni(mgs)
      write(iunit,*)   -il5(mgs)*qscnvi(mgs)
      write(iunit,*)   -il5(mgs)*qraci(mgs)
      write(iunit,*)   -il5(mgs)*qsaci(mgs)
      write(iunit,*)   -il5(mgs)*qhaci(mgs)
      write(iunit,*)   -il5(mgs)*qhlaci(mgs)
      write(iunit,*)   il5(mgs)*qisbv(mgs)
      write(iunit,*)   (1.-il5(mgs))*qimlr(mgs)
      write(iunit,*)   -il5(mgs)*qhcni(mgs)
      write(iunit,*)   'pqcid = ', pqcid(mgs)
      write(iunit,*)   ' Conc:'
      write(iunit,*)   pccii(mgs),pccid(mgs)
      write(iunit,*)   il5(mgs),cicint(mgs)
      write(iunit,*)   cwacii(mgs),cwfrzc(mgs),cwctfzc(mgs)
      write(iunit,*)   cicichr(mgs)
      write(iunit,*)   chmul1(mgs)
      write(iunit,*)   chlmul1(mgs)
      write(iunit,*)   csmul(mgs)
!
!
!
!
      write(iunit,*)
      write(iunit,*)   'Cloud water'
!
      write(iunit,*)   'pqcwi =', pqcwi(mgs)
      write(iunit,*)   -il5(mgs)*qiacw(mgs)
      write(iunit,*)   -il5(mgs)*qwfrzc(mgs)
      write(iunit,*)   -il5(mgs)*qwctfzc(mgs)
!      write(iunit,*)   -il5(mgs)*qwfrzp(mgs)
!      write(iunit,*)   -il5(mgs)*qwctfzp(mgs)
      write(iunit,*)   -il5(mgs)*qiihr(mgs)
      write(iunit,*)   -il5(mgs)*qicichr(mgs)
      write(iunit,*)   -il5(mgs)*qipiphr(mgs)
      write(iunit,*)   -qracw(mgs)
      write(iunit,*)   -qsacw(mgs)
      write(iunit,*)   -qrcnw(mgs)
      write(iunit,*)   -qhacw(mgs)
      write(iunit,*)   -qhlacw(mgs)
      write(iunit,*)   'pqcwd = ', pqcwd(mgs)


      write(iunit,*)
      write(iunit,*)  'Concentration:'
      write(iunit,*)   -cautn(mgs)
      write(iunit,*)   -cracw(mgs)
      write(iunit,*)   -csacw(mgs)
      write(iunit,*)   -chacw(mgs)
      write(iunit,*)  -ciacw(mgs)
      write(iunit,*)  -cwfrzp(mgs)
      write(iunit,*)  -cwctfzp(mgs)
      write(iunit,*)  -cwfrzc(mgs)
      write(iunit,*)  -cwctfzc(mgs)
      write(iunit,*)   pccwd(mgs)
!
      write(iunit,*)
      write(iunit,*)      'Rain '
!
      write(iunit,*)      qracw(mgs)
      write(iunit,*)      qrcnw(mgs)
      write(iunit,*)      Max(0.0, qrcev(mgs))
      write(iunit,*)       -(1-il5(mgs))*qhmlr(mgs)
      write(iunit,*)       -(1-il5(mgs))*qhlmlr(mgs)
      write(iunit,*)       -(1-il5(mgs))*qsmlr(mgs)
      write(iunit,*)       -(1-il5(mgs))*qimlr(mgs)
      write(iunit,*)       -qrshr(mgs)
      write(iunit,*)       'pqrwi = ', pqrwi(mgs)    
      write(iunit,*)        -qsshr(mgs)     
      write(iunit,*)        -qhshr(mgs)     
      write(iunit,*)        -qhlshr(mgs)
      write(iunit,*)        -il5(mgs)*qiacr(mgs),qiacr(mgs), qiacrf(mgs)
      write(iunit,*)        -il5(mgs)*qrfrz(mgs)
      write(iunit,*)        -qsacr(mgs)
      write(iunit,*)        -qhacr(mgs)
      write(iunit,*)        -qhlacr(mgs)
      write(iunit,*)        qrcev(mgs)
      write(iunit,*)       'pqrwd = ', pqrwd(mgs) 
      write(iunit,*)       'fhw, fhlw = ',fhw(mgs),fhlw(mgs)
      write(iunit,*)        'qrzfac = ', qrzfac(mgs)
!
      
      write(iunit,*)
      write(iunit,*)  'Rain concentration'
      write(iunit,*)  pcrwi(mgs) 
      write(iunit,*)    crcnw(mgs)
      write(iunit,*)    1-il5(mgs)
      write(iunit,*)   -chmlr(mgs),-csmlr(mgs)
      write(iunit,*)     -crshr(mgs)
      write(iunit,*)  pcrwd(mgs) 
      write(iunit,*)    il5(mgs)
      write(iunit,*)   -ciacr(mgs),-crfrz(mgs) 
      write(iunit,*)   -csacr(mgs),-chacr(mgs)
      write(iunit,*)   +crcev(mgs)
      write(iunit,*)   cracr(mgs)
!      write(iunit,*)   -il5(mgs)*ciracr(mgs)


      write(iunit,*)
      write(iunit,*)   'Snow'
!
      write(iunit,*)        il5(mgs)*qscni(mgs), qscnvi(mgs)
      write(iunit,*)        il5(mgs)*qsaci(mgs)
      write(iunit,*)        il5(mgs)*qrfrzs(mgs)
      write(iunit,*)        il5(mgs)*qiacrs(mgs),il3(mgs)*(qiacrf(mgs)+qracif(mgs)),il3(mgs),qiacrf(mgs),qracif(mgs)
      write(iunit,*)        il5(mgs)*qsdpv(mgs), qscev(mgs)
      write(iunit,*)        qsacw(mgs)
      write(iunit,*)        qsacr(mgs), qscnh(mgs)
       write(iunit,*)        'pqswi = ',pqswi(mgs)
      write(iunit,*)        -qhcns(mgs)
      write(iunit,*)        -qracs(mgs)
      write(iunit,*)        -qhacs(mgs)
      write(iunit,*)        -qhlacs(mgs)
      write(iunit,*)       (1-il5(mgs))*qsmlr(mgs)
      write(iunit,*)       qsshr(mgs)
!      write(iunit,*)       qsshrp(mgs)
      write(iunit,*)       il5(mgs)*(qssbv(mgs))
      write(iunit,*)       'pqswd = ', pqswd(mgs)
      write(iunit,*)   -qracs(mgs)*(1-il2(mgs)) , qhacs(mgs) , qhlacs(mgs)   
      write(iunit,*)   -qhcns(mgs)   
      write(iunit,*)   +(1-il5(mgs))*qsmlr(mgs) , qsshr(mgs)        !null at this point when wet snow included
      write(iunit,*)   (qssbv(mgs))   
      write(iunit,*)   Min(0.0, qscev(mgs))  
      write(iunit,*)   -qsmul(mgs)
!
!
      write(iunit,*)
      write(iunit,*)   'Graupel'
!
      write(iunit,*)   il5(mgs)*qrfrzf(mgs), qrfrzf(mgs) - qrfrz(mgs)
      write(iunit,*)   il5(mgs)*qiacrf(mgs)
      write(iunit,*)   il5(mgs)*qracif(mgs)
      write(iunit,*)   qhcns(mgs)
      write(iunit,*)   qhcni(mgs)
      write(iunit,*)   il5(mgs)*(qhdpv(mgs))
      write(iunit,*)   qhacr(mgs)
      write(iunit,*)   qhacw(mgs)
      write(iunit,*)   qhacs(mgs)
      write(iunit,*)   qhaci(mgs)
      write(iunit,*)   'pqhwi = ',pqhwi(mgs)
      write(iunit,*)
      write(iunit,*)   qhshr(mgs)
      write(iunit,*)   (1-il5(mgs))*qhmlr(mgs)
      write(iunit,*)   il5(mgs),qhsbv(mgs)
      write(iunit,*)   -qhlcnh(mgs)
      write(iunit,*)   -qhmul1(mgs)
      write(iunit,*)   'pqhwd = ', pqhwd(mgs)
      write(iunit,*)  'Concentration'
      write(iunit,*)   pchwi(mgs),pchwd(mgs)
      write(iunit,*)  crfrzf(mgs)
      write(iunit,*)  chcns(mgs)
      write(iunit,*)  ciacrf(mgs)

!
      write(iunit,*)
      write(iunit,*)   'Hail'
!
      write(iunit,*)   qhlcnh(mgs)
      write(iunit,*)   il5(mgs)*(qhldpv(mgs))
      write(iunit,*)   qhlacr(mgs)
      write(iunit,*)   qhlacw(mgs)
      write(iunit,*)   qhlacs(mgs)
      write(iunit,*)   qhlaci(mgs)
      write(iunit,*)   pqhli(mgs)
      write(iunit,*)
      write(iunit,*)   qhlshr(mgs)
      write(iunit,*)   (1-il5(mgs))*qhlmlr(mgs)
      write(iunit,*)   il5(mgs)*qhlsbv(mgs)
      write(iunit,*)   pqhld(mgs)
      write(iunit,*)  'Concentration'
      write(iunit,*)   pchli(mgs),pchld(mgs)
      write(iunit,*)  chlcnh(mgs)
!
!  Balance and checks for continuity.....within machine precision...
!
!
      write(iunit,*) 'END OF OUTPUT OF SOURCE AND SINK'
      write(iunit,*) 'PTOTAL',ptotal(mgs)
!
      end if
!
      end do
!
      end if ! ( nstep/12*12 .eq. nstep )

!
!  latent heating from phase changes (except qcw, qci cond, and evap)
!
      do mgs = 1,ngscnt
      IF ( warmonly < 0.5 ) THEN
      pfrz(mgs) =    &
     &  (1-il5(mgs))*   &
     &  (qhmlr(mgs)+qsmlr(mgs)+qhlmlr(mgs))   & !+qhmlh(mgs))   &
     &  +il5(mgs)*(qhfzh(mgs)+qsfzs(mgs)+qhlfzhl(mgs))   &
     &  +il5(mgs)*(1-imixedphase)*(   &
     &   qsacw(mgs)+qhacw(mgs) + qhlacw(mgs)   &
     &  +qsacr(mgs)+qhacr(mgs) + qhlacr(mgs)   &
     &  +qsshr(mgs)   &
     &  +qhshr(mgs)   &
     &  +qhlshr(mgs) +qrfrz(mgs)+qiacr(mgs)  &
     &  )  &
     &  +il5(mgs)*(qwfrz(mgs)    &
     &  +qwctfz(mgs)+qiihr(mgs)   &
     &  +qiacw(mgs))
      pmlt(mgs) =    &
     &  (1-il5(mgs))*   &
     &  (qhmlr(mgs)+qsmlr(mgs)+qhlmlr(mgs))    !+qhmlh(mgs))   
      psub(mgs) =    &
     &   il5(mgs)*(   &
     &  + qsdpv(mgs) + qhdpv(mgs)   &
     &  + qhldpv(mgs)    &
     &  + qidpv(mgs) + qisbv(mgs) )   &
     &   + qssbv(mgs)  + qhsbv(mgs) + qhlsbv(mgs)   &
     &  +il5(mgs)*(qiint(mgs))
      pvap(mgs) =    &
     &   qrcev(mgs) + qhcev(mgs) + qscev(mgs) + qhlcev(mgs)
      pevap(mgs) =    &
     &   Min(0.0,qrcev(mgs)) + Min(0.0,qhcev(mgs)) + Min(0.0,qscev(mgs)) + Min(0.0,qhlcev(mgs))
      pdep(mgs) =    &
     &   il5(mgs)*(   &
     &  + qsdpv(mgs) + qhdpv(mgs)   &
     &  + qhldpv(mgs)    &
     &  + qidpv(mgs)  )   &
     &  +il5(mgs)*(qiint(mgs))
      ELSEIF ( warmonly < 0.8 ) THEN
      pfrz(mgs) =    &
     &  (1-il5(mgs))*   &
     &  (qhmlr(mgs)+qhlmlr(mgs))   & !+qhmlh(mgs))   &
     &  +il5(mgs)*(qhfzh(mgs)+qhlfzhl(mgs))   &
     &  +il5(mgs)*(   &
     &  +qhshr(mgs)   &
     &  +qhlshr(mgs)   &
     &  +qrfrz(mgs)+qwfrz(mgs)   &
     &  +qwctfz(mgs)+qiihr(mgs)   &
     &  +qiacw(mgs)                &
     & +qhacw(mgs) + qhlacw(mgs)   &
     & +qhacr(mgs) + qhlacr(mgs)  ) 
      psub(mgs) =  0.0 +  &
     &   il5(mgs)*(   &
     &  + qhdpv(mgs)   &
     &  + qhldpv(mgs)    &
     &  + qidpv(mgs) + qisbv(mgs) )   &
     &  +il5(mgs)*(qiint(mgs))
      pvap(mgs) =    &
     &   qrcev(mgs) + qhcev(mgs) + qhlcev(mgs) ! + qscev(mgs) 
      ELSE
      pfrz(mgs) = 0.0
      psub(mgs) = 0.0
      pvap(mgs) = qrcev(mgs)
      ENDIF ! warmonly
      ptem(mgs) =    &
     &  (1./pi0(mgs))*   &
     &  (felfcp(mgs)*pfrz(mgs)   &
     &  +felscp(mgs)*psub(mgs)    &
     &  +felvcp(mgs)*pvap(mgs))
      thetap(mgs) = thetap(mgs) + dtp*ptem(mgs)
      IF ( eqtset > 2 ) THEN
        pipert(mgs) = pipert(mgs) + (felfpi(mgs)*pfrz(mgs)   &
     &  +felspi(mgs)*psub(mgs)    &
     &  +felvpi(mgs)*pvap(mgs))*dtp
      ENDIF
      end do




!
!  sum the sources and sinks for qwvp, qcw, qci, qrw, qsw
!
!
      do mgs = 1,ngscnt
      qwvp(mgs) = qwvp(mgs) +        &
     &   dtp*(pqwvi(mgs)+pqwvd(mgs))
      qx(mgs,lc) = qx(mgs,lc) +   &
     &   dtp*(pqcwi(mgs)+pqcwd(mgs))
!      IF ( qx(mgs,lr) .gt. 10.0e-3 )  THEN
!       write(0,*)  'RAIN1a: ',igs(mgs),kgs(mgs),qx(mgs,lr)
!      ENDIF
      qx(mgs,lr) = qx(mgs,lr) +   &
     &   dtp*(pqrwi(mgs)+pqrwd(mgs))
!      IF ( qx(mgs,lr) .gt. 10.0e-3 ) THEN
!        write(0,*)  'RAIN1b: ',igs(mgs),kgs(mgs),qx(mgs,lr)
!        write(0,*)  pqrwi(mgs),pqrwd(mgs)
!       ENDIF
      qx(mgs,li) = qx(mgs,li) +   &
     &   dtp*(pqcii(mgs)+pqcid(mgs))
      qx(mgs,ls) = qx(mgs,ls) +   &
     &   dtp*(pqswi(mgs)+pqswd(mgs))
      qx(mgs,lh) = qx(mgs,lh) +    &
     &   dtp*(pqhwi(mgs)+pqhwd(mgs))
      IF ( lhl .gt. 1 ) THEN
      qx(mgs,lhl) = qx(mgs,lhl) +    &
     &   dtp*(pqhli(mgs)+pqhld(mgs))
!       IF ( pqhli(mgs) .gt. 1.e-8 ) write(0,*) ' pqhli,qx(lhl) = ',pqhli(mgs),qx(mgs,lhl)
      ENDIF


      end do

! sum sources for particle volume

      IF ( ldovol ) THEN

      do mgs = 1,ngscnt

      IF ( lvol(ls) .gt. 1 ) THEN
      vx(mgs,ls) = vx(mgs,ls) +    &
     &   dtp*(pvswi(mgs)+pvswd(mgs))
      ENDIF

      IF ( lvol(lh) .gt. 1 ) THEN
      vx(mgs,lh) = vx(mgs,lh) +    &
     &   dtp*(pvhwi(mgs)+pvhwd(mgs))
!     >   rho0(mgs)*dtp*(pqhwi(mgs)+pqhwd(mgs))/xdn0(lh)
      ENDIF

      IF ( lhl .gt. 1 ) THEN
      IF ( lvol(lhl) .gt. 1 ) THEN
      vx(mgs,lhl) = vx(mgs,lhl) +    &
     &   dtp*(pvhli(mgs)+pvhld(mgs))
!     >   rho0(mgs)*dtp*(pqhwi(mgs)+pqhwd(mgs))/xdn0(lh)
      ENDIF
      ENDIF

      ENDDO

      ENDIF  ! ldovol

!
!
!
! concentrations
!
      if ( ipconc .ge. 1  ) then
      do mgs = 1,ngscnt
      cx(mgs,li) = cx(mgs,li) +   &
     &   dtp*(pccii(mgs)+pccid(mgs)) 
      cina(mgs) = cina(mgs) + pccin(mgs)*dtp
      IF ( ipconc .ge. 2 ) THEN
      cx(mgs,lc) = cx(mgs,lc) +   &
     &   dtp*(pccwi(mgs)+pccwd(mgs))
      ENDIF
      IF ( ipconc .ge. 3 ) THEN
      cx(mgs,lr) = cx(mgs,lr) +   &
     &   dtp*(pcrwi(mgs)+pcrwd(mgs))
      ENDIF
      IF ( ipconc .ge. 4 ) THEN
      cx(mgs,ls) = cx(mgs,ls) +   &
     &   dtp*(pcswi(mgs)+pcswd(mgs))
      ENDIF
      IF ( ipconc .ge. 5 ) THEN
      cx(mgs,lh) = cx(mgs,lh) +    &
     &   dtp*(pchwi(mgs)+pchwd(mgs))
       IF ( lhl .gt. 1 ) THEN
        cx(mgs,lhl) = cx(mgs,lhl) +    &
     &     dtp*(pchli(mgs)+pchld(mgs))
!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
!       write(0,*) 'dr: cx,pchli,pchld = ', cx(mgs,lhl),pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
!      ENDIF
       ENDIF
      ENDIF
      end do
      end if


      IF ( wrfchem_flag > 0 ) THEN
! 20130917 acd_mb_washout start
        DO mgs = 1,ngscnt
         evapprod2d(igs(mgs),kgs(mgs)) = -(qrcev(mgs) + qssbv(mgs)  + qhsbv(mgs) + qhlsbv(mgs)) ! - PRE(K) - EVPMS(K) - EVPMG(K)
         rainprod2d(igs(mgs),kgs(mgs)) = qrcnw(mgs) + qracw(mgs) + qsacw(mgs) + qhacw(mgs) + qhlacw(mgs) + &
                                         qraci(mgs) + qsaci(mgs) + qhaci(mgs) + qhlaci(mgs) + qscni(mgs)     ! PRA(K) + PRC(K) + tqimelt(K)
!         evapprod(k) = - PRE(K) - EPRDS(K) - EPRDG(K) 
!         rainprod(k) = PRA(K) + PRC(K) + PSACWS(K) + PSACWG(K) + PGSACW(K) & 
!                       + PRAI(K) + PRCI(K) + PRACI(K) + PRACIS(K) + &
!                       + PRDS(K) + PRDG(K)
        ENDDO
! 20130917 acd_mb_washout end
      ENDIF
!
!
!
! start saturation adjustment
!
      if (ndebug .gt. 0 ) write(0,*) 'conc 30a'
!      include 'sam.jms.satadj.sgi'
!
!
!
!  Modified Straka adjustment (nearly identical to Tao et al. 1989 MWR)
!
!
!
!  set up temperature and vapor arrays
!
      do mgs = 1,ngscnt
      pqs(mgs) = (380.0)/(pres(mgs))
      theta(mgs) = thetap(mgs) + theta0(mgs)
      qvap(mgs) = max( (qwvp(mgs) + qv0(mgs)), 0.0 )
      temg(mgs) = theta(mgs)*pk(mgs) ! ( pres(mgs) / poo ) ** cap
      end do
!
!  melting of cloud ice
!
      do mgs = 1,ngscnt
      qcwtmp(mgs) = qx(mgs,lc)
      ptimlw(mgs) = 0.0
      end do
!
      do mgs = 1,ngscnt
      qitmp(mgs) = qx(mgs,li)
      if( temg(mgs) .gt. tfr .and.   &
     &    qitmp(mgs) .gt. 0.0 ) then
      qx(mgs,lc) = qx(mgs,lc) + qitmp(mgs)
!      pfrz(mgs) = pfrz(mgs) - qitmp(mgs)/dtp
      ptem(mgs) =  ptem(mgs) +   &
     &  (1./pi0(mgs))*   &
     &  felfcp(mgs)*(- qitmp(mgs)/dtp)  
      IF ( eqtset > 2 ) THEN
        pipert(mgs) = pipert(mgs) - (felfpi(mgs)*qitmp(mgs))
      ENDIF
      pmlt(mgs) = pmlt(mgs) - qitmp(mgs)/dtp
      scx(mgs,lc) = scx(mgs,lc) + scx(mgs,li)
      thetap(mgs) = thetap(mgs) -   &
     &  fcc3(mgs)*qitmp(mgs)
      ptimlw(mgs) = -fcc3(mgs)*qitmp(mgs)/dtp
      cx(mgs,lc) = cx(mgs,lc) + cx(mgs,li)
      qx(mgs,li) = 0.0
      cx(mgs,li) = 0.0
      scx(mgs,li) = 0.0
      vx(mgs,li) = 0.0
      qitmp(mgs) = 0.0
      end if
      end do
!
!


!      do mgs = 1,ngscnt
!      qimlw(mgs) = (qcwtmp(mgs)-qx(mgs,lc))/dtp
!      end do
!
!  homogeneous freezing of cloud water
!
      IF ( warmonly < 0.8 ) THEN

      do mgs = 1,ngscnt
      qcwtmp(mgs) = qx(mgs,lc)
      ptwfzi(mgs) = 0.0
      end do
!
      do mgs = 1,ngscnt

!      if( temg(mgs) .lt. tfrh ) THEN
!       write(0,*) 'GS: mgs,temp,qc,qi = ',mgs,temg(mgs),temcg(mgs),qx(mgs,lc),qx(mgs,li)
!      ENDIF

      ctmp = 0.0
      frac = 0.0
      qtmp = 0.0
      
!      if( ( temg(mgs) .lt. thnuc + 2. .or. (ibfc == 2 .and. temg(mgs) < thnuc + 10. ) ) .and.    &
!     &  qx(mgs,lc) .gt. qxmin(lc) .and. (ipconc < 2 .or. ibfc == 0 .or. ibfc == 2 )) then
      if( temg(mgs) .lt. thnuc + 0. .and.    &
     &  qx(mgs,lc) .gt. 0.0 .and. (ipconc < 2 .or. ibfc == 0 )) then

      IF ( ibfc /= 2 .or. ipconc < 2 ) THEN
      frac = Max( 0.25, Min( 1., ((thnuc + 1.) - temg(mgs) )/4.0 ) )
      ELSE
          volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b
                                               ! volt is given in cm**3, so factor of 1.e-6 to convert to m**3
         
         cwfrz(mgs) = cx(mgs,lc)*Exp(-volt/xv(mgs,lc)) ! number of droplets with volume greater than volt

         qtmp = cwfrz(mgs)*xdn0(lc)*rhoinv(mgs)*(volt + xv(mgs,lc))
         frac = qtmp/qx(mgs,lc) ! reset number frozen to same fraction as mass. This makes 
                                                       ! sure that cwfrz and qwfrz are consistent and prevents 
                                                       ! spurious creation of ice crystals.
      
      ENDIF
      qtmp = frac*qx(mgs,lc)

      qx(mgs,li) = qx(mgs,li) + qtmp ! qx(mgs,lc)
      pfrz(mgs) = pfrz(mgs) + qtmp/dtp
      ptem(mgs) =  ptem(mgs) +   &
     &  (1./pi0(mgs))*   &
     &  felfcp(mgs)*(qtmp/dtp)  

      IF ( eqtset > 2 ) THEN
        pipert(mgs) = pipert(mgs) + felfpi(mgs)*qtmp
      ENDIF

!      IF ( lvol(li) .gt. 1 ) vx(mgs,li) = vx(mgs,li) + rho0(mgs)*qx(mgs,lc)/xdn0(li)
      IF ( lvol(li) .gt. 1 ) vx(mgs,li) = vx(mgs,li) + rho0(mgs)*qtmp/xdn0(li)

      IF ( ipconc .ge. 2 ) THEN
        ctmp = frac*cx(mgs,lc)
!        cx(mgs,li) = cx(mgs,li) + cx(mgs,lc)
        cx(mgs,li) = cx(mgs,li) + ctmp
      ELSE ! (ipconc .lt. 2 )
        ctmp = 0.0
        IF ( t9(igs(mgs),jgs,kgs(mgs)-1) .gt. qx(mgs,lc) ) THEN
           qtmp = frac*t9(igs(mgs),jgs,kgs(mgs)-1)  

!           cx(mgs,lc) = cx(mgs,lc)*qx(mgs,lc)*rho0(mgs)/qtmp
           ctmp = cx(mgs,lc)*qx(mgs,lc)*rho0(mgs)/qtmp
        ELSE
           cx(mgs,lc) = Max(0.0,wvel(mgs))*dtp*cwccn   &
     &      /gz(igs(mgs),jgs,kgs(mgs))
          cx(mgs,lc) = cwccn
        ENDIF

       IF ( ipconc .ge. 1 ) cx(mgs,li) = Min(ccimx, cx(mgs,li) + cx(mgs,lc))
      ENDIF

      sctmp = frac*scx(mgs,lc)
!      scx(mgs,li) = scx(mgs,li) + scx(mgs,lc)
      scx(mgs,li) = scx(mgs,li) + sctmp
!      thetap(mgs) = thetap(mgs) + fcc3(mgs)*qx(mgs,lc)
!      ptwfzi(mgs) = fcc3(mgs)*qx(mgs,lc)/dtp
!      qx(mgs,lc) = 0.0
!      cx(mgs,lc) = 0.0
!      scx(mgs,lc) = 0.0
      thetap(mgs) = thetap(mgs) + fcc3(mgs)*qtmp
      ptwfzi(mgs) = fcc3(mgs)*qtmp/dtp
      qx(mgs,lc) = qx(mgs,lc) - qtmp
      cx(mgs,lc) = cx(mgs,lc) - ctmp
      scx(mgs,lc) = scx(mgs,lc) - sctmp
      end if
      end do

      ENDIF ! warmonly
!
!      do mgs = 1,ngscnt
!      qwfzi(mgs) = (qcwtmp(mgs)-qx(mgs,lc))/dtp   ! Not used?? (ERM)
!      end do
!
!  reset temporaries for cloud particles and vapor
!
      qcond(:) = 0.0
      
      IF ( ipconc .le. 1 .and.  lwsm6 ) THEN ! Explicit cloud condensation/evaporation (Rutledge and Hobbs 1983)
       DO mgs = 1,ngscnt

        qcwtmp(mgs) = qx(mgs,lc)
        theta(mgs) = thetap(mgs) + theta0(mgs)
        temgtmp = temg(mgs)
!        temg(mgs) = theta(mgs)*(p2(igs(mgs),jgs,kgs(mgs)) ) ! *pk(mgs) ! ( pres(mgs) / poo ) ** cap
!        temsav = temg(mgs)
!        thsave(mgs) = thetap(mgs)
        temg(mgs) = theta(mgs)*pk(mgs) ! ( pres(mgs) / poo ) ** cap
        temcg(mgs) = temg(mgs) - tfr
        ltemq = (temg(mgs)-163.15)/fqsat+1.5
        ltemq = Min( nqsat, Max(1,ltemq) )

        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)

        IF ( ( qvap(mgs) > qvs(mgs) .or. qx(mgs,lc) > qxmin(lc) ) .and. temg(mgs) > tfrh ) THEN
          tmp = (qvap(mgs) - qvs(mgs))/(1. + qvs(mgs)*felv(mgs)**2/(cp*rw*temg(mgs)**2) )
          qcond(mgs) = Min( Max( 0.0, tmp ), (qvap(mgs)-qvs(mgs)) )
          IF ( qx(mgs,lc) > qxmin(lc) .and. tmp < 0.0 ) THEN ! evaporation
            qcond(mgs) = Max( tmp, -qx(mgs,lc) )
          ENDIF
          qwvp(mgs) = qwvp(mgs) - qcond(mgs)
          qvap(mgs) = qvap(mgs) - qcond(mgs)
          qx(mgs,lc) = Max( 0.0, qx(mgs,lc) + qcond(mgs) )
          thetap(mgs) = thetap(mgs) + felvcp(mgs)*qcond(mgs)/(pi0(mgs))
          
        ENDIF
        
        ENDDO
      
      ENDIF
      
      
      IF ( ipconc .le. 1 .and. .not. lwsm6 ) THEN
!      IF ( ipconc .le. 1  ) THEN
      
      do mgs = 1,ngscnt
      qx(mgs,lv) = max( 0.0, qvap(mgs) )
      qx(mgs,lc) = max( 0.0, qx(mgs,lc) )
      qx(mgs,li) = max( 0.0, qx(mgs,li) )
      qitmp(mgs) = qx(mgs,li)
      end do
!
!
      do mgs = 1,ngscnt
      qcwtmp(mgs) = qx(mgs,lc)
      qitmp(mgs) = qx(mgs,li)
      theta(mgs) = thetap(mgs) + theta0(mgs)
      temgtmp = temg(mgs)
      temg(mgs) = theta(mgs)*(pinit(kgs(mgs)) + p2(igs(mgs),jgs,kgs(mgs)) ) ! *pk(mgs) ! ( pres(mgs) / poo ) ** cap
      temsav = temg(mgs)
      thsave(mgs) = thetap(mgs)
      temcg(mgs) = temg(mgs) - tfr
      tqvcon = temg(mgs)-cbw
      ltemq = (temg(mgs)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )
!      IF ( ltemq .lt. 1 .or. ltemq .gt. nqsat ) THEN
! C$PAR CRITICAL SECTION
!        write(iunit,*) 'out of range ltemq!',temgtmp,temg(mgs),
!     :      thetap(mgs),theta0(mgs),pres(mgs),theta(mgs),
!     :      ltemq,igs(mgs),jy,kgs(mgs)
!        write(iunit,*) an(igs(mgs),jy,kgs(mgs),lt),
!     :   ab(igs(mgs),jy,kgs(mgs),lt),
!     :   t0(igs(mgs),jy,kgs(mgs))
!        write(iunit,*) fcc3(mgs),qx(mgs,lc),qitmp(mgs),dtp,ptem(mgs)
!        STOP
! C$PAR END CRITICAL SECTION
!      END IF
      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
      qis(mgs) = pqs(mgs)*tabqis(ltemq)
!      qss(kz) = qvs(kz)
!      if ( temg(kz) .lt. tfr ) then
!      if( qcw(kz) .le. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
!     >  qss(kz) = qis(kz)
!      if( qcw(kz) .gt. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
!     >   qss(kz) = (qcw(kz)*qvs(kz) + qci(kz)*qis(kz)) /
!     >   (qcw(kz) + qci(kz))
!      qss(kz) = qis(kz)
!      end if
! dont get enough condensation with qcw .le./.gt. qxmin(lc)
!      if ( temg(mgs) .lt. tfr ) then
!      if( qx(mgs,lc) .ge. 0.0 .and. qitmp(mgs) .le. qxmin(li) )
!     >  qss(mgs) = qvs(mgs)
!      if( qx(mgs,lc) .eq. 0.0 .and. qitmp(mgs) .gt. qxmin(li))
!     >  qss(mgs) = qis(mgs)
!      if( qx(mgs,lc) .gt. 0.0 .and. qitmp(mgs) .gt. qxmin(li))
!     >   qss(mgs) = (qx(mgs,lc)*qvs(mgs) + qitmp(mgs)*qis(mgs)) /
!     >   (qx(mgs,lc) + qitmp(mgs))
!      else
!      qss(mgs) = qvs(mgs)
!      end if
      qss(mgs) = qvs(mgs)
      if ( temg(mgs) .lt. tfr ) then
      if( qx(mgs,lc) .ge. 0.0 .and. qitmp(mgs) .le. qxmin(li) )   &
     &  qss(mgs) = qvs(mgs)
      if( qx(mgs,lc) .le. qxmin(lc) .and. qitmp(mgs) .gt. qxmin(li))   &
     &  qss(mgs) = qis(mgs)
      if( qx(mgs,lc) .gt. qxmin(lc) .and. qitmp(mgs) .gt. qxmin(li))   &
     &   qss(mgs) = (qx(mgs,lc)*qvs(mgs) + qitmp(mgs)*qis(mgs)) /   &
     &   (qx(mgs,lc) + qitmp(mgs))
      end if
      end do
!
!  iterate  adjustment
!
      do itertd = 1,2
!
      do mgs = 1,ngscnt
!
!  calculate super-saturation
!
      qitmp(mgs) = qx(mgs,li)
      fcci(mgs) = 0.0
      fcip(mgs) = 0.0
      dqcw(mgs) = 0.0
      dqci(mgs) = 0.0
      dqwv(mgs) = ( qx(mgs,lv) - qss(mgs) )
!
!  evaporation and sublimation adjustment
!
      if( dqwv(mgs) .lt. 0. ) then           !  subsaturated
        if( qx(mgs,lc) .gt. -dqwv(mgs) ) then  ! check if qc can make up all of the deficit
          dqcw(mgs) = dqwv(mgs)
          dqwv(mgs) = 0.
        else                                 !  otherwise make all qc available for evap
          dqcw(mgs) = -qx(mgs,lc)
          dqwv(mgs) = dqwv(mgs) + qx(mgs,lc)
        end if
!
        if( qitmp(mgs) .gt. -dqwv(mgs) ) then  ! check if qi can make up all the deficit
          dqci(mgs) = dqwv(mgs)
          dqwv(mgs) = 0.
        else                                  ! otherwise make all ice available for sublimation
          dqci(mgs) = -qitmp(mgs)
          dqwv(mgs) = dqwv(mgs) + qitmp(mgs)
        end if
!
       qwvp(mgs) = qwvp(mgs) - ( dqcw(mgs) + dqci(mgs) )  ! add to perturbation vapor
!
! This next line removed 3/19/2003 thanks to Adam Houston,
!  who found the bug in the 3-ICE code
!      qwvp(mgs) = max(qwvp(mgs), 0.0)
      qitmp(mgs) = qx(mgs,li)
      IF ( qitmp(mgs) .gt. qxmin(li) ) THEN
        fcci(mgs) = qx(mgs,li)/(qitmp(mgs))
      ELSE
        fcci(mgs) = 0.0
      ENDIF
      qx(mgs,lc) = qx(mgs,lc) + dqcw(mgs)
      qx(mgs,li) = qx(mgs,li) + dqci(mgs) * fcci(mgs)
      thetap(mgs) = thetap(mgs) +   &
     &  1./pi0(mgs)*   &
     &  (felvcp(mgs)*dqcw(mgs) +felscp(mgs)*dqci(mgs))

      IF ( eqtset > 2 ) THEN
        pipert(mgs) = pipert(mgs)   &
     &  +(felspi(mgs)*dqci(mgs)    &
     &  +felvpi(mgs)*dqcw(mgs))*dtp
      ENDIF

      end if  ! dqwv(mgs) .lt. 0. (end of evap/sublim)
!
! condensation/deposition
!
      IF ( dqwv(mgs) .ge. 0. ) THEN
      
!      write(iunit,*) 'satadj: mgs,iter = ',mgs,itertd,dqwv(mgs),qss(mgs),qx(mgs,lv),qx(mgs,lc)
!
        qitmp(mgs) = qx(mgs,li)
        fracl(mgs) = 1.0
        fraci(mgs) = 0.0
        if ( temg(mgs) .lt. tfr .and. temg(mgs) .gt. thnuc ) then
          fracl(mgs) = max(min(1.,(temg(mgs)-233.15)/(20.)),0.0)
          fraci(mgs) = 1.0-fracl(mgs)
        end if
        if ( temg(mgs) .le. thnuc ) then
           fraci(mgs) = 1.0
           fracl(mgs) = 0.0
         end if
        fraci(mgs) = 1.0-fracl(mgs)
!
       gamss = (felvcp(mgs)*fracl(mgs) + felscp(mgs)*fraci(mgs))   &
     &      / (pi0(mgs))
!
      IF ( temg(mgs) .lt. tfr ) then
        IF (qx(mgs,lc) .ge. 0.0 .and. qitmp(mgs) .le. qxmin(li) ) then
         dqvcnd(mgs) = dqwv(mgs)/(1. + fcqv1(mgs)*qss(mgs)/   &
     &  ((temg(mgs)-cbw)**2))
        END IF
        IF ( qx(mgs,lc) .eq. 0.0 .and. qitmp(mgs) .gt. qxmin(li) ) then
          dqvcnd(mgs) = dqwv(mgs)/(1. + fcqv2(mgs)*qss(mgs)/   &
     &  ((temg(mgs)-cbi)**2))
        END IF
        IF ( qx(mgs,lc) .gt. 0.0 .and. qitmp(mgs) .gt. qxmin(li) ) then
         cdw = caw*pi0(mgs)*tfrcbw/((temg(mgs)-cbw)**2)
         cdi = cai*pi0(mgs)*tfrcbi/((temg(mgs)-cbi)**2)
         denom1 = qx(mgs,lc) + qitmp(mgs)
         denom2 = 1.0 + gamss*   &
     &    (qx(mgs,lc)*qvs(mgs)*cdw + qitmp(mgs)*qis(mgs)*cdi) / denom1
         dqvcnd(mgs) =  dqwv(mgs) / denom2
        END IF 

      ENDIF  !  temg(mgs) .lt. tfr
!
      if ( temg(mgs) .ge. tfr ) then
      dqvcnd(mgs) = dqwv(mgs)/(1. + fcqv1(mgs)*qss(mgs)/   &
     &  ((temg(mgs)-cbw)**2))
      end if
!
      delqci1=qx(mgs,li)
!
      IF ( qitmp(mgs) .gt. qxmin(li) ) THEN
        fcci(mgs) = qx(mgs,li)/(qitmp(mgs))
      ELSE
        fcci(mgs) = 0.0
      ENDIF
!
      dqcw(mgs) = dqvcnd(mgs)*fracl(mgs)
      dqci(mgs) = dqvcnd(mgs)*fraci(mgs)
!
      thetap(mgs) = thetap(mgs) +   &
     &   (felvcp(mgs)*dqcw(mgs) + felscp(mgs)*dqci(mgs))   &
     & / (pi0(mgs))

      IF ( eqtset > 2 ) THEN
        pipert(mgs) = pipert(mgs) + (0   &
     &  +felspi(mgs)*dqci(mgs)    &
     &  +felvpi(mgs)*dqcw(mgs))*dtp
      ENDIF

      qwvp(mgs) = qwvp(mgs) - ( dqvcnd(mgs) )
      qx(mgs,lc) = qx(mgs,lc) + dqcw(mgs)
      IF ( qitmp(mgs) .gt. qxmin(li) ) THEN
        qx(mgs,li) = qx(mgs,li) + dqci(mgs)*fcci(mgs)
        qitmp(mgs) = qx(mgs,li)
      ENDIF
!
!      delqci(mgs) =  dqci(mgs)*fcci(mgs)
!
      END IF !  dqwv(mgs) .ge. 0.
      end do
!
      do mgs = 1,ngscnt
      qitmp(mgs) = qx(mgs,li)
      theta(mgs) = thetap(mgs) + theta0(mgs)
      temg(mgs) = theta(mgs)*pk(mgs) ! ( pres(mgs) / poo ) ** cap
      qvap(mgs) = Max((qwvp(mgs) + qv0(mgs)), 0.0)
      temcg(mgs) = temg(mgs) - tfr
      tqvcon = temg(mgs)-cbw
      ltemq = (temg(mgs)-163.15)/fqsat+1.5
      ltemq = Min( nqsat, Max(1,ltemq) )
      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
      qis(mgs) = pqs(mgs)*tabqis(ltemq)
      qx(mgs,lc) = max( 0.0, qx(mgs,lc) )
      qitmp(mgs) = max( 0.0, qitmp(mgs) )
      qx(mgs,lv) = max( 0.0, qvap(mgs))
!      if ( temg(mgs) .lt. tfr ) then
!      if( qx(mgs,lc) .ge. 0.0 .and. qitmp(mgs) .le. qxmin(li) )
!     >  qss(mgs) = qvs(mgs)
!c      if( qx(mgs,lc) .le. qxmin(lc) .and. qitmp(mgs) .gt. qxmin(li))
!      if( qx(mgs,lc) .eq. 0.0 .and. qitmp(mgs) .gt. qxmin(li))
!     >  qss(mgs) = qis(mgs)
!c      if( qx(mgs,lc) .gt. qxmin(lc) .and. qitmp(mgs) .gt. qxmin(li))
!      if( qx(mgs,lc) .gt. 0.0 .and. qitmp(mgs) .gt. qxmin(li))
!     >  qss(mgs) = (qx(mgs,lc)*qvs(mgs) + qitmp(mgs)*qis(mgs)) /
!     > (qx(mgs,lc) + qitmp(mgs))
!      else
!      qss(mgs) = qvs(mgs)
!      end if
      qss(mgs) = qvs(mgs)
      if ( temg(mgs) .lt. tfr ) then
      if( qx(mgs,lc) .ge. 0.0 .and. qitmp(mgs) .le. qxmin(li) )   &
     &  qss(mgs) = qvs(mgs)
      if( qx(mgs,lc) .le. qxmin(lc) .and. qitmp(mgs) .gt. qxmin(li))   &
     &  qss(mgs) = qis(mgs)
      if( qx(mgs,lc) .gt. qxmin(lc) .and. qitmp(mgs) .gt. qxmin(li))   &
     &   qss(mgs) = (qx(mgs,lc)*qvs(mgs) + qitmp(mgs)*qis(mgs)) /   &
     &   (qx(mgs,lc) + qitmp(mgs))
      end if
!      pceds(mgs) = (thetap(mgs) - thsave(mgs))/dtp
!      write(iunit,*) 'satadj2: mgs,iter = ',mgs,itertd,dqwv(mgs),qss(mgs),qx(mgs,lv),qx(mgs,lc)
      end do
!
!  end the saturation adjustment iteration loop
!
      end do

     ENDIF ! ( ipconc .le. 1 )

!
!  spread the growth owing to vapor diffusion onto the
!  ice crystal categories using the
!
!  END OF SATURATION ADJUSTMENT
!

      if (ndebug .gt. 0 ) write(0,*) 'conc 30b'
!
!
!  end of saturation adjustment

!
!
! !DIR$ IVDEP
      do mgs = 1,ngscnt
      t0(igs(mgs),jy,kgs(mgs)) =  temg(mgs)
      end do
!
! Load the save arrays
!



      if (ndebug .gt. 0 ) write(0,*) 'gs 11'

      do mgs = 1,ngscnt
!
      an(igs(mgs),jy,kgs(mgs),lt) =    &
     &  theta0(mgs) + thetap(mgs) 
      an(igs(mgs),jy,kgs(mgs),lv) = qwvp(mgs) + qv0(mgs) !

      IF ( eqtset > 2 ) THEN
        p2(igs(mgs),jy,kgs(mgs)) = pipert(mgs)
      ENDIF
!
      
      DO il = lc,lhab
        IF ( ido(il) .eq. 1 ) THEN
         an(igs(mgs),jy,kgs(mgs),il) = qx(mgs,il) +   &
     &     min( an(igs(mgs),jy,kgs(mgs),il), 0.0 )
         qx(mgs,il) = an(igs(mgs),jy,kgs(mgs),il)
        ENDIF
      ENDDO

      IF ( lcina > 1 ) THEN
        an(igs(mgs),jy,kgs(mgs),lcina) = cina(mgs)
      ENDIF


!
      end do
!

      if ( ipconc .ge. 1 ) then
      DO il = lc,lhab !{

!        write(0,*) 'limiter loop: il,ipc,lz: ',il,ipc(il),lz(il),ipconc

       IF ( ipconc .ge. ipc(il) ) THEN ! {

         IF (  ipconc .ge. 4 .and. ipc(il) .ge. 1 ) THEN ! {

!            write(0,*) 'MY limiter: il,ipc,lz: ',il,ipc(il),lz(il),lr,lzr
!            STOP

          IF ( lz(il) <= 1 .or. ioldlimiter == 1 ) THEN ! { { is a two-moment category so dont worry about reflectivity
          

           DO mgs = 1,ngscnt
            IF ( qx(mgs,il) .le. 0.0 ) THEN
              cx(mgs,il) = 0.0
            ELSE !{
              IF ( cx(mgs,il) .gt. cxmin ) THEN !{
!              xv(mgs,il) = rho0(mgs)*qx(mgs,il)/(xdn(mgs,il)*Max(1.0e-9,cx(mgs,il)))
!              xv(mgs,il) = rho0(mgs)*qx(mgs,il)/(xdn(mgs,il)*Max(cxmin,cx(mgs,il)))
                xv(mgs,il) = rho0(mgs)*qx(mgs,il)/(xdn(mgs,il)*cx(mgs,il))
              
!              IF ( lhl .gt. 1 .and. il .eq. lhl ) THEN
!               write(0,*) 'dr: xv,cx,qx,xdn,ln = ',xv(mgs,il),cx(mgs,il),qx(mgs,il),xdn(mgs,il),ln(il)
!              ENDIF
              
               IF ( xv(mgs,il) .lt. xvmn(il) .or. xv(mgs,il) .gt. xvmx(il) ) THEN
                xv(mgs,il) = Min( xvmx(il), xv(mgs,il) )
                xv(mgs,il) = Max( xvmn(il), xv(mgs,il) )
                cx(mgs,il) = rho0(mgs)*qx(mgs,il)/(xv(mgs,il)*xdn(mgs,il))
               ENDIF
              
             ENDIF !}

!              IF ( lhl .gt. 1 .and. il .eq. lhl ) THEN
!               write(0,*) 'dr: xv,cx,= ',xv(mgs,il),cx(mgs,il)
!              ENDIF

            ENDIF !}
           ENDDO ! mgs
          
          
          ENDIF ! }}
          ENDIF ! }

          DO mgs = 1,ngscnt
            an(igs(mgs),jy,kgs(mgs),ln(il)) = Max(cx(mgs,il), 0.0)
          ENDDO
        ENDIF ! }
      ENDDO ! il }

      IF ( lcin > 1 ) THEN
      do mgs = 1,ngscnt
        an(igs(mgs),jy,kgs(mgs),lcin) = Max(0.0, ccin(mgs))
      end do
      ENDIF

      IF ( ipconc .ge. 2 ) THEN
      do mgs = 1,ngscnt
        IF ( lss > 1 ) THEN
          an(igs(mgs),jy,kgs(mgs),lss) = Max(0.0, ssmax(mgs) )
        ENDIF

        IF ( lccn > 1 ) THEN
          an(igs(mgs),jy,kgs(mgs),lccn) = Max(0.0, ccnc(mgs) )
        ENDIF
      end do
      ENDIF
      
      ELSEIF ( ipconc .eq. 0 .and. lni .gt. 1 ) THEN
      
          DO mgs = 1,ngscnt
            an(igs(mgs),jy,kgs(mgs),lni) = Max(cx(mgs,li), 0.0)
          ENDDO


      end if

      IF ( ldovol ) THEN

       DO il = li,lhab

        IF ( lvol(il) .ge. 1 ) THEN

          DO mgs = 1,ngscnt

           an(igs(mgs),jy,kgs(mgs),lvol(il)) = Max( 0.0, vx(mgs,il) )
          ENDDO
          
        ENDIF
      
       ENDDO
      
      ENDIF
!
!
!
!
!
      if (ndebug .gt. 0 ) write(0,*) 'gs 12'



      if (ndebug .gt. 0 ) write(0,*) 'gs 13'

 9998 continue

      if ( kz .gt. nz-1 .and. ix .ge. itile) then
        if ( ix .ge. itile ) then
         go to 1200 ! exit gather scatter
        else
         nzmpb = kz
        endif
      else
        nzmpb = kz
      end if

      if ( ix .ge. itile ) then
        nxmpb = 1
        nzmpb = kz+1
      else
       nxmpb = ix+1
      end if

 1000 continue
 1200 continue
!
!  end of gather scatter (for this jy slice)
!
!

      return
      end subroutine nssl_2mom_gs
!
!--------------------------------------------------------------------------
!



!
!--------------------------------------------------------------------------
!


END MODULE module_mp_nssl_2mom

param.F         1587934976  1602  20    100644  201546    `

      subroutine param(dt,dtlast,stattim,taptim,rsttim,radtim,prcltim,  &
                       cloudvar,rhovar,qname,budname,                   &
                       xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf, &
                       yh,vh,rvh,yf,vf,rvf,xfref,yfref,                 &
                       rds,sigma,rdsf,sigmaf,tauh,taus,zh,mh,rmh,cc1,cc2,tauf,zf,mf,rmf, &
                       zs,gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy,gx,gxu,gy,gyv,  &
                       ntdiag,nqdiag,                                   &
                       reqs_u,reqs_v,reqs_s,reqs_p,                     &
                       nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                       n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,         &
                       sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,         &
                       uw31,uw32,ue31,ue32,us31,us32,un31,un32,         &
                       vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,         &
                       ww31,ww32,we31,we32,ws31,ws32,wn31,wn32)
#ifdef MPI
      use mpi
#endif
      use module_mp_thompson
      use module_mp_graupel
      use module_mp_nssl_2mom, only:    &
                        nssl_2mom_init, &
                        rho_qr,         &
                        cnor,           &
                        rho_qs,         &
                        cnos,           &
                        rho_qh,         &
                        cnoh,           &
                        ccn,            &
                        infall,         &
                        alphah,         &
                        alphahl,        &
                        imurain,        &
                        icdx,           &
                        icdxhl,         &
                        dfrz,           &
                        hldnmn,         &
                        iferwisventr,   &
                        iehw,iehlw,     &
                        ehw0,ehlw0,     &
                        dmrauto,        &
                        ioldlimiter
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real :: dt,dtlast
      double precision :: stattim,taptim,rsttim,radtim,prcltim
      logical, dimension(maxq) :: cloudvar,rhovar
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh,ruh
      real, dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf,ruf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: yf,vf,rvf
      real, dimension(-2:nx+4) :: xfref
      real, dimension(-2:ny+4) :: yfref
      real, dimension(kb:ke) :: rds,sigma
      real, dimension(kb:ke+1) :: rdsf,sigmaf
      real, dimension(ib:ie,jb:je,kb:ke) :: tauh,taus,zh,mh,rmh,cc1,cc2
      real, dimension(ib:ie,jb:je,kb:ke+1) :: tauf,zf,mf,rmf
      real, dimension(ib:ie,jb:je) :: zs
      real, dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      integer, intent(inout) ::ntdiag,nqdiag
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_s,reqs_p
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(cmp,cmp,kmt+1) :: n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, intent(inout), dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32

!-----------------------------------------------------------------------

      integer i,j,k,n,m,nn,kst,ni1,ni2,ni3,nj1,nj2,nj3,nk1,nk2,nk3
      integer ival,jval
      integer iterrain
      integer :: inum
      real :: var
      real :: zfw1d(kb:ke+1), zfs1d(kb:ke+1)
      double precision :: gzc(kb:ke+1), gze(kb:ke+1)
      integer :: nbndlyr    = 0
      real    :: rtop       = 1.0     ! upper level stretch factor
      real    :: ztopstr    = 100000. ! height to start upper level stretching
      real    :: dzmaxtop   = 700.    ! max upper level dz
#ifdef MPI
      character*50 fname
      integer nabor
#endif
      real c1,c2,nominal_dx,nominal_dy,nominal_dz,z1,z2,z3,mult
      real x1,x2,y1,y2
      logical :: doit
      double precision, dimension(:), allocatable :: xfdp,yfdp

      integer, parameter :: bigm = 4   ! highest deriv
      integer, parameter :: bign = 3   ! number of grid points minus 1
      double precision :: x0,b1,b2,b3
      double precision, dimension(0:bign) :: alpha
      ! delta(n,m,nu):
      double precision, dimension(0:bign,-1:bigm,0:bign) :: delta

      namelist /param1/ dx,dy,dz,dtl,timax,run_time,                    &
          tapfrq,rstfrq,statfrq,prclfrq
      namelist /param2/                                                 &
          adapt_dt,irst,rstnum,iconly,                                  &
          hadvordrs,vadvordrs,hadvordrv,vadvordrv,pdscheme,apmasscon,   &
          advwenos,advwenov,idiff,mdiff,difforder,imoist,iturb,         &
          tconfig,bcturbs,dns,                                          &
          irdamp,hrdamp,psolver,nsound,ptype,ihail,iautoc,              &
          icor,pertcor,eqtset,idiss,efall,rterm,                        &
          wbc,ebc,sbc,nbc,bbc,tbc,irbc,roflux,isnd,iwnd,itern,iinit,    &
          irandp,ibalance,iorigin,axisymm,imove,iptra,npt,pdtra,        &
          iprcl,nparcels
      namelist /param3/ kdiff2,kdiff6,fcor,kdiv,alph,rdalpha,zd,xhd,    &
                        umove,vmove,v_t,l_h,lhref1,lhref2,l_inf,ndcnst
      namelist /param4/ stretch_x,dx_inner,dx_outer,nos_x_len,tot_x_len
      namelist /param5/ stretch_y,dy_inner,dy_outer,nos_y_len,tot_y_len
      namelist /param6/ stretch_z,ztop,str_bot,str_top,dz_bot,dz_top
      namelist /param7/ bc_temp,ptc_top,ptc_bot,viscosity,pr_num
      namelist /param8/ var1,var2,var3,var4,var5,var6,var7,var8,var9,var10
      namelist /param9/                                                       &
              output_path,output_basename,output_format,output_filetype,      &
              output_interp,                                                  &
              output_rain,output_sws,output_svs,output_sps,output_srs,        &
              output_sgs,output_sus,output_shs,output_coldpool,               &
              output_sfcflx,output_sfcparams,output_sfcdiags,                 &
              output_psfc,output_zs,output_zh,output_basestate,               &
              output_th,output_thpert,output_prs,output_prspert,              &
              output_pi,output_pipert,output_rho,output_rhopert,output_tke,   &
              output_km,output_kh,                                            &
              output_qv,output_qvpert,output_q,output_dbz,output_buoyancy,    &
              output_u,output_upert,output_uinterp,                           &
              output_v,output_vpert,output_vinterp,output_w,output_winterp,   &
              output_vort,output_pv,output_uh,output_pblten,                  &
              output_dissten,output_dissheat,output_mptend,output_fallvel,    &
              output_nm,output_def,output_turbten,output_impdiften,           &
              output_radten,                                                  &
              restart_format,restart_filetype,                                &
              restart_file_theta,restart_file_dbz,restart_file_th0,           &
              restart_file_prs0,restart_file_pi0,restart_file_rho0,           &
              restart_file_qv0,restart_file_u0,restart_file_v0,               &
              restart_file_zs,restart_file_zh,restart_file_zf,                &
              restart_file_diags,restart_use_theta,restart_reset_frqtim
      namelist /param10/                                                      &
              stat_w,stat_u,stat_v,stat_rmw,stat_pipert,stat_prspert,         &
              stat_thpert,stat_q,                                             &
              stat_tke,stat_km,stat_kh,stat_div,stat_rh,stat_rhi,stat_the,    &
              stat_cloud,stat_sfcprs,stat_wsp,stat_cfl,stat_vort,             &
              stat_tmass,stat_tmois,stat_qmass,stat_tenerg,stat_mo,stat_tmf,  &
              stat_pcn,stat_qsrc
      namelist /param11/                                                      &
              radopt,dtrad,ctrlat,ctrlon,year,month,day,hour,minute,second
      namelist /param12/                                                      &
              isfcflx,sfcmodel,oceanmodel,ipbl,initsfc,                       &
              tsk0,tmn0,xland0,lu0,season,cecd,pertflx,cnstce,cnstcd,         &
              isftcflx,iz0tlnd,oml_hml0,oml_gamma
      namelist /param13/                                                      &
              prcl_th,prcl_t,prcl_prs,prcl_ptra,prcl_q,prcl_nc,               &
              prcl_km,prcl_kh,prcl_tke,prcl_dbz,prcl_b,prcl_vpg,prcl_vort,    &
              prcl_rho,prcl_qsat,prcl_sfc

      NAMELIST /nssl2mom_params/            &
                        rho_qr,         &
                        cnor,           &
                        rho_qs,         &
                        cnos,           &
                        rho_qh,         &
                        cnoh,           &
                        ccn,            &
                        infall,         &
                        alphah,         &
                        alphahl,        &
                        imurain,        &
                        icdx,           &
                        icdxhl,         &
                        dfrz,           &
                        hldnmn,         &
                        iferwisventr,   &
                        iehw,iehlw,     &
                        ehw0,ehlw0,     &
                        dmrauto,        &
                        ioldlimiter

!--------------------------------------------------------------

#ifdef MPI
      IF(procfiles)THEN
        fname='procXXXXXX.print.out'
        write(fname(5:10),100) myid
100     format(i6.6)
        open(unit=10,file=fname,status='unknown')
      ENDIF
#endif

      if(dowr) write(outfile,*) 'Inside PARAM'

#ifndef MPI
!--------------------------------------------------------------

      if(nodex.ne.1 .or. nodey.ne.1)then
        print *
        print *,'  For non-MPI runs, nodex and nodey must be = 1 !'
        print *
        call stopcm1
      endif

#endif
!--------------------------------------------------------------

#ifdef MPI
      if(myid.eq.0)then
#endif

      open(unit=20,file='namelist.input',form='formatted',status='old',    &
           access='sequential',err=8000)
      read(20,nml=param1,err=8001,end=8001)
      read(20,nml=param2,err=8002,end=8002)
      read(20,nml=param3,err=8003,end=8003)
      read(20,nml=param11,err=8011,end=8011)
      read(20,nml=param12,err=8012,end=8012)
      read(20,nml=param4,err=8004,end=8004)
      read(20,nml=param5,err=8005,end=8005)
      read(20,nml=param6,err=8006,end=8006)
      read(20,nml=param7,err=8007,end=8007)
      read(20,nml=param8,err=8008,end=8008)
      read(20,nml=param9,err=8009,end=8009)
      read(20,nml=param10,err=8010,end=8010)
      if( iprcl.eq.1 )then
        read(20,nml=param13,err=8013,end=8013)
      endif
      IF ( ptype .ge. 26 ) THEN
         read(20,nml=nssl2mom_params,err=8051,end=8051)
      ENDIF
      close(unit=20)

#ifdef MPI
      endif

      call MPI_BCAST(dx    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dy    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dz    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dtl   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(timax ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(run_time,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tapfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rstfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(statfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prclfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(adapt_dt ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(irst     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rstnum   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iconly   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(hadvordrs,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(vadvordrs,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(hadvordrv,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(vadvordrv,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(pdscheme ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(apmasscon,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(advwenos ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(advwenov ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(idiff    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(mdiff    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(difforder,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(imoist   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iturb    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tconfig  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(bcturbs  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dns      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(irdamp   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(hrdamp   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(psolver  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nsound   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ptype    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ihail    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iautoc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(icor     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(pertcor  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(eqtset   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(idiss    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(efall    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rterm    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(wbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ebc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(bbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(irbc     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(roflux   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(isnd     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iwnd     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(itern    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iinit    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(irandp   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ibalance ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iorigin  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(axisymm  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(imove    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iptra    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(npt      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(pdtra    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iprcl    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nparcels ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(kdiff2 ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kdiff6 ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(fcor   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kdiv   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(alph   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rdalpha,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(zd     ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(xhd    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(umove  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(vmove  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(v_t    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(l_h    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(lhref1 ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(lhref2 ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(l_inf  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ndcnst ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(stretch_x,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dx_inner ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dx_outer ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nos_x_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tot_x_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(stretch_y,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dy_inner ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dy_outer ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nos_y_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tot_y_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(stretch_z,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ztop     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(str_bot  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(str_top  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dz_bot   ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dz_top   ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(bc_temp  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ptc_top  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ptc_bot  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(viscosity,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(pr_num   ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(var1     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var2     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var3     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var4     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var5     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var6     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var7     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var8     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var9     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(var10    ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(output_path    ,70,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_basename,70,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_format  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_filetype,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_interp ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_rain   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sws    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_svs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sps    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_srs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sgs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sus    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_shs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_coldpool,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sfcflx ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sfcparams,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_sfcdiags,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_psfc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_zs     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_zh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_basestate,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_th     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_thpert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_prs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_prspert,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_pi     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_pipert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_rho    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_rhopert,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_tke    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_km     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_kh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_qv     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_qvpert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_q      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_dbz    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_buoyancy,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_u      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_upert  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_uinterp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_v      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_vpert  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_vinterp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_w      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_winterp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_vort   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_pv     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_uh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_pblten ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_dissten,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_dissheat,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_mptend  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_fallvel ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_nm     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_def    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_turbten,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_impdiften,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(output_radten ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(restart_format      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_filetype    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_theta  ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_dbz    ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_th0    ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_prs0   ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_pi0    ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_rho0   ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_qv0    ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_u0     ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_v0     ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_zs     ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_zh     ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_zf     ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_file_diags  ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_use_theta   ,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(restart_reset_frqtim,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(stat_w      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_u      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_v      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_rmw    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_pipert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_prspert,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_thpert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_q      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_tke    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_km     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_kh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_div    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_rh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_rhi    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_the    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_cloud  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_sfcprs ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_wsp    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_cfl    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_vort   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_tmass  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_tmois  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_qmass  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_tenerg ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_mo     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_tmf    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_pcn    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stat_qsrc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(prcl_th     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_t      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_prs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_ptra   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_q      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_nc     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_km     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_kh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_tke    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_dbz    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_b      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_vpg    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_vort   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_rho    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_qsat   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcl_sfc    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(radopt   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dtrad  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ctrlat ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ctrlon ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(year   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(month  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(day    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(hour   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(minute ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(second ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

      call MPI_BCAST(isfcflx   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfcmodel  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(oceanmodel,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ipbl      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(initsfc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tsk0      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(tmn0      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(xland0    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(lu0       ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(season    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cecd      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(pertflx   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cnstce    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cnstcd    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(isftcflx  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iz0tlnd   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(oml_hml0  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(oml_gamma ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)

      IF ( ptype .ge. 26 ) THEN
      call MPI_BCAST(ccn       ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rho_qr    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cnor      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rho_qs    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cnos      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rho_qh    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cnoh      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(alphah    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(alphahl   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dfrz      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(hldnmn    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(infall    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(icdx      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(icdxhl    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(imurain   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iferwisventr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iehw      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(iehlw     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ehw0      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ehlw0     ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dmrauto   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ioldlimiter,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      ENDIF
#endif

!-----------------------------------------------------------------------
!  Some "dummy" checks:

      eqtset = max( eqtset , 1 )
      eqtset = min( eqtset , 2 )
      if(imoist.ne.1) efall=0
      if(imove.eq.0) umove=0.0
      if(imove.eq.0) vmove=0.0
      irst = max( irst , 0 )
      irst = min( irst , 1 )

      IF( nk.lt.5 )THEN
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        if(myid.eq.0)then
        print *,'  nk = ',nk
        print *,'  nk must be >= 5 '
        endif
        call stopcm1
      ENDIF

!------------------------------------------------
!  begin non-fatal checks:

      IF( hadvordrs.lt.5 .or. hadvordrs.gt.6 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  hadvordrs = ',hadvordrs
        print *
        print *,'  This value is invalid ... setting to 5 '
        print *
        print *,'  -------------------------------- '
        endif
        hadvordrs = 5
      ENDIF
      IF( hadvordrv.lt.5 .or. hadvordrv.gt.6 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  hadvordrv = ',hadvordrv
        print *
        print *,'  This value is invalid ... setting to 5 '
        print *
        print *,'  -------------------------------- '
        endif
        hadvordrv = 5
      ENDIF
      IF( vadvordrs.lt.5 .or. vadvordrs.gt.6 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  vadvordrs = ',vadvordrs
        print *
        print *,'  This value is invalid ... setting to 5 '
        print *
        print *,'  -------------------------------- '
        endif
        vadvordrs = 5
      ENDIF
      IF( vadvordrv.lt.5 .or. vadvordrv.gt.6 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  vadvordrv = ',vadvordrv
        print *
        print *,'  This value is invalid ... setting to 5 '
        print *
        print *,'  -------------------------------- '
        endif
        vadvordrv = 5
      ENDIF
      IF( sfcmodel.ge.1 )THEN
        IF( oceanmodel.le.0 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  sfcmodel = ',sfcmodel
        print *
        print *,'  but oceanmodel = ',oceanmodel
        print *
        print *,'  setting oceanmodel to 1  (just in case its needed) '
        print *
        print *,'  -------------------------------- '
        endif
        oceanmodel = 1
        ENDIF
      ENDIF
      IF( (sfcmodel.ge.1) .or. (oceanmodel.eq.2) .or. (ipbl.ge.1) )then
        IF( bbc.ne.3 .and. dns.eq.0 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  sfcmodel   = ',sfcmodel
        print *,'  oceanmodel = ',oceanmodel
        print *,'  ipbl       = ',ipbl
        print *
        print *,'  at least one of these options requires bbc = 3 '
        print *,'  ... so, setting bbc to 3 '
        print *
        print *,'  -------------------------------- '
        endif
        bbc = 3
        ENDIF
      ENDIF
      IF( irst.eq.1 .and. iinit.ne.0 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  irst       = ',irst
        print *,'  iinit      = ',iinit
        print *
        print *,'  This is a restart. '
        print *,'  so, setting iinit to 0 '
        print *
        print *,'  -------------------------------- '
        endif
        iinit = 0
      ENDIF
      IF( irst.eq.1 .and. irandp.ne.0 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  irst       = ',irst
        print *,'  irandp     = ',irandp
        print *
        print *,'  This is a restart. '
        print *,'  so, setting irandp to 0 '
        print *
        print *,'  -------------------------------- '
        endif
        irandp = 0
      ENDIF
      IF( (sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4) .and. isfcflx.eq.0 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  sfcmodel   = ',sfcmodel
        print *,'  isfcflx    = ',isfcflx
        print *
        print *,'  sfcmodel=2,3,4 requires isfcflx=1 '
        print *,'  so, setting isfcflx to 1 '
        print *
        print *,'  -------------------------------- '
        endif
        isfcflx = 1
      ENDIF
      IF( (psolver.eq.4.or.psolver.eq.5.or.psolver.eq.6) .and. eqtset.eq.2 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  psolver    = ',psolver
        print *,'  eqtset     = ',eqtset
        print *
        print *,'  psolver=4,5,6 requires eqtset=1 '
        print *,'  ... setting eqtset to 1 ... '
        print *
        print *,'  -------------------------------- '
        endif
        eqtset = 1
      ENDIF
      IF( (psolver.eq.4.or.psolver.eq.5.or.psolver.eq.6) .and. apmasscon.eq.1 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  psolver    = ',psolver
        print *,'  apmasscon  = ',apmasscon
        print *
        print *,'  psolver=4,5,6 requires apmasscon=0 '
        print *,'  ... setting apmasscon to 0 ... '
        print *
        print *,'  -------------------------------- '
        endif
        apmasscon = 0
      ENDIF
      IF( restart_use_theta )THEN
      IF( .not. restart_file_theta )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  restart_use_theta = ',restart_use_theta
        print *
        print *,'  ... setting restart_file_theta to true ... '
        print *
        print *,'  -------------------------------- '
        endif
        restart_file_theta = .true.
      ENDIF
      ENDIF
#ifndef MPI
      IF( restart_filetype.ge.3 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  Single processor run: '
        print *
        print *,'  restart_filetype >= 3 not available '
        print *
        print *,'  ... setting restart_filetype to 2 ... '
        print *
        print *,'  -------------------------------- '
        endif
        restart_filetype = 2
      ENDIF
#endif
      IF( restart_format.eq.1 .and. restart_filetype.eq.1 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  binary-format restart file: '
        print *
        print *,'  restart_filetype = 1 not available '
        print *
        print *,'  ... setting restart_filetype to 2 ... '
        print *
        print *,'  -------------------------------- '
        endif
        restart_filetype = 2
      ENDIF
#ifdef NETCDF
      IF( restart_format.eq.2 .and. restart_filetype.ge.3 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  netcdf-format restart file: '
        print *
        print *,'  restart_filetype >= 3 not available '
        print *
        print *,'  ... setting restart_filetype to 2 ... '
        print *
        print *,'  -------------------------------- '
        endif
        restart_filetype = 2
      ENDIF
#endif
      IF( (iturb.eq.3) .and. (tconfig.ne.2) )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  iturb=3  requires  tconfig=2 '
        print *
        print *,'  ... setting tconfig to 2 ... '
        print *
        print *,'  -------------------------------- '
        endif
        tconfig = 2
      ENDIF
      IF( ipbl.ge.1 .and. iturb.eq.3 .and. abs(l_inf).gt.1.0e-6 )THEN
        if(myid.eq.0)then
        print *,'  -------------------------------- '
        print *
        print *,'  ipbl >= 1  requires  l_inf = 0 '
        print *
        print *,'  ... setting l_inf to 0 ... '
        print *
        print *,'  -------------------------------- '
        endif
        l_inf = 0.0
      ENDIF

!  end non-fatal checks:
!------------------------------------------------
!  begin fatal checks  (ie, model stops)

      IF( psolver.lt.1 .or. psolver.gt.6 )THEN
        if(myid.eq.0)then
        print *
        print *,'  psolver  = ',psolver
        print *
        print *,'  invalid value for psolver '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( psolver.eq.1 .and. adapt_dt.eq.1 )THEN
        if(myid.eq.0)then
        print *
        print *,'  psolver  = ',psolver
        print *,'  adapt_dt = ',adapt_dt
        print *
        print *,'  Cannot use adapt_dt with psolver=1 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( psolver.eq.2 .or. psolver.eq.3 )THEN
        IF( nsound.lt.4 )THEN
          if(myid.eq.0)then
          print *
          print *,'  nsound = ',nsound
          print *
          print *,'  nsound must be >= 4 '
          print *
          print *,'   stopping model .... '
          print *
          endif
#ifdef MPI
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1
        ENDIF
        IF( mod(nsound,2).ne.0 )THEN
          if(myid.eq.0)then
          print *
          print *,'  nsound = ',nsound
          print *
          print *,'  nsound must be an even integer '
          print *
          print *,'   stopping model .... '
          print *
          endif
#ifdef MPI
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1
        ENDIF
      ENDIF
      IF(dns.gt.1.or.dns.lt.0)THEN
        if(myid.eq.0)then
        print *
        print *,'  dns   = ',dns
        print *
        print *,'  dns must be either 0 or 1'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(sfcmodel.eq.1)THEN
      IF(cecd.lt.1.or.cecd.gt.3)THEN
        if(myid.eq.0)then
        print *
        print *,'  cecd  = ',cecd
        print *
        print *,'  cecd must be 1,2,3'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      ENDIF
      IF(iturb.gt.3.or.iturb.lt.0)THEN
        if(myid.eq.0)then
        print *
        print *,'  iturb   = ',iturb
        print *
        print *,'  iturb must be either 0, 1, 2, or 3'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(iturb.ge.1 .and. dns.ge.1)THEN
        if(myid.eq.0)then
        print *
        print *,'  iturb = ',iturb
        print *,'  dns   = ',dns
        print *
        print *,'  For dns = 1, iturb must be 0'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(iturb.ge.1 .and. (idiff.eq.1.and.difforder.eq.2))THEN
        if(myid.eq.0)then
        print *
        print *,'  iturb     = ',iturb
        print *,'  idiff     = ',idiff
        print *,'  difforder = ',difforder
        print *
        print *,'  For idiff=1 with difforder=2, iturb > 0 cannot be used '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(bcturbs.lt.1.or.bcturbs.gt.2)THEN
        if(myid.eq.0)then
        print *
        print *,'  bcturbs = ',bcturbs
        print *
        print *,'  bcturbs must be 1 or 2'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(dns.ge.1 .and. imoist.ge.1)THEN
        if(myid.eq.0)then
        print *
        print *,'  imoist = ',imoist
        print *,'  dns    = ',dns
        print *
        print *,'  For dns = 1, imoist must be 0'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(imoist.eq.1 .and. (             isnd.eq.2   &
                        .or.isnd.eq.3.or.isnd.eq.8.) )THEN
        if(myid.eq.0)then
        print *
        print *,'  imoist = ',imoist
        print *,'  isnd   = ',isnd
        print *
        print *,'  For this value of isnd, imoist must be 0'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( bbc.lt.1 .or. bbc.gt.3 )THEN
        if(myid.eq.0)then
        print *
        print *,'  bbc = ',bbc
        print *
        print *,'  bbc must be 1, 2, or 3'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( tbc.lt.1 .or. tbc.gt.2 )THEN
        if(myid.eq.0)then
        print *
        print *,'  tbc = ',tbc
        print *
        print *,'  tbc must be 1 or 2'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(dns.eq.1 .and. (bc_temp.le.0 .or. bc_temp.ge.3))THEN
        if(myid.eq.0)then
        print *
        print *,'  dns     = ',dns
        print *,'  bc_temp = ',bc_temp
        print *
        print *,'  for dns = 1, bc_temp must be either 1 or 2'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(ihail.lt.0.or.ihail.gt.1)THEN
        if(myid.eq.0)then
        print *
        print *,'  ihail   = ',ihail
        print *
        print *,'  ihail must be 0 or 1'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(imoist.eq.1.and.output_dbz.eq.1.and.ptype.ne.2.and.ptype.ne.3.and.ptype.ne.5  &
          .and. (.not. ptype.ge.26))then
        if(myid.eq.0)then
        print *
        print *,'  ptype      = ',ptype
        print *,'  output_dbz = ',output_dbz
        print *
        print *,'  output_dbz is only available for ptype=2,3,5,26,27,28'
        print *
        endif
        IF(ptype.eq.4)THEN
          print *,'   stopping model .... '
          print *
#ifdef MPI
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1
        ELSE
          output_dbz = 0
        ENDIF
      ENDIF
      IF(imoist.eq.1 .and. eqtset.ge.2 .and. ptype.eq.4)THEN
        if(myid.eq.0)then
        print *
        print *,'  eqtset  = ',eqtset
        print *,'  ptype   = ',ptype
        print *
        print *,'  eqtset = 2 is not available for ptype = 4'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(imoist.eq.1 .and. efall.eq.1)THEN
      IF(ptype.ne.1.and.ptype.ne.2.and.ptype.ne.5.and.ptype.ne.6)THEN
        if(myid.eq.0)then
        print *
        print *,'  efall   = ',efall
        print *,'  ptype   = ',ptype
        print *
        print *,'  efall = 1 is only supported with ptype = 1,2,5,6'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      ENDIF
      IF((imoist.eq.1).and.(ptype.eq.4).and.terrain_flag)THEN
        if(myid.eq.0)then
        print *
        print *,'  ptype   = ',ptype
        print *,'  terrain_flag = ',terrain_flag
        print *
        print *,'  ptype = 4 does not work with terrain '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(imoist.eq.1 .and. ndcnst.le.1.0e-6)THEN
        if(myid.eq.0)then
        print *
        print *,'  imoist  = ',imoist
        print *,'  ndcnst  = ',ndcnst
        print *
        print *,'  ndcnst is too small.  Please enter a larger value '
        print *,'  in the param3 section of namelist.input '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(terrain_flag .and. (iprcl.ne.0) )THEN
        if(myid.eq.0)then
        print *
        print *,'  terrain_flag = ',terrain_flag
        print *,'  iprcl        = ',iprcl
        print *
        print *,'  cannot use parcels with terrain (for now) '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(terrain_flag .and. (psolver.eq.4.or.psolver.eq.5) )THEN
        if(myid.eq.0)then
        print *
        print *,'  terrain_flag = ',terrain_flag
        print *,'  psolver      = ',psolver
        print *
        print *,'  for psolver = 4,5 terrain_flag must be .false.'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (psolver.eq.4.or.psolver.eq.5) .and.    &
          (wbc.eq.2.or.ebc.eq.2.or.sbc.eq.2.or.nbc.eq.2) )THEN
        if(myid.eq.0)then
        print *
        print *,'  psolver = ',psolver
        print *
        print *,'  cannot use open boundary conditions for psolver = 4 and 5 (at the moment)'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(terrain_flag .and. ibalance.eq.2)THEN
        if(myid.eq.0)then
        print *
        print *,'  terrain_flag = ',terrain_flag
        print *,'  ibalance     = ',ibalance
        print *
        print *,'  for ibalance.eq.2, terrain_flag must be .false.'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(iinit.eq.6)THEN
        if(myid.eq.0)then
        print *
        print *,'  iinit        = ',iinit
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (output_format.le.0) .or. (output_format.ge.6) )THEN
        if(myid.eq.0)then
        print *
        print *,'  output_format = ',output_format
        print *
        print *,'  only output_format = 1,2,3,4,5 are currently supported'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (axisymm.eq.1) .and. (iorigin.ne.1) )THEN
        if(myid.eq.0)then
        print *
        print *,'  iorigin = ',iorigin
        print *
        print *,'  axisymm=1 requires iorigin=1'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (axisymm.eq.1) .and. (imove.ne.0) )THEN
        if(myid.eq.0)then
        print *
        print *,'  imove = ',imove
        print *
        print *,'  axisymm=1 requires imove=0'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( terrain_flag .and. (imove.ne.0) )THEN
        if(myid.eq.0)then
        print *
        print *,'  imove = ',imove
        print *
        print *,'  imove must be 0 when using terrain '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (axisymm.eq.1) .and. terrain_flag )THEN
        if(myid.eq.0)then
        print *
        print *,'  terrain_flag = ',terrain_flag
        print *
        print *,'  axisymm=1 cannot be used with terrain '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( icor.eq.0 ) fcor = 0.0
      IF( (axisymm.eq.1) .and. (wbc.ne.3) )THEN
        if(myid.eq.0)then
        print *
        print *,'  wbc = ',wbc
        print *
        print *,'  axisymm=1 requires wbc=3 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (axisymm.eq.1) .and. ( (sbc.ne.1).or.(nbc.ne.1) ) )THEN
        if(myid.eq.0)then
        print *
        print *,'  sbc = ',sbc
        print *,'  nbc = ',nbc
        print *
        print *,'  axisymm=1 requires sbc=nbc=1 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (axisymm.eq.1).and.(ny.gt.1) )THEN
        if(myid.eq.0)then
        print *
        print *,'  ny = ',ny
        print *
        print *,'  axisymm=1 requires ny=1'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (axisymm.eq.1.and.iturb.ge.1).and.iturb.ne.3 )THEN
        if(myid.eq.0)then
        print *
        print *,'  iturb    = ',iturb
        print *
        print *,'  axisymm=1 is only available with iturb=3'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( axisymm.eq.1.and.(psolver.eq.1.or.psolver.eq.4.or.psolver.eq.5) )THEN
        if(myid.eq.0)then
        print *
        print *,'  psolver    = ',psolver
        print *
        print *,'  axisymm=1 is only available with psolver=2,3,6'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( axisymm.eq.1 .and. idiff.eq.1 .and. difforder.eq.6 )THEN
        idiff = 0
        difforder = 0
      ENDIF
      IF( (bbc.eq.3) .and. (sfcmodel.le.0) )THEN
        if(myid.eq.0)then
        print *
        print *,'  bbc      = ',bbc
        print *,'  sfcmodel = ',sfcmodel
        print *
        print *,'  bbc=3 requires a setting for sfcmodel '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (bbc.eq.3).or.(isfcflx.eq.1) )THEN
      IF( iturb.eq.0 .and. ipbl.eq.0 .and. dns.ne.1 .and. idiff.ne.1 )THEN
        if(myid.eq.0)then
        print *
        print *,'  bbc      = ',bbc
        print *,'  isfcflx  = ',isfcflx
        print *
        print *,'  these options require the use of a vertical diffusion/turbulence scheme'
        print *
        print *,'  iturb    = ',iturb
        print *,'  dns      = ',dns
        print *,'  ipbl     = ',ipbl
        print *,'  idiff    = ',idiff
        print *
        print *,'  Use iturb = 1,2,3 or ipbl = 1,2 or idiff = 1'
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      ENDIF
      IF( ipbl.ge.1 .and. (iturb.eq.1.or.iturb.eq.2) )THEN
        if(myid.eq.0)then
        print *
        print *,'  ipbl  = ',ipbl
        print *,'  iturb = ',iturb
        print *
        print *,'  cannot use PBL scheme and LES subgrid turbulence scheme at same time '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( isfcflx.ne.0 )THEN
      IF( sfcmodel.lt.1 .or. sfcmodel.gt.4 )THEN
        if(myid.eq.0)then
        print *
        print *,'  sfcmodel   = ',sfcmodel
        print *
        print *,'  sfcmodel must be 1,2,3,4 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      ENDIF
      IF( (sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4).and.imove.ne.0 )THEN
        if(myid.eq.0)then
        print *
        print *,'  sfcmodel  = ',sfcmodel
        print *,'  imove     = ',imove
        print *
        print *,'  domain translation is now allowed with sfcmodel = 2,3,4 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4).and.(season.le.0.or.season.ge.3) )THEN
        if(myid.eq.0)then
        print *
        print *,'  sfcmodel = ',sfcmodel
        print *,'  season   = ',season
        print *
        print *,'  season must have a value of 1 or 2 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( pertflx.eq.1 .and. sfcmodel.ge.2 )THEN
        if(myid.eq.0)then
        print *
        print *,'  pertflx  = ',pertflx
        print *,'  sfcmodel = ',sfcmodel
        print *
        print *,'  pertflx can only be used with sfcmodel = 1  '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( sfcmodel.eq.1 .and. oceanmodel.ne.1 )THEN
        if(myid.eq.0)then
        print *
        print *,'  sfcmodel   = ',sfcmodel
        print *,'  oceanmodel = ',oceanmodel
        print *
        print *,'  sfcmodel = 1 requires oceanmodel = 1 '
        print *,'  (oceanmodel = 2 requires sfcmodel = 2 ) '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( radopt.lt.0 .or. radopt.gt.1 )THEN
        if(myid.eq.0)then
        print *
        print *,'  radopt   = ',radopt
        print *
        print *,'  radopt must be 0,1 '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (radopt.eq.1.or.radopt.eq.2) .and. imoist.eq.0 )THEN
        if(myid.eq.0)then
        print *
        print *,'  radopt   = ',radopt
        print *,'  imoist   = ',imoist
        print *
        print *,'  radopt=1 requires imoist=1 (for now) '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( ipbl.ge.1 .and. imoist.eq.0 )THEN
        if(myid.eq.0)then
        print *
        print *,'  ipbl     = ',ipbl
        print *,'  imoist   = ',imoist
        print *
        print *,'  ipbl=1,2 requires imoist=1 (for now) '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (radopt.eq.1.or.radopt.eq.2) .and. rterm.eq.1 )THEN
        if(myid.eq.0)then
        print *
        print *,'  radopt   = ',radopt
        print *,'  rterm    = ',rterm
        print *
        print *,'  cannot use radopt and rterm at the same time '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (radopt.eq.1.or.radopt.eq.2) .and. (ptype.eq.1.or.ptype.eq.6)  )THEN
        if(myid.eq.0)then
        print *
        print *,'  radopt   = ',radopt
        print *,'  ptype    = ',ptype
        print *
        print *,'  radopt=1 requires an ice microphysics scheme (for now) '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (radopt.eq.1.or.radopt.eq.2) .and. sfcmodel.eq.0 )THEN
        if(myid.eq.0)then
        print *
        print *,'  radopt   = ',radopt
        print *,'  sfcmodel = ',sfcmodel
        print *
        print *,'  radopt=1 requires a surface model '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF( (sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4) .and. imoist.eq.0 )THEN
        if(myid.eq.0)then
        print *
        print *,'  sfcmodel = ',sfcmodel
        print *,'  imoist   = ',imoist
        print *
        print *,'  sfcmodel=2,3,4 requires imoist=1 (for now) '
        print *
        print *,'   stopping model .... '
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
#ifndef NETCDF
      IF(output_format.eq.2)THEN
        if(myid.eq.0)then
        print *
        print *,'  output_format = ',output_format
        print *
        print *,'  You have requested netcdf output, but you have not'
        print *,'  compiled the code with netcdf capability.  Modify the'
        print *,'  Makefile, clean, and recompile'
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
      IF(restart_format.eq.2)THEN
        if(myid.eq.0)then
        print *
        print *,'  restart_format = ',restart_format
        print *
        print *,'  You have requested netcdf restart files, but you have not'
        print *,'  compiled the code with netcdf capability.  Modify the'
        print *,'  Makefile, clean, and recompile'
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
#endif
#ifdef NETCDF
      IF( terrain_flag .and. output_interp.ne.0 .and. output_format.eq.2 )THEN
        if(myid.eq.0)then
        print *
        print *,'  output_interp = ',output_interp
        print *
        print *,'  output_interp=1 is not currently available for netcdf output'
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
#endif
#ifndef HDFOUT
      IF(output_format.eq.3.or.output_format.eq.4.or.output_format.eq.5)THEN
        if(myid.eq.0)then
        print *
        print *,'  output_format = ',output_format
        print *
        print *,'  You have requested hdf output, but you have not'
        print *,'  compiled the code with hdf capability.  Modify the'
        print *,'  Makefile, clean, and recompile'
        print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF
#endif
#ifdef MPI
      IF(psolver.eq.4.or.psolver.eq.5)THEN
        if(myid.eq.0)then
        print *
        print *,'  psolver = ',psolver
        print *
        print *,'  psolver = 4 and 5 are not supported in MPI mode'
        print *
        print *,'   stopping model .... '
        print *
        endif
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
        call stopcm1
      ENDIF
      IF(axisymm.eq.1)THEN
        if(myid.eq.0)then
        print *
        print *,'  axisymm = ',axisymm
        print *
        print *,'  axisymm is not supported in MPI mode'
        print *
        print *,'   stopping model .... '
        print *
        endif
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
        call stopcm1
      ENDIF
      IF(ny.lt.3)THEN
        if(myid.eq.0)then
        print *
        print *,'  ny = ',ny
        print *
        print *,'  ny must be .ge. 3 for  MPI runs'
        print *
        print *,'   stopping model .... '
        print *
        endif
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
        call stopcm1
      ENDIF
#endif


!--------------------------------------------------------------
!  Check domain size (MPI only)
#ifdef MPI

        if((nodex*nodey).ne.numprocs)then
          if(myid.eq.0)then
          print *
          print *,'  WARNING!!! '
          print *,'  nodes does not equal numprocs!'
          print *,'  nodex,nodey,nodes=',nodex,nodey,nodex*nodey
          print *,'  numprocs=',numprocs
          print *
          endif
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
          call stopcm1
        endif

        if(mod(nx,nodex).ne.0)then
          if(myid.eq.0)then
          print *
          print *,'  nx does not divide exactly by nodex! '
          print *,'  nx,nodex,mod(nx,nodex)=',nx,nodex,mod(nx,nodex)
          print *
          endif
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
          call stopcm1
        endif

        if(mod(ny,nodey).ne.0)then
          if(myid.eq.0)then
          print *
          print *,'  ny does not divide exactly by nodey! '
          print *,'  ny,nodey,mod(ny,nodey)=',ny,nodey,mod(ny,nodey)
          print *
          endif
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
          call stopcm1
        endif

        IF( (ni.lt.3).or.(nj.lt.3) )THEN
          if(myid.eq.0)then
          print *
          print *,'  ni = ',ni
          print *,'  nj = ',nj
          print *,'  both ni and nj must be >= 3 '
          print *
          endif
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
          call stopcm1
        ENDIF

        ppnode = min( ppnode , nodex*nodey )

        if(mod(nodex*nodey,ppnode).ne.0)then
          if(myid.eq.0)then
          print *
          print *,'  nodex*nodey does not divide exactly by ppnode! '
          print *,'  nodex*nodey,ppnode=',nodex*nodey,ppnode
          print *
          endif
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
          call stopcm1
        endif

      if(myid.eq.0)then

        print *
        print *,'  Everything is cool!'
        print *,'  ni,nj=',ni,nj
        print *

      endif

#endif
!--------------------------------------------------------------
!  Check that lateral bc combinations make sense:

      if(ebc.eq.1 .and. wbc.ne.1)then
        print *,"Can not have periodic b.c.'s on one side only!"
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      endif
      if(wbc.eq.1 .and. ebc.ne.1)then
        print *,"Can not have periodic b.c.'s on one side only!"
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      endif
      if(nbc.eq.1 .and. sbc.ne.1)then
        print *,"Can not have periodic b.c.'s on one side only!"
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      endif
      if(sbc.eq.1 .and. nbc.ne.1)then
        print *,"Can not have periodic b.c.'s on one side only!"
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      endif

!  end fatal checks  (ie, model stops)
!--------------------------------------------------------------
!  Some basic checks:

      ! for passive tracers:
      iptra    = max(0,min(1,iptra))
      if(iptra.eq.1)then
        npt      = max(1,npt)
      else
        npt      = 1
      endif

      ! for parcels:
      nparcels = max(1,nparcels)

!-----

      if(stretch_z.lt.1) ztop = dz*float(nk)
      IF ( stretch_z == 2 ) dz = ztop/float(nk) ! nk is the number of scalar levels

      IF( advwenos.eq.2 )THEN
        hadvordrs = 5
        vadvordrs = 5
      ENDIF
      IF( advwenos.lt.0 .or. advwenos.gt.2 )THEN
        print *
        print *,'  advwenos = ',advwenos
        print *
        print *,'  unrecognized value for advwenos '
        print *
        print *,'   stopping model .... '
        print *
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF

      !-----

      IF( advwenov.eq.2 )THEN
        hadvordrv = 5
        vadvordrv = 5
      ENDIF
      IF( advwenov.lt.0 .or. advwenov.gt.2 )THEN
        print *
        print *,'  advwenov = ',advwenov
        print *
        print *,'  unrecognized value for advwenov '
        print *
        print *,'   stopping model .... '
        print *
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF

!--------------------------------------------------------------

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'dx        =',dx
      if(dowr) write(outfile,*) 'dy        =',dy
      if(dowr) write(outfile,*) 'dz        =',dz
      if(dowr) write(outfile,*) 'dtl       =',dtl
      if(dowr) write(outfile,*) 'timax     =',timax
      if(dowr) write(outfile,*) 'run_time  =',run_time
      if(dowr) write(outfile,*) 'tapfrq    =',tapfrq
      if(dowr) write(outfile,*) 'rstfrq    =',rstfrq
      if(dowr) write(outfile,*) 'statfrq   =',statfrq
      if(dowr) write(outfile,*) 'prclfrq   =',prclfrq
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'adapt_dt  =',adapt_dt
      if(dowr) write(outfile,*) 'irst      =',irst
      if(dowr) write(outfile,*) 'rstnum    =',rstnum
      if(dowr) write(outfile,*) 'iconly    =',iconly
      if(dowr) write(outfile,*) 'hadvordrs =',hadvordrs
      if(dowr) write(outfile,*) 'vadvordrs =',vadvordrs
      if(dowr) write(outfile,*) 'hadvordrv =',hadvordrv
      if(dowr) write(outfile,*) 'vadvordrv =',vadvordrv
      if(dowr) write(outfile,*) 'pdscheme  =',pdscheme
      if(dowr) write(outfile,*) 'apmasscon =',apmasscon
      if(dowr) write(outfile,*) 'advwenos  =',advwenos
      if(dowr) write(outfile,*) 'advwenov  =',advwenov
      if(dowr) write(outfile,*) 'idiff     =',idiff
      if(dowr) write(outfile,*) 'mdiff     =',mdiff
      if(dowr) write(outfile,*) 'difforder =',difforder
      if(dowr) write(outfile,*) 'imoist    =',imoist
      if(dowr) write(outfile,*) 'iturb     =',iturb
      if(dowr) write(outfile,*) 'tconfig   =',tconfig
      if(dowr) write(outfile,*) 'bcturbs   =',bcturbs
      if(dowr) write(outfile,*) 'dns       =',dns
      if(dowr) write(outfile,*) 'irdamp    =',irdamp
      if(dowr) write(outfile,*) 'hrdamp    =',hrdamp
      if(dowr) write(outfile,*) 'psolver   =',psolver
      if(dowr) write(outfile,*) 'nsound    =',nsound
      if(dowr) write(outfile,*) 'ptype     =',ptype
      if(dowr) write(outfile,*) 'ihail     =',ihail
      if(dowr) write(outfile,*) 'iautoc    =',iautoc
      if(dowr) write(outfile,*) 'icor      =',icor
      if(dowr) write(outfile,*) 'pertcor   =',pertcor
      if(dowr) write(outfile,*) 'eqtset    =',eqtset
      if(dowr) write(outfile,*) 'idiss     =',idiss
      if(dowr) write(outfile,*) 'efall     =',efall
      if(dowr) write(outfile,*) 'rterm     =',rterm
      if(dowr) write(outfile,*) 'wbc       =',wbc
      if(dowr) write(outfile,*) 'ebc       =',ebc
      if(dowr) write(outfile,*) 'sbc       =',sbc
      if(dowr) write(outfile,*) 'nbc       =',nbc
      if(dowr) write(outfile,*) 'bbc       =',bbc
      if(dowr) write(outfile,*) 'tbc       =',tbc
      if(dowr) write(outfile,*) 'irbc      =',irbc
      if(dowr) write(outfile,*) 'roflux    =',roflux
      if(dowr) write(outfile,*) 'isnd      =',isnd
      if(dowr) write(outfile,*) 'iwnd      =',iwnd
      if(dowr) write(outfile,*) 'itern     =',itern
      if(dowr) write(outfile,*) 'iinit     =',iinit
      if(dowr) write(outfile,*) 'irandp    =',irandp
      if(dowr) write(outfile,*) 'ibalance  =',ibalance
      if(dowr) write(outfile,*) 'iorigin   =',iorigin
      if(dowr) write(outfile,*) 'axisymm   =',axisymm
      if(dowr) write(outfile,*) 'imove     =',imove
      if(dowr) write(outfile,*) 'iptra     =',iptra
      if(dowr) write(outfile,*) 'npt       =',npt
      if(dowr) write(outfile,*) 'pdtra     =',pdtra
      if(dowr) write(outfile,*) 'iprcl     =',iprcl
      if(dowr) write(outfile,*) 'nparcels  =',nparcels
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'kdiff2    =',kdiff2
      if(dowr) write(outfile,*) 'kdiff6    =',kdiff6
      if(dowr) write(outfile,*) 'fcor      =',fcor
      if(dowr) write(outfile,*) 'kdiv      =',kdiv
      if(dowr) write(outfile,*) 'alph      =',alph
      if(dowr) write(outfile,*) 'rdalpha   =',rdalpha
      if(dowr) write(outfile,*) 'zd        =',zd
      if(dowr) write(outfile,*) 'xhd       =',xhd
      if(dowr) write(outfile,*) 'umove     =',umove
      if(dowr) write(outfile,*) 'vmove     =',vmove
      if(dowr) write(outfile,*) 'v_t       =',v_t
      if(dowr) write(outfile,*) 'l_h       =',l_h
      if(dowr) write(outfile,*) 'lhref1    =',lhref1
      if(dowr) write(outfile,*) 'lhref2    =',lhref2
      if(dowr) write(outfile,*) 'l_inf     =',l_inf
      if(dowr) write(outfile,*) 'ndcnst    =',ndcnst
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'radopt    =',radopt
      if(dowr) write(outfile,*) 'dtrad     =',dtrad
      if(dowr) write(outfile,*) 'ctrlat    =',ctrlat
      if(dowr) write(outfile,*) 'ctrlon    =',ctrlon
      if(dowr) write(outfile,*) 'year      =',year
      if(dowr) write(outfile,*) 'month     =',month
      if(dowr) write(outfile,*) 'day       =',day
      if(dowr) write(outfile,*) 'hour      =',hour
      if(dowr) write(outfile,*) 'minute    =',minute
      if(dowr) write(outfile,*) 'second    =',second
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'isfcflx   =',isfcflx
      if(dowr) write(outfile,*) 'sfcmodel  =',sfcmodel
      if(dowr) write(outfile,*) 'oceanmodel=',oceanmodel
      if(dowr) write(outfile,*) 'ipbl      =',ipbl
      if(dowr) write(outfile,*) 'initsfc   =',initsfc
      if(dowr) write(outfile,*) 'tsk0      =',tsk0
      if(dowr) write(outfile,*) 'tmn0      =',tmn0
      if(dowr) write(outfile,*) 'xland0    =',xland0
      if(dowr) write(outfile,*) 'lu0       =',lu0
      if(dowr) write(outfile,*) 'season    =',season
      if(dowr) write(outfile,*) 'cecd      =',cecd
      if(dowr) write(outfile,*) 'pertflx   =',pertflx
      if(dowr) write(outfile,*) 'cnstce    =',cnstce
      if(dowr) write(outfile,*) 'cnstcd    =',cnstcd
      if(dowr) write(outfile,*) 'isftcflx  =',isftcflx
      if(dowr) write(outfile,*) 'iz0tlnd   =',iz0tlnd
      if(dowr) write(outfile,*) 'oml_hml0  =',oml_hml0
      if(dowr) write(outfile,*) 'oml_gamma =',oml_gamma
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'stretch_x =',stretch_x
      if(dowr) write(outfile,*) 'dx_inner  =',dx_inner
      if(dowr) write(outfile,*) 'dx_outer  =',dx_outer
      if(dowr) write(outfile,*) 'nos_x_len =',nos_x_len
      if(dowr) write(outfile,*) 'tot_x_len =',tot_x_len
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'stretch_y =',stretch_y
      if(dowr) write(outfile,*) 'dy_inner  =',dy_inner
      if(dowr) write(outfile,*) 'dy_outer  =',dy_outer
      if(dowr) write(outfile,*) 'nos_y_len =',nos_y_len
      if(dowr) write(outfile,*) 'tot_y_len =',tot_y_len
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'stretch_z =',stretch_z
      if(dowr) write(outfile,*) 'ztop      =',ztop
      if(dowr) write(outfile,*) 'str_bot   =',str_bot
      if(dowr) write(outfile,*) 'str_top   =',str_top
      if(dowr) write(outfile,*) 'dz_bot    =',dz_bot
      if(dowr) write(outfile,*) 'dz_top    =',dz_top
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'bc_temp   =',bc_temp
      if(dowr) write(outfile,*) 'ptc_top   =',ptc_top
      if(dowr) write(outfile,*) 'ptc_bot   =',ptc_bot
      if(dowr) write(outfile,*) 'viscosity =',viscosity
      if(dowr) write(outfile,*) 'pr_num    =',pr_num
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'var1      =',var1
      if(dowr) write(outfile,*) 'var2      =',var2
      if(dowr) write(outfile,*) 'var3      =',var3
      if(dowr) write(outfile,*) 'var4      =',var4
      if(dowr) write(outfile,*) 'var5      =',var5
      if(dowr) write(outfile,*) 'var6      =',var6
      if(dowr) write(outfile,*) 'var7      =',var7
      if(dowr) write(outfile,*) 'var8      =',var8
      if(dowr) write(outfile,*) 'var9      =',var9
      if(dowr) write(outfile,*) 'var10     =',var10
      if(dowr) write(outfile,*)


      IF ( ptype >= 26 .and. dowr ) THEN
        write(outfile,NML=nssl2mom_params)
!        write(outfile,*) 'alphah    =',alphah
!        write(outfile,*) 'alphahl   =',alphahl
!        write(outfile,*) 'dfrz      =',dfrz
!        write(outfile,*) 'hldnmn    =',hldnmn
!        write(outfile,*) 'imurain   =',imurain
!        write(outfile,*) 'ccn       =',ccn
!        write(outfile,*) 'icdx      =',icdx
!        write(outfile,*) 'icdxhl    =',icdxhl
!        write(outfile,*) 'iferwisventr =',iferwisventr
!        write(outfile,*) 'iehw      =',iehw
!        write(outfile,*) 'iehlw     =',iehlw
!        write(outfile,*) 'ehw0      =',ehw0
!        write(outfile,*) 'ehlw0     =',ehlw0
!        write(outfile,*) 'dmrauto   =',dmrauto
!        write(outfile,*) 'ioldlimiter=',ioldlimiter
      ENDIF


!--------------------------------------------------------------
!  Configuration for simulations with moisture
!

      !--- begin: define defaults (please do not change) ---------
      iice     = 0
      idm      = 0
      idmplus  = 0
      numq     = 1
      nqv      = 1
      nql1     = 1
      nql2     = 1
      nqs1     = 1
      nqs2     = 1
      nnc1     = 1
      nnc2     = 1
      nzl1     = 1
      nzl2     = 1
      nvl1     = 1
      nvl2     = 1
      nbudget  = 10
      budrain  = 1
      cloudvar = .false.
      rhovar   = .false.
      !--- end: define defaults ----------------------------------

      IF(imoist.eq.1)THEN

!-----------------------------------------------------------------------
!-------   BEGIN:  modify stuff below here -----------------------------
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
        IF(ptype.eq.1)THEN        ! Kessler scheme

          numq = 3    ! there are 3 q variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array

          cloudvar(1) = .false.
          cloudvar(2) = .true.
          cloudvar(3) = .false.

          qname(1) = 'qv '
          qname(2) = 'qc '
          qname(3) = 'qr '

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... using Kessler microphysics scheme ... '
          if(dowr) write(outfile,*) '         numq   = ',numq
          if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
        ELSEIF((ptype.eq.2).or.(ptype.eq.4))THEN    ! Goddard-LFO or 
                                                    ! GSR-LFO scheme

          iice = 1    ! this means that ptype=2,4 are ice schemes

          numq = 6    ! there are 6 q variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 6    ! the last solid variable is the sixth array

          cloudvar(1) = .false.
          cloudvar(2) = .true.
          cloudvar(3) = .false.
          cloudvar(4) = .true.
          cloudvar(5) = .false.
          cloudvar(6) = .false.

          qname(1) = 'qv '
          qname(2) = 'qc '
          qname(3) = 'qr '
          qname(4) = 'qi '
          qname(5) = 'qs '
          qname(6) = 'qg '

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          !----- initialize the Goddard or GSR LFO scheme -----

          if(ptype.eq.2)THEN

            if(dowr) write(outfile,*)
            if(dowr) write(outfile,*) 'Calling CONSAT'
            if(dowr) write(outfile,*)

            call consat
            call consat2(dtl)

            if(dowr) write(outfile,*)
            if(dowr) write(outfile,*) '  ... using Goddard LFO microphysics scheme ... '
            if(dowr) write(outfile,*) '         numq   = ',numq
            if(dowr) write(outfile,*) '         ihail  = ',ihail
            if(dowr) write(outfile,*)

          endif

          if(ptype.eq.4)then

            if(dowr) write(outfile,*)
            if(dowr) write(outfile,*) 'Calling lfoice_init'
            if(dowr) write(outfile,*)

            call lfoice_init(dtl)

            if(dowr) write(outfile,*)
            if(dowr) write(outfile,*) '  ... using GSR LFO microphysics scheme ... '
            if(dowr) write(outfile,*) '         numq   = ',numq
            if(dowr) write(outfile,*)

          endif

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
        ELSEIF(ptype.eq.3)THEN    ! Thompson scheme

          iice = 1    ! this means that ptype=3 is an ice scheme
          idm  = 1    ! this means that ptype=3 has at least one double moment

          numq = 8    ! there are 8 q variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 6    ! the last solid variable is the sixth array
          nnc1 = 7    ! the first number concentration var is the seventh array
          nnc2 = 8    ! the last number concentration var is the eighth array

          cloudvar(1) = .false.
          cloudvar(2) = .true.
          cloudvar(3) = .false.
          cloudvar(4) = .true.
          cloudvar(5) = .false.
          cloudvar(6) = .false.
          cloudvar(7) = .false.
          cloudvar(8) = .false.

          qname(1) = 'qv '
          qname(2) = 'qc '
          qname(3) = 'qr '
          qname(4) = 'qi '
          qname(5) = 'qs '
          qname(6) = 'qg '
          qname(7) = 'nci'
          qname(8) = 'ncr'

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          !----- initialize the Thompson scheme -----

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) 'Calling thompson_init'
          if(dowr) write(outfile,*) '(this can take several minutes ... please be patient)'

          call thompson_init

          if(dowr) write(outfile,*) 'Done with thompson_init'
          if(dowr) write(outfile,*)

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... using Thompson microphysics scheme ... '
          if(dowr) write(outfile,*) '         numq   = ',numq
          if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

        ELSEIF(ptype.eq.5)THEN    ! Morrison scheme

          !----- initialize the Morrison scheme -----

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) 'Calling GRAUPEL_INIT'

          call graupel_init(ihail,inum,ndcnst)

          if(dowr) write(outfile,*) 'Returned from GRAUPEL_INIT'
          if(dowr) write(outfile,*)

          !------------------------------------------

          iice = 1    ! this means that ptype=5 is an ice scheme
          idm  = 1    ! this means that ptype=5 has at least one double moment

        if(inum.eq.1)then
          ! constant cloud-drop concentration

          numq = 10   ! there are 10 q variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 6    ! the last solid variable is the sixth array
          nnc1 = 7    ! the first number concentration var is the seventh array
          nnc2 = 10   ! the last number concentration var is the tenth array

          cloudvar( 1) = .false.
          cloudvar( 2) = .true.
          cloudvar( 3) = .false.
          cloudvar( 4) = .true.
          cloudvar( 5) = .false.
          cloudvar( 6) = .false.
          cloudvar( 7) = .false.
          cloudvar( 8) = .false.
          cloudvar( 9) = .false.
          cloudvar(10) = .false.

          qname( 1) = 'qv '
          qname( 2) = 'qc '
          qname( 3) = 'qr '
          qname( 4) = 'qi '
          qname( 5) = 'qs '
          qname( 6) = 'qg '
          qname( 7) = 'nci'
          qname( 8) = 'ncs'
          qname( 9) = 'ncr'
          qname(10) = 'ncg'

        elseif(inum.eq.0)then
          ! cloud-droplet concentration is a predicted variable

          numq = 11   ! there are 11 q variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 6    ! the last solid variable is the sixth array
          nnc1 = 7    ! the first number concentration var is the seventh array
          nnc2 = 11   ! the last number concentration var is the eleventh array

          cloudvar( 1) = .false.
          cloudvar( 2) = .true.
          cloudvar( 3) = .false.
          cloudvar( 4) = .true.
          cloudvar( 5) = .false.
          cloudvar( 6) = .false.
          cloudvar( 7) = .false.
          cloudvar( 8) = .false.
          cloudvar( 9) = .false.
          cloudvar(10) = .false.
          cloudvar(11) = .false.

          qname( 1) = 'qv '
          qname( 2) = 'qc '
          qname( 3) = 'qr '
          qname( 4) = 'qi '
          qname( 5) = 'qs '
          qname( 6) = 'qg '
          qname( 7) = 'nci'
          qname( 8) = 'ncs'
          qname( 9) = 'ncr'
          qname(10) = 'ncg'
          qname(11) = 'ncc'

        else

          print *,'  unrecognized value for inum '
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1

        endif

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... using Morrison microphysics scheme ... '
          if(dowr) write(outfile,*) '         numq   = ',numq
          if(dowr) write(outfile,*) '         ihail  = ',ihail
        if(inum.eq.1)then
          if(dowr) write(outfile,*) '         assuming constant cloud droplet concentration' 
          if(dowr) write(outfile,*) '         ndcnst = ',ndcnst
        else
          if(dowr) write(outfile,*) '         predicting cloud droplet concentration'
        endif
          if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

        ELSEIF(ptype.eq.6)THEN        ! Rotunno-Emanuel scheme

          numq = 2    ! there are 2 q variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 2    ! the last liquid variable is the second array

          cloudvar(1) = .false.
          cloudvar(2) = .true.

          qname(1) = 'qv '
          qname(2) = 'ql '

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... using Rotunno-Emanuel microphysics scheme ... '
          if(dowr) write(outfile,*) '         numq   = ',numq
          if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

        ELSEIF ( ptype .eq. 26 ) THEN    ! ZVD scheme (with no hail category)

          iice = 1    ! this means that ptype=26 is an ice scheme
          idm  = 1    ! this means that ptype=26 has at least one double moment
          idmplus = 1

          numq = 13   ! number of variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 6    ! the last solid variable is the sixth array
          nnc1 = 7    ! the first number concentration var is the seventh array
          nnc2 = 12   ! the last number concentration var is the eleventh array
          nvl1 = 13   ! the first partical volume var is the seventh array
          nvl2 = 13   ! the last partical volume var is the eleventh array

          cloudvar( 1) = .false.
          cloudvar( 2) = .true.
          cloudvar( 3) = .false.
          cloudvar( 4) = .true.
          cloudvar( 5) = .false.
          cloudvar( 6) = .false.
          cloudvar( 7) = .false.
          cloudvar( 8) = .false.
          cloudvar( 9) = .false.
          cloudvar(10) = .false.
          cloudvar(11) = .false.
          cloudvar(12) = .false.
          cloudvar(13) = .false.
!          cloudvar(14) = .false.
!          cloudvar(15) = .false.

          qname( 1) = 'qv '
          qname( 2) = 'qc '
          qname( 3) = 'qr '
          qname( 4) = 'qi '
          qname( 5) = 'qs '
          qname( 6) = 'qg '
!          qname( 7) = 'qhl'
          qname( 7) = 'ccn' ! CCN concentration
          qname( 8) = 'ccw' ! droplet conc
          qname( 9) = 'crw' ! rain conc
          qname(10) = 'cci' ! ice crystal conc
          qname(11) = 'csw' ! snow conc
          qname(12) = 'chw' ! graupel conc
!          qname(14) = 'chl' ! hail conc
          qname(13) = 'vhw' ! graupel volume

          rhovar( 1) = .false.
          rhovar( 2) = .false.
          rhovar( 3) = .false.
          rhovar( 4) = .false.
          rhovar( 5) = .false.
          rhovar( 6) = .false.
          rhovar( 7) = .true.
          rhovar( 8) = .true.
          rhovar( 9) = .true.
          rhovar(10) = .true.
          rhovar(11) = .true.
          rhovar(12) = .true.
!          rhovar(13) = .false.
          rhovar(13) = .true.
!          rhovar(14) = .true.
!          rhovar(15) = .true.

!          ipconc = 5
!          lr = 4
!          li = 5
!          ls = 6
!          lh = 7
!          lg = lh
!          lhab = lh
!          lhl = 0
!          lqe  = lhab
!
!          lccn = 8
!          lnc  = 9
!          lnr  = 10
!          lni  = 11
!          lns  = 12
!          lnh  = 13
!          lnhl = 0
!          lss  = 14
!          lvh  = 15
!
!          lsch = 0
!          lschab = 0
!          lscw = 0
!          lscb = lscw
!          lscni = 0
!          lscpi = 0
!          lsce = lscni
!          lsceq= lschab
!
!          lsw  = 0
!          lhw  = 0
!          lhlw = 0

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          !----- initialize the ZVD scheme -----

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) 'Calling index_module_init'
          if(dowr) write(outfile,*)

!          write(0,*) 'option 26 currently not available'
!          STOP
         CALL nssl_2mom_init(ipctmp=5,mixphase=0,ihvol=-1,eqtset_tmp=eqtset)
!          call INDEX_MODULE_INIT(ptype)

          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) 'Returned from index_module_init'
          if(dowr) write(outfile,*)

        ELSEIF ( ptype .eq. 27 ) THEN    ! ZVDH scheme (with hail)

          iice = 1    ! this means that ptype=27 is an ice scheme
          idm  = 1    ! this means that ptype=27 has at least one double moment
          idmplus = 1

          numq = 16   ! number of variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 7    ! the last solid variable is the sixth array
          nnc1 = 8    ! the first number concentration var is the seventh array
          nnc2 = 14   ! the last number concentration var is the eleventh array
          nvl1 = 15   ! the first partical volume var is the seventh array
          nvl2 = 16   ! the last partical volume var is the eleventh array

          cloudvar( 1) = .false.
          cloudvar( 2) = .true.
          cloudvar( 3) = .false.
          cloudvar( 4) = .true.
          cloudvar( 5) = .false.
          cloudvar( 6) = .false.
          cloudvar( 7) = .false.
          cloudvar( 8) = .false.
          cloudvar( 9) = .false.
          cloudvar(10) = .false.
          cloudvar(11) = .false.
          cloudvar(12) = .false.
          cloudvar(13) = .false.
          cloudvar(14) = .false.
          cloudvar(15) = .false.
          cloudvar(16) = .false.

          qname( 1) = 'qv '
          qname( 2) = 'qc '
          qname( 3) = 'qr '
          qname( 4) = 'qi '
          qname( 5) = 'qs '
          qname( 6) = 'qg '
          qname( 7) = 'qhl'
          qname( 8) = 'ccn' ! CCN concentration
          qname( 9) = 'ccw' ! droplet conc
          qname(10) = 'crw' ! rain conc
          qname(11) = 'cci' ! ice crystal conc
          qname(12) = 'csw' ! snow conc
          qname(13) = 'chw' ! graupel conc
          qname(14) = 'chl' ! hail conc
!          qname(15) = 'ss ' ! max supersaturation
          qname(15) = 'vhw' ! graupel volume
          qname(16) = 'vhl' ! hail volume

          rhovar( 1) = .false.
          rhovar( 2) = .false.
          rhovar( 3) = .false.
          rhovar( 4) = .false.
          rhovar( 5) = .false.
          rhovar( 6) = .false.
          rhovar( 7) = .false.
          rhovar( 8) = .true.
          rhovar( 9) = .true.
          rhovar(10) = .true.
          rhovar(11) = .true.
          rhovar(12) = .true.
          rhovar(13) = .true.
          rhovar(14) = .true.
!          rhovar(15) = .false.
          rhovar(15) = .true.
          rhovar(16) = .true.

!          ipconc = 5
!          lr = 4
!          li = 5
!          ls = 6
!          lh = 7
!          lhl = 8
!          lg = lh
!          lhab = lhl
!          lqe  = lhab
!
!          lccn = 9
!          lnc  = 10
!          lnr  = 11
!          lni  = 12
!          lns  = 13
!          lnh  = 14
!          lnhl = 15
!          lss  = 16
!          lvh  = 17
!          lvhl = 18
!
!          lsch = 0
!          lschab = 0
!          lscw = 0
!          lscb = lscw
!          lscni = 0
!          lscpi = 0
!          lsce = lscni
!          lsceq= lschab
!
!          lsw  = 0
!          lhw  = 0
!          lhlw = 0

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          !----- initialize the ZVD scheme -----

!          if(dowr) write(outfile,*)
!          if(dowr) write(outfile,*) 'Calling graupel_init'
!          if(dowr) write(outfile,*)

!          call INDEX_MODULE_INIT(ptype)
         CALL nssl_2mom_init(ipctmp=5,mixphase=0,ihvol=1,eqtset_tmp=eqtset)

!          if(dowr) write(outfile,*)
!          if(dowr) write(outfile,*) 'Returned from graupel_init'
!          if(dowr) write(outfile,*)

        ELSEIF ( ptype .eq. 28 ) THEN    ! single moment ZIEG scheme (without hail)

          iice = 1    ! this means that ptype=28 is an ice scheme
          idm  = 0    ! this means that ptype=28 has at least one double moment
          idmplus = 1

          numq = 6   ! number of variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 6    ! the last solid variable is the sixth array

          cloudvar( 1) = .false.
          cloudvar( 2) = .true.
          cloudvar( 3) = .false.
          cloudvar( 4) = .true.
          cloudvar( 5) = .false.
          cloudvar( 6) = .false.

          qname( 1) = 'qv '
          qname( 2) = 'qc '
          qname( 3) = 'qr '
          qname( 4) = 'qi '
          qname( 5) = 'qs '
          qname( 6) = 'qg '

          rhovar( 1) = .false.
          rhovar( 2) = .false.
          rhovar( 3) = .false.
          rhovar( 4) = .false.
          rhovar( 5) = .false.
          rhovar( 6) = .false.

!          ipconc = 0
!          lr = 4
!          li = 5
!          ls = 6
!          lh = 7
!          lg = lh
!          lhab = lh
!          lhl = 0
!          lqe  = lhab
!
!          lccn = 0
!          lnc  = 0
!          lnr  = 0
!          lni  = 0
!          lns  = 0
!          lnh  = 0
!          lnhl = 0
!          lss  = 0
!          lvh  = 0
!
!          lsch = 0
!          lschab = 0
!          lscw = 0
!          lscb = lscw
!          lscni = 0
!          lscpi = 0
!          lsce = lscni
!          lsceq= lschab
!
!          lsw  = 0
!          lhw  = 0
!          lhlw = 0

          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          !----- initialize the ZVD scheme -----

!          if(dowr) write(outfile,*)
!          if(dowr) write(outfile,*) 'Calling graupel_init'
!          if(dowr) write(outfile,*)

         CALL nssl_2mom_init(ipctmp=0,mixphase=0,ihvol=-1,eqtset_tmp=eqtset)


!          if(dowr) write(outfile,*)
!          if(dowr) write(outfile,*) 'Returned from graupel_init'
!          if(dowr) write(outfile,*)

        ELSEIF ( ptype .eq. 29 ) THEN    ! 3-moment ZVDH scheme (with hail)

          iice = 1    ! this means that ptype=27 is an ice scheme
          idm  = 1    ! this means that ptype=27 has at least one double moment
          idmplus = 1

          numq = 19   ! number of variables

          nqv  = 1    ! qv is the first array
          nql1 = 2    ! the first liquid variable is the second array
          nql2 = 3    ! the last liquid variable is the third array
          nqs1 = 4    ! the first solid variable is the fourth array
          nqs2 = 7    ! the last solid variable is the sixth array
          nnc1 = 8    ! the first number concentration var is the seventh array
          nnc2 = 14   ! the last number concentration var is the eleventh array
          nzl1 = 15   ! the first reflectivity var is the seventh array
          nzl2 = 17   ! the last reflectivity var is the eleventh array
          nvl1 = 18   ! the first partical volume var is the seventh array
          nvl2 = 19   ! the last partical volume var is the eleventh array

          cloudvar( 1) = .false.
          cloudvar( 2) = .true.
          cloudvar( 3) = .false.
          cloudvar( 4) = .true.
          cloudvar( 5) = .false.
          cloudvar( 6) = .false.
          cloudvar( 7) = .false.
          cloudvar( 8) = .false.
          cloudvar( 9) = .false.
          cloudvar(10) = .false.
          cloudvar(11) = .false.
          cloudvar(12) = .false.
          cloudvar(13) = .false.
          cloudvar(14) = .false.
          cloudvar(15) = .false.
          cloudvar(16) = .false.
          cloudvar(17) = .false.
          cloudvar(18) = .false.
          cloudvar(19) = .false.

          qname( 1) = 'qv '
          qname( 2) = 'qc '
          qname( 3) = 'qr '
          qname( 4) = 'qi '
          qname( 5) = 'qs '
          qname( 6) = 'qg '
          qname( 7) = 'qhl'
          qname( 8) = 'ccn' ! CCN concentration
          qname( 9) = 'ccw' ! droplet conc
          qname(10) = 'crw' ! rain conc
          qname(11) = 'cci' ! ice crystal conc
          qname(12) = 'csw' ! snow conc
          qname(13) = 'chw' ! graupel conc
          qname(14) = 'chl' ! hail conc
!          qname(15) = 'ss ' ! max supersaturation
          qname(15) = 'zrw' ! rain reflectivity moment
          qname(16) = 'zhw' ! graupel reflectivity moment
          qname(17) = 'zhl' ! hail reflectivity moment
          qname(18) = 'vhw' ! graupel volume
          qname(19) = 'vhl' ! hail volume

          rhovar( 1) = .false.
          rhovar( 2) = .false.
          rhovar( 3) = .false.
          rhovar( 4) = .false.
          rhovar( 5) = .false.
          rhovar( 6) = .false.
          rhovar( 7) = .false.
          rhovar( 8) = .true.
          rhovar( 9) = .true.
          rhovar(10) = .true.
          rhovar(11) = .true.
          rhovar(12) = .true.
          rhovar(13) = .true.
          rhovar(14) = .true.
!          rhovar(15) = .false.
          rhovar(15) = .true.
          rhovar(16) = .true.
          rhovar(17) = .true.
          rhovar(18) = .true.
          rhovar(19) = .true.


          !----- budget stuff below here -----

          nbudget = 10

          budname(1) = 'tcond '
          budname(2) = 'tevac '
          budname(3) = 'tauto '
          budname(4) = 'taccr '
          budname(5) = 'tevar '
          budname(6) = 'train '
          budname(7) = 'erain '
          budname(8) = 'qsfc  '
          budname(9) = 'esfc  '
          budname(10) = 'erad  '

          budrain = 6

          !----- initialize the ZVD scheme -----

!          if(dowr) write(outfile,*)
!          if(dowr) write(outfile,*) 'Calling graupel_init'
!          if(dowr) write(outfile,*)

!          call INDEX_MODULE_INIT(ptype)
         CALL nssl_2mom_init(ipctmp=8,mixphase=0,ihvol=1,eqtset_tmp=eqtset)

!          if(dowr) write(outfile,*)
!          if(dowr) write(outfile,*) 'Returned from graupel_init'
!          if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  insert new ptype here

!!!        ELSEIF(ptype.eq.8)THEN    ! new microphysics scheme

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

        ELSE

          IF(myid.eq.0)THEN
            print *
            print *,'  ptype = ',ptype
            print *
            print *,'  Unrecognized value for ptype '
            print *
            print *,'  ... stopping cm1 ... '
            print *
          ENDIF

#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1

        ENDIF    ! endif for ptype

      ENDIF    ! endif for imoist=1

!-----------------------------------------------------------------------
!-------   END:  modify stuff above here -------------------------------
!-----------------------------------------------------------------------

      IF( (radopt.eq.1.or.radopt.eq.2) .and. iice.ne.1 )THEN
        print *
        print *,'  radopt   = ',radopt
        print *,'  iice     = ',iice
        print *
        print *,'  radopt=1 requires an ice microphysics scheme '
        print *
        print *,'   stopping model .... '
        print *
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      ENDIF

!-----------------------------------------------------------------------

      nqc = 0
      nqr = 0
      nqi = 0
      nqs = 0
      nqg = 0

      do n=1,numq
        if( qname(n).eq.'qc ' .or. qname(n).eq.'ql ' ) nqc = n
        if( qname(n).eq.'qr ' ) nqr = n
        if( qname(n).eq.'qi ' ) nqi = n
        if( qname(n).eq.'qs ' ) nqs = n
        if( qname(n).eq.'qg ' ) nqg = n
      enddo

      if(numq .gt. maxq)then
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  WARNING!   numq > maxq'
        if(dowr) write(outfile,*) '  You need to increase maxq in input.incl and recompile'
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Stopping model ....'
        if(dowr) write(outfile,*)
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'iice      =',iice
      if(dowr) write(outfile,*) 'idm       =',idm
      if(dowr) write(outfile,*) 'idmplus   =',idmplus
      if(dowr) write(outfile,*) 'numq      =',numq
      if(dowr) write(outfile,*) 'nqv       =',nqv
      if(dowr) write(outfile,*) 'nqc       =',nqc
      if(dowr) write(outfile,*) 'nqr       =',nqr
      if(dowr) write(outfile,*) 'nqi       =',nqi
      if(dowr) write(outfile,*) 'nqs       =',nqs
      if(dowr) write(outfile,*) 'nqg       =',nqg
      if(dowr) write(outfile,*) 'nql1      =',nql1
      if(dowr) write(outfile,*) 'nql2      =',nql2
      if(dowr) write(outfile,*) 'nqs1      =',nqs1
      if(dowr) write(outfile,*) 'nqs2      =',nqs2
      if(dowr) write(outfile,*) 'nnc1      =',nnc1
      if(dowr) write(outfile,*) 'nnc2      =',nnc2
      if(dowr) write(outfile,*) 'nvl1      =',nvl1
      if(dowr) write(outfile,*) 'nvl2      =',nvl2
      if(dowr) write(outfile,*) 'nzl1      =',nzl1
      if(dowr) write(outfile,*) 'nzl2      =',nzl2
      if(dowr) write(outfile,*)

!--------------------------------------------------------------

      iterrain = 0
      if(terrain_flag) iterrain = 1

      output_interp  = max(0,min(1,output_interp))*iterrain
      output_rain    = max(0,min(1,output_rain))
      output_sws     = max(0,min(1,output_sws))
      output_svs     = max(0,min(1,output_svs))
      output_sps     = max(0,min(1,output_sps))
      output_srs     = max(0,min(1,output_srs))
      output_sgs     = max(0,min(1,output_sgs))
      output_sus     = max(0,min(1,output_sus))
      output_shs     = max(0,min(1,output_shs))
      output_coldpool= max(0,min(1,output_coldpool))
      output_sfcflx  = max(0,min(1,output_sfcflx))
      output_sfcparams = max(0,min(1,output_sfcparams))
      output_sfcdiags = max(0,min(1,output_sfcdiags))
      output_psfc    = max(0,min(1,output_psfc))
      output_zs      = max(0,min(1,output_zs))*iterrain
      output_zh      = max(0,min(1,output_zh))
      output_basestate = max(0,min(1,output_basestate))
      output_th      = max(0,min(1,output_th))
      output_thpert  = max(0,min(1,output_thpert))
      output_prs     = max(0,min(1,output_prs))
      output_prspert = max(0,min(1,output_prspert))
      output_pi      = max(0,min(1,output_pi))
      output_pipert  = max(0,min(1,output_pipert))
      output_rho     = max(0,min(1,output_rho))
      output_rhopert = max(0,min(1,output_rhopert))
      output_tke     = max(0,min(1,output_tke))
      output_km      = max(0,min(1,output_km))
      output_kh      = max(0,min(1,output_kh))
      output_qv      = max(0,min(1,output_qv))
      output_qvpert  = max(0,min(1,output_qvpert))
      output_q       = max(0,min(1,output_q))
      output_dbz     = max(0,min(1,output_dbz))
      output_buoyancy= max(0,min(1,output_buoyancy))
      output_u       = max(0,min(1,output_u))
      output_upert   = max(0,min(1,output_upert))
      output_uinterp = max(0,min(1,output_uinterp))
      output_v       = max(0,min(1,output_v))
      output_vpert   = max(0,min(1,output_vpert))
      output_vinterp = max(0,min(1,output_vinterp))
      output_w       = max(0,min(1,output_w))
      output_winterp = max(0,min(1,output_winterp))
      output_vort    = max(0,min(1,output_vort))
      output_pv      = max(0,min(1,output_pv))
      output_uh      = max(0,min(1,output_uh))
      output_pblten  = max(0,min(1,output_pblten))
      output_dissten = max(0,min(1,output_dissten))
      output_dissheat = max(0,min(1,output_dissheat))
      output_mptend   = max(0,min(1,output_mptend))
      output_fallvel  = max(0,min(1,output_fallvel))
      output_nm      = max(0,min(1,output_nm))
      output_def     = max(0,min(1,output_def))
      output_turbten = max(0,min(1,output_turbten))
      output_impdiften = max(0,min(1,output_impdiften))
      output_radten  = max(0,min(1,output_radten))


      nrain = 1
      if(imove.eq.1) nrain = 2

      if(dowr) write(outfile,*) 'nrain     =',nrain
      if(dowr) write(outfile,*)

      if(imoist.eq.0)then
        output_rain=0
        output_srs=0
        output_sgs=0
        output_qv=0
        output_qvpert=0
        output_q=0
        output_dbz=0
      endif
      if( nqr.le.0 ) output_srs = 0
      if( nqg.le.0 ) output_sgs = 0
      if( (iturb.eq.0.or.dns.eq.1) )then
        output_tke=0
      endif
      if( (iturb.eq.0.or.dns.eq.1).and.(ipbl.eq.0) )then
        output_km=0
        output_kh=0
      endif
      if(iturb.eq.2.or.iturb.eq.3)then
        output_tke=0
      endif
      if(ipbl.lt.1)then
        output_pblten=0
      endif
      if(radopt.eq.0)then
        output_radten=0
      endif
      if( iturb.eq.0 )then
        output_turbten = 0
      endif
      if( output_impdiften.eq.1 )then
        if( hadvordrv.ne.5 .and. vadvordrv.ne.5 ) output_impdiften = 0
      endif
      if( bbc.ne.3 .and. isfcflx.eq.0 )then
!!!        output_sfcflx = 0
        output_sfcparams = 0
        output_sfcdiags = 0
      endif
      if(terrain_flag)then
        output_zs = 1
        output_zh = 1
      endif
      if( imoist.eq.0 )then
        output_mptend = 0
      endif
      if( imoist.eq.0 .or. ptype.ne.5 )then
        output_fallvel = 0
      endif
      if( idiss.eq.0 )then
        output_dissheat = 0
      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'output_path      = ',output_path
      if(dowr) write(outfile,*) 'output_basename  = ',output_basename
      if(dowr) write(outfile,*) 'output_format    =',output_format
      if(dowr) write(outfile,*) 'output_filetype  =',output_filetype
      if(dowr) write(outfile,*) 'output_interp    =',output_interp
      if(dowr) write(outfile,*) 'output_rain      =',output_rain
      if(dowr) write(outfile,*) 'output_sws       =',output_sws
      if(dowr) write(outfile,*) 'output_svs       =',output_svs
      if(dowr) write(outfile,*) 'output_sps       =',output_sps
      if(dowr) write(outfile,*) 'output_srs       =',output_srs
      if(dowr) write(outfile,*) 'output_sgs       =',output_sgs
      if(dowr) write(outfile,*) 'output_sus       =',output_sus
      if(dowr) write(outfile,*) 'output_shs       =',output_shs
      if(dowr) write(outfile,*) 'output_coldpool  =',output_coldpool
      if(dowr) write(outfile,*) 'output_sfcflx    =',output_sfcflx
      if(dowr) write(outfile,*) 'output_sfcparams =',output_sfcparams
      if(dowr) write(outfile,*) 'output_sfcdiags  =',output_sfcdiags
      if(dowr) write(outfile,*) 'output_psfc      =',output_psfc
      if(dowr) write(outfile,*) 'output_zs        =',output_zs
      if(dowr) write(outfile,*) 'output_zh        =',output_zh
      if(dowr) write(outfile,*) 'output_basestate =',output_basestate
      if(dowr) write(outfile,*) 'output_th        =',output_th
      if(dowr) write(outfile,*) 'output_thpert    =',output_thpert
      if(dowr) write(outfile,*) 'output_prs       =',output_prs
      if(dowr) write(outfile,*) 'output_prspert   =',output_prspert
      if(dowr) write(outfile,*) 'output_pi        =',output_pi
      if(dowr) write(outfile,*) 'output_pipert    =',output_pipert
      if(dowr) write(outfile,*) 'output_rho       =',output_rho
      if(dowr) write(outfile,*) 'output_rhopert   =',output_rhopert
      if(dowr) write(outfile,*) 'output_tke       =',output_tke
      if(dowr) write(outfile,*) 'output_km        =',output_km
      if(dowr) write(outfile,*) 'output_kh        =',output_kh
      if(dowr) write(outfile,*) 'output_qv        =',output_qv
      if(dowr) write(outfile,*) 'output_qvpert    =',output_qvpert
      if(dowr) write(outfile,*) 'output_q         =',output_q
      if(dowr) write(outfile,*) 'output_dbz       =',output_dbz
      if(dowr) write(outfile,*) 'output_buoyancy  =',output_buoyancy
      if(dowr) write(outfile,*) 'output_u         =',output_u
      if(dowr) write(outfile,*) 'output_upert     =',output_upert
      if(dowr) write(outfile,*) 'output_uinterp   =',output_uinterp
      if(dowr) write(outfile,*) 'output_v         =',output_v
      if(dowr) write(outfile,*) 'output_vpert     =',output_vpert
      if(dowr) write(outfile,*) 'output_vinterp   =',output_vinterp
      if(dowr) write(outfile,*) 'output_w         =',output_w
      if(dowr) write(outfile,*) 'output_winterp   =',output_winterp
      if(dowr) write(outfile,*) 'output_vort      =',output_vort
      if(dowr) write(outfile,*) 'output_pv        =',output_pv
      if(dowr) write(outfile,*) 'output_uh        =',output_uh
      if(dowr) write(outfile,*) 'output_pblten    =',output_pblten
      if(dowr) write(outfile,*) 'output_dissten   =',output_dissten
      if(dowr) write(outfile,*) 'output_dissheat  =',output_dissheat
      if(dowr) write(outfile,*) 'output_mptend    =',output_mptend
      if(dowr) write(outfile,*) 'output_fallvel   =',output_fallvel
      if(dowr) write(outfile,*) 'output_nm        =',output_nm
      if(dowr) write(outfile,*) 'output_def       =',output_def
      if(dowr) write(outfile,*) 'output_turbten   =',output_turbten
      if(dowr) write(outfile,*) 'output_impdiften =',output_impdiften
      if(dowr) write(outfile,*) 'output_radten    =',output_radten
      if(dowr) write(outfile,*)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'restart_format       = ',restart_format
      if(dowr) write(outfile,*) 'restart_filetype     = ',restart_filetype
      if(dowr) write(outfile,*) 'restart_file_theta   = ',restart_file_theta
      if(dowr) write(outfile,*) 'restart_file_dbz     = ',restart_file_dbz
      if(dowr) write(outfile,*) 'restart_file_th0     = ',restart_file_th0
      if(dowr) write(outfile,*) 'restart_file_prs0    = ',restart_file_prs0
      if(dowr) write(outfile,*) 'restart_file_pi0     = ',restart_file_pi0
      if(dowr) write(outfile,*) 'restart_file_rho0    = ',restart_file_rho0
      if(dowr) write(outfile,*) 'restart_file_qv0     = ',restart_file_qv0
      if(dowr) write(outfile,*) 'restart_file_u0      = ',restart_file_u0
      if(dowr) write(outfile,*) 'restart_file_v0      = ',restart_file_v0
      if(dowr) write(outfile,*) 'restart_file_zs      = ',restart_file_zs
      if(dowr) write(outfile,*) 'restart_file_zh      = ',restart_file_zh
      if(dowr) write(outfile,*) 'restart_file_zf      = ',restart_file_zf
      if(dowr) write(outfile,*) 'restart_file_diags   = ',restart_file_diags
      if(dowr) write(outfile,*) 'restart_use_theta    = ',restart_use_theta
      if(dowr) write(outfile,*) 'restart_reset_frqtim = ',restart_reset_frqtim
      if(dowr) write(outfile,*)

      maxk = nk

      if(dowr) write(outfile,*) '  maxk = ',maxk
      if(dowr) write(outfile,*)

!--------------------------------------------------------------
!  Define dimensions for allocatable arrays

      if(imoist.eq.1)then
        ibm=ib
        iem=ie
        jbm=jb
        jem=je
        kbm=kb
        kem=ke
        if(ptype.ge.26)then
          ibzvd=ib
          iezvd=ie
          jbzvd=jb
          jezvd=je
          kbzvd=kb
          kezvd=ke
          nqzvd = numq + 1
        else
          ibzvd=1
          iezvd=1
          jbzvd=1
          jezvd=1
          kbzvd=1
          kezvd=1
          nqzvd=1
        endif
      else
        ibm=1
        iem=1
        jbm=1
        jem=1
        kbm=1
        kem=1
        ibzvd=1
        iezvd=1
        jbzvd=1
        jezvd=1
        kbzvd=1
        kezvd=1
        nqzvd=1
      endif

      if(iice.eq.1)then
        ibi=ib
        iei=ie
        jbi=jb
        jei=je
        kbi=kb
        kei=ke
      else
        ibi=1
        iei=1
        jbi=1
        jei=1
        kbi=1
        kei=1
      endif

      if(radopt.ge.1)then
        ibr=ib
        ier=ie
        jbr=jb
        jer=je
        kbr=kb
        ker=ke
      else
        ibr=1
        ier=1
        jbr=1
        jer=1
        kbr=1
        ker=1
      endif

      if(ipbl.ge.1)then
        ibb=ib
        ieb=ie
        jbb=jb
        jeb=je
        kbb=kb
        keb=ke
      else
        ibb=1
        ieb=1
        jbb=1
        jeb=1
        kbb=1
        keb=1
      endif

      if( (sfcmodel.ge.1) .or. (oceanmodel.eq.2) .or. (ipbl.ge.1) .or. (bbc.eq.3) )then
        ibl=ib
        iel=ie
        jbl=jb
        jel=je
      else
        ibl=1
        iel=1
        jbl=1
        jel=1
      endif

      if((iturb.ge.1).or.(ipbl.ge.1))then
        ibc=ib
        iec=ie
        jbc=jb
        jec=je
        kbc=kb
        kec=ke+1
      else
        ibc=1
        iec=1
        jbc=1
        jec=1
        kbc=1
        kec=1
      endif

      if(iturb.eq.1)then
        ibt=ib
        iet=ie
        jbt=jb
        jet=je
        kbt=kb
        ket=ke+1
      else
        ibt=1
        iet=1
        jbt=1
        jet=1
        kbt=1
        ket=1
      endif

      if(iptra.eq.1)then
        ibp=ib
        iep=ie
        jbp=jb
        jep=je
        kbp=kb
        kep=ke
      else
        ibp=1
        iep=1
        jbp=1
        jep=1
        kbp=1
        kep=1
      endif

      if(psolver.eq.4.or.psolver.eq.5.or.ibalance.eq.2)then

        imirror = 0
        jmirror = 0

        ipb=1
        ipe=ni

        jpb=1
        jpe=nj

        if( (wbc.eq.2.or.wbc.eq.3).or.(ebc.eq.2.or.ebc.eq.3) )then

          imirror = 1
          ipe = ni*2

        endif

        if( (sbc.eq.2.or.sbc.eq.3).or.(nbc.eq.2.or.nbc.eq.3) )then

          jmirror = 1
          jpe = nj*2

        endif

        kpb=0
        kpe=nk+1

      else

        ipb=1
        ipe=1
        jpb=1
        jpe=1
        kpb=1
        kpe=1

      endif

      ! for diagnostics:
      ibd = 1
      ied = 1
      jbd = 1
      jed = 1
      kbd = 1
      ked = 1
      ntdiag = 0
      nqdiag = 0
      td_diss = 0
      td_mptend = 0
      qd_vtc = 0
      qd_vtr = 0
      qd_vts = 0
      qd_vtg = 0
      qd_vti = 0

      doit = .false.
      IF( output_dissheat.eq.1 .or. ipbl.eq.2 )THEN
        doit = .true.
        ntdiag = ntdiag + 1
        td_diss = ntdiag
      ENDIF
      IF( output_mptend.eq.1 )THEN
        doit = .true.
        ntdiag = ntdiag + 1
        td_mptend = ntdiag
      ENDIF

      IF( output_fallvel.eq.1 )THEN
        if( ptype.eq.5 )then
          doit = .true.

          nqdiag = nqdiag+1
          qd_vtc = nqdiag

          nqdiag = nqdiag+1
          qd_vtr = nqdiag

          nqdiag = nqdiag+1
          qd_vts = nqdiag

          nqdiag = nqdiag+1
          qd_vtg = nqdiag

          nqdiag = nqdiag+1
          qd_vti = nqdiag

        endif
      ENDIF

      ntdiag = max( ntdiag , 1 )
      nqdiag = max( nqdiag , 1 )

      IF( doit )THEN
        ibd = ib
        ied = ie
        jbd = jb
        jed = je
        kbd = kb
        ked = ke
      ENDIF

#ifdef MPI
      mynode = int( float(myid)/float(ppnode) )
      nodemaster = mynode * ppnode
      nodes = nodex * nodey / ppnode
#else
      mynode = 0
      nodemaster = 0
      nodes = 1
      ppnode = 1
#endif

      d2i  = 1
      d2is = 1
      d2iu = 1
      d2iv = 1

      d2j  = 1
      d2js = 1
      d2ju = 1
      d2jv = 1

      d3i  = 1
      d3is = 1
      d3iu = 1
      d3iv = 1

      d3j  = 1
      d3js = 1
      d3ju = 1
      d3jv = 1

      d3n = 1
      d3t = 1

      IF( myid.eq.nodemaster )THEN

        d2i   = (ni+1)*nodex
        d2is  = nx
        d2iu  = nx+1
        d2iv  = nx

        d2j   = (nj+1)*nodey
        d2js  = ny
        d2ju  = ny
        d2jv  = ny+1

        d3i   = ni+1
        d3is  = ni
        d3iu  = ni+1
        d3iv  = ni

        d3j   = nj+1
        d3js  = nj
        d3ju  = nj
        d3jv  = nj+1

        d3n = max( numprocs , 1 )

        d3t = max( ppnode-1 + nodes-1 , 1 )

      ENDIF

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  myid,mynode             = ',myid,mynode
      if(dowr) write(outfile,*) '  nodemaster,nodes,ppnode = ',nodemaster,nodes,ppnode
      if(dowr) write(outfile,*) '  nodex,nodey             = ',nodex,nodey
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  d2i   = ',d2i
      if(dowr) write(outfile,*) '  d2is  = ',d2is
      if(dowr) write(outfile,*) '  d2iu  = ',d2iu
      if(dowr) write(outfile,*) '  d2iv  = ',d2iv
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  d2j   = ',d2j
      if(dowr) write(outfile,*) '  d2js  = ',d2js
      if(dowr) write(outfile,*) '  d2ju  = ',d2ju
      if(dowr) write(outfile,*) '  d2jv  = ',d2jv
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  d3i   = ',d3i
      if(dowr) write(outfile,*) '  d3is  = ',d3is
      if(dowr) write(outfile,*) '  d3iu  = ',d3iu
      if(dowr) write(outfile,*) '  d3iv  = ',d3iv
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  d3j   = ',d3j
      if(dowr) write(outfile,*) '  d3js  = ',d3js
      if(dowr) write(outfile,*) '  d3ju  = ',d3ju
      if(dowr) write(outfile,*) '  d3jv  = ',d3jv
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  d3n   = ',d3n
      if(dowr) write(outfile,*) '  d3t   = ',d3t
      if(dowr) write(outfile,*)

!--------------------------------------------------------------

      stat_w       = max(0,min(1,stat_w))
      stat_u       = max(0,min(1,stat_u))
      stat_v       = max(0,min(1,stat_v))
      stat_rmw     = max(0,min(1,stat_rmw))
      IF(axisymm.ne.1) stat_rmw = 0
      stat_pipert  = max(0,min(1,stat_pipert))
      stat_prspert = max(0,min(1,stat_prspert))
      stat_thpert  = max(0,min(1,stat_thpert))
      stat_q       = max(0,min(1,stat_q))
      stat_tke     = max(0,min(1,stat_tke))
      stat_km      = max(0,min(1,stat_km))
      stat_kh      = max(0,min(1,stat_kh))
      stat_div     = max(0,min(1,stat_div))
      stat_rh      = max(0,min(1,stat_rh))
      stat_rhi     = max(0,min(1,stat_rhi))
      stat_the     = max(0,min(1,stat_the))
      stat_cloud   = max(0,min(1,stat_cloud))
      stat_sfcprs  = max(0,min(1,stat_sfcprs))
      stat_wsp     = max(0,min(1,stat_wsp))
      stat_cfl     = max(0,min(1,stat_cfl))
      stat_vort    = max(0,min(1,stat_vort))
      stat_tmass   = max(0,min(1,stat_tmass))
      stat_tmois   = max(0,min(1,stat_tmois))
      stat_qmass   = max(0,min(1,stat_qmass))
      stat_tenerg  = max(0,min(1,stat_tenerg))
      stat_mo      = max(0,min(1,stat_mo))
      stat_tmf     = max(0,min(1,stat_tmf))
      stat_pcn     = max(0,min(1,stat_pcn))
      stat_qsrc    = max(0,min(1,stat_qsrc))


      if(imoist.eq.0)then
        stat_q=0
        stat_rh=0
        stat_rhi=0
        stat_the=0
        stat_cloud=0
        stat_tmois=0
        stat_qmass=0
        stat_pcn=0
        stat_qsrc=0
      endif
      if(iice.eq.0)then
        stat_rhi=0
      endif
      if(iturb.eq.0.or.dns.eq.1)then
        stat_tke=0
        stat_km=0
        stat_kh=0
      endif 
      if(iturb.eq.2.or.iturb.eq.3)then
        stat_tke=0
      endif


      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'stat_w       = ',stat_w
      if(dowr) write(outfile,*) 'stat_u       = ',stat_u
      if(dowr) write(outfile,*) 'stat_v       = ',stat_v
      if(dowr) write(outfile,*) 'stat_rmw     = ',stat_rmw
      if(dowr) write(outfile,*) 'stat_pipert  = ',stat_pipert
      if(dowr) write(outfile,*) 'stat_prspert = ',stat_prspert
      if(dowr) write(outfile,*) 'stat_thpert  = ',stat_thpert
      if(dowr) write(outfile,*) 'stat_q       = ',stat_q
      if(dowr) write(outfile,*) 'stat_tke     = ',stat_tke
      if(dowr) write(outfile,*) 'stat_km      = ',stat_km
      if(dowr) write(outfile,*) 'stat_kh      = ',stat_kh
      if(dowr) write(outfile,*) 'stat_div     = ',stat_div
      if(dowr) write(outfile,*) 'stat_rh      = ',stat_rh
      if(dowr) write(outfile,*) 'stat_rhi     = ',stat_rhi
      if(dowr) write(outfile,*) 'stat_the     = ',stat_the
      if(dowr) write(outfile,*) 'stat_cloud   = ',stat_cloud
      if(dowr) write(outfile,*) 'stat_sfcprs  = ',stat_sfcprs
      if(dowr) write(outfile,*) 'stat_wsp     = ',stat_wsp
      if(dowr) write(outfile,*) 'stat_cfl     = ',stat_cfl
      if(dowr) write(outfile,*) 'stat_vort    = ',stat_vort
      if(dowr) write(outfile,*) 'stat_tmass   = ',stat_tmass
      if(dowr) write(outfile,*) 'stat_tmois   = ',stat_tmois
      if(dowr) write(outfile,*) 'stat_qmass   = ',stat_qmass
      if(dowr) write(outfile,*) 'stat_tenerg  = ',stat_tenerg
      if(dowr) write(outfile,*) 'stat_mo      = ',stat_mo
      if(dowr) write(outfile,*) 'stat_tmf     = ',stat_tmf
      if(dowr) write(outfile,*) 'stat_pcn     = ',stat_pcn
      if(dowr) write(outfile,*) 'stat_qsrc    = ',stat_qsrc
      if(dowr) write(outfile,*)

      stat_out=2*(stat_w+stat_pipert+stat_prspert+numq*stat_q+              &
              stat_tke+2*stat_km+2*stat_kh+stat_div+stat_rh+stat_rhi+       &
              stat_cloud+2*stat_sfcprs+2*stat_wsp)  +                       &
              4*(stat_thpert+stat_u+stat_v)  + 2*stat_rmw +                 &
              3*stat_cfl  +  6*stat_vort  +  stat_tmass  +  stat_tmois  +   &
              (1+(1+nql2-nql1)+iice*(1+nqs2-nqs1))*stat_qmass +             &
              5*stat_tenerg  +  3*stat_mo  +                                &
              nbudget*stat_pcn  + numq*2*stat_qsrc +                        &
              4*stat_the  +  2*stat_tmf + 2*iptra*npt
      IF( adapt_dt.eq.1 ) stat_out = stat_out + 1
      IF( stat_wsp.eq.1 .and. bbc.eq.3 ) stat_out = stat_out + 2
      IF( stat_cfl.ge.1 .and. iturb.lt.1 ) stat_out = stat_out - 2
!!!      stat_out = max(1,stat_out)

      if(dowr) write(outfile,*) 'stat_out = ',stat_out
      if(dowr) write(outfile,*)


      prcl_th       = max(0,min(1,prcl_th))
      prcl_t        = max(0,min(1,prcl_t))
      prcl_prs      = max(0,min(1,prcl_prs))
      prcl_ptra     = max(0,min(1,prcl_ptra))
      prcl_q        = max(0,min(1,prcl_q))
      prcl_nc       = max(0,min(1,prcl_nc))
      prcl_km       = max(0,min(1,prcl_km))
      prcl_kh       = max(0,min(1,prcl_kh))
      prcl_tke      = max(0,min(1,prcl_tke))
      prcl_dbz      = max(0,min(1,prcl_dbz))
      prcl_b        = max(0,min(1,prcl_b))
      prcl_vpg      = max(0,min(1,prcl_vpg))
      prcl_vort     = max(0,min(1,prcl_vort))
      prcl_rho      = max(0,min(1,prcl_rho))
      prcl_qsat     = max(0,min(1,prcl_qsat))
      prcl_sfc      = max(0,min(1,prcl_sfc))


      if( iptra.eq.0 )then
        prcl_ptra = 0
      endif
      if( imoist.eq.0 )then
        prcl_q  = 0
        prcl_nc = 0
        prcl_dbz = 0
        prcl_qsat = 0
      else
        if( ptype.eq.1 .or. ptype.eq.4 )then
          prcl_dbz = 0
        endif
        if( idm.eq.0 )then
          prcl_nc = 0
        endif
      endif
      if( iturb.eq.0 )then
        prcl_km = 0
        prcl_kh = 0
      endif
      if( iturb.ne.1 )then
        prcl_tke = 0
      endif
      if( bbc.ne.3 )then
        prcl_sfc = 0
      endif


      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'prcl_th      = ',prcl_th
      if(dowr) write(outfile,*) 'prcl_t       = ',prcl_t
      if(dowr) write(outfile,*) 'prcl_prs     = ',prcl_prs
      if(dowr) write(outfile,*) 'prcl_ptra    = ',prcl_ptra
      if(dowr) write(outfile,*) 'prcl_q       = ',prcl_q
      if(dowr) write(outfile,*) 'prcl_nc      = ',prcl_nc
      if(dowr) write(outfile,*) 'prcl_km      = ',prcl_km
      if(dowr) write(outfile,*) 'prcl_kh      = ',prcl_kh
      if(dowr) write(outfile,*) 'prcl_tke     = ',prcl_tke
      if(dowr) write(outfile,*) 'prcl_dbz     = ',prcl_dbz
      if(dowr) write(outfile,*) 'prcl_b       = ',prcl_b
      if(dowr) write(outfile,*) 'prcl_vpg     = ',prcl_vpg
      if(dowr) write(outfile,*) 'prcl_vort    = ',prcl_vort
      if(dowr) write(outfile,*) 'prcl_rho     = ',prcl_rho
      if(dowr) write(outfile,*) 'prcl_qsat    = ',prcl_qsat
      if(dowr) write(outfile,*) 'prcl_sfc     = ',prcl_sfc
      if(dowr) write(outfile,*)

!------------------------------------------------------------------
!  constants in subgrid turbulence schemes:

      c_e1 = c_m * c_l * c_l * ( 1.0 / ri_c - 1.0 )
      c_e2 = max( 0.0 , c_m * pi * pi - c_e1 )

      c_s = ( c_m * c_m * c_m / ( c_e1 + c_e2 ) )**0.25
      rcs = 1.0/c_s

      IF( dowr .and. ( iturb.eq.1 .or. iturb.eq.2 ) )THEN
        write(outfile,*)
        write(outfile,*) '  c_m,c_l,ri_c  = ',c_m,c_l,ri_c
        write(outfile,*) '  c_e1,c_e2,sum = ',c_e1,c_e2,c_e1+c_e2
        write(outfile,*) '  c_s,rcs       = ',c_s,rcs
      ENDIF

!--------------------------------------------------------------

      rdx=1.0/dx
      rdy=1.0/dy
      rdz=1.0/dz
      rdx2=1.0/(2.0*dx)
      rdy2=1.0/(2.0*dy)
      rdz2=1.0/(2.0*dz)
      rdx4=1.0/(4.0*dx)
      rdy4=1.0/(4.0*dy)
      rdz4=1.0/(4.0*dz)

      thec_mb=0.0
      qt_mb=0.0

      stattim=statfrq
      taptim=tapfrq
      rsttim=rstfrq
      ! GHB:  now setting prcltim in cm1.F
!!!      prcltim=prclfrq
      if( iprcl.ne.1 ) prcltim = 1.0d30
      radtim=0.0

!--------------------------------------------------------------

      npvals = 1

      prx = 0
      pry = 0
      prz = 0
      pru = 0
      prv = 0
      prw = 0
      prth = 0
      prt = 0
      prprs = 0
      prpt1 = 0
      prpt2 = 0
      prqv = 0
      prq1 = 0
      prq2 = 0
      prnc1 = 0
      prnc2 = 0
      prkm = 0
      prkh = 0
      prtke = 0
      prdbz = 0
      prb = 0
      prvpg = 0
      przv = 0
      prrho = 0
      prqsl = 0
      prqsi = 0
      prznt = 0
      prust = 0

      ! for parcels:
      if(iprcl.eq.1)then

        ! 6 basic variables for all simulations:
        ! (x,y,z,u,v,w)
        !  1 2 3 4 5 6
        npvals = 6

        prx = 1
        pry = 2
        prz = 3
        pru = 4
        prv = 5
        prw = 6

        if( prcl_th.eq.1 )then
          npvals = npvals+1
          prth = npvals
        endif
        if( prcl_t.eq.1 )then
          npvals = npvals+1
          prt = npvals
        endif
        if( prcl_prs.eq.1 )then
          npvals = npvals+1
          prprs = npvals
        endif

        ! passive tracers:
        if( prcl_ptra.eq.1 )then
          prpt1 = npvals+1
          npvals = npvals + npt
          prpt2 = npvals
        endif

        ! moisture variables:
        if( prcl_q.eq.1 )then
          !---
          npvals = npvals+1
          prqv = npvals
          prq1 = npvals+1
          !---
          npvals = npvals+(nql2-nql1+1)
          if( iice.eq.1 )then
            npvals = npvals+(nqs2-nqs1+1)
          endif
          !---
          prq2 = npvals
        endif
        if( prcl_nc.eq.1 .and. idm.eq.1 )then
          prnc1 = npvals+1
          npvals = npvals+(nnc2-nnc1+1)
          prnc2 = npvals
        endif


        ! turbulence parameters:
        if( iturb.ge.1 )then
          if( prcl_km.eq.1 )then
            prkm = npvals+1
            npvals = npvals+2
          endif
          if( prcl_kh.eq.1 )then
            prkh = npvals+1
            npvals = npvals+2
          endif
          if( prcl_tke.eq.1 )then
            npvals = npvals+1
            prtke = npvals
          endif
        endif

        if( prcl_dbz.eq.1 )then
          npvals = npvals+1
          prdbz = npvals
        endif
        if( prcl_b.eq.1 )then
          npvals = npvals+1
          prb = npvals
        endif
        if( prcl_vpg.eq.1 )then
          npvals = npvals+1
          prvpg = npvals
        endif
        if( prcl_vort.eq.1 )then
          npvals = npvals+1
          przv = npvals
        endif
        if( prcl_rho.eq.1 )then
          npvals = npvals+1
          prrho = npvals
        endif
        if( prcl_qsat.eq.1 )then
          npvals = npvals+1
          prqsl = npvals
          if( iice.eq.1 )then
            npvals = npvals+1
            prqsi = npvals
          endif
        endif
        if( prcl_sfc.eq.1 )then
          npvals = npvals+1
          prznt = npvals
          npvals = npvals+1
          prust = npvals
        endif

      else

        nparcels = 1

      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  nparcels = ',nparcels
      if(dowr) write(outfile,*) '  npvals   = ',npvals
      if(dowr) write(outfile,*) '    prx      = ',prx
      if(dowr) write(outfile,*) '    pry      = ',pry
      if(dowr) write(outfile,*) '    prz      = ',prz
      if(dowr) write(outfile,*) '    pru      = ',pru
      if(dowr) write(outfile,*) '    prv      = ',prv
      if(dowr) write(outfile,*) '    prw      = ',prw
      if(dowr) write(outfile,*) '    prth     = ',prth
      if(dowr) write(outfile,*) '    prt      = ',prt
      if(dowr) write(outfile,*) '    prprs    = ',prprs
      if(dowr) write(outfile,*) '    prpt1    = ',prpt1
      if(dowr) write(outfile,*) '    prpt2    = ',prpt2
      if(dowr) write(outfile,*) '    prqv     = ',prqv
      if(dowr) write(outfile,*) '    prq1     = ',prq1
      if(dowr) write(outfile,*) '    prq2     = ',prq2
      if(dowr) write(outfile,*) '    prnc1    = ',prnc1
      if(dowr) write(outfile,*) '    prnc2    = ',prnc2
      if(dowr) write(outfile,*) '    prkm     = ',prkm
      if(dowr) write(outfile,*) '    prkh     = ',prkh
      if(dowr) write(outfile,*) '    prtke    = ',prtke
      if(dowr) write(outfile,*) '    prdbz    = ',prdbz
      if(dowr) write(outfile,*) '    prb      = ',prb
      if(dowr) write(outfile,*) '    prvpg    = ',prvpg
      if(dowr) write(outfile,*) '    przv     = ',przv
      if(dowr) write(outfile,*) '    prrho    = ',prrho
      if(dowr) write(outfile,*) '    prqsl    = ',prqsl
      if(dowr) write(outfile,*) '    prqsi    = ',prqsi
      if(dowr) write(outfile,*) '    prznt    = ',prznt
      if(dowr) write(outfile,*) '    prust    = ',prust
      if(dowr) write(outfile,*)

!--------------------------------------------------------------
!  Get identity

      ibw=0
      ibe=0
      ibs=0
      ibn=0

      patchsws = .false.
      patchsww = .false.
      patchses = .false.
      patchsee = .false.
      patchnwn = .false.
      patchnww = .false.
      patchnen = .false.
      patchnee = .false.

      p2tchsws = .false.
      p2tchsww = .false.
      p2tchses = .false.
      p2tchsee = .false.
      p2tchnwn = .false.
      p2tchnww = .false.
      p2tchnen = .false.
      p2tchnee = .false.

      myi=1
      myj=1

#ifdef MPI
      myj = myid / nodex + 1
      myi = myid - (myj-1)*nodex  + 1

      if(dowr) write(outfile,*) '  myi,myj=',myi,myj
      if(dowr) write(outfile,*)

      mynorth = nabor(myi,   myj+1, nodex, nodey)
      mysouth = nabor(myi,   myj-1, nodex, nodey)
      myeast  = nabor(myi+1, myj,   nodex, nodey)
      mywest  = nabor(myi-1, myj,   nodex, nodey)

      if(dowr) write(outfile,*) '  mywest  =',mywest
      if(dowr) write(outfile,*) '  myeast  =',myeast
      if(dowr) write(outfile,*) '  mysouth =',mysouth
      if(dowr) write(outfile,*) '  mynorth =',mynorth
      if(dowr) write(outfile,*)

      mysw = nabor(myi-1, myj-1,   nodex, nodey)
      mynw = nabor(myi-1, myj+1,   nodex, nodey)
      myne = nabor(myi+1, myj+1,   nodex, nodey)
      myse = nabor(myi+1, myj-1,   nodex, nodey)

      if(dowr) write(outfile,*) '  mysw    =',mysw
      if(dowr) write(outfile,*) '  mynw    =',mynw
      if(dowr) write(outfile,*) '  myne    =',myne
      if(dowr) write(outfile,*) '  myse    =',myse

      cs1we = (nj)*(nk)
      cs1sn = (ni)*(nk)
      ct1we = (nj)*(nk+1)
      ct1sn = (ni)*(nk+1)
      cv1we = (nj+1)*(nk)
      cu1sn = (ni+1)*(nk)
      cw1we = (nj)*(nk-1)
      cw1sn = (ni)*(nk-1)
      cs2we = 2*(nj)*(nk)
      cs2sn = (ni)*2*(nk)
      cs3we = 3*(nj)*(nk)
      cs3sn = (ni)*3*(nk)
      ct3we = 3*(nj)*(nk+1)
      ct3sn = (ni)*3*(nk+1)
      cv3we = 3*(nj+1)*(nk)
      cu3sn = 3*(ni+1)*(nk)
      cw3we = 3*(nj)*(nk-1)
      cw3sn = (ni)*3*(nk-1)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  cs1we   =',cs1we
      if(dowr) write(outfile,*) '  cs1sn   =',cs1sn
      if(dowr) write(outfile,*) '  ct1we   =',ct1we
      if(dowr) write(outfile,*) '  ct1sn   =',ct1sn
      if(dowr) write(outfile,*) '  cv1we   =',cv1we
      if(dowr) write(outfile,*) '  cu1sn   =',cu1sn
      if(dowr) write(outfile,*) '  cw1we   =',cw1we
      if(dowr) write(outfile,*) '  cw1sn   =',cw1sn
      if(dowr) write(outfile,*) '  cs2we   =',cs2we
      if(dowr) write(outfile,*) '  cs2sn   =',cs2sn
      if(dowr) write(outfile,*) '  cs3we   =',cs3we
      if(dowr) write(outfile,*) '  cs3sn   =',cs3sn
      if(dowr) write(outfile,*) '  ct3we   =',ct3we
      if(dowr) write(outfile,*) '  ct3sn   =',ct3sn
      if(dowr) write(outfile,*) '  cv3we   =',cv3we
      if(dowr) write(outfile,*) '  cu3sn   =',cu3sn
      if(dowr) write(outfile,*) '  cw3we   =',cw3we
      if(dowr) write(outfile,*) '  cw3sn   =',cw3sn
      if(dowr) write(outfile,*)
#endif

    allocate( xfdp(-2:nx+4) )
    allocate( yfdp(-2:ny+4) )

    IF(iorigin.eq.1)THEN

      do i=-2,nx+4
        xfdp(i)=dble(dx)*(i-1)
      enddo
      do i=ib,ie+1
        xf(i)=xfdp(i+(myi-1)*ni)
      enddo
      do i=ib,ie
        xh(i)=0.5d0*(xfdp(i+1+(myi-1)*ni)+xfdp(i+(myi-1)*ni))
      enddo

        i = ib
        if(i+(myi-1)*nx/nodex.eq.(-2) .and. wbc.ne.1) ibw=1
        i = ie
        if(i+(myi-1)*nx/nodex.eq.(nx+3) .and. ebc.ne.1) ibe=1

      do j=-2,ny+4
        yfdp(j)=dble(dy)*(j-1)
      enddo
      do j=jb,je+1
        yf(j)=yfdp(j+(myj-1)*nj)
      enddo
      do j=jb,je
        yh(j)=0.5d0*(yfdp(j+1+(myj-1)*nj)+yfdp(j+(myj-1)*nj))
      enddo

        j = jb
        if(j+(myj-1)*ny/nodey.eq.(-2) .and. sbc.ne.1) ibs=1
        j = je
        if(j+(myj-1)*ny/nodey.eq.(ny+3) .and. nbc.ne.1) ibn=1

    ELSEIF(iorigin.eq.2)THEN

      do i=-2,nx+4
        xfdp(i)=dble(dx)*(i-1)-0.5d0*dble(dx)*nx
      enddo
      do i=ib,ie+1
        xf(i)=xfdp(i+(myi-1)*ni)
      enddo
      do i=ib,ie
        xh(i)=0.5d0*(xfdp(i+1+(myi-1)*ni)+xfdp(i+(myi-1)*ni))
      enddo

        i = ib
        if(i+(myi-1)*nx/nodex.eq.(-2) .and. wbc.ne.1) ibw=1
        i = ie
        if(i+(myi-1)*nx/nodex.eq.(nx+3) .and. ebc.ne.1) ibe=1

      do j=-2,ny+4
        yfdp(j)=dble(dy)*(j-1)-0.5d0*dble(dy)*ny
      enddo
      do j=jb,je+1
        yf(j)=yfdp(j+(myj-1)*nj)
      enddo
      do j=jb,je
        yh(j)=0.5d0*(yfdp(j+1+(myj-1)*nj)+yfdp(j+(myj-1)*nj))
      enddo

        j = jb
        if(j+(myj-1)*ny/nodey.eq.(-2) .and. sbc.ne.1) ibs=1
        j = je
        if(j+(myj-1)*ny/nodey.eq.(ny+3) .and. nbc.ne.1) ibn=1

    ELSE

      print *,'  invalid option for iorigin'
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
      call stopcm1

    ENDIF

#ifndef MPI
      if(wbc.eq.2)then
        ibw=1
      endif

      if(ebc.eq.2)then
        ibe=1
      endif

      if(sbc.eq.2)then
        ibs=1
      endif

      if(nbc.eq.2)then
        ibn=1
      endif
#endif

!--------------------------------------------------------------

      if(dowr) write(outfile,*)

      if(dowr) write(outfile,*) 'g     =',g
      if(dowr) write(outfile,*) 'to    =',to
      if(dowr) write(outfile,*) 'rd    =',rd
      if(dowr) write(outfile,*) 'rv    =',rv
      if(dowr) write(outfile,*) 'cp    =',cp
      if(dowr) write(outfile,*) 'cv    =',cv
      if(dowr) write(outfile,*) 'cpv   =',cpv
      if(dowr) write(outfile,*) 'cvv   =',cvv
      if(dowr) write(outfile,*) 'p00   =',p00
      if(dowr) write(outfile,*) 'rp00  =',rp00
      if(dowr) write(outfile,*) 'th0r  =',th0r
      if(dowr) write(outfile,*) 'rcp   =',rcp
      if(dowr) write(outfile,*) 'pi    =',pi

      if(dowr) write(outfile,*)

      if(dowr) write(outfile,*) 'cpdcv =',cpdcv
      if(dowr) write(outfile,*) 'rovcp =',rovcp
      if(dowr) write(outfile,*) 'rddcv =',rddcv
      if(dowr) write(outfile,*) 'cvdrd =',cvdrd
      if(dowr) write(outfile,*) 'cpdrd =',cpdrd
      if(dowr) write(outfile,*) 'eps   =',eps
      if(dowr) write(outfile,*) 'reps  =',reps
      if(dowr) write(outfile,*) 'repsm1=',repsm1
      if(dowr) write(outfile,*) 'cpt   =',cpt
      if(dowr) write(outfile,*) 'cvt   =',cvt
      if(dowr) write(outfile,*) 'pnum  =',pnum
      if(dowr) write(outfile,*) 'xlv   =',xlv
      if(dowr) write(outfile,*) 'xls   =',xls
      if(dowr) write(outfile,*) 'lvdcp =',lvdcp
      if(dowr) write(outfile,*) 'condc =',condc
      if(dowr) write(outfile,*) 'cpl   =',cpl
      if(dowr) write(outfile,*) 'cpi   =',cpi
      if(dowr) write(outfile,*) 'lv1   =',lv1
      if(dowr) write(outfile,*) 'lv2   =',lv2
      if(dowr) write(outfile,*) 'ls1   =',ls1
      if(dowr) write(outfile,*) 'ls2   =',ls2
      if(dowr) write(outfile,*) 'karman=',karman

      if( psolver.eq.6 )then
        !----------------
        ! speed of sound for compressible-Boussinesq equations (psolver=6)
        csound = 300.0
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) 'csound=',csound
        if(dowr) write(outfile,*)
      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'timeformat   =',timeformat
      if(dowr) write(outfile,*) 'timestats    =',timestats
      if(dowr) write(outfile,*) 'terrain_flag =',terrain_flag
      if(dowr) write(outfile,*) 'procfiles    =',procfiles


      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'nx    =',nx
      if(dowr) write(outfile,*) 'ny    =',ny
      if(dowr) write(outfile,*) 'nz    =',nz

#ifdef MPI
      if(dowr) write(outfile,*)

      if(dowr) write(outfile,*) 'nodex    =',nodex
      if(dowr) write(outfile,*) 'nodey    =',nodey
      if(dowr) write(outfile,*) 'numprocs =',numprocs
      if(dowr) write(outfile,*) 'ppnode   =',ppnode
#endif

      if(dowr) write(outfile,*)
 
      if(dowr) write(outfile,*) 'ni    =',ni
      if(dowr) write(outfile,*) 'nj    =',nj
      if(dowr) write(outfile,*) 'nk    =',nk
      if(dowr) write(outfile,*) 'nkp1  =',nkp1

      if(dowr) write(outfile,*)
 
      if(dowr) write(outfile,130) 'ib,ibm,ibi,ibc,ibt=',ib,ibm,ibi,ibc,ibt
      if(dowr) write(outfile,130) 'ie,iem,iei,iec,iet=',ie,iem,iei,iec,iet
      if(dowr) write(outfile,130) 'jb,jbm,jbi,jbc,jbt=',jb,jbm,jbi,jbc,jbt
      if(dowr) write(outfile,130) 'je,jem,jei,jec,jet=',je,jem,jei,jec,jet
      if(dowr) write(outfile,130) 'kb,kbm,kbi,kbc,kbt=',kb,kbm,kbi,kbc,kbt
      if(dowr) write(outfile,130) 'ke,kem,kei,kec,ket=',ke,kem,kei,kec,ket

130   format(1x,a19,5(4x,i5))

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'imirror,jmirror = ',imirror,jmirror
      if(dowr) write(outfile,*)

      if(dowr) write(outfile,131) 'ibp,itb,ipb,ibr,ibb=',ibp,itb,ipb,ibr,ibb
      if(dowr) write(outfile,131) 'iep,ite,ipe,ier,ieb=',iep,ite,ipe,ier,ieb
      if(dowr) write(outfile,131) 'jbp,jtb,jpb,jbr,jbb=',jbp,jtb,jpb,jbr,jbb
      if(dowr) write(outfile,131) 'jep,jte,jpe,jer,jeb=',jep,jte,jpe,jer,jeb
      if(dowr) write(outfile,131) 'kbp,ktb,kpb,kbr,kbb=',kbp,ktb,kpb,kbr,kbb
      if(dowr) write(outfile,131) 'kep,kte,kpe,ker,keb=',kep,kte,kpe,ker,keb

131   format(1x,a20,5(4x,i5))

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,132) 'ibd               =',ibd
      if(dowr) write(outfile,132) 'ied               =',ied
      if(dowr) write(outfile,132) 'jbd               =',jbd
      if(dowr) write(outfile,132) 'jed               =',jed
      if(dowr) write(outfile,132) 'kbd               =',kbd
      if(dowr) write(outfile,132) 'ked               =',ked

      if( dowr )then
        if( td_diss   .gt.0 ) write(outfile,*),'  td_diss   = ',td_diss
        if( td_mptend .gt.0 ) write(outfile,*),'  td_mptend = ',td_mptend
        if( qd_vtc    .gt.0 ) write(outfile,*),'  qd_vtc    = ',qd_vtc
        if( qd_vtr    .gt.0 ) write(outfile,*),'  qd_vtr    = ',qd_vtr
        if( qd_vts    .gt.0 ) write(outfile,*),'  qd_vts    = ',qd_vts
        if( qd_vtg    .gt.0 ) write(outfile,*),'  qd_vtg    = ',qd_vtg
        if( qd_vti    .gt.0 ) write(outfile,*),'  qd_vti    = ',qd_vti
      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,132) 'ibl               =',ibl
      if(dowr) write(outfile,132) 'iel               =',iel
      if(dowr) write(outfile,132) 'jbl               =',jbl
      if(dowr) write(outfile,132) 'jel               =',jel

132   format(1x,a19,1(4x,i5))

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,133) imp,jmp,kmp,kmt,rmp,cmp

133   format(' imp,jmp,kmp,kmt,rmp,cmp =',6(2x,i5))

!----------

      if(dowr) write(outfile,*)

      if(dowr) write(outfile,*) 'rdx    =',rdx
      if(dowr) write(outfile,*) 'rdy    =',rdy
      if(dowr) write(outfile,*) 'rdz    =',rdz
      if(dowr) write(outfile,*) 'rdx2   =',rdx2
      if(dowr) write(outfile,*) 'rdy2   =',rdy2
      if(dowr) write(outfile,*) 'rdz2   =',rdz2
      if(dowr) write(outfile,*) 'rdx4   =',rdx4
      if(dowr) write(outfile,*) 'rdy4   =',rdy4
      if(dowr) write(outfile,*) 'rdz4   =',rdz4
      if(dowr) write(outfile,*) 'govtwo =',govtwo
      if(dowr) write(outfile,*) 'clwsat =',clwsat
      if(dowr) write(outfile,*) 'smeps  =',smeps
      if(dowr) write(outfile,*) 'tsmall =',tsmall
      if(dowr) write(outfile,*) 'qsmall =',qsmall
      if(dowr) write(outfile,*) 'cstar  =',cstar
      if(dowr) write(outfile,*) 'csmax  =',csmax
      if(dowr) write(outfile,*) 'epsilon=',epsilon

      if(dowr) write(outfile,*)

!--------------------------------------------------------------

      do i=ib,ie
        uh(i)=1.0
      enddo

      do i=ib,ie+1
        uf(i)=1.0
      enddo

      strx:  IF(stretch_x.ge.1)THEN

!!!        ibw=0
!!!        ibe=0

        ni1 = 0
        ni2 = 0
        ni3 = 0

!-----------------------------------------------------------------------
!  Begin hard-wired analytic stretching function

        nominal_dx = 0.5*( dx_inner + dx_outer )

      IF(stretch_x.eq.1)THEN
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' stretch_x = 1 ... stretching on both west and east sides of domain:'
        if(dowr) write(outfile,*)
        ni1 = nint( (tot_x_len-nos_x_len)*0.5/nominal_dx )
        ni2 = nint( nos_x_len/dx_inner )
        ni3 = ni1
        if(dowr) write(outfile,*) '  ni1,ni2,ni3 = ',(tot_x_len-nos_x_len)*0.5/nominal_dx,   &
                         nos_x_len/dx_inner,(tot_x_len-nos_x_len)*0.5/nominal_dx
        if(dowr) write(outfile,*) '    (note:  ni1,ni2,ni3 need to be exact integers for this to work correctly)'
      ELSEIF(stretch_x.eq.2)THEN
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' stretch_x = 2 ... stretching on east side of domain only:'
        if(dowr) write(outfile,*)
        ni1 = 0
        ni2 = nint( nos_x_len/dx_inner )
        ni3 = nint( (tot_x_len-nos_x_len)/nominal_dx )
        if(dowr) write(outfile,*) '  ni1,ni2,ni3 = ',0.0,nos_x_len/dx_inner,(tot_x_len-nos_x_len)/nominal_dx
        if(dowr) write(outfile,*) '    (note:  ni1,ni2,ni3 need to be exact integers for this to work correctly)'
      ELSE
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' stretch_x must be either 1 or 2'
        if(dowr) write(outfile,*)
        call stopcm1
      ENDIF

        c2=(nominal_dx-dx_inner)/(nominal_dx*nominal_dx*float(ni3-1))
        c1=(dx_inner/nominal_dx)-c2*nominal_dx

        if(dowr) write(outfile,*) '  nominal_dx  = ',nominal_dx
        if(dowr) write(outfile,*) '  c1,c2       = ',c1,c2
        if(dowr) write(outfile,*)

        ! Test to see if nx is kosher.
      IF(stretch_x.eq.1)THEN
        if( nx.ne.(ni1+ni2+ni3) .or. ni1.lt.0 .or. ni2.lt.0 .or. ni3.lt.0 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  User value of nx = ',nx
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '       ni1,ni2,ni3 = ',ni1,ni2,ni3
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  Value needed for these settings ...'
          if(dowr) write(outfile,*) '       dx_inner  = ',dx_inner
          if(dowr) write(outfile,*) '       dx_outer  = ',dx_outer
          if(dowr) write(outfile,*) '       nos_x_len = ',nos_x_len
          if(dowr) write(outfile,*) '       tot_x_len = ',tot_x_len
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... would be nx = ',(nos_x_len/dx_inner)+(tot_x_len-nos_x_len)/(0.5*(dx_inner+dx_outer))
          if(dowr) write(outfile,*) '  (if this number is an integer) '
          if(dowr) write(outfile,*) '  (and if ni1,ni2,ni3 are all integers) '
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... stopping ...  '
          if(dowr) write(outfile,*)
          call stopcm1
        endif
      ELSEIF(stretch_x.eq.2)THEN
        if( nx.ne.(ni1+ni2+ni3) .or. ni1.lt.0 .or. ni2.lt.0 .or. ni3.lt.0 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  User value of nx = ',nx
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '       ni1,ni2,ni3 = ',ni1,ni2,ni3
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  Value for these settings ...'
          if(dowr) write(outfile,*) '       dx_inner  = ',dx_inner
          if(dowr) write(outfile,*) '       dx_outer  = ',dx_outer
          if(dowr) write(outfile,*) '       nos_x_len = ',nos_x_len
          if(dowr) write(outfile,*) '       tot_x_len = ',tot_x_len
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... would be nx = ',(nos_x_len/dx_inner)+(tot_x_len-nos_x_len)/(0.5*(dx_inner+dx_outer))
          if(dowr) write(outfile,*) '  (if this number is an integer) '
          if(dowr) write(outfile,*) '  (and if ni1,ni2,ni3 are all integers) '
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... stopping ...  '
          if(dowr) write(outfile,*)
          call stopcm1
        endif
      ENDIF

        mult = 0.0
        if(iorigin.eq.2) mult = 0.5

      IF(stretch_x.eq.1)THEN

        do i=ni1+1,ni1+ni2+1
            xfdp(i)=ni1*nominal_dx+(i-ni1-1)*dx_inner - mult*tot_x_len
        enddo
        do i=ni1+ni2+2,ni1+ni2+ni3+4
            xfdp(i)=ni1*nominal_dx+(ni1+ni2+1-ni1-1)*dble(dx_inner)   &
                 +(c1+c2*dble(i-1-ni1-ni2)*nominal_dx)   &
                 *dble(i-1-ni1-ni2)*nominal_dx - mult*tot_x_len
        enddo
        do i=-2,ni1
            xfdp(i)=ni1*nominal_dx+(ni1+1-ni1-1)*dble(dx_inner)    &
                 -(c1+c2*dble(ni1+1-i)*nominal_dx)   &
                 *dble(ni1+1-i)*nominal_dx - mult*tot_x_len
        enddo

      ELSEIF(stretch_x.eq.2)THEN

        do i=ni1+1,ni1+ni2+1
            xfdp(i)=ni1*nominal_dx+(i-ni1-1)*dx_inner - mult*tot_x_len
        enddo
        do i=ni1+ni2+2,ni1+ni2+ni3+3
            xfdp(i)=ni1*nominal_dx+(ni1+ni2+1-ni1-1)*dble(dx_inner)   &
                 +(c1+c2*dble(i-1-ni1-ni2)*nominal_dx)   &
                 *dble(i-1-ni1-ni2)*nominal_dx - mult*tot_x_len
        enddo
        do i=-2,ni1
            xfdp(i)=ni1*nominal_dx+(ni1+1-ni1-1)*dble(dx_inner)    &
                 -(c1+c2*dble(ni1+1-i)*nominal_dx)   &
                 *dble(ni1+1-i)*nominal_dx - mult*tot_x_len
        enddo

      ENDIF

!!!        if( xf(ib).lt.0.0  .and. wbc.ne.1 ) ibw=1
!!!        if( xf(ie).gt.maxx .and. ebc.ne.1 ) ibe=1

        IF(stretch_x.eq.1)THEN
          xfdp( 0)=xfdp(1)-1*dx_outer
          xfdp(-1)=xfdp(1)-2*dx_outer
          xfdp(-2)=xfdp(1)-3*dx_outer
        ELSEIF(stretch_x.eq.2)THEN
          xfdp( 0)=xfdp(1)-1*dx_inner
          xfdp(-1)=xfdp(1)-2*dx_inner
          xfdp(-2)=xfdp(1)-3*dx_inner
        ENDIF

          xfdp(nx+2)=xfdp(nx+1)+1*dx_outer
          xfdp(nx+3)=xfdp(nx+1)+2*dx_outer
          xfdp(nx+4)=xfdp(nx+1)+3*dx_outer

!  End hard-wired analytic stretching function
!-----------------------------------------------------------------------
!
!  Optional:  to use a different stretching function, or to use 
!  arbitrarily located grid points, simply comment out the 
!  "hard-wired" section above, and then specify values for xfref
!  here.  Do not change anything below here!
!
!  Note:  xfref stores the location of the staggered u points for
!  the entire domain (from x=-2 to x=nx+4) (note: this includes
!  the boundary points that extend 3 gridpoints beyond the
!  computational domain.
!
!-----------------------------------------------------------------------

      ENDIF  strx

        do i=ib,ie+1
          xf(i)=xfdp(i+(myi-1)*ni)
        enddo

        do i=ib,ie
          xh(i)=0.5d0*(xfdp(i+1+(myi-1)*ni)+xfdp(i+(myi-1)*ni))
          uh(i)=dble(dx)/(xfdp(i+1+(myi-1)*ni)-xfdp(i+(myi-1)*ni))
        enddo

        arh1 = 1.0
        arh2 = 1.0
        arf1 = 1.0
        arf2 = 1.0

      IF(axisymm.eq.1)THEN

        print *
        do i=ib,ie
          arh1(i) = ( xfdp(i  )/( 0.5d0*(xfdp(i+1)+xfdp(i)) ) )
          arh2(i) = ( xfdp(i+1)/( 0.5d0*(xfdp(i+1)+xfdp(i)) ) )
          print *,'  arh1,arh2 = ',i,arh1(i),arh2(i),0.5*(arh1(i)+arh2(i))
        enddo
        print *
        print *
        do i=ib+1,ie
          if( abs(xfdp(i)).le.smeps )then
            arf1(i) = 1.0
            arf2(i) = 1.0
          else
            arf1(i) = ( 0.5d0*(xfdp(i-1)+xfdp(i)) / xfdp(i) )
            arf2(i) = ( 0.5d0*(xfdp(i+1)+xfdp(i)) / xfdp(i) )
          endif
          print *,'  arf1,arf2 = ',i,arf1(i),arf2(i),0.5*(arf1(i)+arf2(i))
        enddo
        print *

      ENDIF

        do i=ib+1,ie
          uf(i)=dble(dx)/( 0.5d0*(xfdp(i+1+(myi-1)*ni)+xfdp(i+(myi-1)*ni)) &
                          -0.5d0*(xfdp(i-1+(myi-1)*ni)+xfdp(i+(myi-1)*ni)) )
        enddo

        if(ibw.eq.1)then
          uf( 0)=uf(1)
          uf(-1)=uf(1)
          uf(-2)=uf(1)
        endif

        if(ibe.eq.1)then
          uf(ni+2)=uf(ni+1)
          uf(ni+3)=uf(ni+1)
          uf(ni+4)=uf(ni+1)
        endif

      do i=ib,ie
        rxh(i)=1.0/(smeps+xh(i))
        ruh(i)=1.0/uh(i)
      enddo

      do i=ib,ie+1
        rxf(i)=1.0/(smeps+xf(i))
        ruf(i)=1.0/uf(i)
      enddo

      do i=-2,nx+4
        xfref(i) = xfdp(i)
      enddo

      minx = xfref(1)
      maxx = xfref(nx+1)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'x:'
      if(dowr) write(outfile,124)
      if(dowr) write(outfile,125)
#ifdef MPI
    ! for MPI runs without procfiles, print the entire domain info:
    IF(.not.procfiles)THEN
      do i=1-ngxy,1-1
        if(dowr) write(outfile,122) i,xfref(i),0.5*(xfref(i)+xfref(i+1)),xfref(i+1)-xfref(i),dx/(0.5*(xfref(1)+xfref(2))-0.5*(xfref(0)+xfref(1))),dx/(xfref(i+1)-xfref(i)),'   x'
      enddo
      do i=1,nx
        if(dowr) write(outfile,122) i,xfref(i),0.5*(xfref(i)+xfref(i+1)),xfref(i+1)-xfref(i),dx/(0.5*(xfref(i)+xfref(i+1))-0.5*(xfref(i-1)+xfref(i))),dx/(xfref(i+1)-xfref(i)),'    '
      enddo
      do i=nx+1,nx+ngxy
        if(dowr) write(outfile,122) i,xfref(i),0.5*(xfref(i)+xfref(i+1)),xfref(i+1)-xfref(i),dx/(0.5*(xfref(nx+1)+xfref(nx+2))-0.5*(xfref(nx)+xfref(nx+1))),dx/(xfref(i+1)-xfref(i)),'   x'
      enddo
      if(dowr) write(outfile,123) nx+1+ngxy,xfref(nx+1+ngxy),dx/(0.5*(xfref(nx+1)+xfref(nx+2))-0.5*(xfref(nx)+xfref(nx+1)))
    ELSE
#endif
      do i=ib,ib+2
        if(dowr) write(outfile,122) i,xf(i),xh(i),xf(i+1)-xf(i),uf(i),uh(i),'   x'
      enddo
      do i=ib+3,ie-3
        if(dowr) write(outfile,122) i,xf(i),xh(i),xf(i+1)-xf(i),uf(i),uh(i),'    '
      enddo
      do i=ie-2,ie
        if(dowr) write(outfile,122) i,xf(i),xh(i),xf(i+1)-xf(i),uf(i),uh(i),'   x'
      enddo
      if(dowr) write(outfile,123) ie+1,xf(ie+1),uf(ie+1)
#ifdef MPI
    ENDIF
#endif
      if(dowr) write(outfile,*)

122   format(3x,i5,3x,f11.2,3x,f11.2,3x,f9.2,3x,f8.4,3x,f8.4,a4)
123   format(3x,i5,3x,f11.2,29x,f8.4)
124   format('      i         xf           xh         dx         uf         uh')
125   format(' ---------------------------------------------------------------')

!--------------------------------------------------------------

      do j=jb,je
        vh(j)=1.0
      enddo

      do j=jb,je+1
        vf(j)=1.0
      enddo

      IF(stretch_y.ge.1)THEN

!!!        ibs=0
!!!        ibn=0

!-----------------------------------------------------------------------
!  Begin hard-wired analytic stretching function

        nominal_dy = 0.5*( dy_inner + dy_outer )

      IF(stretch_y.eq.1)THEN
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' stretch_y = 1 ... stretching on both south and north sides of domain:'
        if(dowr) write(outfile,*)
        nj1 = nint( (tot_y_len-nos_y_len)*0.5/nominal_dy )
        nj2 = nint( nos_y_len/dy_inner )
        nj3 = nj1
        if(dowr) write(outfile,*) '  nj1,nj2,nj3 = ',(tot_y_len-nos_y_len)*0.5/nominal_dy,   &
                         nos_y_len/dy_inner,(tot_y_len-nos_y_len)*0.5/nominal_dy
        if(dowr) write(outfile,*) '    (note:  nj1,nj2,nj3 need to be exact integers for this to work correctly)'
      ELSEIF(stretch_y.eq.2)THEN
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' stretch_y = 2 ... stretching on north side of domain only:'
        if(dowr) write(outfile,*)
        nj1 = 0
        nj2 = nint( nos_y_len/dy_inner )
        nj3 = nint( (tot_y_len-nos_y_len)/nominal_dy )
        if(dowr) write(outfile,*) '  nj1,nj2,nj3 = ',0.0,nos_y_len/dy_inner,(tot_y_len-nos_y_len)/nominal_dy
        if(dowr) write(outfile,*) '    (note:  nj1,nj2,nj3 need to be exact integers for this to work correctly)'
      ELSE
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) ' stretch_y must be either 1 or 2'
        if(dowr) write(outfile,*)
        call stopcm1
      ENDIF

        c2=(nominal_dy-dy_inner)/(nominal_dy*nominal_dy*float(nj3-1))
        c1=(dy_inner/nominal_dy)-c2*nominal_dy

        if(dowr) write(outfile,*) '  nominal_dy  = ',nominal_dy
        if(dowr) write(outfile,*) '  c1,c2       = ',c1,c2
        if(dowr) write(outfile,*)

        ! Test to see if ny is kosher.
      IF(stretch_y.eq.1)THEN
        if( ny.ne.(nj1+nj2+nj3) .or. nj1.lt.0 .or. nj2.lt.0 .or. nj3.lt.0 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  User value of ny = ',ny
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '       nj1,nj2,nj3 = ',nj1,nj2,nj3
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  Value needed for these settings ...'
          if(dowr) write(outfile,*) '       dy_inner  = ',dy_inner
          if(dowr) write(outfile,*) '       dy_outer  = ',dy_outer
          if(dowr) write(outfile,*) '       nos_y_len = ',nos_y_len
          if(dowr) write(outfile,*) '       tot_y_len = ',tot_y_len
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... would be ny = ',(nos_y_len/dy_inner)+(tot_y_len-nos_y_len)/(0.5*(dy_inner+dy_outer))
          if(dowr) write(outfile,*) '  (if this number is an integer) '
          if(dowr) write(outfile,*) '  (and if nj1,nj2,nj3 are all integers) '
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... stopping ...  '
          if(dowr) write(outfile,*)
          call stopcm1
        endif
      ELSEIF(stretch_y.eq.2)THEN
        if( ny.ne.(nj1+nj2+nj3) .or. nj1.lt.0 .or. nj2.lt.0 .or. nj3.lt.0 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  User value of ny = ',ny
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '       nj1,nj2,nj3 = ',nj1,nj2,nj3
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  Value for these settings ...'
          if(dowr) write(outfile,*) '       dy_inner  = ',dy_inner
          if(dowr) write(outfile,*) '       dy_outer  = ',dy_outer
          if(dowr) write(outfile,*) '       nos_y_len = ',nos_y_len
          if(dowr) write(outfile,*) '       tot_y_len = ',tot_y_len
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... would be ny = ',(nos_y_len/dy_inner)+(tot_y_len-nos_y_len)/(0.5*(dy_inner+dy_outer))
          if(dowr) write(outfile,*) '  (if this number is an integer) '
          if(dowr) write(outfile,*) '  (and if nj1,nj2,nj3 are all integers) '
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... stopping ...  '
          if(dowr) write(outfile,*)
          call stopcm1
        endif
      ENDIF

        mult = 0.0
        if(iorigin.eq.2) mult = 0.5

      IF(stretch_y.eq.1)THEN

        do j=nj1+1,nj1+nj2+1
            yfdp(j)=nj1*nominal_dy+(j-nj1-1)*dy_inner - mult*tot_y_len
        enddo
        do j=nj1+nj2+2,nj1+nj2+nj3+4
            yfdp(j)=nj1*nominal_dy+(nj1+nj2+1-nj1-1)*dble(dy_inner)   &
                 +(c1+c2*dble(j-1-nj1-nj2)*nominal_dy)   &
                 *dble(j-1-nj1-nj2)*nominal_dy - mult*tot_y_len
        enddo
        do j=-2,nj1
            yfdp(j)=nj1*nominal_dy+(nj1+1-nj1-1)*dble(dy_inner)    &
                 -(c1+c2*dble(nj1+1-j)*nominal_dy)   &
                 *dble(nj1+1-j)*nominal_dy - mult*tot_y_len
        enddo

      ELSEIF(stretch_y.eq.2)THEN

        do j=nj1+1,nj1+nj2+1
            yfdp(j)=nj1*nominal_dy+(j-nj1-1)*dy_inner - mult*tot_y_len
        enddo
        do j=nj1+nj2+2,nj1+nj2+nj3+3
            yfdp(j)=nj1*nominal_dy+(nj1+nj2+1-nj1-1)*dble(dy_inner)   &
                 +(c1+c2*dble(j-1-nj1-nj2)*nominal_dy)   &
                 *dble(j-1-nj1-nj2)*nominal_dy - mult*tot_y_len
        enddo
        do j=-2,nj1
            yfdp(j)=nj1*nominal_dy+(nj1+1-nj1-1)*dble(dy_inner)    &
                 -(c1+c2*dble(nj1+1-j)*nominal_dy)   &
                 *dble(nj1+1-j)*nominal_dy - mult*tot_y_len
        enddo

      ENDIF

!!!        if( yf(jb).lt.0.0  .and. sbc.ne.1 ) ibs=1
!!!        if( yf(je).gt.maxy .and. nbc.ne.1 ) ibn=1

        IF(stretch_y.eq.1)THEN
          yfdp( 0)=yfdp(1)-1*dy_outer
          yfdp(-1)=yfdp(1)-2*dy_outer
          yfdp(-2)=yfdp(1)-3*dy_outer
        ELSEIF(stretch_y.eq.2)THEN
          yfdp( 0)=yfdp(1)-1*dy_inner
          yfdp(-1)=yfdp(1)-2*dy_inner
          yfdp(-2)=yfdp(1)-3*dy_inner
        ENDIF

          yfdp(ny+2)=yfdp(ny+1)+1*dy_outer
          yfdp(ny+3)=yfdp(ny+1)+2*dy_outer
          yfdp(ny+4)=yfdp(ny+1)+3*dy_outer

!  End hard-wired analytic stretching function
!-----------------------------------------------------------------------
!
!  Optional:  to use a different stretching function, or to use 
!  arbitrarily located grid points, simply comment out the 
!  "hard-wired" section above, and then specify values for yfref
!  here.  Do not change anything below here!
!
!  Note:  yfref stores the location of the staggered v points for
!  the entire domain (from y=-2 to y=ny+4) (note: this includes
!  the boundary points that extend 3 gridpoints beyond the
!  computational domain.
!
!-----------------------------------------------------------------------

        do j=jb,je+1
          yf(j)=yfdp(j+(myj-1)*nj)
        enddo

        do j=jb,je
          yh(j)=0.5d0*(yfdp(j+1+(myj-1)*nj)+yfdp(j+(myj-1)*nj))
          vh(j)=dble(dy)/(yfdp(j+1+(myj-1)*nj)-yfdp(j+(myj-1)*nj))
        enddo

        do j=jb+1,je
          vf(j)=dble(dy)/( 0.5d0*(yfdp(j+1+(myj-1)*nj)+yfdp(j+(myj-1)*nj)) &
                          -0.5d0*(yfdp(j-1+(myj-1)*nj)+yfdp(j+(myj-1)*nj)) )
        enddo

        if(ibs.eq.1)then
          vf( 0)=vf(1)
          vf(-1)=vf(1)
          vf(-2)=vf(1)
        endif

        if(ibn.eq.1)then
          vf(nj+2)=vf(nj+1)
          vf(nj+3)=vf(nj+1)
          vf(nj+4)=vf(nj+1)
        endif

      ENDIF

      do j=jb,je
        rvh(j)=1.0/vh(j)
      enddo

      do j=jb,je+1
        rvf(j)=1.0/vf(j)
      enddo

      do j=-2,ny+4
        yfref(j) = yfdp(j)
      enddo

      miny = yfref(1)
      maxy = yfref(ny+1)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'y:'
      if(dowr) write(outfile,134)
      if(dowr) write(outfile,125)
#ifdef MPI
    ! for MPI runs without procfiles, print the entire domain info:
    IF(.not.procfiles)THEN
      do j=1-ngxy,1-1
        if(dowr) write(outfile,122) j,yfref(j),0.5*(yfref(j)+yfref(j+1)),yfref(j+1)-yfref(j),dy/(0.5*(yfref(1)+yfref(2))-0.5*(yfref(0)+yfref(1))),dy/(yfref(j+1)-yfref(j)),'   x'
      enddo
      do j=1,ny
        if(dowr) write(outfile,122) j,yfref(j),0.5*(yfref(j)+yfref(j+1)),yfref(j+1)-yfref(j),dy/(0.5*(yfref(j)+yfref(j+1))-0.5*(yfref(j-1)+yfref(j))),dy/(yfref(j+1)-yfref(j)),'    '
      enddo
      do j=ny+1,ny+ngxy
        if(dowr) write(outfile,122) j,yfref(j),0.5*(yfref(j)+yfref(j+1)),yfref(j+1)-yfref(j),dy/(0.5*(yfref(ny+1)+yfref(ny+2))-0.5*(yfref(ny)+yfref(ny+1))),dy/(yfref(j+1)-yfref(j)),'   x'
      enddo
      if(dowr) write(outfile,123) ny+1+ngxy,yfref(ny+1+ngxy),dy/(0.5*(yfref(ny+1)+yfref(ny+2))-0.5*(yfref(ny)+yfref(ny+1)))
    ELSE
#endif
      do j=jb,jb+2
        if(dowr) write(outfile,122) j,yf(j),yh(j),yf(j+1)-yf(j),vf(j),vh(j),'   x'
      enddo
      do j=jb+3,je-3
        if(dowr) write(outfile,122) j,yf(j),yh(j),yf(j+1)-yf(j),vf(j),vh(j),'    '
      enddo
      do j=je-2,je
        if(dowr) write(outfile,122) j,yf(j),yh(j),yf(j+1)-yf(j),vf(j),vh(j),'   x'
      enddo
      if(dowr) write(outfile,123) je+1,yf(je+1),vf(je+1)
#ifdef MPI
    ENDIF
#endif
      if(dowr) write(outfile,*)

134   format('      j         yf           yh         dy         vf         vh')

!--------------------------------------------------------------

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        zf(i,j,k)=dz*(k-1)
        mf(i,j,k)=1.0
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        zh(i,j,k)=0.5*(zf(i,j,k)+zf(i,j,k+1))
        mh(i,j,k)=1.0
      enddo
      enddo
      enddo

      do k=kb,ke+1
        sigmaf(k)=zf(1,1,k)
      enddo
      do k=kb,ke
        sigma(k)=0.5*(sigmaf(k)+sigmaf(k+1))
      enddo

    IF(stretch_z.ge.1)THEN

!-----------------------------------------------------------------------
!  Begin hard-wired analytic stretching function

      strz:  IF ( stretch_z == 1 ) THEN

        nominal_dz = 0.5*(dz_bot+dz_top)

        nk1 = nint( str_bot/dz_bot )
        nk3 = nint( (ztop-str_top)/dz_top )
        nk2 = nk-(nk1+nk3)

        ! dummy checks:
        if(dowr) write(outfile,*) '  bot: ',nk1*dz_bot,str_bot,nk1*dz_bot-str_bot
        if( abs(nk1*dz_bot-str_bot).gt.0.01 )then
          if(dowr) write(outfile,*) '  depth of bottom layer does not exactly divide by dz_bot! '
          if(dowr) write(outfile,*) '  nk1*dz_bot = ',nk1*dz_bot
          if(dowr) write(outfile,*) '  str_bot    = ',str_bot
          if(dowr) write(outfile,*) '  diff       = ',nk1*dz_bot-str_bot
          if(dowr) write(outfile,*) '  stopping cm1 ... '
          call stopcm1
        endif
        if(dowr) write(outfile,*) '  mid: ',nk2*nominal_dz,(str_top-str_bot),nk2*nominal_dz-(str_top-str_bot)
        if( abs(nk2*nominal_dz-(str_top-str_bot)).ge.0.01 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) amod(str_top-str_bot,nominal_dz),1.0e-6*(str_top-str_bot)
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  depth of middle layer does not exactly divide by nominal_dz! '
          if(dowr) write(outfile,*) '  nk2*nominal_dz  = ',nk2*nominal_dz
          if(dowr) write(outfile,*) '  str_top-str_bot = ',str_top-str_bot
          if(dowr) write(outfile,*) '  diff            = ',nk2*nominal_dz-(str_top-str_bot)
          if(dowr) write(outfile,*) '  stopping cm1 ... '
          call stopcm1
        endif
        if(dowr) write(outfile,*) '  top: ',nk3*dz_top,(ztop-str_top),nk3*dz_top-(ztop-str_top)
        if( abs(nk3*dz_top-(ztop-str_top)).gt.0.01 )then
          if(dowr) write(outfile,*) '  depth of top layer does not exactly divide by dz_top! '
          if(dowr) write(outfile,*) '  nk3*dz_top   = ',nk3*dz_top
          if(dowr) write(outfile,*) '  ztop-str_top = ',ztop-str_top
          if(dowr) write(outfile,*) '  diff         = ',nk3*dz_top-(ztop-str_top)
          if(dowr) write(outfile,*) '  stopping cm1 ... '
          call stopcm1
        endif
        if( (nk1+nk2+nk3)-nk .ne. 0 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  (nk1+nk2+nk3) does not equal nk '
          if(dowr) write(outfile,*) '  (nk1+nk2+nk3) = ',(nk1+nk2+nk3)
          if(dowr) write(outfile,*) '   nk           = ',nk
          if(dowr) write(outfile,*)
          call stopcm1
        endif

        nominal_dz=(str_top-str_bot)/nk2

        c2=(nominal_dz-dz_bot)/(nominal_dz*nominal_dz*float(nk2-1))
        c1=(dz_bot/nominal_dz)-c2*nominal_dz

        ! Test to see if nk is kosher.
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  actual-nk,test-nk:',float(nk),float(nk1+nk3)+(str_top-str_bot)/(0.5*(dz_bot+dz_top))
        if( abs(float(nk)-(float(nk1+nk3)+(str_top-str_bot)/(0.5*(dz_bot+dz_top)))).gt.1.0e-3  &
              .or. nk1.lt.0 .or. nk2.lt.0 .or. nk3.lt.0 )then
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  User value of nz = ',nz
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '       nk1,nk2,nk3 = ',nk1,nk2,nk3
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  Value needed for these settings:'
          if(dowr) write(outfile,*) '       ztop      = ',ztop
          if(dowr) write(outfile,*) '       str_bot   = ',str_bot
          if(dowr) write(outfile,*) '       str_top   = ',str_top
          if(dowr) write(outfile,*) '       dz_bot    = ',dz_bot
          if(dowr) write(outfile,*) '       dz_top    = ',dz_top
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  would be nz = ',nk1+nk3+(str_top-str_bot)/(0.5*(dz_bot+dz_top))
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ... stopping ...  '
          if(dowr) write(outfile,*)
          call stopcm1
        endif

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  nk1,nk2,nk3,ntot=',nk1,nk2,nk3,(nk1+nk2+nk3)
        if(dowr) write(outfile,*) '  nominal_dz =',nominal_dz
        if(dowr) write(outfile,*) '  c1,c2 = ',c1,c2
        if(dowr) write(outfile,*)

      do j=jb,je
      do i=ib,ie

        do k=1,nk1+1
          zf(i,j,k)=(k-1)*dz_bot
        enddo
        do k=(nk1+1),(nk1+nk2+1)
          zf(i,j,k)=zf(i,j,nk1+1)+(c1+c2*float(k-1-nk1)*nominal_dz)   &
                         *float(k-1-nk1)*nominal_dz
        enddo
        do k=(nk1+nk2+2),(nk1+nk2+nk3+1)
          zf(i,j,k)=zf(i,j,k-1)+dz_top
        enddo

      enddo
      enddo

!!!      if(terrain_flag)then

        do k=1,nk1+1
          sigmaf(k)=(k-1)*dz_bot
        enddo
        do k=(nk1+1),(nk1+nk2+1)
          sigmaf(k)=sigmaf(nk1+1)+(c1+c2*float(k-1-nk1)*nominal_dz)   &
                         *float(k-1-nk1)*nominal_dz
        enddo
        do k=(nk1+nk2+2),(nk1+nk2+nk3+1)
          sigmaf(k)=sigmaf(k-1)+dz_top
        enddo

        sigmaf(0)=-sigmaf(2)
        sigmaf(nk+2)=sigmaf(nk+1)+(sigmaf(nk+1)-sigmaf(nk))

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      ELSEIF ( stretch_z == 2 ) THEN ! geometric stretching from COMMAS

! nz is ke (number of w points)
! kb = 0
! so ng = 1 and zfw1d(-ng+1:nz+ng)
! SUBROUTINE ZGRID(dz, dz_stretch, nz, nbndlyr, gzc, gze, ng, dzmax,ztopstr,rtop,dzmaxtop)
       
       nbndlyr = Int( str_bot/dz_bot + 0.01) - 1
       CALL ZGRID(dz, dz_bot, ke, nbndlyr, gzc, gze, 1, dz_top,ztopstr,rtop,dzmaxtop)
       
         IF ( myid == 0 ) THEN
           DO k = 1,ke
             write(6,*) 'k,gzc,gze = ',k,gzc(k),gze(k)
           ENDDO
         ENDIF
         gze(0) = -gze(2)
         gze(ke+1) = gze(ke) + (gze(ke) - gze(ke-1))

        DO k = kb,ke+1
         DO j = jb,je
          DO i = ib,ie
           zf(i,j,k) = gze(k)
          ENDDO
         ENDDO
        ENDDO

        if(terrain_flag)then
          write(0,*) 'terrain not yet compatible with stretch_z == 2'
          STOP
        ENDIF

        do k=kb,ke+1
          sigmaf(k)=zf(1,1,k)
        enddo
        do k=kb,ke
          sigma(k)=0.5*(sigmaf(k)+sigmaf(k+1))
        enddo

      ENDIF  strz

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!  End hard-wired analytic stretching function
!-----------------------------------------------------------------------
!
!  Optional:  to use a different stretching function, or to use 
!  arbitrarily located grid points, simply comment out the 
!  "hard-wired" section above, and then specify values for zf
!  here.  Do not change anything below here!
!
!  Note:  zf stores the location of the staggered w points. 
!
!  Note:  if you are using terrain, you need to also specify the nominal 
!  locations of the zf points in the sigmaf array.
!
!-----------------------------------------------------------------------

      do j=jb,je
      do i=ib,ie

        zf(i,j,0)=-zf(i,j,2)
        zf(i,j,nk+2)=zf(i,j,nk+1)+(zf(i,j,nk+1)-zf(i,j,nk))

        do k=0,nk+1
          zh(i,j,k)=0.5*(zf(i,j,k+1)+zf(i,j,k))
          mh(i,j,k)=dz/(zf(i,j,k+1)-zf(i,j,k))
        enddo
        zh(i,j,0)=-zh(i,j,1)
        zh(i,j,nk+1)=zh(i,j,nk)+2.0*(zf(i,j,nk+1)-zh(i,j,nk))

        do k=1,nk+1
          mf(i,j,k)=dz/(zh(i,j,k)-zh(i,j,k-1))
        enddo
        mf(i,j,0)=mf(i,j,1)
        mf(i,j,nk+2)=mf(i,j,nk+1)

      enddo
      enddo

    ENDIF

! end vertical stretching section
!-----------------------------------------------------------------------

      do k=kb,ke
        sigma(k)=0.5*(sigmaf(k)+sigmaf(k+1))
      enddo

      maxz = sigmaf(nk+1)

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rmh(i,j,k)=1.0/mh(i,j,k)
      enddo
      enddo
      enddo

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        rmf(i,j,k)=1.0/mf(i,j,k)
      enddo
      enddo
      enddo

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'model heights:'
      if(dowr) write(outfile,104)
104   format('     k       zf         zh         dz         mf         mh')
      if(dowr) write(outfile,105)
105   format(' ---------------------------------------------------------------')
      do k=1,nk
        if(dowr) write(outfile,102) k,zf(1,1,k),zh(1,1,k),zf(1,1,k+1)-zf(1,1,k),mf(1,1,k),mh(1,1,k)
102     format(3x,i4,3x,f8.2,3x,f8.2,3x,f8.2,3x,f8.4,3x,f8.4)
      enddo
      if(dowr) write(outfile,103) nk+1,zf(1,1,nk+1),mf(1,1,nk+1)
103   format(3x,i4,3x,f8.2,25x,f8.4)
      if(dowr) write(outfile,*)

!-----------------------------------------------------------------------

#ifdef MPI
      if( ibw.eq.1 .and. ibs.eq.0 ) patchsww = .true.
      if( ibw.eq.1 .and. ibn.eq.0 ) patchnww = .true.
      if( ibe.eq.1 .and. ibs.eq.0 ) patchsee = .true.
      if( ibe.eq.1 .and. ibn.eq.0 ) patchnee = .true.
      if( ibs.eq.1 .and. ibw.eq.0 ) patchsws = .true.
      if( ibs.eq.1 .and. ibe.eq.0 ) patchses = .true.
      if( ibn.eq.1 .and. ibw.eq.0 ) patchnwn = .true.
      if( ibn.eq.1 .and. ibe.eq.0 ) patchnen = .true.

      if(dowr) write(outfile,*) '  patchsww =',patchsww
      if(dowr) write(outfile,*) '  patchnww =',patchnww
      if(dowr) write(outfile,*) '  patchsee =',patchsee
      if(dowr) write(outfile,*) '  patchnee =',patchnee
      if(dowr) write(outfile,*) '  patchsws =',patchsws
      if(dowr) write(outfile,*) '  patchses =',patchses
      if(dowr) write(outfile,*) '  patchnwn =',patchnwn
      if(dowr) write(outfile,*) '  patchnen =',patchnen
      if(dowr) write(outfile,*)

      if( ibw.eq.1 .and. ibs.eq.1 ) p2tchsww = .true.
      if( ibw.eq.1 .and. ibn.eq.1 ) p2tchnww = .true.
      if( ibe.eq.1 .and. ibs.eq.1 ) p2tchsee = .true.
      if( ibe.eq.1 .and. ibn.eq.1 ) p2tchnee = .true.
      if( ibs.eq.1 .and. ibw.eq.1 ) p2tchsws = .true.
      if( ibs.eq.1 .and. ibe.eq.1 ) p2tchses = .true.
      if( ibn.eq.1 .and. ibw.eq.1 ) p2tchnwn = .true.
      if( ibn.eq.1 .and. ibe.eq.1 ) p2tchnen = .true.

      if(dowr) write(outfile,*) '  p2tchsww =',p2tchsww
      if(dowr) write(outfile,*) '  p2tchnww =',p2tchnww
      if(dowr) write(outfile,*) '  p2tchsee =',p2tchsee
      if(dowr) write(outfile,*) '  p2tchnee =',p2tchnee
      if(dowr) write(outfile,*) '  p2tchsws =',p2tchsws
      if(dowr) write(outfile,*) '  p2tchses =',p2tchses
      if(dowr) write(outfile,*) '  p2tchnwn =',p2tchnwn
      if(dowr) write(outfile,*) '  p2tchnen =',p2tchnen
      if(dowr) write(outfile,*)
#endif

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!                  BEGIN TERRAIN !
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      rds  = 1.0
      rdsf = 1.0

      zs=0.0

      gz=1.0
      rgz=1.0
      gzu=1.0
      rgzu=1.0
      gzv=1.0
      rgzv=1.0
      dzdx=0.0
      dzdy=0.0

      gx=0.0
      gxu=0.0
      gy=0.0
      gyv=0.0

      IF(terrain_flag)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  Terrain included!'
        if(dowr) write(outfile,*)

        ! moved this section of code to init_terrain in cm1r15:
        call init_terrain(xh,uh,xf,uf,yh,vh,yf,vf,rds,sigma,rdsf,sigmaf,  &
                          zh,zf,zs,gz,rgz,gzu,rgzu,gzv,rgzv,         &
                          dzdx,dzdy,gx,gxu,gy,gyv,                   &
                          reqs_u,reqs_v,reqs_s,reqs_p,               &
                          nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,           &
                          sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,   &
                          uw31,uw32,ue31,ue32,us31,us32,un31,un32,   &
                          vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,   &
                          ww31(1,1,1),ww32(1,1,1),we31(1,1,1),we32(1,1,1), &
                          ws31(1,1,1),ws32(1,1,1),wn31(1,1,1),wn32(1,1,1))

      ENDIF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!                  END   TERRAIN !
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        mh(i,j,k)=dz/(zf(i,j,k+1)-zf(i,j,k))
        rmh(i,j,k)=1.0/mh(i,j,k)
      enddo
      enddo
      enddo

      do k=kb+1,ke
      do j=jb,je
      do i=ib,ie
        mf(i,j,k)=dz/(zh(i,j,k)-zh(i,j,k-1))
      enddo
      enddo
      enddo

      do j=jb,je
      do i=ib,ie
        mf(i,j,0)=mf(i,j,1)
        mf(i,j,nk+2)=mf(i,j,nk+1)
      enddo
      enddo

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        rmf(i,j,k)=1.0/mf(i,j,k)
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------

      if(dowr) write(outfile,*) '  minx = ',minx
      if(dowr) write(outfile,*) '  maxx = ',maxx
      if(dowr) write(outfile,*) '  miny = ',miny
      if(dowr) write(outfile,*) '  maxy = ',maxy
      if(dowr) write(outfile,*) '  maxz = ',maxz
      if(dowr) write(outfile,*)

      if(dowr) write(outfile,*) '  ibw =',ibw
      if(dowr) write(outfile,*) '  ibe =',ibe
      if(dowr) write(outfile,*) '  ibs =',ibs
      if(dowr) write(outfile,*) '  ibn =',ibn
      if(dowr) write(outfile,*)

!-----------------------------------------------------------------------
!  Get min/max dx,dy,dz on grid
!  (needed for adapt_dt ... but interesting to report, nontheless)

      min_dx = 1.0e20
      min_dy = 1.0e20
      min_dz = 1.0e20

      max_dx = 0.0
      max_dy = 0.0
      max_dz = 0.0

      do i=1,ni
        min_dx = min( min_dx , xf(i+1)-xf(i) )
        max_dx = max( max_dx , xf(i+1)-xf(i) )
      enddo

      do j=1,nj
        min_dy = min( min_dy , yf(j+1)-yf(j) )
        max_dy = max( max_dy , yf(j+1)-yf(j) )
      enddo

      do k=1,nk
      do j=1,nj
      do i=1,ni
        min_dz = min( min_dz , zf(i,j,k+1)-zf(i,j,k) )
        max_dz = max( max_dz , zf(i,j,k+1)-zf(i,j,k) )
      enddo
      enddo
      enddo

#ifdef MPI
      var=0.0
      call MPI_ALLREDUCE(min_dx,var,1,MPI_REAL,MPI_MIN,MPI_COMM_WORLD,ierr)
      min_dx=var
      var=0.0
      call MPI_ALLREDUCE(min_dy,var,1,MPI_REAL,MPI_MIN,MPI_COMM_WORLD,ierr)
      min_dy=var
      var=0.0
      call MPI_ALLREDUCE(min_dz,var,1,MPI_REAL,MPI_MIN,MPI_COMM_WORLD,ierr)
      min_dz=var
      var=0.0
      call MPI_ALLREDUCE(max_dx,var,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      max_dx=var
      var=0.0
      call MPI_ALLREDUCE(max_dy,var,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      max_dy=var
      var=0.0
      call MPI_ALLREDUCE(max_dz,var,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      max_dz=var
#endif

      if(dowr) write(outfile,*) '  min_dx = ',min_dx
      if(dowr) write(outfile,*) '  max_dx = ',max_dx
      if(dowr) write(outfile,*) '  min_dy = ',min_dy
      if(dowr) write(outfile,*) '  max_dy = ',max_dy
      if(dowr) write(outfile,*) '  min_dz = ',min_dz
      if(dowr) write(outfile,*) '  max_dz = ',max_dz
      if(dowr) write(outfile,*)

!--------------------------------------------------------------
!  new (cm1r16) arrays for vertical interpolation:

      do k=1,nk+1
      do j=jb,je
      do i=ib,ie
        cc2(i,j,k)=(zf(i,j,k)-zh(i,j,k-1))/(zh(i,j,k)-zh(i,j,k-1))
      enddo
      enddo
      enddo

      call bcs(cc2)
#ifdef MPI
      call comm_all_s(cc2,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,  &
                          n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,reqs_s)
#endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  k,c1,c2,zhm1,zf,zh:'
      do k=1,nk+1
      do j=jb,je
      do i=ib,ie
        cc1(i,j,k)=1.0-cc2(i,j,k)
        if(i.eq.1.and.j.eq.1.and.dowr) write(outfile,141) k,cc1(i,j,k),cc2(i,j,k),zh(i,j,k-1),zf(i,j,k),zh(i,j,k)
141     format(3x,i4,2(3x,f7.4),3(3x,f8.2))
      enddo
      enddo
      enddo
      if(dowr) write(outfile,*)

!--------------------------------------------------------------
!  Specify coefficient for Rayleigh damper in vertical

      if( (irdamp.eq.1).and.(zd.lt.maxz) )then

        IF( zd.lt.(0.5*maxz) )THEN
          if(myid.eq.0)then
          print *
          print *,'  Warning:  with these settings, Rayleigh damping would  '
          print *,'  be applied over MORE than half the domain '
          print *
          print *,'  zd,maxz = ',zd,maxz
          print *
          print *,'   stopping model .... '
          print *
          endif
#ifdef MPI
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1
        ENDIF

        do j=jb,je
        do i=ib,ie
          do k=1,nk
            if(zh(i,j,k).gt.zd)then
            tauh(i,j,k)=0.5*(1.0-cos(pi*(zh(i,j,k)-zd)/(zf(i,j,nk+1)-zd)))
            taus(i,j,k)=tauh(i,j,k)
            endif
          enddo
          enddo
        enddo
 
        do j=jb,je
        do i=ib,ie
          do k=1,nk+1
            if(zf(i,j,k).gt.zd)then
            tauf(i,j,k)=0.5*(1.0-cos(pi*(zf(i,j,k)-zd)/(zf(i,j,nk+1)-zd)))
            endif
          enddo
          enddo
        enddo

      endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  ------ tauf, tauh -----'
      do k=1,nk
        if(dowr) write(outfile,*) k,tauf(1,1,k),tauh(1,1,k)
      enddo
      if(dowr) write(outfile,*) nk+1,tauf(1,1,nk+1)
      if(dowr) write(outfile,*)

!--------------------------------------------------------------
!  Rayleigh damping near lateral boundaries:

      IF(hrdamp.eq.1)THEN

        IF( nx.gt.1 )THEN
        IF( xhd.gt.(0.5*(maxx-minx)) )THEN
          if(myid.eq.0)then
          print *
          print *,'  Warning:  with these settings, Rayleigh damping would  '
          print *,'  be applied over MORE than half the domain '
          print *
          print *,'  xhd,minx,maxx = ',xhd,minx,maxx
          print *
          print *,'   stopping model .... '
          print *
          endif
#ifdef MPI
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1
        ENDIF
        ENDIF
        IF( ny.gt.1 )THEN
        IF( xhd.gt.(0.5*(maxy-miny)) )THEN
          if(myid.eq.0)then
          print *
          print *,'  Warning:  with these settings, Rayleigh damping would  '
          print *,'  be applied over MORE than half the domain '
          print *
          print *,'  xhd,miny,maxy = ',xhd,miny,maxy
          print *
          print *,'   stopping model .... '
          print *
          endif
#ifdef MPI
          call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
          call stopcm1
        ENDIF
        ENDIF

        do k=1,nk
        do j=jb,je
        do i=ib,ie
          ! skip this section of code for 2d simulations:
          IF(nx.gt.1)THEN
            ! west boundary:
            IF( axisymm.ne.1 )THEN
              x1 = (xhd+minx)-xh(i)
              if( x1.gt.0.0 )then
                tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*x1/xhd)) )
                tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*x1/xhd)) )
              endif
            ENDIF
            ! east boundary:
            x2 = xh(i)-(maxx-xhd)
            if( x2.gt.0.0 )then
              tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*x2/xhd)) )
              tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*x2/xhd)) )
            endif
          ENDIF
          ! skip this section of code for 2d simulations:
          IF(ny.gt.1)THEN
            ! south boundary:
            y1 = (xhd+miny)-yh(j)
            if( y1.gt.0.0 )then
              tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*y1/xhd)) )
              tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*y1/xhd)) )
            endif
            ! north boundary:
            y2 = yh(j)-(maxy-xhd)
            if( y2.gt.0.0 )then
              tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*y2/xhd)) )
              tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*y2/xhd)) )
            endif
          ENDIF
        enddo
        enddo
        enddo

        IF( nx.gt.1 )THEN
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ------ tauh for horizontal Rayleigh damping (W-to-E) -----'
          j = nint(0.5*float(nj))
          j = max( j , 1 )
          j = min( j , nj )
          if(dowr) write(outfile,*) '  i,tauh:'
          do i=0,ni+1
            if(dowr) write(outfile,*) i,tauh(i,j,1)
          enddo
          if(dowr) write(outfile,*)
        ENDIF

        IF( ny.gt.1 )THEN
          if(dowr) write(outfile,*)
          if(dowr) write(outfile,*) '  ------ tauh for horizontal Rayleigh damping (S-to-N) -----'
          i = nint(0.5*float(ni))
          i = max( i , 1 )
          i = min( i , ni )
          if(dowr) write(outfile,*) '  j,tauh:'
          do j=0,nj+1
            if(dowr) write(outfile,*) j,tauh(i,j,1)
          enddo
          if(dowr) write(outfile,*)
        ENDIF

      ENDIF

!--------------------------------------------------------------
!  vertically implicit turbulent diffusion:

      ! Set vialpha:
      !      0.0 = forward-in-time (unstable if K dt / (dz^2) > 0.5)
      !      0.5 = centered-in-time (Crank-Nicholson) (stable but oscillatory)
      !      1.0 = backward-in-time (stable)
!      vialpha = 1.0

      ! Do not change this:
!      vibeta  = 1.0 - vialpha

!      NOTE:  these are now set in constants.incl files

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  vialpha,vibeta = ',vialpha,vibeta
        if(dowr) write(outfile,*)

!--------------------------------------------------------------

      dt = dtl
      dtlast = dt

      deallocate( xfdp )
      deallocate( yfdp )

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Get 2nd-order extrapolation coefficients (Fornberg 1988)   ccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

  DO nn=1,2

    IF(nn.eq.1)THEN
      x0 = sigmaf(1)/(sigmaf(2)-sigmaf(1))
      alpha(0) = sigma(1)/(sigmaf(2)-sigmaf(1))
      alpha(1) = sigma(2)/(sigmaf(2)-sigmaf(1))
      alpha(2) = sigma(3)/(sigmaf(2)-sigmaf(1))
      alpha(3) = sigma(4)/(sigmaf(2)-sigmaf(1))
    ELSE
      x0 = sigmaf(nk+1)/(sigmaf(nk+1)-sigmaf(nk))
      alpha(0) = sigma(nk  )/(sigmaf(nk+1)-sigmaf(nk))
      alpha(1) = sigma(nk-1)/(sigmaf(nk+1)-sigmaf(nk))
      alpha(2) = sigma(nk-2)/(sigmaf(nk+1)-sigmaf(nk))
      alpha(3) = sigma(nk-3)/(sigmaf(nk+1)-sigmaf(nk))
    ENDIF

      delta = 0.0

      delta(0,0,0) = 1.0
      b1 = 1.0

      do n = 1,bign
        b2 = 1.0
        do nu = 0,n-1
          b3 = alpha(n)-alpha(nu)
          b2 = b2*b3
          if( n.le.bigm ) delta(n-1,n,nu) = 0.0
          do m = 0,min(n,bigm)
            delta(n,m,nu) = ( (alpha(n)-x0)*delta(n-1,m,nu) - m*delta(n-1,m-1,nu) )/b3
          enddo
        enddo
        do m = 0,min(n,bigm)
          delta(n,m,n) = (b1/b2)*( m*delta(n-1,m-1,n-1) - (alpha(n-1)-x0)*delta(n-1,m,n-1) )
        enddo
        b1 = b2
      enddo

    IF(nn.eq.1)THEN
      cgs1 = delta(2,0,0)
      cgs2 = delta(2,0,1)
      cgs3 = delta(2,0,2)
      var = cgs1*sigma(1)+cgs2*sigma(2)+cgs3*sigma(3)
      dgs1 = delta(2,1,0)
      dgs2 = delta(2,1,1)
      dgs3 = delta(2,1,2)
    ELSE
      cgt1 = delta(2,0,0)
      cgt2 = delta(2,0,1)
      cgt3 = delta(2,0,2)
      var = cgt1*sigma(nk)+cgt2*sigma(nk-1)+cgt3*sigma(nk-2)
      dgt1 = delta(2,1,0)
      dgt2 = delta(2,1,1)
      dgt3 = delta(2,1,2)
    ENDIF

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  x0,alpha,delta,sum,predict,maxz:'
      if(dowr) write(outfile,*) sngl(x0)
      if(dowr) write(outfile,*) sngl(alpha(0)),sngl(alpha(1)),sngl(alpha(2)),sngl(alpha(3))
      if(dowr) write(outfile,*) sngl(delta(2,0,0)),sngl(delta(2,0,1)),sngl(delta(2,0,2)),sngl(delta(2,0,3))
      if(dowr) write(outfile,*) sngl(delta(2,0,0)+delta(2,0,1)+delta(2,0,2)+delta(2,0,3)),var,maxz
      if(dowr) write(outfile,*)

      IF( nn.eq.1 )then
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  cgs1,cgs2,cgs3 = ',cgs1,cgs2,cgs3
        if(dowr) write(outfile,*) '  sum            = ',cgs1+cgs2+cgs3
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  dgs1,dgs2,dgs3 = ',dgs1,dgs2,dgs3
        if(dowr) write(outfile,*) '  sum            = ',dgs1+dgs2+dgs3
        if(dowr) write(outfile,*)
      ELSEIF( nn.eq.2 )THEN
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  cgt1,cgt2,cgt3 = ',cgt1,cgt2,cgt3
        if(dowr) write(outfile,*) '  sum            = ',cgt1+cgt2+cgt3
        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  dgt1,dgt2,dgt3 = ',dgt1,dgt2,dgt3
        if(dowr) write(outfile,*) '  sum            = ',dgt1+dgt2+dgt3
        if(dowr) write(outfile,*)
      ENDIF

  ENDDO

!--------------------------------------------------------------
!  cm1r18:  Set ghost points for zh
!  [Note:  since cm1r17, the array index (i,j,0) means the surface]
!     (upper/lower ghost points are used by parcel subroutines only)

    DO j=jb,je
    DO i=ib,ie
      zh(i,j,0) = zf(i,j,1)
      zh(i,j,nk+1) = zf(i,j,nk+1)
    ENDDO
    ENDDO

!--------------------------------------------------------------

      if(dowr) write(outfile,*) 'Leaving PARAM'

      return

8000  print *
      print *,'  8000: error opening namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8001  print *
      print *,'  8001: error reading param1 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8002  print *
      print *,'  8002: error reading param2 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8003  print *
      print *,'  8003: error reading param3 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8004  print *
      print *,'  8004: error reading param4 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8005  print *
      print *,'  8005: error reading param5 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8006  print *
      print *,'  8006: error reading param6 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8007  print *
      print *,'  8007: error reading param7 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8008  print *
      print *,'  8008: error reading param8 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8009  print *
      print *,'  8009: error reading param9 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8010  print *
      print *,'  8010: error reading param10 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8011  print *
      print *,'  8011: error reading param11 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8012  print *
      print *,'  8012: error reading param12 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8013  print *
      print *,'  8013: error reading param13 section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

8051  print *
      print *,'  8051: error reading nssl2mom_params section of namelist.input '
      print *,'    ... stopping cm1 ... '
      print *
      call stopcm1

      end subroutine param


!-------------------------------------------------------------------------------
!
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>   SUBROUTINE ZGRID  <<<<<<<<<<<<<<<<<<<<<<<<<<< !
!
!-------------------------------------------------------------------------------
! Creates the vertical grid using a geometric stretch 
!
! Option - set nbndlyr > 0 input deck.  A suggested value is ~ nz/4 to create a 
! layer having constant resolution near the surface.
!
!-------------------------------------------------------------------------------

 SUBROUTINE ZGRID(dz, dz_stretch, nz, nbndlyr, gzc, gze, ng, dzmax,ztopstr,rtop,dzmaxtop)

   implicit none


   real dz, dz_stretch
   real  dzmax,ztopstr,rtop,dzmaxtop
   integer, intent(in) :: nbndlyr, nz, ng
   double precision gzc(-ng+1:nz+ng), gze(-ng+1:nz+ng)  ! stay   real gzc(nz), gze(nz)  ??

!   real dzmax
!   parameter( dzmax = 700. )
   integer n, k
   double precision stretch, zx, xmid, fmid, ztop

   real zheight
!   external zheight

!-----------------------------------------------------------------------------
! MPI LOCAL VARIABLES

! Use Newton interation to find grid coefficients

   ztop    = dz * (nz-1)
   zx      = 1.0d0
   stretch = 1.0d0

   IF( dz .gt. dz_stretch ) THEN

    DO n = 1,50

     IF( abs(zx) .gt. 1.0e-12 ) THEN
      zx   = zx * 0.5
      xmid = stretch + zx
      fmid = ZHEIGHT(dz_stretch,xmid,nz-1,dzmax,nbndlyr,ztopstr,rtop,dzmaxtop) - ztop
!      write(6,*) 'Stretch: ',n,zx,xmid,fmid,fmid + ztop
      IF( fmid .le. 0.0 ) stretch = xmid
      IF ( fmid .eq. 0.0d0 ) EXIT
     ENDIF

    ENDDO

   ENDIF

   write(6,*)
   IF( stretch .gt. 1.1 ) THEN
    write(6,*) 'STRETCH FAC TOO BIG! - NUMERICAL ERRORS WILL BE LARGE'
    write(6,*) 'STRETCH FAC  = ',stretch
    write(6,*) 'INCREASE NZ in namelist or increase dz_bot'
    STOP
   ELSE
    write(6,*) 'ZGRID:  STRETCH FAC  = ',stretch
    write(6,*) 'ZGRID:  DOMAIN  HGT  = ',ZHEIGHT(dz_stretch,stretch,nz-1,dzmax,nbndlyr,ztopstr,rtop,dzmaxtop)
   ENDIF

   gze(1) = 0.0
   DO k = 1,nz-1
    gze(k+1) = ZHEIGHT(dz_stretch,stretch,k,dzmax,nbndlyr,ztopstr,rtop,dzmaxtop)
    gzc(k)   = 0.5 * ( gze(k) + gze(k+1) )
!    write(6,*) 'ZGRID: gze,gzc = ',k,gze(k+1),gzc(k)
   ENDDO

   gzc(nz) = 2.*gzc(nz-1) - gzc(nz-2) 


  END SUBROUTINE ZGRID

!--------------------------------------------------------------------------
! FUNCTION ZHEIGHT:  Computes the height of a geometrically stretched grid
!                    with a few wrinkles:  It can have a layer of constant
!                    dz at the bottom 'n1' layers thick, it also limits
!                    the size of dz at the top of the model to be 'dzmax'.

 REAL FUNCTION ZHEIGHT(dzbot,r,nz,dzmax,n1,zctop,ztopr,dzmax2)

  implicit none
  integer nz, n1, k, k2
  integer n2
  real dzbot
  double precision r
  double precision sum
  double precision dznew, dzmaxdp, dzmax2dp
  real dzmax
  real zctop  ! height for upper level stretch
  real ztopr  ! upper level stretch factor
  real dzmax2 ! maximum upper dz
  real dzm

  sum = 0.0d0
  dzmaxdp = dzmax
  dzmax2dp = dzmax2
  
!  zctop = 10000.
!  ztopr = 1.09
!  dzmax2 = 1000. ! 2*dzmax
  
  n2 = 0

  DO k = 1,nz

   IF( k .le. n1 ) THEN
    dznew=dzbot
   ELSE
    k2=k-n1
    dznew = Min(dzbot * r**(k2-1),dzmaxdp)
      IF ( sum .ge. zctop ) THEN
       IF ( n2 .eq. 0 ) dzm = Min(dznew,dzmaxdp)
       n2 = n2 + 1
       dznew = Min(dzm * ztopr**n2, dzmax2)
      ENDIF
   ENDIF
   sum = sum + dznew

  ENDDO

  ZHEIGHT = sum

 RETURN
 END FUNCTION ZHEIGHT

parcel.F        1587424407  1602  20    100644  50298     `


      subroutine parcel_driver(dt,xh,uh,ruh,xf,yh,vh,rvh,yf,zh,mh,rmh,zf,mf,    &
                               znt,rho,ua,va,wa,pdata,packet,ploc,              &
                               reqs_p,reqs_u,reqs_v,reqs_w,                     &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                 &
                               nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                               n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,         &
                               uw31,uw32,ue31,ue32,us31,us32,un31,un32,         &
                               vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,         &
                               ww31,ww32,we31,we32,ws31,ws32,wn31,wn32)
#ifdef MPI
      use mpi
#endif
      implicit none

!-----------------------------------------------------------------------
!  This subroutine updates the parcel locations
!-----------------------------------------------------------------------

      include 'input.incl'
      include 'constants.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh,rmh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf
      real, intent(in), dimension(ib:ie,jb:je) :: znt
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(npvals,nparcels) :: pdata
      real, intent(inout), dimension(3,nparcels) :: packet,ploc
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_p
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(cmp,cmp,kmt+1) :: n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, intent(inout), dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32

      integer :: n,np,i,j,k,iflag,jflag,kflag
      real :: uval,vval,wval,rx,ry,rz,w1,w2,w3,w4,w5,w6,w7,w8,wsum
      real :: x3d,y3d,z3d
      integer :: nrkp
      real :: dt2,uu1,vv1,ww1
      real :: z0,rznt,var

      logical, parameter :: debug = .false.

!----------------------------------------------------------------------
!  get corner info, ghost zone data, etc:
!  (may not parallelize correctly if this is not done)

      call bcu(ua)
#ifdef MPI
      call comm_3u_start(ua,uw31,uw32,ue31,ue32,us31,us32,un31,un32,reqs_u)
#endif
      call bcv(va)
#ifdef MPI
      call comm_3v_start(va,vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,reqs_v)
#endif
      call bcw(wa,1)
#ifdef MPI
      call comm_3w_start(wa,ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,reqs_w)
      call comm_3u_end(  ua,uw31,uw32,ue31,ue32,us31,us32,un31,un32,reqs_u)
      call comm_3v_end(  va,vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,reqs_v)
      call comm_3w_end(  wa,ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,reqs_w)
      call getcorneru3(ua,n3w1(1,1,1),n3w2(1,1,1),n3e1(1,1,1),n3e2(1,1,1),  &
                          s3w1(1,1,1),s3w2(1,1,1),s3e1(1,1,1),s3e2(1,1,1))
      call getcornerv3(va,n3w1(1,1,1),n3w2(1,1,1),n3e1(1,1,1),n3e2(1,1,1),  &
                          s3w1(1,1,1),s3w2(1,1,1),s3e1(1,1,1),s3e2(1,1,1))
      call getcornerw3(wa,n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2)
      call bcu2(ua)
      call bcv2(va)
      call bcw2(wa)
#endif

!----------------------------------------------------------------------
!  apply bottom/top boundary conditions:
!  [Note:  for u,v the array index (i,j,0) means the surface, ie z=0]
!     (for the parcel subroutines only!)

!$omp parallel do default(shared)  &
!$omp private(i,j)
  DO j=jb,je+1

    IF(bbc.eq.1)THEN
      ! free slip ... extrapolate:
      IF(j.le.je)THEN
      do i=ib,ie+1
        ua(i,j,0) = cgs1*ua(i,j,1)+cgs2*ua(i,j,2)+cgs3*ua(i,j,3)
      enddo
      ENDIF
      do i=ib,ie
        va(i,j,0) = cgs1*va(i,j,1)+cgs2*va(i,j,2)+cgs3*va(i,j,3)
      enddo
    ELSEIF(bbc.eq.2)THEN
      ! no slip:
      IF(j.le.je)THEN
      do i=ib,ie+1
        ua(i,j,0) = 0.0
      enddo
      ENDIF
      do i=ib,ie
        va(i,j,0) = 0.0
      enddo
    ELSEIF(bbc.eq.3)THEN
      ! u,v near sfc are determined below using log-layer equations
    ENDIF

!----------

    IF(tbc.eq.1)THEN
      ! free slip ... extrapolate:
      IF(j.le.je)THEN
      do i=ib,ie+1
        ua(i,j,nk+1) = cgt1*ua(i,j,nk)+cgt2*ua(i,j,nk-1)+cgt3*ua(i,j,nk-2)
      enddo
      ENDIF
      do i=ib,ie
        va(i,j,nk+1) = cgt1*va(i,j,nk)+cgt2*va(i,j,nk-1)+cgt3*va(i,j,nk-2)
      enddo
    ELSEIF(tbc.eq.2)THEN
      ! no slip:
      IF(j.le.je)THEN
      do i=ib,ie+1
        ua(i,j,nk+1) = 0.0
      enddo
      ENDIF
      do i=ib,ie
        va(i,j,nk+1) = 0.0
      enddo
    ENDIF

!----------

      ! assuming no terrain:
      IF(j.le.je)THEN
      do i=ib,ie
        wa(i,j,1)    = 0.0
        wa(i,j,nk+1) = 0.0
      enddo
      ENDIF

  ENDDO

!----------------------------------------------------------------------
!  Loop through all parcels:  if you have it, update it's location:

    dt2 = dt/2.0

    nploop:  DO np=1,nparcels

      x3d = pdata(prx,np)
      y3d = pdata(pry,np)
      z3d = pdata(prz,np)

      iflag=-100
      jflag=-100
      kflag=0

    IF(nx.eq.1)THEN
      iflag = 1
    ELSE
      do i=1,ni
        if( x3d.ge.xf(i) .and. x3d.le.xf(i+1) ) iflag=i
      enddo
    ENDIF

    IF(axisymm.eq.1.or.ny.eq.1)THEN
      jflag = 1
    ELSE
      do j=1,nj
        if( y3d.ge.yf(j) .and. y3d.le.yf(j+1) ) jflag=j
      enddo
    ENDIF

#ifdef MPI
      ! check for conflict:
    IF( (iflag.ge.1.and.iflag.le.ni) .and.   &
        (jflag.ge.1.and.jflag.le.nj) )THEN
      IF( iflag.eq.ni .and. pdata(prx,np).eq.xf(iflag+1) .and. nodex.gt.1 .and.  myi.ne.nodex ) iflag = -1
      IF( jflag.eq.nj .and. pdata(pry,np).eq.yf(jflag+1) .and. nodey.gt.1 .and.  myj.ne.nodey ) jflag = -1
    ENDIF
#endif

      myparcel:  IF( (iflag.ge.1.and.iflag.le.ni) .and.   &
                     (jflag.ge.1.and.jflag.le.nj) )THEN

      rkloop:  DO nrkp = 1,2

      IF( nrkp.eq.1 )THEN
        i=iflag
        j=jflag
      ELSE
        iflag = -100
        jflag = -100
        IF(nx.eq.1)THEN
          iflag = 1
        ELSE
          do i=0,ni+1
            if( x3d.ge.xf(i) .and. x3d.le.xf(i+1) ) iflag=i
          enddo
        ENDIF
        IF(axisymm.eq.1.or.ny.eq.1)THEN
          jflag = 1
        ELSE
          do j=0,nj+1
            if( y3d.ge.yf(j) .and. y3d.le.yf(j+1) ) jflag=j
          enddo
        ENDIF
        i=iflag
        j=jflag
      ENDIF

        IF(debug)THEN
        if( i.lt.0 .or. i.gt.(ni+1) .or. j.lt.0 .or. j.gt.(nj+1) )then
          print *,'  myid,i,j = ',myid,i,j
          print *,'  x,x1     = ',x3d,pdata(prx,np)
          print *,'  y,y1     = ',y3d,pdata(pry,np)
          do i=0,ni+1
            print *,i,abs(xh(i)-x3d),0.5*dx*ruh(i)
          enddo
          do j=0,nj+1
            print *,j,abs(yh(j)-y3d),0.5*dy*rvh(j)
          enddo
          call stopcm1
        endif
        ENDIF

        kflag = 1
        do while( z3d.ge.zf(iflag,jflag,kflag) )
          kflag = kflag+1
        enddo
        kflag = kflag-1

        IF(debug)THEN
        if( kflag.le.0 .or. kflag.ge.(nk+1) )then
          print *,myid,nrkp
          print *,iflag,jflag,kflag
          print *,pdata(prx,np),pdata(pry,np),pdata(prz,np)
          print *,x3d,y3d,z3d
          print *,uval,vval,wval
          print *,zf(iflag,jflag,kflag),z3d,zf(iflag,jflag,kflag+1)
          print *,'  16667 '
          call stopcm1
        endif
        ENDIF

!----------------------------------------------------------------------
!  Data on u points

        i=iflag
        j=jflag
        k=kflag

        if( y3d.lt.yh(j) )then
          j=j-1
        endif
        if( z3d.lt.zh(iflag,jflag,k) )then
          k=k-1
        endif

        rx = ( x3d-xf(i) )/( xf(i+1)-xf(i) )
        ry = ( y3d-yh(j) )/( yh(j+1)-yh(j) )
        rz = ( z3d-zh(iflag,jflag,k) )/( zh(iflag,jflag,k+1)-zh(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.0 .or. i.gt.(ni+1)   .or.        &
            j.lt.-1 .or. j.gt.(nj+1)   .or.       &
            k.lt.0 .or. k.gt.nk                   )then
          print *
          print *,'  13333a: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *,'  xf1,x3d,xf2 = ',xf(i),x3d,xf(i+1)
          print *,'  yh1,y3d,yh2 = ',yh(j),y3d,yh(j+1)
          print *,'  zh1,z3d,zh2 = ',zh(iflag,jflag,k),z3d,zh(iflag,jflag,k+1)
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni+1,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,ua,uval)

!----------------------------------------------------------------------
!  Data on v points

        i=iflag
        j=jflag
        k=kflag

        if( x3d.lt.xh(i) )then
          i=i-1
        endif
        if( z3d.lt.zh(iflag,jflag,k) )then
          k=k-1
        endif

        rx = ( x3d-xh(i) )/( xh(i+1)-xh(i) )
        ry = ( y3d-yf(j) )/( yf(j+1)-yf(j) )
        rz = ( z3d-zh(iflag,jflag,k) )/( zh(iflag,jflag,k+1)-zh(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.-1 .or. i.gt.(ni+1)   .or.       &
            j.lt.0 .or. j.gt.(nj+1)   .or.        &
            k.lt.0 .or. k.gt.nk                   )then
          print *
          print *,'  23333b: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *,'  xh1,x3d,xh2 = ',xh(i),x3d,xh(i+1)
          print *,'  yf1,y3d,yh2 = ',yf(j),y3d,yf(j+1)
          print *,'  zh1,z3d,zh2 = ',zh(iflag,jflag,k),z3d,zh(iflag,jflag,k+1)
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni,nj+1,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,va,vval)

!----------------------------------------------------------------------
!  uv for parcels below lowest model level:

      IF( bbc.eq.3 )THEN
        ! semi-slip lower boundary condition:
        if( z3d.lt.zh(1,1,1) )then
          ! re-calculate velocities if parcel is below lowest model level:
          !------
          ! u at lowest model level:
          i=iflag
          j=jflag
          if( y3d.lt.yh(j) )then
            j=j-1
          endif
          call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 1, 0, 1, 0,ua(ib,jb,1),uval)
          !------
          ! v at lowest model level:
          i=iflag
          j=jflag
          if( x3d.lt.xh(i) )then
            i=i-1
          endif
          call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 0, 1, 0, 1,va(ib,jb,1),vval)
          !------
          ! z0:
          i=iflag
          j=jflag
          if( x3d.lt.xh(i) )then
            i=i-1
          endif
          if( y3d.lt.yh(j) )then
            j=j-1
          endif
          call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 0, 0, 0, 0,znt,z0)
          !------
          ! get u,v from (neutral) log-layer equation:
          rznt = 1.0/z0
          var = alog((z3d+z0)*rznt)/alog((zh(1,1,1)+z0)*rznt)
          uval = uval*var
          vval = vval*var
        endif
      ENDIF

!----------------------------------------------------------------------
!  Data on w points

        i=iflag
        j=jflag
        k=kflag

        if( x3d.lt.xh(i) )then
          i=i-1
        endif
        if( y3d.lt.yh(j) )then
          j=j-1
        endif

        rx = ( x3d-xh(i) )/( xh(i+1)-xh(i) )
        ry = ( y3d-yh(j) )/( yh(j+1)-yh(j) )
        rz = ( z3d-zf(iflag,jflag,k) )/( zf(iflag,jflag,k+1)-zf(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.-1 .or. i.gt.(ni+1)   .or.       &
            j.lt.-1 .or. j.gt.(nj+1)   .or.       &
            k.lt.1 .or. k.gt.nk                   )then
          print *
          print *,'  43333a: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *,'  xh1,x3d,xh2 = ',xh(i),x3d,xh(i+1)
          print *,'  yh1,y3d,yh2 = ',yh(j),y3d,yh(j+1)
          print *,'  zh1,z3d,zh2 = ',zf(iflag,jflag,k),z3d,zf(iflag,jflag,k+1)
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,wa,wval)

!-----------------------------------------------------
!  Update parcel positions:
!-----------------------------------------------------

      ! RK2 scheme:
      IF(nrkp.eq.1)THEN
        IF(nx.eq.1)THEN
          x3d=0.0
        ELSE
          x3d=pdata(prx,np)+dt*uval
        ENDIF
        IF(axisymm.eq.1.or.ny.eq.1)THEN
          y3d=0.0
        ELSE
          y3d=pdata(pry,np)+dt*vval
        ENDIF
        z3d=pdata(prz,np)+dt*wval
        uu1=uval
        vv1=vval
        ww1=wval
      ELSE
        IF(nx.eq.1)THEN
          x3d=0.0
        ELSE
          x3d=pdata(prx,np)+dt2*(uu1+uval)
        ENDIF
        IF(axisymm.eq.1.or.ny.eq.1)THEN
          y3d=0.0
        ELSE
          y3d=pdata(pry,np)+dt2*(vv1+vval)
        ENDIF
        z3d=pdata(prz,np)+dt2*(ww1+wval)
      ENDIF

        IF( z3d.lt.0.0 )THEN
          print *,'  parcel is below surface:  np,x3d,y3d,z3d = ',np,x3d,y3d,z3d
          z3d=1.0e-6
        ENDIF
        z3d=min(z3d,maxz)

      ENDDO  rkloop

!-----------------------------------------------------
!  Account for boundary conditions (if necessary)
!-----------------------------------------------------

        ! New for cm1r17:  if parcel exits domain,
        ! just assume periodic lateral boundary conditions
        ! (no matter what actual settings are for wbc,ebc,sbc,nbc)

        if(x3d.lt.minx)then
          x3d=x3d+(maxx-minx)
        endif
        if(x3d.gt.maxx)then
          x3d=x3d-(maxx-minx)
        endif

        if( (y3d.gt.maxy).and.(axisymm.ne.1).and.(ny.ne.1) )then
          y3d=y3d-(maxy-miny)
        endif
        if( (y3d.lt.miny).and.(axisymm.ne.1).and.(ny.ne.1) )then
          y3d=y3d+(maxy-miny)
        endif

        pdata(prx,np)=x3d
        pdata(pry,np)=y3d
        pdata(prz,np)=z3d

#ifdef MPI
        do n=1,3
          ploc(n,np) = pdata(n,np)
        enddo

      ELSE

        ! set to really small number (so we can use the allreduce command below)
        do n=1,3
          ploc(n,np) = -1.0e30
        enddo
#endif

      ENDIF  myparcel

    ENDDO  nploop

!----------------------------------------------------------------------
!  communicate data  (for MPI runs)

#ifdef MPI

        call MPI_ALLREDUCE(ploc(1,1),packet(1,1),3*nparcels,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)

        DO np=1,nparcels
        DO n=1,3
          pdata(n,np) = packet(n,np)
        ENDDO
        ENDDO

#endif

!----------------------------------------------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine parcel_interp(dt,xh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                               zh,mh,rmh,zf,mf,znt,ust,c1,c2,          &
                               pi0,th0,thv0,qv0,qc0,qi0,rth0,          &
                               dum1,dum2,dum3,dum4,zv  ,qt  ,prs,rho,  &
                               dbz ,dum7,dum8,buoy,vpg  ,              &
                               u3d,v3d,w3d,pp3d,th   ,t     ,th3d,q3d, &
                               kmh,kmv,khh,khv,tke3d,pt3d,pdata,       &
                               packet,reqs_p,                          &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,        &
                               nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
#ifdef MPI
      use mpi
#endif
      implicit none

!-----------------------------------------------------------------------
!  This subroutine interpolates model information to the parcel locations
!  (diagnostic only ... not used for model integration)
!-----------------------------------------------------------------------

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh,rmh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf
      real, intent(in), dimension(ib:ie,jb:je) :: znt,ust
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,th0,thv0,qv0,qc0,qi0,rth0
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,zv,qt,prs,rho
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dbz,dum7,dum8
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: w3d,buoy,vpg
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pp3d,th3d
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: th,t
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d
      real, intent(inout), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tke3d
      real, intent(inout), dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pt3d
      real, intent(inout), dimension(npvals,nparcels) :: pdata,packet
      integer, intent(inout), dimension(rmp) :: reqs_p
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer :: n,np,i,j,k,iflag,jflag,kflag
      real :: tem,tem1
      real :: uval,vval,wval,rx,ry,rz,w1,w2,w3,w4,w5,w6,w7,w8,wsum
      real :: x3d,y3d,z3d,z0,rznt,var
      real :: rslf,rsif

      logical, parameter :: debug = .false.

!----------------------------------------------------------------------
!  Get derived variables:

    IF(imoist.eq.1)THEN
      ! with moisture:

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
    do k=1,nk

      do j=1,nj
      do i=1,ni
        qt(i,j,k)=q3d(i,j,k,nqv)
      enddo
      enddo
      do n=nql1,nql2
        do j=1,nj
        do i=1,ni
          qt(i,j,k)=qt(i,j,k)+q3d(i,j,k,n)
        enddo
        enddo
      enddo
      IF(iice.eq.1)THEN
        do n=nqs1,nqs2
        do j=1,nj
        do i=1,ni
          qt(i,j,k)=qt(i,j,k)+q3d(i,j,k,n)
        enddo
        enddo
        enddo
      ENDIF
      IF( prth.ge.1 .or. prt.ge.1 .or. prqsl.ge.1 .or. prqsi.ge.1 .or.  prvpg.ge.1 )THEN
        do j=1,nj
        do i=1,ni
          th(i,j,k) = (th0(i,j,k)+th3d(i,j,k))
          t(i,j,k) = th(i,j,k)*(pi0(i,j,k)+pp3d(i,j,k))
        enddo
        enddo
      ENDIF
      IF( prb.ge.1 .or. prvpg.ge.1 )THEN
        do j=1,nj
        do i=1,ni
          dum7(i,j,k) = g*( th3d(i,j,k)*rth0(i,j,k)             &
                           +repsm1*(q3d(i,j,k,nqv)-qv0(i,j,k))  &
                           -(qt(i,j,k)-q3d(i,j,k,nqv)-qc0(i,j,k)-qi0(i,j,k))   )
        enddo
        enddo
      ENDIF
      IF( prvpg.ge.1 )THEN
        do j=1,nj
        do i=1,ni
          dum8(i,j,k) = th(i,j,k)*(1.0+reps*q3d(i,j,k,nqv))/(1.0+qt(i,j,k))
        enddo
        enddo
      ENDIF

    enddo

    ELSE
      ! dry:

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    do k=1,nk

      IF( prth.ge.1 .or. prt.ge.1 .or. prvpg.ge.1 )THEN
        do j=1,nj
        do i=1,ni
          th(i,j,k)= (th0(i,j,k)+th3d(i,j,k))
          t(i,j,k) = th(i,j,k)*(pi0(i,j,k)+pp3d(i,j,k))
        enddo
        enddo
      ENDIF
      IF( prb.ge.1 .or. prvpg.ge.1 )THEN
        do j=1,nj
        do i=1,ni
          dum7(i,j,k) = g*( th3d(i,j,k)*rth0(i,j,k) )
        enddo
        enddo
      ENDIF
      IF( prvpg.ge.1 )THEN
        do j=1,nj
        do i=1,ni
          dum8(i,j,k) = th(i,j,k)
        enddo
        enddo
      ENDIF

    enddo

    ENDIF


    IF( prb.ge.1 .or. prvpg.ge.1 )THEN
      do k=2,nk
      do j=1,nj
      do i=1,ni
        buoy(i,j,k) = (c1(1,1,k)*dum7(i,j,k-1)+c2(1,1,k)*dum7(i,j,k))
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_parcels=time_parcels+mytime()
      call prepcornert(buoy,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                            pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      do j=0,nj+1
      do i=0,ni+1
        buoy(i,j,1) = buoy(i,j,2)+(buoy(i,j,3)-buoy(i,j,2))  &
                                 *(  zf(i,j,1)-  zf(i,j,2))  &
                                 /(  zf(i,j,3)-  zf(i,j,2))
        buoy(i,j,nk+1) = buoy(i,j,nk)+(buoy(i,j,nk  )-buoy(i,j,nk-1))  &
                                     *(  zf(i,j,nk+1)-  zf(i,j,nk  ))  &
                                     /(  zf(i,j,nk  )-  zf(i,j,nk-1))
      enddo
      enddo
    ENDIF
    IF( prvpg.ge.1 )THEN
      tem1 = rdz*cp
      ! assuming no terrain:
      do k=2,nk
      do j=1,nj
      do i=1,ni
        vpg(i,j,k) = -tem1*(pp3d(i,j,k)-pp3d(i,j,k-1))*mf(1,1,k)  &
                          *(c2(1,1,k)*dum8(i,j,k)+c1(1,1,k)*dum8(i,j,k-1))
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_parcels=time_parcels+mytime()
      call prepcornert(vpg,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                           pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      ! cmr18:  at top/bottom boundaries, vpg + buoy = 0
      do j=0,nj+1
      do i=0,ni+1
        vpg(i,j,1) = -buoy(i,j,1)
        vpg(i,j,nk+1) = -buoy(i,j,nk+1)
      enddo
      enddo
    ENDIF

    if(timestats.ge.1) time_parcels=time_parcels+mytime()

!----------------------------------------------------------------------
!  get corner info for MPI runs
!  (may not parallelize correctly if this is not done)

#ifdef MPI
      call getcorneru(u3d,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcu2(u3d)
      call getcornerv(v3d,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcv2(v3d)
      call getcornerw(w3d,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcw2(w3d)
#endif

!----------------------------------------------------------------------
!  apply bottom/top boundary conditions:
!  [Note:  for u,v,s the array index (i,j,0) means the surface, ie z=0]
!     (for the parcel subroutines only!)

!$omp parallel do default(shared)  &
!$omp private(i,j)
  DO j=jb,je+1

    IF(bbc.eq.1)THEN
      ! free slip ... extrapolate:
      IF(j.le.je)THEN
      do i=ib,ie+1
        u3d(i,j,0) = cgs1*u3d(i,j,1)+cgs2*u3d(i,j,2)+cgs3*u3d(i,j,3)
      enddo
      ENDIF
      do i=ib,ie
        v3d(i,j,0) = cgs1*v3d(i,j,1)+cgs2*v3d(i,j,2)+cgs3*v3d(i,j,3)
      enddo
    ELSEIF(bbc.eq.2)THEN
      ! no slip:
      IF(j.le.je)THEN
      do i=ib,ie+1
        u3d(i,j,0) = 0.0
      enddo
      ENDIF
      do i=ib,ie
        v3d(i,j,0) = 0.0
      enddo
    ELSEIF(bbc.eq.3)THEN
      ! u,v near sfc are determined below using log-layer equations
    ENDIF

!----------

    IF(tbc.eq.1)THEN
      ! free slip ... extrapolate:
      IF(j.le.je)THEN
      do i=ib,ie+1
        u3d(i,j,nk+1) = cgt1*u3d(i,j,nk)+cgt2*u3d(i,j,nk-1)+cgt3*u3d(i,j,nk-2)
      enddo
      ENDIF
      do i=ib,ie
        v3d(i,j,nk+1) = cgt1*v3d(i,j,nk)+cgt2*v3d(i,j,nk-1)+cgt3*v3d(i,j,nk-2)
      enddo
    ELSEIF(tbc.eq.2)THEN
      ! no slip:
      IF(j.le.je)THEN
      do i=ib,ie+1
        u3d(i,j,nk+1) = 0.0
      enddo
      ENDIF
      do i=ib,ie
        v3d(i,j,nk+1) = 0.0
      enddo
    ENDIF

!----------

      ! assuming no terrain:
      IF(j.le.je)THEN
      do i=ib,ie
        w3d(i,j,1)    = 0.0
        w3d(i,j,nk+1) = 0.0
      enddo
      ENDIF

  ENDDO

      if(timestats.ge.1) time_parcels=time_parcels+mytime()

      if( prth.ge.1 )then
        call prepcorners(th ,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      endif
      if( prt.ge.1 )then
        call prepcorners(t  ,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      endif
      if( prprs.ge.1 )then
        call prepcorners(prs,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      endif
      if( prrho.ge.1 )then
        call prepcorners(rho,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      endif
      if(prpt1.ge.1)then
        do n=1,npt
          call prepcorners(pt3d(ib,jb,kb,n),nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                                            pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
        enddo
      endif
      if( prqv.ge.1 )then
        call prepcorners(q3d(ib,jb,kb,nqv),nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                                           pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
      endif
      if( prq1.ge.1 .or. prnc1.ge.1 )then
        do n = 1,numq
          call prepcorners(q3d(ib,jb,kb,n),nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                                           pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
        enddo
      endif
      if( prkm.ge.1 )then
        call prepcornert(kmh,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
        call prepcornert(kmv,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
      endif
      if( prkh.ge.1 )then
        call prepcornert(khh,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
        call prepcornert(khv,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
      endif
      if( prtke.ge.1 )then
        call prepcornert(tke3d,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,0)
      endif
      if( prdbz.ge.1 )then
        call prepcorners(dbz,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                             pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
      endif

!----------------------------------------------------------------------

    IF( prqsl.ge.1 )THEN
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum1(i,j,k) = rslf( prs(i,j,k) , t(i,j,k) )
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_parcels=time_parcels+mytime()
      call prepcorners(dum1,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                            pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
    ENDIF
    IF( prqsi.ge.1 )THEN
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum2(i,j,k) = rsif( prs(i,j,k) , t(i,j,k) )
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_parcels=time_parcels+mytime()
      call prepcorners(dum2,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,  &
                            pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p,1)
    ENDIF

!----------------------------------------------------------------------
!  Get zvort at appropriate C-grid location:
!  (assuming no terrain)
!  cm1r18:  below lowest model level:
!           Use extrapolated velocities for bbc=1,2
!           Use log-layer equations for bbc=3 (see below)

    IF( przv.ge.1)THEN

      do k=0,nk+1
      do j=1,nj+1
      do i=1,ni+1
        zv(i,j,k) = (v3d(i,j,k)-v3d(i-1,j,k))*rdx*uf(i)   &
                   -(u3d(i,j,k)-u3d(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------------
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!----------------------------------------------------------------------
!  Loop through all parcels:  if you have it, get interpolated info:

    DO np=1,nparcels

      iflag=0
      jflag=0

    IF(nx.eq.1)THEN
      iflag = 1
    ELSE
      do i=1,ni
        if( pdata(prx,np).ge.xf(i) .and. pdata(prx,np).le.xf(i+1) ) iflag=i
      enddo
    ENDIF

    IF(axisymm.eq.1.or.ny.eq.1)THEN
      jflag = 1
    ELSE
      do j=1,nj
        if( pdata(pry,np).ge.yf(j) .and. pdata(pry,np).le.yf(j+1) ) jflag=j
      enddo
    ENDIF

#ifdef MPI
      ! check for conflict:
    IF( (iflag.ge.1.and.iflag.le.ni) .and.   &
        (jflag.ge.1.and.jflag.le.nj) )THEN
      IF( iflag.eq.ni .and. pdata(prx,np).eq.xf(iflag+1) .and. nodex.gt.1 .and.  myi.ne.nodex ) iflag = -1
      IF( jflag.eq.nj .and. pdata(pry,np).eq.yf(jflag+1) .and. nodey.gt.1 .and.  myj.ne.nodey ) jflag = -1
    ENDIF
#endif

      myprcl:  IF( (iflag.ge.1.and.iflag.le.ni) .and.   &
                   (jflag.ge.1.and.jflag.le.nj) )THEN

        i=iflag
        j=jflag

        kflag = 1
        do while( pdata(prz,np).ge.zf(iflag,jflag,kflag) )
          kflag = kflag+1
        enddo
        kflag = kflag-1

        x3d = pdata(prx,np)
        y3d = pdata(pry,np)
        z3d = pdata(prz,np)

!----------------------------------------------------------------------
!  Data on u points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(pry,np).lt.yh(j) )then
          j=j-1
        endif
        if( pdata(prz,np).lt.zh(iflag,jflag,k) )then
          k=k-1
        endif

        rx = ( pdata(prx,np)-xf(i) )/( xf(i+1)-xf(i) )
        ry = ( pdata(pry,np)-yh(j) )/( yh(j+1)-yh(j) )
        rz = ( pdata(prz,np)-zh(iflag,jflag,k) )/( zh(iflag,jflag,k+1)-zh(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.0 .or. i.gt.(ni+1)   .or.        &
            j.lt.-1 .or. j.gt.(nj+1)   .or.       &
            k.lt.0 .or. k.gt.nk                   )then
          print *
          print *,'  13333b: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *,'  xf1,x3d,xf2 = ',xf(i),pdata(prx,np),xf(i+1)
          print *,'  yh1,y3d,yh2 = ',yh(j),pdata(pry,np),yh(j+1)
          print *,'  zh1,z3d,zh2 = ',zh(iflag,jflag,k),pdata(prz,np),zh(iflag,jflag,k+1)
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni+1,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,u3d,uval)

!----------------------------------------------------------------------
!  Data on v points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(prx,np).lt.xh(i) )then
          i=i-1
        endif
        if( pdata(prz,np).lt.zh(iflag,jflag,k) )then
          k=k-1
        endif

        rx = ( pdata(prx,np)-xh(i) )/( xh(i+1)-xh(i) )
        ry = ( pdata(pry,np)-yf(j) )/( yf(j+1)-yf(j) )
        rz = ( pdata(prz,np)-zh(iflag,jflag,k) )/( zh(iflag,jflag,k+1)-zh(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.-1 .or. i.gt.(ni+1)   .or.       &
            j.lt.0 .or. j.gt.(nj+1)   .or.        &
            k.lt.0 .or. k.gt.nk                   )then
          print *
          print *,'  23333a: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *,'  xh1,x3d,xh2 = ',xh(i),pdata(prx,np),xh(i+1)
          print *,'  yf1,y3d,yh2 = ',yf(j),pdata(pry,np),yf(j+1)
          print *,'  zh1,z3d,zh2 = ',zh(iflag,jflag,k),pdata(prz,np),zh(iflag,jflag,k+1)
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni,nj+1,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,v3d,vval)

!----------------------------------------------------------------------
!  Data on w points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(prx,np).lt.xh(i) )then
          i=i-1
        endif
        if( pdata(pry,np).lt.yh(j) )then
          j=j-1
        endif

        rx = ( pdata(prx,np)-xh(i) )/( xh(i+1)-xh(i) )
        ry = ( pdata(pry,np)-yh(j) )/( yh(j+1)-yh(j) )
        rz = ( pdata(prz,np)-zf(iflag,jflag,k) )/( zf(iflag,jflag,k+1)-zf(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.-1 .or. i.gt.ni   .or.           &
            j.lt.-1 .or. j.gt.nj   .or.           &
            k.lt.1 .or. k.gt.nk                   )then
          print *
          print *,'  43333b: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *,'  xh1,x3d,xh2 = ',xh(i),pdata(prx,np),xh(i+1)
          print *,'  yh1,y3d,yh2 = ',yh(j),pdata(pry,np),yh(j+1)
          print *,'  zh1,z3d,zh2 = ',zf(iflag,jflag,k),pdata(prz,np),zf(iflag,jflag,k+1)
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,w3d ,wval)
      if(prkm.ge.1)then
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,kmh,pdata(prkm  ,np))
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,kmv,pdata(prkm+1,np))
      endif
      if(prkh.ge.1)then
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,khh,pdata(prkh  ,np))
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,khv,pdata(prkh+1,np))
      endif
      if( prtke.ge.1 )then
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,tke3d,pdata(prtke,np))
      endif
      if( prb.ge.1 )then
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,buoy,pdata(prb,np))
      endif
      if( prvpg.ge.1 )then
        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,vpg(ib,jb,kb),pdata(prvpg,np))
      endif

!----------------------------------------------------------------------
!  Data on scalar points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(prx,np).lt.xh(i) )then
          i=i-1
        endif
        if( pdata(pry,np).lt.yh(j) )then
          j=j-1
        endif
        if( pdata(prz,np).lt.zh(iflag,jflag,k) )then
          k=k-1
        endif

        rx = ( pdata(prx,np)-xh(i) )/( xh(i+1)-xh(i) )
        ry = ( pdata(pry,np)-yh(j) )/( yh(j+1)-yh(j) )
        rz = ( pdata(prz,np)-zh(iflag,jflag,k) )/( zh(iflag,jflag,k+1)-zh(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.-1 .or. i.gt.ni   .or.           &
            j.lt.-1 .or. j.gt.nj   .or.           &
            k.lt.0 .or. k.gt.nk                   )then
          print *
          print *,'  15558: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *
          call stopcm1
        endif
        ENDIF

      if(imoist.eq.1)then
        if(prdbz.ge.1)  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,dbz,pdata(prdbz,np))
        if(prqv.ge.1)  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,q3d(ib,jb,kb,nqv),pdata(prqv,np))
        if(prq1.ge.1)then
          do n=nql1,nql1+(prq2-prq1)
            call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,q3d(ib,jb,kb,n),pdata(prq1+(n-nql1),np))
          enddo
        endif
        if(prnc1.ge.1)then
          do n=nnc1,nnc1+(prnc2-prnc1)
            call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,q3d(ib,jb,kb,n),pdata(prnc1+(n-nnc1),np))
          enddo
        endif
        if( prqsl.ge.1 )  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,dum1,pdata(prqsl,np))
        if( prqsi.ge.1 )  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,dum2,pdata(prqsi,np))
      endif

        if( prth.ge.1 )  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,th ,pdata(prth,np))
        if( prt.ge.1 )  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,t  ,pdata(prt ,np))
        if( prprs.ge.1 )  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,prs,pdata(prprs,np))
        if( prrho.ge.1 )  &
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,rho,pdata(prrho,np))

        if(prpt1.ge.1)then
          do n=1,npt
          call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,pt3d(ib,jb,kb,n),pdata(prpt1+n-1,np))
          enddo
        endif

!----------------------------------------------------------------------
!  Data on zvort points

      IF( przv.ge.1 )THEN

        i=iflag
        j=jflag
        k=kflag

        if( pdata(prz,np).lt.zh(iflag,jflag,k) )then
          k=k-1
        endif

        rx = ( pdata(prx,np)-xf(i) )/( xf(i+1)-xf(i) )
        ry = ( pdata(pry,np)-yf(j) )/( yf(j+1)-yf(j) )
        rz = ( pdata(prz,np)-zh(iflag,jflag,k) )/( zh(iflag,jflag,k+1)-zh(iflag,jflag,k) )

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        IF(debug)THEN
        wsum = w1+w2+w3+w4+w5+w6+w7+w8
        if( rx.lt.-0.0001 .or. rx.gt.1.0001 .or.  &
            ry.lt.-0.0001 .or. ry.gt.1.0001 .or.  &
            rz.lt.-0.0001 .or. rz.gt.1.0001 .or.  &
            wsum.le.0.99999 .or.                  &
            wsum.ge.1.00001 .or.                  &
            i.lt.1 .or. i.gt.(ni+1)   .or.        &
            j.lt.1 .or. j.gt.(nj+1)   .or.        &
            k.lt.0 .or. k.gt.nk                   )then
          print *
          print *,'  15559: '
          print *,'  np          = ',np
          print *,'  myid,i,j,k  = ',myid,i,j,k
          print *,'  rx,ry,rz    = ',rx,ry,rz
          print *,'  wsum        = ',wsum
          print *
          call stopcm1
        endif
        ENDIF

        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,zv,pdata(przv,np))

      ENDIF

!----------------------------------------------------------------------
!  surface variables  and  uv for parcels below lowest model level:

      IF( prznt.ge.1 .or. prust.ge.1 .or. bbc.eq.3 )THEN
        i=iflag
        j=jflag
        if( x3d.lt.xh(i) )then
          i=i-1
        endif
        if( y3d.lt.yh(j) )then
          j=j-1
        endif
        call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 0, 0, 0, 0,znt,z0)
        if( prznt.ge.1 ) pdata(prznt,np) = z0
        if( prust.ge.1 )  &
        call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 0, 0, 0, 0,ust,pdata(prust,np))
      ENDIF

      IF( bbc.eq.3 )THEN
        ! semi-slip lower boundary condition:
        if( z3d.lt.zh(1,1,1) )then
          ! re-calculate velocities if parcel is below lowest model level:
          !------
          ! u at lowest model level:
          i=iflag
          j=jflag
          if( y3d.lt.yh(j) )then
            j=j-1
          endif
          call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 1, 0, 1, 0,u3d(ib,jb,1),uval)
          !------
          ! v at lowest model level:
          i=iflag
          j=jflag
          if( x3d.lt.xh(i) )then
            i=i-1
          endif
          call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 0, 1, 0, 1,v3d(ib,jb,1),vval)
          !------
          ! get u,v from (neutral) log-layer equation:
          rznt = 1.0/z0
          var = alog((z3d+z0)*rznt)/alog((zh(1,1,1)+z0)*rznt)
          uval = uval*var
          vval = vval*var
          !------
          IF( przv.ge.1 )THEN
            do j=jflag-1,jflag+1
            do i=iflag  ,iflag+1
              z0 = 0.5*(znt(i-1,j)+znt(i,j))
              rznt = 1.0/z0
              dum3(i,j,1) = u3d(i,j,1)*alog((z3d+z0)*rznt)/alog((zh(1,1,1)+z0)*rznt)
            enddo
            enddo
            do j=jflag  ,jflag+1
            do i=iflag-1,iflag+1
              z0 = 0.5*(znt(i,j-1)+znt(i,j))
              rznt = 1.0/z0
              dum4(i,j,1) = v3d(i,j,1)*alog((z3d+z0)*rznt)/alog((zh(1,1,1)+z0)*rznt)
            enddo
            enddo
            do j=jflag,jflag+1
            do i=iflag,iflag+1
              dum7(i,j,1) = (dum4(i,j,1)-dum4(i-1,j,1))*rdx*uf(i)   &
                           -(dum3(i,j,1)-dum3(i,j-1,1))*rdy*vf(j)
            enddo
            enddo
            i=iflag
            j=jflag
            call get2d(i,j,x3d,y3d,xh,xf,yh,yf, 1, 1, 0, 0,dum7(ib,jb,1),pdata(przv,np))
          ENDIF
        endif
      ENDIF


!----------------------------------------------------------------------

        pdata(pru,np)=uval
        pdata(prv,np)=vval
        pdata(prw,np)=wval

#ifdef MPI
      ELSE

        ! set to really small number (so we can use the allreduce command below)
        do n=1,npvals
          pdata(n,np) = -1.0e30
        enddo
#endif

      ENDIF  myprcl

    ENDDO

!----------------------------------------------------------------------
!  communicate data

#ifdef MPI

      call MPI_REDUCE(pdata(1,1),packet(1,1),npvals*nparcels,MPI_REAL,MPI_MAX,0,MPI_COMM_WORLD,ierr)

      if( myid.eq.0 )then
        do np=1,nparcels
        do n=1,npvals
          pdata(n,np) = packet(n,np)
        enddo
        enddo
      endif

#endif

!----------------------------------------------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine parcel_write(prec,rtime,qname,pdata,ploc)
      implicit none

      include 'input.incl'

      integer, intent(inout) :: prec
      real, intent(in) :: rtime
      character*3, intent(in), dimension(maxq) :: qname
      real, intent(in), dimension(npvals,nparcels) :: pdata
      real, intent(inout), dimension(3,nparcels) :: ploc

      integer :: n,np

!----------------------------------------------------------------------
!  write out data

    IF(myid.eq.0)THEN

      IF(output_format.eq.1)THEN
        ! GrADS format:

        string(totlen+1:totlen+22) = '_pdata.dat            '
        if(dowr) write(outfile,*) string
        open(unit=61,file=string,form='unformatted',access='direct',   &
             recl=4*npvals*nparcels,status='unknown')

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  pdata prec = ',prec

        write(61,rec=prec) ((pdata(n,np),np=1,nparcels),n=1,npvals)
        prec=prec+1

        close(unit=61)

#ifdef NETCDF
      ELSEIF(output_format.eq.2)THEN

        call writepdata_nc(prec,rtime,qname,pdata,ploc(1,1))

#endif
#ifdef HDFOUT
      ELSEIF(output_format.ge.3)THEN

        if(dowr) write(outfile,*)
        if(dowr) write(outfile,*) '  pdata prec = ',prec

        call writepdata_hdf5(prec,rtime,pdata)

#endif
      ENDIF
      if(dowr) write(outfile,*)

    ENDIF   ! endif for myid=0

      return
      end subroutine parcel_write


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine tri_interp(iz,jz,kz,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,s,pdata)
      implicit none

      include 'input.incl'

      integer :: iz,jz,kz,i,j,k
      real :: w1,w2,w3,w4,w5,w6,w7,w8
      real, dimension(1-ngxy:iz+ngxy,1-ngxy:jz+ngxy,1-ngz:kz+ngz) :: s
      real :: pdata

      pdata=s(i  ,j  ,k  )*w1    &
           +s(i+1,j  ,k  )*w2    &
           +s(i  ,j+1,k  )*w3    &
           +s(i  ,j  ,k+1)*w4    &
           +s(i+1,j  ,k+1)*w5    &
           +s(i  ,j+1,k+1)*w6    &
           +s(i+1,j+1,k  )*w7    &
           +s(i+1,j+1,k+1)*w8

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


    subroutine get2d(i,j,x3d,y3d,xh,xf,yh,yf,xs,ys,is,js,s,sval)
    implicit none

    include 'input.incl'

    integer, intent(in) :: i,j
    real, intent(in) :: x3d,y3d
    real, intent(in), dimension(ib:ie) :: xh
    real, intent(in), dimension(ib:ie+1) :: xf
    real, intent(in), dimension(jb:je) :: yh
    real, intent(in), dimension(jb:je+1) :: yf

    ! 0 = scalar point
    ! 1 = velocity point
    integer, intent(in) :: xs,ys
    integer, intent(in) :: is,js

    real, intent(in), dimension(ib:ie+is,jb:je+js) :: s
    real, intent(out) :: sval

    real :: wg1,wg2,wg3,wg4
    real :: x13,x23,x33,x43
    real :: w1,w2,w3,w7,rx,ry,rz

    logical, parameter :: debug = .false.

!-----------------------------------------------------------------------
      ! tri-linear interp:

      IF(xs.eq.1)THEN
        rx = ( x3d-xf(i) )/( xf(i+1)-xf(i) )
      ELSE
        rx = ( x3d-xh(i) )/( xh(i+1)-xh(i) )
      ENDIF

      IF(ys.eq.1)THEN
        ry = ( y3d-yf(j) )/( yf(j+1)-yf(j) )
      ELSE
        ry = ( y3d-yh(j) )/( yh(j+1)-yh(j) )
      ENDIF

        w1=(1.0-rx)*(1.0-ry)
        w2=rx*(1.0-ry)
        w3=(1.0-rx)*ry
        w7=rx*ry

      IF( debug )THEN
        if( rx.lt.-0.000001 .or. rx.gt.1.000001 .or.        &
            ry.lt.-0.000001 .or. ry.gt.1.000001 .or.        &
            (w1+w2+w3+w7).lt.0.999999 .or.  &
            (w1+w2+w3+w7).gt.1.000001       &
          )then
          print *,'  x3d,y3d     = ',x3d,y3d
          print *,'  i,j         = ',i,j
          print *,'  rx,ry       = ',rx,ry
          print *,'  w1,w2,w3,w7 = ',w1,w2,w3,w7
          print *,'  w1+w2+w3+w7 = ',w1+w2+w3+w7
          print *,' 22346 '
          call stopcm1
        endif
      ENDIF

      sval =s(i  ,j  )*w1    &
           +s(i+1,j  )*w2    &
           +s(i  ,j+1)*w3    &
           +s(i+1,j+1)*w7

!-----------------------------------------------------------------------

    end subroutine get2d

pdef.F          1587424407  1602  20    100644  15285     `
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefx1(xh,arh1,arh2,uh,rho0,gz,rgz,rru,advx,dum,mass,s0,s,dt,flag,west,newwest,east,neweast,reqs_s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie) :: xh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho0,s0,s
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: advx,dum,mass
      real, intent(in) :: dt
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      real, intent(inout), dimension(cmp,jmp,kmp) :: west,newwest,east,neweast
      integer, intent(inout), dimension(4) :: reqs_s

      integer i,j,k
      real foo1,foo2,foo3,rdt

!----------------------------------------------------------------
! cm1r17:  include divx component

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    kloop:  DO k=1,nk

      IF(.not.terrain_flag)THEN
        IF(axisymm.eq.0)THEN
          do j=1,nj
          do i=1,ni
            dum(i,j,k)=rho0(1,1,k)*s0(i,j,k)+dt*( advx(i,j,k)  &
                   +s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i) )
          enddo
          enddo
        ELSE
          do j=1,nj
          do i=1,ni
            dum(i,j,k)=rho0(1,1,k)*s0(i,j,k)+dt*( advx(i,j,k)  &
                   +s(i,j,k)*(arh2(i)*rru(i+1,j,k)-arh1(i)*rru(i,j,k))*rdx*uh(i) )
          enddo
          enddo
        ENDIF
      ELSE
          do j=1,nj
          do i=1,ni
            dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)+dt*( advx(i,j,k)  &
                   +s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i) )*gz(i,j)
          enddo
          enddo
      ENDIF

        if(wbc.eq.2 .and. ibw.eq.1)then
          do j=1,nj
            if(rru(1,j,k).ge.0.0)then
              i=1
              dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)
            endif
          enddo
        endif

        if(ebc.eq.2 .and. ibe.eq.1)then
          do j=1,nj
            if(rru(ni+1,j,k).le.0.0)then
              i=ni
              dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)
            endif
          enddo
        endif

    ENDDO  kloop

        if(timestats.ge.1) time_pdef=time_pdef+mytime()

        call bcs(dum)
#ifdef MPI
        call comm_2we_start(dum,west(1,1,1),newwest(1,1,1),east(1,1,1),neweast(1,1,1),reqs_s)
#endif

!----------------------------------------------------------------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefx2(xh,arh1,arh2,uh,rho0,gz,rgz,rru,advx,dum,mass,s0,s,dt,flag,west,newwest,east,neweast,reqs_s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie) :: xh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho0,s0,s
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: advx,dum,mass
      real, intent(in) :: dt
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      real, intent(inout), dimension(cmp,jmp,kmp) :: west,newwest,east,neweast
      integer, intent(inout), dimension(4) :: reqs_s

      integer i,j,k
      real foo1,foo2,foo3,rdt

!----------------------------------------------------------------
! cm1r17:  include divx component

#ifdef MPI
        call comm_2we_end(dum,west(1,1,1),newwest(1,1,1),east(1,1,1),neweast(1,1,1),reqs_s)
#endif

        rdt=1.0/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3)
    DO k=1,nk

        do j=1,nj
        do i=-1,ni+2
          mass(i,j,k)=0.0
        enddo
        enddo

      IF(axisymm.eq.0)THEN

        jloop:  do j=1,nj
        do i=-1,ni+2
          flag(i,j,k)=.false.
        enddo
        do i=0,ni+1
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i-1,j,k))
            foo2=max(0.0,dum(i+1,j,k))
            if(foo1+foo2.gt.smeps)then
              foo3=max(dum(i,j,k),-(foo1+foo2))/(foo1+foo2)
              mass(i-1,j,k)=mass(i-1,j,k)+foo1*foo3
              mass(i  ,j,k)=mass(i  ,j,k)-(foo1+foo2)*foo3
              mass(i+1,j,k)=mass(i+1,j,k)+foo2*foo3
              if(dum(i-1,j,k).gt.smeps) flag(i-1,j,k)=.true.
                                        flag(i  ,j,k)=.true.
              if(dum(i+1,j,k).gt.smeps) flag(i+1,j,k)=.true.
            endif
          endif
        enddo
        !-----
        IF(.not.terrain_flag)THEN
        do i=1,ni
        if(flag(i,j,k))then
          advx(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(1,1,k)*s0(i,j,k))*rdt  &
                   -s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
        endif
        enddo
        !-----
        ELSE
        do i=1,ni
        if(flag(i,j,k))then
          advx(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(i,j,k)*s0(i,j,k))*rdt*rgz(i,j)  &
                   -s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
        endif
        enddo
        ENDIF
        !-----
        enddo  jloop

      ELSE

        do j=1,nj
        do i=-1,ni+2
          flag(i,j,k)=.false.
        enddo
        do i=0,ni+1
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i-1,j,k))
            foo2=max(0.0,dum(i+1,j,k))
            if(foo1+foo2.gt.smeps)then
              foo3=max(xh(i)*dum(i,j,k),-(xh(i-1)*foo1+xh(i+1)*foo2))   &
                                        /(xh(i-1)*foo1+xh(i+1)*foo2)
              mass(i-1,j,k)=mass(i-1,j,k)+foo1*foo3
              mass(i  ,j,k)=mass(i  ,j,k)-(foo1+foo2)*foo3
              mass(i+1,j,k)=mass(i+1,j,k)+foo2*foo3
              if(dum(i-1,j,k).gt.smeps) flag(i-1,j,k)=.true.
                                        flag(i  ,j,k)=.true.
              if(dum(i+1,j,k).gt.smeps) flag(i+1,j,k)=.true.
            endif
          endif
        enddo
        do i=1,ni
        if(flag(i,j,k))then
          advx(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(1,1,k)*s0(i,j,k))*rdt  &
                   -s(i,j,k)*(arh2(i)*rru(i+1,j,k)-arh1(i)*rru(i,j,k))*rdx*uh(i)
        endif
        enddo
        enddo

      ENDIF

    ENDDO

!----------------------------------------------------------------

      if(timestats.ge.1) time_pdef=time_pdef+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefy1(vh,rho0,gz,rgz,rrv,advy,dum,mass,s0,s,dt,flag,south,newsouth,north,newnorth,reqs_s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho0,s0,s
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: advy,dum,mass
      real, intent(in) :: dt
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      real, intent(inout), dimension(imp,cmp,kmp) :: south,newsouth,north,newnorth
      integer, intent(inout), dimension(4) :: reqs_s

      integer i,j,k
      real foo1,foo2,foo3,rdt

!----------------------------------------------------------------
! cm1r17:  include divx component

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    kloop:  DO k=1,nk

      IF(.not.terrain_flag)THEN
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=rho0(1,1,k)*s0(i,j,k)+dt*( advy(i,j,k)  &
                       +s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j) )
        enddo
        enddo
      ELSE
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)+dt*( advy(i,j,k)  &
                       +s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j) )*gz(i,j)
        enddo
        enddo
      ENDIF

        if(sbc.eq.2 .and. ibs.eq.1)then
          do i=1,ni
            if(rrv(i,1,k).ge.0.0)then
              j=1
              dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)
            endif
          enddo
        endif

        if(nbc.eq.2 .and. ibn.eq.1)then
          do i=1,ni
            if(rrv(i,nj+1,k).le.0.0)then
              j=nj
              dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)
            endif
          enddo
        endif

    ENDDO  kloop

        if(timestats.ge.1) time_pdef=time_pdef+mytime()

        call bcs(dum)
#ifdef MPI
        call comm_2sn_start(dum,south(1,1,1),newsouth(1,1,1),north(1,1,1),newnorth(1,1,1),reqs_s)
#endif

!----------------------------------------------------------------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefy2(vh,rho0,gz,rgz,rrv,advy,dum,mass,s0,s,dt,flag,south,newsouth,north,newnorth,reqs_s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho0,s0,s
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: advy,dum,mass
      real, intent(in) :: dt
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      real, intent(inout), dimension(imp,cmp,kmp) :: south,newsouth,north,newnorth
      integer, intent(inout), dimension(4) :: reqs_s

      integer i,j,k
      real foo1,foo2,foo3,rdt

!----------------------------------------------------------------
! cm1r17:  include divx component

#ifdef MPI
        call comm_2sn_end(dum,south(1,1,1),newsouth(1,1,1),north(1,1,1),newnorth(1,1,1),reqs_s)
#endif

        rdt=1.0/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3)
      DO k=1,nk

        do j=-1,nj+2
        do i=1,ni
          mass(i,j,k)=0.0
        enddo
        enddo

        do j=-1,nj+2
        do i=1,ni
          flag(i,j,k)=.false.
        enddo
        enddo

        do j=0,nj+1
        do i=1,ni
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i,j-1,k))
            foo2=max(0.0,dum(i,j+1,k))
            if(foo1+foo2.gt.smeps)then
              foo3=max(dum(i,j,k),-(foo1+foo2))/(foo1+foo2)
              mass(i,j-1,k)=mass(i,j-1,k)+foo1*foo3
              mass(i,j  ,k)=mass(i,j  ,k)-(foo1+foo2)*foo3
              mass(i,j+1,k)=mass(i,j+1,k)+foo2*foo3
              if(dum(i,j-1,k).gt.smeps) flag(i,j-1,k)=.true.
                                        flag(i,j  ,k)=.true.
              if(dum(i,j+1,k).gt.smeps) flag(i,j+1,k)=.true.
            endif
          endif
        enddo
        enddo
        !-----
        IF(.not.terrain_flag)THEN
        do j=1,nj
        do i=1,ni
        if(flag(i,j,k))then
          advy(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(1,1,k)*s0(i,j,k))*rdt  &
                       -s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
        endif
        enddo
        enddo
        !-----
        ELSE
        do j=1,nj
        do i=1,ni
        if(flag(i,j,k))then
          advy(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(i,j,k)*s0(i,j,k))*rdt*rgz(i,j)  &
                       -s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
        endif
        enddo
        enddo
        ENDIF
        !-----

      ENDDO

!----------------------------------------------------------------

      if(timestats.ge.1) time_pdef=time_pdef+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefz(mh,rho0,gz,rgz,rdsf,rrw,advz,dum,mass,s0,s,dt,flag)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,s0,s
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz
      real, intent(in), dimension(kb:ke+1) :: rdsf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: advz,dum,mass
      real, intent(in) :: dt
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag

      integer i,j,k
      real foo1,foo2,foo3,rdt

!----------------------------------------------------------------

        rdt=1.0/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3)
    DO j=1,nj

      IF(.not.terrain_flag)THEN
        do k=1,nk
        do i=1,ni
          dum(i,j,k)=rho0(1,1,k)*s0(i,j,k)+dt*( advz(i,j,k)  &
                       +s(i,j,k)*(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(1,1,k) )
        enddo
        enddo
      ELSE
        do k=1,nk
        do i=1,ni
          dum(i,j,k)=rho0(i,j,k)*s0(i,j,k)+dt*( advz(i,j,k)  &
                       +s(i,j,k)*(rrw(i,j,k+1)-rrw(i,j,k))*rdsf(k) )*gz(i,j)
        enddo
        enddo
      ENDIF

        do i=1,ni
          dum(i,j, 0)=0.0
          dum(i,j,nk+1)=0.0
        enddo

        do k=0,nk+1
        do i=0,ni+1
          mass(i,j,k)=0.0
        enddo
        enddo

        do k=0,nk+1
        do i=1,ni
          flag(i,j,k)=.false.
        enddo
        enddo

        do k=1,nk
        do i=1,ni
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i,j,k-1))
            foo2=max(0.0,dum(i,j,k+1))
            if(foo1+foo2.gt.smeps)then
              foo3=max(dum(i,j,k),-(foo1+foo2))/(foo1+foo2)
              mass(i,j,k-1)=mass(i,j,k-1)+foo1*foo3
              mass(i,j,k  )=mass(i,j,k  )-(foo1+foo2)*foo3
              mass(i,j,k+1)=mass(i,j,k+1)+foo2*foo3
              if(dum(i,j,k-1).gt.smeps) flag(i,j,k-1)=.true.
                                        flag(i,j,k  )=.true.
              if(dum(i,j,k+1).gt.smeps) flag(i,j,k+1)=.true.
            endif
          endif
        enddo
        enddo
        !-----
        IF(.not.terrain_flag)THEN
        do k=1,nk
        do i=1,ni
        if(flag(i,j,k))then
          advz(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(1,1,k)*s0(i,j,k))*rdt  &
                       -s(i,j,k)*(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(1,1,k)
        endif
        enddo
        enddo
        !-----
        ELSE
        do k=1,nk
        do i=1,ni
        if(flag(i,j,k))then
          advz(i,j,k)=(dum(i,j,k)+mass(i,j,k)-rho0(i,j,k)*s0(i,j,k))*rdt*rgz(i,j)  &
                       -s(i,j,k)*(rrw(i,j,k+1)-rrw(i,j,k))*rdsf(k)
        endif
        enddo
        enddo
        ENDIF
        !-----

    ENDDO

!----------------------------------------------------------------

      if(timestats.ge.1) time_pdef=time_pdef+mytime()

      return
      end



poiss.F         1587424407  1602  20    100644  4838      `


      subroutine poiss(uh,vh,mh,rmh,mf,rmf,pi0,thv0,rho0,rf0,   &
                       def,divx,ppi,uten,vten,wten,             &
                       cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans,dttmp)

      use singleton
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie) :: uh
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rho0,rf0
      real, dimension(ib:ie,jb:je,kb:ke) :: def,divx,ppi
      real, dimension(ib:ie+1,jb:je,kb:ke) :: uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wten
      real, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, dimension(kpb:kpe) :: cfa,cfc,d1,d2
      complex, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, dimension(ipb:ipe,jpb:jpe) :: rhs,trans
      real dttmp

      integer i,j,k
      real :: tem
      real, dimension(0:nk+1) :: r1
      complex, dimension(nk) :: lgbth,lgbph

!!!
!!!  Get the forcing from the exact numerical representation
!!!  of the right-hand side of the momentum equation
!!!
!!!  The divx term reduces accumulation of numerical errors over time
!!!

      IF(axisymm.eq.1)THEN
        if(myid.eq.0)then
          print *
          print *,'  The anelastic/incompressible solver cannot be '
          print *,'  used with the axisymmetric model(yet)'
          print *
          print *,'  Stopping model ...'
          print *
        endif
        call stopcm1
      ENDIF

      tem = 1.0/dttmp

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        def(i,j,k)=rho0(1,1,k)*(                                  &
                   (uten(i+1,j,k)-uten(i,j,k))*rdx*uh(i)          &
                  +(vten(i,j+1,k)-vten(i,j,k))*rdy*vh(j) )        &
                  +( rf0(i,j,k+1)*wten(i,j,k+1)                   &
                    -rf0(i,j,k  )*wten(i,j,k  ) )*rdz*mh(i,j,k)   &
                  +divx(i,j,k)*tem
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!!!
!!! fourier transform the total forcing
!!!

      DO k=1,nk

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          rhs(i,j)=cmplx(def(i,j,k)*d1(k),0.0)
        enddo
        enddo

        if(imirror.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            rhs(ipe+1-i,j)=rhs(i,j)
          enddo
          enddo

        endif

        if(jmirror.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            rhs(i,jpe+1-j)=rhs(i,j)
          enddo
          enddo

        endif

        trans=fft(rhs)

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=jpb,jpe
        do i=ipb,ipe
          deft(i,j,k)=trans(i,j)
        enddo
        enddo

      ENDDO

!-----------------------------------------------------------------------

!!!
!!! solve the tri-diagonal matrix
!!!

!$omp parallel do default(shared)  &
!$omp private(i,j,k,r1,lgbth,lgbph)
      DO j=jpb,jpe
      DO i=ipb,ipe

        if(i.eq.1.and.j.eq.1)then
          r1(nk+1)=0.0
          r1(nk)=0.0
          do k=nk,2,-1
            r1(k-1)=(deft(i,j,k)-cfc(k)*r1(k+1)-cfb(i,j,k)*r1(k))/cfa(k)
          enddo
          do k=1,nk
            pdt(i,j,k)=cmplx( r1(k) , 0.0 )
          enddo
        else
          lgbth(1)=-cfc(1)/cfb(i,j,1)
          lgbph(1)= deft(i,j,1)/cfb(i,j,1)
          do k=2,nk
            lgbth(k)=-cfc(k)/(cfa(k)*lgbth(k-1)+cfb(i,j,k))
            lgbph(k)=(deft(i,j,k)-cfa(k)*lgbph(k-1))/(cfa(k)*lgbth(k-1)+cfb(i,j,k))
          enddo
          pdt(i,j,nk)=lgbph(nk)
          do k=nk-1,1,-1
            pdt(i,j,k)=lgbth(k)*pdt(i,j,k+1)+lgbph(k)
          enddo
        endif

      ENDDO
      ENDDO

!---------------------------------------------

!!!
!!! reverse fourier transform and we're done, not so bad after all!
!!!

      DO k=1,nk

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=jpb,jpe
        do i=ipb,ipe
          rhs(i,j)=pdt(i,j,k)
        enddo
        enddo

        trans=fft(rhs,inv=.true.)

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          ppi(i,j,k)=real(trans(i,j))*d2(k)
        enddo
        enddo

      ENDDO

      if(timestats.ge.1) time_poiss=time_poiss+mytime()

!-----------------------------------------------------------------------

      call bcp(ppi)

!-----------------------------------------------------------------------
!  All done.

      return
      end


sfcphys.F       1587424407  1602  20    100644  13321     `
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcecd(u0,v0,u1,v1,s1,u,v,za,u10,v10,s10,xland,znt,ust,cd,ch,cq)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je) :: u1,v1,s1
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,u
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,v
      real, intent(in), dimension(ib:ie,jb:je) :: za
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: u10,v10,s10
      real, intent(in), dimension(ib:ie,jb:je) :: xland
      real, intent(inout), dimension(ib:ie,jb:je) :: znt,ust,cd,ch,cq

      integer i,j,n,nmax
      real wsp,wlast,var,rznt

      real, parameter :: dcd1  =  1.0e-3
      real, parameter :: dcd2  =  2.4e-3
      real, parameter :: dwsp1 =  5.0
      real, parameter :: dwsp2 = 25.0

      real, parameter :: dfac = (dcd2-dcd1)/(dwsp2-dwsp1)

!-----------------------------------------------------------------------
!
!  This subroutine determines several important variables at the surface
!  (eg, drag coefficient, roughness length, friction velocity).
!
!-----------------------------------------------------------------------

!!!    print *,'  za = ',za(1,1),za(ni/2,1),za(ni,1)

    nmax = 0

!$omp parallel do default(shared)   &
!$omp private(i,j,wlast,n,var,rznt)
    DO j=1,nj
    do i=1,ni
      ! Get cd/znt/ust:
      IF(xland(i,j).gt.1.5)THEN
        !-----------------------------------------
        ! water:  roughness length (z0) is a function of windspeed
        ! use last known z0 for first guess:
        rznt = 1.0/znt(i,j)
        var = alog((10.0+znt(i,j))*rznt)/alog((za(i,j)+znt(i,j))*rznt)
        s10(i,j) = s1(i,j)*var
        wlast = -1.0
        n = 0
        do while( abs(s10(i,j)-wlast).gt.0.001 )
          n = n + 1
          wlast = s10(i,j)
          IF(cecd.eq.1)THEN
            ! constant value:
            cd(i,j) = max(1.0e-4,cnstcd)
          ELSEIF(cecd.eq.2)THEN
            ! Deacon's formula:  see Rotunno and Emanuel (1987, JAS, p. 547)
            cd(i,j) = 1.1e-3+(4.0e-5*s10(i,j))
          ELSEIF(cecd.eq.3)THEN
            ! based on Fairall et al (2003, JClim) at low wind speeds
            ! based on Donelan et al (2004, GRL) at high wind speeds
            cd(i,j) = dcd1+(s10(i,j)-dwsp1)*dfac
            cd(i,j) = min(cd(i,j),dcd2)
            cd(i,j) = max(cd(i,j),dcd1)
          ENDIF
          znt(i,j) = 10.0/(exp(karman/sqrt(cd(i,j)))-1.0)
          rznt = 1.0/znt(i,j)
          var = alog((10.0+znt(i,j))*rznt)/alog((za(i,j)+znt(i,j))*rznt)
          s10(i,j) = s1(i,j)*var
          if(n.gt.10) print *,'  getcecd:  myid,n,s10 = ',myid,n,s10(i,j)
          if(n.gt.20)then
            call stopcm1
          endif
        enddo
!!!        nmax = max(nmax,n)
        ! end water
        !-----------------------------------------
      ELSE
        !-----------------------------------------
        ! land:  roughness length (z0) is specified
        IF(cecd.eq.1)THEN
          cd(i,j) = max(1.0e-4,cnstcd)
          znt(i,j) = 10.0/(exp(karman/sqrt(cd(i,j)))-1.0)
          rznt = 1.0/znt(i,j)
        ELSE
          rznt = 1.0/znt(i,j)
          cd(i,j) = ( karman/alog((10.0+znt(i,j))*rznt) )**2
        ENDIF
        var = alog((10.0+znt(i,j))*rznt)/alog((za(i,j)+znt(i,j))*rznt)
        s10(i,j) = s1(i,j)*var
        ! end land
        !-----------------------------------------
      ENDIF
      u10(i,j) = u1(i,j)*var
      v10(i,j) = v1(i,j)*var
!!!      ust(i,j) = sqrt(cd(i,j))*s10(i,j)
      ust(i,j) = max( s1(i,j)*karman/alog((za(i,j)+znt(i,j))*rznt) , 1.0e-6 )
    enddo
    !  End cd/znt/ust
    !cccccccccccccccccc
    !  Get Ce:
    IF(isfcflx.eq.1)THEN
      do i=1,ni
        IF(xland(i,j).gt.1.5)THEN
          !-------
          ! water:
          IF(cecd.eq.1)THEN
            ! constant value (from namelist.input):
            ch(i,j) = cnstce
            cq(i,j) = cnstce
          ELSEIF(cecd.eq.2)THEN
            ! Deacon's formula:  see Rotunno and Emanuel (1987, JAS, p. 547)
            ch(i,j) = 1.1e-3+(4.0e-5*s10(i,j))
            cq(i,j) = 1.1e-3+(4.0e-5*s10(i,j))
          ELSEIF(cecd.eq.3)THEN
            ! Constant, based on Drennan et al. (2007, JAS, p. 1103)
            ch(i,j) = 1.20e-3
            cq(i,j) = 1.20e-3
          ENDIF
          ! end water
          !-------
        ELSE
          !-------
          ! land ... just set Ce to Cd:
          ch(i,j) = cd(i,j)
          cq(i,j) = cd(i,j)
          ! end land
          !-------
        ENDIF
      enddo
    ENDIF

    ENDDO  ! enddo for j-loop

!-----------------------------------------------------------------------

!!!      print *,'  nmax = ',nmax

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine sfcflux(dt,ruh,xf,rvh,pi0s,ch,cq,pi0,thv0,th0,u0,v0,tsk,thflux,qvflux,mavail,   &
                         rho,rf,u1,v1,s1,u ,v ,ppi,tha,qva,qbsfc,psfc,u10,v10,s10,qsfc,znt,rtime)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: ruh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: rvh
      real, intent(in), dimension(ib:ie,jb:je) :: pi0s,ch,cq
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,th0
      real, intent(in), dimension(ib:ie,jb:je) :: tsk
      real, intent(inout), dimension(ib:ie,jb:je) :: psfc,thflux,qvflux
      real, intent(in), dimension(ibl:iel,jbl:jel) :: mavail
      real, intent(in), dimension(ib:ie,jb:je) :: u1,v1,s1
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,u
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,v
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rf,ppi,tha
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem) :: qva
      double precision, intent(inout) :: qbsfc
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: u10,v10,s10,qsfc
      real, intent(inout), dimension(ib:ie,jb:je) :: znt
      real, intent(in) :: rtime

      integer :: i,j
      real :: pisfc,qvsat,rhosfc,tem,shf
      real :: rslf
      double precision, dimension(nj) :: bud1

!-----------------------------------------------------------------------
!
!  This subroutine calculates surface fluxes of heat and moisture.
!
!-----------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,pisfc,qvsat,rhosfc)
    DO j=1,nj
      bud1(j)=0.0d0

      !  sensible heat flux:
      do i=1,ni
        pisfc = (psfc(i,j)*rp00)**rovcp
        thflux(i,j)=ch(i,j)*s10(i,j)*(tsk(i,j)/pisfc-th0(i,j,1)-tha(i,j,1))
      enddo

      !  latent heat flux:
      IF(imoist.eq.1)THEN
        do i=1,ni
          qvsat=rslf(psfc(i,j),tsk(i,j))
          qsfc(i,j)=qvsat
          qvflux(i,j)=cq(i,j)*s10(i,j)*(qvsat-qva(i,j,1))*mavail(i,j)
          ! some budget calculations (only calculated if imoist=1):
          rhosfc=rf(i,j,1)
          if(axisymm.eq.1) rhosfc=rhosfc*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
          bud1(j)=bud1(j)+qvflux(i,j)*ruh(i)*rvh(j)*rhosfc
        enddo
      ENDIF
    ENDDO

    IF(imoist.eq.1)THEN
      tem = dt*dx*dy
      do j=1,nj
        qbsfc=qbsfc+bud1(j)*tem
      enddo
    ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine sfcdiags(tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,             &
                          xland,psfc,qsfc,u10,v10,hfx,qfx,cda,znt,gz1oz0,  &
                          psim,psih,br,zol,mol,hpbl,dsxy,th2,t2,q2,fm,fh,  &
                          zs,za,pi0s,pi0,th0,ppi,tha,rho,rf,qa,ua,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je) :: tsk,thflux,qvflux,   &
                                                  cd,ch,cq,u1,v1,s1,xland,psfc
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: qsfc,u10,v10,hfx,qfx, &
                                    cda,gz1oz0,psim,psih,br,zol,mol,hpbl,dsxy,th2,t2,q2,fm,fh
      real, intent(inout), dimension(ib:ie,jb:je) :: znt
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(ib:ie,jb:je) :: za
      real, intent(in), dimension(ib:ie,jb:je) :: pi0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,th0,ppi,tha,rho,rf,qa
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer :: i,j
      real :: pisfc,thgb,thx,thvx,tskv,govrth,dthvdz,vconv,vsgd,dthvm,   &
              val,fluxc,wspd,rznt
      real :: rslf

      REAL    , PARAMETER ::  VCONVC=1.
      REAL    , PARAMETER ::  CZO=0.0185
      REAL    , PARAMETER ::  OZO=1.59E-5
      REAL    , PARAMETER ::  EP1 = rv/rd - 1.0

      ! surface layer diagnostics:

!$omp parallel do default(shared)   &
!$omp private(i,j,pisfc,thgb,thx,thvx,tskv,govrth,dthvdz,vconv,vsgd,   &
!$omp dthvm,val,fluxc,wspd,rznt)
      do j=1,nj
      do i=1,ni
        pisfc = (psfc(i,j)*rp00)**rovcp
        thgb = tsk(i,j)/pisfc
        thx = th0(i,j,1)+tha(i,j,1)
        thvx = thx*(1.+EP1*qa(i,j,1))
        qsfc(i,j) = rslf(psfc(i,j),tsk(i,j))
        tskv = thgb*(1.0+ep1*qsfc(i,j))
        govrth = g/thx
        rznt = 1.0/znt(i,j)
        gz1oz0(i,j) = alog((za(i,j)+znt(i,j))*rznt)
        DTHVDZ = THVX-TSKV
        ! cm1r18:  use same formulation over land and water:
!!!        if (xland(i,j).lt.1.5) then
          ! land:
          fluxc = max(thflux(i,j) + ep1*tskv*qvflux(i,j),0.)
          VCONV = vconvc*(g/tsk(i,j)*hpbl(i,j)*fluxc)**.33
!!!        else
!!!          ! ocean:
!!!          IF(-DTHVDZ.GE.0)THEN
!!!            DTHVM=-DTHVDZ
!!!          ELSE
!!!            DTHVM=0.
!!!          ENDIF
!!!          VCONV = 2.*SQRT(DTHVM)
!!!        endif
! Mahrt and Sun low-res correction
        VSGD = 0.32 * (max(dsxy(i,j)/5000.-1.,0.))**.33
        wspd = sqrt( s1(i,j)*s1(i,j) + vconv*vconv + vsgd*vsgd )
        wspd = max(0.1,wspd)
        br(i,j) = govrth*za(i,j)*DTHVDZ/(wspd**2)
        hfx(i,j) = thflux(i,j)*cp*rf(i,j,1)
        qfx(i,j) = qvflux(i,j)*rf(i,j,1)
        cda(i,j) = cd(i,j)
        ! impose neutral sfc layer:
        psim(i,j) = 0.0
        psih(i,j) = 0.0
        zol(i,j) = 0.0
        mol(i,j) = 0.0
        fm(i,j) = GZ1OZ0(i,j)
        fh(i,j) = GZ1OZ0(i,j)
        ! get 2-m th/q/t:
        val = alog((2.0+znt(i,j))*rznt)/alog((za(i,j)+znt(i,j))*rznt)
        th2(i,j) = thgb+(thx-thgb)*val
        q2(i,j) = qsfc(i,j)+(qa(i,j,1)-qsfc(i,j))*val
        t2(i,j) = th2(i,j)*pisfc
      enddo
      enddo

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
      end subroutine sfcdiags


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine gethpbl(zh,th0,tha,qa,hpbl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,th0,tha,qa
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: hpbl

      integer :: i,j,kk
      real :: thx,thvx,thv,thvlast,thcrit

      REAL    , PARAMETER ::  EP1 = rv/rd - 1.0

      ! (NEEDED BY SFCLAY ... THIS IS A ROUGH ESTIMATE ONLY)
      ! (ONLY NEEDED WHEN IPBL=0)
      ! (USE WITH CAUTION)
      ! extraordinarily simple calculation:  define pbl depth as 
      ! level where thv is first greater than thv at lowest model level
      ! 110104:  add 0.5 K, for the sake of slightly stable PBLs

!$omp parallel do default(shared)   &
!$omp private(i,j,kk,thx,thvx,thv,thvlast,thcrit)
      do j=1,nj
      do i=1,ni
        hpbl(i,j) = 0.0
        kk = 1
        thx = th0(i,j,1)+tha(i,j,1)
        thvx = thx*(1.+EP1*qa(i,j,1))
        thvlast = thvx
        thcrit = thvx+0.5
        do while( hpbl(i,j).lt.1.0e-12 .and. kk.lt.nk )
          kk = kk + 1
          thv = (th0(i,j,kk)+tha(i,j,kk))*(1.0+EP1*qa(i,j,kk))
          if( thv.ge.thcrit )then
            hpbl(i,j) = zh(i,j,kk-1)+(zh(i,j,kk)-zh(i,j,kk-1))   &
                                    *(thcrit-thvlast)/(thv-thvlast)
          endif
          thvlast = thv
        enddo
        if( kk.gt.(nk-1) .or. hpbl(i,j).lt.1.0e-12 ) hpbl(i,j) = 0.0
      enddo
      enddo

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
      end subroutine gethpbl



singleton.F     1587424407  1602  20    100644  38594     `
MODULE singleton
  !-----------------------------------------------------------------------------
  ! Multivariate Fast Fourier Transform
  !
  ! Fortran 90 (ELF90) Implementation of Singleton's mixed-radix algorithm,
  ! RC Singleton, Stanford Research Institute, Sept. 1968.
  !
  ! Adapted from fftn.c, translated from Fortran 66 to C by Mark Olesen and
  ! John Beale.
  !
  ! Fourier transforms can be computed either in place, using assumed size
  ! arguments, or by generic function, using assumed shape arguments.
  !
  !
  ! Public:
  !
  !   fftkind                              kind parameter of complex arguments
  !                                        and function results.
  !
  !   fft(array, dim, inv)                 generic transform function
  !    COMPLEX(fftkind), DIMENSION(:,...,:), INTENT(IN)           :: array
  !    INTEGER,          DIMENSION(:),       INTENT(IN),  OPTIONAL:: dim
  !    LOGICAL,                              INTENT(IN),  OPTIONAL:: inv
  !
  !   fftn(array, shape, dim, inv, stat)   in place transform subroutine
  !    COMPLEX(fftkind), DIMENSION(*), INTENT(INOUT)        :: array
  !    INTEGER,          DIMENSION(:), INTENT(IN)           :: shape
  !    INTEGER,          DIMENSION(:), INTENT(IN),  OPTIONAL:: dim
  !    LOGICAL,                        INTENT(IN),  OPTIONAL:: inv
  !    INTEGER,                        INTENT(OUT), OPTIONAL:: stat
  !
  !
  ! Formal Parameters:
  !
  !   array    The complex array to be transformed. array can be of arbitrary
  !            rank (i.e. up to seven).
  !
  !   shape    With subroutine fftn, the shape of the array to be transformed
  !            has to be passed separately, since fftradix - the internal trans-
  !            formation routine - will treat array always as one dimensional.
  !            The product of elements in shape must be the number of
  !            elements in array.
  !            Although passing array with assumed shape would have been nicer,
  !            I prefered assumed size in order to prevent the compiler from
  !            using a copy-in-copy-out mechanism. That would generally be
  !            necessary with fftn passing array to fftradix and with fftn
  !            being prepared for accepting non consecutive array sections.
  !            Using assumed size, it's up to the user to pass an array argu-
  !            ment, that can be addressed as continous one dimensional array
  !            without copying. Otherwise, transformation will not really be
  !            performed in place.
  !            On the other hand, since the rank of array and the size of
  !            shape needn't match, fftn is appropriate for handling more than
  !            seven dimensions.
  !            As far as function fft is concerned all this doesn't matter,
  !            because the argument will be copied anyway. Thus no extra
  !            shape argument is needed for fft.
  !
  ! Optional Parameters:
  !
  !   dim      One dimensional integer array, containing the dimensions to be
  !            transformed. Default is (/1,...,N/) with N being the rank of
  !            array, i.e. complete transform. dim can restrict transformation
  !            to a subset of available dimensions. Its size must not exceed the
  !            rank of array or the size of shape respectivly.
  !
  !   inv      If .true., inverse transformation will be performed. Default is
  !            .false., i.e. forward transformation.
  !
  !   stat     If present, a system dependent nonzero status value will be
  !            returned in stat, if allocation of temporary storage failed.
  !            For functions, the integer variable status is used.
  !
  ! Scaling:
  !
  !   Transformation results will always be scaled by the square root of the
  !   product of sizes of each dimension in dim. (See examples below)
  !
  !
  ! Examples:
  !
  !   Let A be a L*M*N three dimensional complex array. Then
  !
  !     result = fft(A)
  !
  !   will produce a three dimensional transform, scaled by sqrt(L*M*N), while
  !
  !     call fftn(A, SHAPE(A))
  !
  !   will do the same in place.
  !
  !     result = fft(A, dim=(/1,3/))
  !
  !   will transform with respect to the first and the third dimension, scaled
  !   by sqrt(L*N).
  !
  !     result = fft(fft(A), inv=.true.)
  !
  !   should (approximately) reproduce A.
  !   With B having the same shape as A
  !
  !     result = fft(fft(A) * CONJG(fft(B)), inv=.true.)
  !
  !   will correlate A and B.
  !
  !
  ! Remarks:
  !
  !   Following changes have been introduced with respect to fftn.c:
  !   - complex arguments and results are of type complex, rather than
  !     real an imaginary part separately.
  !   - increment parameter (magnitude of isign) has been dropped,
  !     inc is always one, direction of transform is given by inv.     
  !   - maxf and maxp have been dropped. The amount of temporary storage
  !     needed is determined by the fftradix routine. Both fftn and fft
  !     can handle any size of array. (Maybe they take a lot of time and
  !     memory, but they will do it)
  !
  !   Redesigning fftradix in a way, that it handles assumed shape arrays
  !   would have been desirable. However, I found it rather hard to do this
  !   in an efficient way. Problems were:
  !   - to prevent stride multiplications when indexing arrays. At least our
  !     compiler was not clever enough to discover that in fact additions
  !     would do the job as well. On the other hand, I haven't been clever
  !     enough to find an implementation using array operations.
  !   - fftradix is rather large and different versions would be necessaray
  !     for each possible rank of array.
  !   Consequently, in place transformation still needs the argument stored
  !   in a consecutive bunch of memory and can't be performed on array
  !   sections like A(100:199:-3, 50:1020). Calling fftn with such sections
  !   will most probably imply copy-in-copy-out. However, the function fft
  !   works with everything it gets and should be convenient to use.
  !
  !   To enable this module to be used with ELF90 it appears to be necessary
  !   to allocate a 1-D work array into which the multi-dimensional array is
  !   copied, and then to copy the results back from the 1-D array to the
  !   multi-dimensional array ft.
  !
  !   Unfortunately, ELF90 will not allow a function to return more than one
  !   output variable.   The variable `stat' has been dropped from the function
  !   arguments.   Users should examine the value of the variable `status'
  !   instead.   This is a PUBLIC variable declared in this module.
  !
  ! Michael Steffens, 09.12.96, <Michael.Steffens@mbox.muk.uni-hannover.de>
  ! ELF90-compatible version by Alan Miller, 29 April 1997 & 6 June 1997
  ! amiller @ bigpond.net.au
  ! Restructured fftradix for better optimization by M. Steffens, 4 June 1997
  !-----------------------------------------------------------------------------
  IMPLICIT NONE

  PRIVATE
  PUBLIC:: fft, fftn, fftkind, status

  INTEGER, PARAMETER:: fftkind = KIND(0.0) !--- adjust here for other precisions
  INTEGER, SAVE     :: status = 0 !--- shifted to here as ELF90 does not allow
                                  !    arguments to be INTENT(OUT)

  REAL(fftkind), PARAMETER:: sin60 = 0.86602540378443865_fftkind
  REAL(fftkind), PARAMETER:: cos72 = 0.30901699437494742_fftkind
  REAL(fftkind), PARAMETER:: sin72 = 0.95105651629515357_fftkind
  REAL(fftkind), PARAMETER:: pi    = 3.14159265358979323_fftkind

  INTERFACE fft
     MODULE PROCEDURE fft1d
     MODULE PROCEDURE fft2d
     MODULE PROCEDURE fft3d
     MODULE PROCEDURE fft4d
     MODULE PROCEDURE fft5d
     MODULE PROCEDURE fft6d
     MODULE PROCEDURE fft7d
  END INTERFACE


CONTAINS


  FUNCTION fft1d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:), INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                        INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION(SIZE(array, 1)):: ft

    ft = array
    CALL fftn(ft, SHAPE(array), dim, inv = inv, stat = status)

    RETURN
  END FUNCTION fft1d


  FUNCTION fft2d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),   INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                          INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION(SIZE(array, 1), SIZE(array, 2)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft2d


  FUNCTION fft3d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),     INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                            INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), &
         DIMENSION(SIZE(array, 1), SIZE(array, 2), SIZE(array, 3)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft3d


  FUNCTION fft4d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),       INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                              INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft4d


  FUNCTION fft5d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),         INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                                INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4), &
         SIZE(array, 5)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4), SIZE(array, 5) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft5d


  FUNCTION fft6d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),           INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                                  INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4), &
         SIZE(array, 5), SIZE(array, 6)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4), SIZE(array, 5), SIZE(array, 6) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft6d


  FUNCTION fft7d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),             INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                                    INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4), &
         SIZE(array, 5), SIZE(array, 6), SIZE(array, 7)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4), SIZE(array, 5), SIZE(array, 6), &
                          SIZE(array, 7) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft7d


  SUBROUTINE fftn(array, shape, dim, inv, stat)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT)       :: array
    INTEGER,          DIMENSION(:), INTENT(IN)           :: shape
    INTEGER,          DIMENSION(:), INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                        INTENT(IN),  OPTIONAL:: inv
    INTEGER,                        INTENT(OUT), OPTIONAL:: stat
    !--- local arrays
    INTEGER, DIMENSION(SIZE(shape)):: d
    !--- local scalars
    LOGICAL      :: inverse
    INTEGER      :: i, ndim, ntotal
    REAL(fftkind):: scale

    !--- optional parameter settings
    IF (PRESENT(inv)) THEN
       inverse = inv
    ELSE
       inverse = .FALSE.
    END IF
    IF (PRESENT(dim)) THEN
       ndim = MIN(SIZE(dim), SIZE(d))
       d(1:ndim) = dim(1:ndim)
    ELSE
       ndim = SIZE(d)
       d = (/(i, i = 1, SIZE(d))/)
    END IF

    ntotal = PRODUCT(shape)
    scale = SQRT(1.0_fftkind / PRODUCT(shape(d(1:ndim))))
    DO i = 1, ntotal
       array(i) = CMPLX(REAL(array(i)) * scale, AIMAG(array(i)) * scale, &
            KIND=fftkind)
    END DO

    DO i = 1, ndim
       CALL fftradix(array, ntotal, shape(d(i)), PRODUCT(shape(1:d(i))), &
            inverse)
    END DO

    IF (PRESENT(stat)) stat = status
    RETURN
  END SUBROUTINE fftn


  SUBROUTINE fftradix(array, ntotal, npass, nspan, inv)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT)       :: array
    INTEGER,                        INTENT(IN)           :: ntotal, npass, nspan
    LOGICAL,                        INTENT(IN)           :: inv
    !--- local arrays
    INTEGER,          DIMENSION(BIT_SIZE(0))     :: factor
    !--- local scalars
    INTEGER         :: maxfactor, nfactor, nsquare
    !--- intrinsics used

    IF (npass <= 1) RETURN

    CALL factorize(npass, factor, nfactor, nsquare)

    maxfactor = MAXVAL(factor(:nfactor))

    CALL transform(array, ntotal, npass, nspan, factor, nfactor, inv)
    CALL permute(array, ntotal, npass, nspan, &
            factor, nfactor, nsquare, maxfactor)

    RETURN


  CONTAINS


    SUBROUTINE factorize(npass, factor, nfactor, nsquare)
      !--- formal parameters
      INTEGER,               INTENT(IN) :: npass
      INTEGER, DIMENSION(:), INTENT(OUT):: factor
      INTEGER,               INTENT(OUT):: nfactor, nsquare
      !--- local scalars
      INTEGER:: j, jj, k

      nfactor = 0
      k = npass
      DO WHILE (MOD(k, 16) == 0) 
         nfactor = nfactor + 1
         factor(nfactor) = 4
         k = k / 16
      END DO
      j = 3
      jj = 9
      DO
         DO WHILE (MOD(k, jj) == 0)
            nfactor = nfactor + 1
            factor(nfactor) = j
            k = k / jj
         END DO
         j = j + 2
         jj = j * j
         IF (jj > k) EXIT
      END DO
      IF (k <= 4) THEN
         nsquare = nfactor
         factor(nfactor + 1) = k
         IF (k /= 1) nfactor = nfactor + 1
      ELSE 
         IF (k - ISHFT(k / 4, 2) == 0) THEN
            nfactor = nfactor + 1
            factor(nfactor) = 2
            k = k / 4
         END IF
         nsquare = nfactor
         j = 2
         DO
            IF (MOD(k, j) == 0) THEN
               nfactor = nfactor + 1
               factor(nfactor) = j
               k = k / j
            END IF
            j = ISHFT((j + 1) / 2, 1) + 1
            IF (j > k) EXIT
         END DO
      END IF
      IF (nsquare > 0) THEN
         j = nsquare
         DO
            nfactor = nfactor + 1
            factor(nfactor) = factor(j)
            j = j - 1
            IF (j==0) EXIT
         END DO
      END IF

      RETURN
    END SUBROUTINE factorize


    SUBROUTINE transform(array, ntotal, npass, nspan, &
         factor, nfactor, inv) !-- compute fourier transform
      !--- formal parameters
      COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT):: array
      INTEGER,                        INTENT(IN)    :: ntotal, npass, nspan
      INTEGER,          DIMENSION(:), INTENT(IN)    :: factor
      INTEGER,                        INTENT(IN)    :: nfactor
      LOGICAL,                        INTENT(IN)    :: inv
      !--- local scalars
      INTEGER         :: ii, ispan
      INTEGER         :: j, jc, jf, jj
      INTEGER         :: k, kk, kspan, k1, k2, k3, k4
      INTEGER         :: nn, nt
      REAL(fftkind)   :: s60, c72, s72, pi2, radf
      REAL(fftkind)   :: c1, s1, c2, s2, c3, s3, cd, sd, ak
      COMPLEX(fftkind):: cc, cj, ck, cjp, cjm, ckp, ckm
      !--- local arrays
      COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE  :: ctmp
      REAL(fftkind),    DIMENSION(:), ALLOCATABLE  :: sine, cosine

      maxfactor = MAXVAL(factor(:nfactor))
      ALLOCATE(ctmp(maxfactor), sine(maxfactor), cosine(maxfactor), STAT=status)
      IF (status /= 0) RETURN

      c72 = cos72
      IF (inv) THEN
         s72 = sin72
         s60 = sin60
         pi2 = pi
      ELSE
         s72 = -sin72
         s60 = -sin60
         pi2 = -pi
      END IF

      nt = ntotal
      nn = nt - 1
      kspan = nspan
      jc = nspan / npass
      radf = pi2 * jc
      pi2 = pi2 * 2.0_fftkind !-- use 2 PI from here on

      ii = 0
      jf = 0
      DO
         sd = radf / kspan
         cd = SIN(sd)
         cd = 2.0_fftkind * cd * cd
         sd = SIN(sd + sd)
         kk = 1
         ii = ii + 1

         SELECT CASE (factor(ii))
         CASE (2)
            !-- transform for factor of 2 (including rotation factor)
            kspan = kspan / 2
            k1 = kspan + 2
            DO
               DO
                  k2 = kk + kspan
                  ck = array(k2)
                  array(k2) = array(kk)-ck
                  array(kk) = array(kk) + ck
                  kk = k2 + kspan
                  IF (kk > nn) EXIT
               END DO
               kk = kk - nn
               IF (kk > jc) EXIT
            END DO
            IF (kk > kspan) THEN
               DEALLOCATE(ctmp, sine, cosine, STAT=status)
               RETURN
            END IF
            DO
               c1 = 1.0_fftkind - cd
               s1 = sd
               DO
                  DO
                     DO
                        k2 = kk + kspan
                        ck = array(kk) - array(k2)
                        array(kk) = array(kk) + array(k2)
                        array(k2) = ck * CMPLX(c1, s1, KIND=fftkind)
                        kk = k2 + kspan
                        IF (kk >= nt) EXIT
                     END DO
                     k2 = kk - nt
                     c1 = -c1
                     kk = k1 - k2
                     IF (kk <= k2) EXIT
                  END DO
                  ak = c1 - (cd * c1 + sd * s1)
                  s1 = sd * c1 - cd * s1 + s1
                  c1 = 2.0_fftkind - (ak * ak + s1 * s1)
                  s1 = s1 * c1
                  c1 = c1 * ak
                  kk = kk + jc
                  IF (kk >= k2) EXIT
               END DO
               k1 = k1 + 1 + 1
               kk = (k1 - kspan) / 2 + jc
               IF (kk > jc + jc) EXIT
            END DO

         CASE (4) !-- transform for factor of 4
            ispan = kspan
            kspan = kspan / 4

            DO
               c1 = 1.0_fftkind
               s1 = 0.0_fftkind
               DO
                  DO
                     k1 = kk + kspan
                     k2 = k1 + kspan
                     k3 = k2 + kspan
                     ckp = array(kk) + array(k2)
                     ckm = array(kk) - array(k2)
                     cjp = array(k1) + array(k3)
                     cjm = array(k1) - array(k3)
                     array(kk) = ckp + cjp
                     cjp = ckp - cjp
                     IF (inv) THEN
                        ckp = ckm + CMPLX(-AIMAG(cjm), REAL(cjm), KIND=fftkind)
                        ckm = ckm + CMPLX(AIMAG(cjm), -REAL(cjm), KIND=fftkind)
                     ELSE
                        ckp = ckm + CMPLX(AIMAG(cjm), -REAL(cjm), KIND=fftkind)
                        ckm = ckm + CMPLX(-AIMAG(cjm), REAL(cjm), KIND=fftkind)
                     END IF
                     !-- avoid useless multiplies
                     IF (s1 == 0.0_fftkind) THEN
                        array(k1) = ckp
                        array(k2) = cjp
                        array(k3) = ckm
                     ELSE
                        array(k1) = ckp * CMPLX(c1, s1, KIND=fftkind)
                        array(k2) = cjp * CMPLX(c2, s2, KIND=fftkind)
                        array(k3) = ckm * CMPLX(c3, s3, KIND=fftkind)
                     END IF
                     kk = k3 + kspan
                     IF (kk > nt) EXIT
                  END DO

                  c2 = c1 - (cd * c1 + sd * s1)
                  s1 = sd * c1 - cd * s1 + s1
                  c1 = 2.0_fftkind - (c2 * c2 + s1 * s1)
                  s1 = s1 * c1
                  c1 = c1 * c2
                  !-- values of c2, c3, s2, s3 that will get used next time
                  c2 = c1 * c1 - s1 * s1
                  s2 = 2.0_fftkind * c1 * s1
                  c3 = c2 * c1 - s2 * s1
                  s3 = c2 * s1 + s2 * c1
                  kk = kk - nt + jc
                  IF (kk > kspan) EXIT
               END DO
               kk = kk - kspan + 1
               IF (kk > jc) EXIT
            END DO
            IF (kspan == jc) THEN
               DEALLOCATE(ctmp, sine, cosine, STAT=status)
               RETURN
            END IF

         CASE default
            !-- transform for odd factors
            k = factor(ii)
            ispan = kspan
            kspan = kspan / k

            SELECT CASE (k)
            CASE (3) !-- transform for factor of 3 (optional code)
               DO
                  DO
                     k1 = kk + kspan
                     k2 = k1 + kspan
                     ck = array(kk)
                     cj = array(k1) + array(k2)
                     array(kk) = ck + cj
                     ck = ck - CMPLX( &
                          0.5_fftkind * REAL (cj), &
                          0.5_fftkind * AIMAG(cj), &
                          KIND=fftkind)
                     cj = CMPLX( &
                          (REAL (array(k1)) - REAL (array(k2))) * s60, &
                          (AIMAG(array(k1)) - AIMAG(array(k2))) * s60, &
                          KIND=fftkind)
                     array(k1) = ck + CMPLX(-AIMAG(cj), REAL(cj), KIND=fftkind)
                     array(k2) = ck + CMPLX(AIMAG(cj), -REAL(cj), KIND=fftkind)
                     kk = k2 + kspan
                     IF (kk >= nn) EXIT
                  END DO
                  kk = kk - nn
                  IF (kk > kspan) EXIT
               END DO

            CASE (5) !-- transform for factor of 5 (optional code)
               c2 = c72 * c72 - s72 * s72
               s2 = 2.0_fftkind * c72 * s72
               DO
                  DO
                     k1 = kk + kspan
                     k2 = k1 + kspan
                     k3 = k2 + kspan
                     k4 = k3 + kspan
                     ckp = array(k1) + array(k4)
                     ckm = array(k1) - array(k4)
                     cjp = array(k2) + array(k3)
                     cjm = array(k2) - array(k3)
                     cc = array(kk)
                     array(kk) = cc + ckp + cjp
                     ck = CMPLX(REAL(ckp) * c72, AIMAG(ckp) * c72, &
                          KIND=fftkind) + &
                          CMPLX(REAL(cjp) * c2,  AIMAG(cjp) * c2,  &
                          KIND=fftkind) + cc
                     cj = CMPLX(REAL(ckm) * s72, AIMAG(ckm) * s72, &
                          KIND=fftkind) + &
                          CMPLX(REAL(cjm) * s2,  AIMAG(cjm) * s2,  &
                          KIND=fftkind)
                     array(k1) = ck + CMPLX(-AIMAG(cj), REAL(cj), KIND=fftkind)
                     array(k4) = ck + CMPLX(AIMAG(cj), -REAL(cj), KIND=fftkind)
                     ck = CMPLX(REAL(ckp) * c2,  AIMAG(ckp) * c2,  &
                          KIND=fftkind) + &
                          CMPLX(REAL(cjp) * c72, AIMAG(cjp) * c72, &
                          KIND=fftkind) + cc
                     cj = CMPLX(REAL(ckm) * s2,  AIMAG(ckm) * s2,  &
                          KIND=fftkind) - &
                          CMPLX(REAL(cjm) * s72, AIMAG(cjm) * s72, &
                          KIND=fftkind)
                     array(k2) = ck + CMPLX(-AIMAG(cj), REAL(cj), KIND=fftkind)
                     array(k3) = ck + CMPLX(AIMAG(cj), -REAL(cj), KIND=fftkind)
                     kk = k4 + kspan
                     IF (kk >= nn) EXIT
                  END DO
                  kk = kk - nn
                  IF (kk > kspan) EXIT
               END DO

            CASE default
               IF (k /= jf) THEN
                  jf = k
                  s1 = pi2 / k
                  c1 = COS(s1)
                  s1 = SIN(s1)
                  cosine (jf) = 1.0_fftkind
                  sine (jf) = 0.0_fftkind
                  j = 1
                  DO
                     cosine (j) = cosine (k) * c1 + sine (k) * s1
                     sine (j) = cosine (k) * s1 - sine (k) * c1
                     k = k-1
                     cosine (k) = cosine (j)
                     sine (k) = -sine (j)
                     j = j + 1
                     IF (j >= k) EXIT
                  END DO
               END IF
               DO
                  DO
                     k1 = kk
                     k2 = kk + ispan
                     cc = array(kk)
                     ck = cc
                     j = 1
                     k1 = k1 + kspan
                     DO
                        k2 = k2 - kspan
                        j = j + 1
                        ctmp(j) = array(k1) + array(k2)
                        ck = ck + ctmp(j)
                        j = j + 1
                        ctmp(j) = array(k1) - array(k2)
                        k1 = k1 + kspan
                        IF (k1 >= k2) EXIT
                     END DO
                     array(kk) = ck
                     k1 = kk
                     k2 = kk + ispan
                     j = 1
                     DO
                        k1 = k1 + kspan
                        k2 = k2 - kspan
                        jj = j
                        ck = cc
                        cj = (0.0_fftkind, 0.0_fftkind)
                        k = 1
                        DO
                           k = k + 1
                           ck = ck + CMPLX( &
                                REAL (ctmp(k)) * cosine(jj), &
                                AIMAG(ctmp(k)) * cosine(jj), KIND=fftkind)
                           k = k + 1
                           cj = cj + CMPLX( &
                                REAL (ctmp(k)) * sine(jj), &
                                AIMAG(ctmp(k)) * sine(jj), KIND=fftkind)
                           jj = jj + j
                           IF (jj > jf) jj = jj - jf
                           IF (k >= jf) EXIT
                        END DO
                        k = jf - j
                        array(k1) = ck + CMPLX(-AIMAG(cj), REAL(cj), &
                             KIND=fftkind)
                        array(k2) = ck + CMPLX(AIMAG(cj), -REAL(cj), &
                             KIND=fftkind)
                        j = j + 1
                        IF (j >= k) EXIT
                     END DO
                     kk = kk + ispan
                     IF (kk > nn) EXIT
                  END DO
                  kk = kk - nn
                  IF (kk > kspan) EXIT
               END DO

            END SELECT
            !--  multiply by rotation factor (except for factors of 2 and 4)
            IF (ii == nfactor) THEN
               DEALLOCATE(ctmp, sine, cosine, STAT=status)
               RETURN
            END IF

            kk = jc + 1
            DO
               c2 = 1.0_fftkind - cd
               s1 = sd
               DO
                  c1 = c2
                  s2 = s1
                  kk = kk + kspan
                  DO
                     DO
                        array(kk) = CMPLX(c2, s2, KIND=fftkind) * array(kk)
                        kk = kk + ispan
                        IF (kk > nt) EXIT
                     END DO
                     ak = s1 * s2
                     s2 = s1 * c2 + c1 * s2
                     c2 = c1 * c2 - ak
                     kk = kk - nt + kspan
                     IF (kk > ispan) EXIT
                  END DO
                  c2 = c1 - (cd * c1 + sd * s1)
                  s1 = s1 + sd * c1 - cd * s1
                  c1 = 2.0_fftkind - (c2 * c2 + s1 * s1)
                  s1 = s1 * c1
                  c2 = c2 * c1
                  kk = kk - ispan + jc
                  IF (kk > kspan) EXIT
               END DO
               kk = kk - kspan + jc + 1
               IF (kk > jc + jc) EXIT
            END DO

         END SELECT
      END DO

      DEALLOCATE(ctmp, sine, cosine, STAT=status)
      RETURN
    END SUBROUTINE transform


    SUBROUTINE permute(array, ntotal, npass, nspan, &
         factor, nfactor, nsquare, maxfactor)
      !--- formal parameters
      COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT):: array
      INTEGER,                        INTENT(IN)    :: ntotal, npass, nspan
      INTEGER,          DIMENSION(:), INTENT(IN OUT):: factor
      INTEGER,                        INTENT(IN)    :: nfactor, nsquare
      INTEGER,                        INTENT(IN)    :: maxfactor
      !--- local scalars
      INTEGER         :: ii, ispan
      INTEGER         :: j, jc, jj
      INTEGER         :: k, kk, kspan, kt, k1, k2, k3
      INTEGER         :: nn, nperm, nt
      COMPLEX(fftkind):: ck
      !--- local arrays
      COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE  :: ctmp
      INTEGER         , DIMENSION(:), ALLOCATABLE  :: perm

      ALLOCATE(ctmp(maxfactor), STAT=status)
      IF (status /= 0) RETURN

      IF (nfactor - ISHFT(nsquare, 1) > 0) THEN
         nperm = MAX(nfactor + 1, PRODUCT(factor(nsquare+1: nfactor-nsquare)) - 1)
      ELSE
         nperm = nfactor + 1
      END IF
      ALLOCATE(perm(nperm), STAT=status)
      IF (status /= 0) RETURN

      !--  permute the results to normal order---done in two stages
      !--  permutation for square factors of n

      nt = ntotal
      nn = nt - 1
      kt = nsquare
      kspan = nspan
      jc = nspan / npass

      perm (1) = nspan
      IF (kt > 0) THEN
         k = kt + kt + 1
         IF (nfactor < k) k = k - 1
         j = 1
         perm (k + 1) = jc
         DO
            perm (j + 1) = perm (j) / factor(j)
            perm (k) = perm (k + 1) * factor(j)
            j = j + 1
            k = k - 1
            IF (j >= k) EXIT
         END DO
         k3 = perm (k + 1)
         kspan = perm (2)
         kk = jc + 1
         k2 = kspan + 1
         j = 1

         IF (npass /= ntotal) THEN
            permute_multi: DO
               DO
                  DO
                     k = kk + jc
                     DO
                        !-- swap array(kk) <> array(k2)
                        ck = array(kk)
                        array(kk) = array(k2)
                        array(k2) = ck
                        kk = kk + 1
                        k2 = k2 + 1
                        IF (kk >= k) EXIT
                     END DO
                     kk = kk + nspan - jc
                     k2 = k2 + nspan - jc
                     IF (kk >= nt) EXIT
                  END DO
                  kk = kk - nt + jc
                  k2 = k2 - nt + kspan
                  IF (k2 >= nspan) EXIT
               END DO
               DO
                  DO
                     k2 = k2 - perm (j)
                     j = j + 1
                     k2 = perm (j + 1) + k2
                     IF (k2 <= perm (j)) EXIT
                  END DO
                  j = 1
                  DO
                     IF (kk < k2) CYCLE permute_multi
                     kk = kk + jc
                     k2 = k2 + kspan
                     IF (k2 >= nspan) EXIT
                  END DO
                  IF (kk >= nspan) EXIT
               END DO
               EXIT
            END DO permute_multi
         ELSE
            permute_single: DO
               DO
                  !-- swap array(kk) <> array(k2)
                  ck = array(kk)
                  array(kk) = array(k2)
                  array(k2) = ck
                  kk = kk + 1
                  k2 = k2 + kspan
                  IF (k2 >= nspan) EXIT
               END DO
               DO
                  DO
                     k2 = k2 - perm (j)
                     j = j + 1
                     k2 = perm (j + 1) + k2
                     IF (k2 <= perm (j)) EXIT
                  END DO
                  j = 1
                  DO
                     IF (kk < k2) CYCLE permute_single
                     kk = kk + 1
                     k2 = k2 + kspan
                     IF (k2 >= nspan) EXIT
                  END DO
                  IF (kk >= nspan) EXIT
               END DO
               EXIT
            END DO permute_single
         END IF
         jc = k3
      END IF

      IF (ISHFT(kt, 1) + 1 >= nfactor) THEN
         DEALLOCATE(perm, ctmp)
         RETURN
      END IF

      ispan = perm (kt + 1)
      !-- permutation for square-free factors of n
      j = nfactor - kt
      factor(j + 1) = 1
      DO
         factor(j) = factor(j) * factor(j+1)
         j = j - 1
         IF (j == kt) EXIT
      END DO
      kt = kt + 1
      nn = factor(kt) - 1
      j = 0
      jj = 0
      DO
         k = kt + 1
         k2 = factor(kt)
         kk = factor(k)
         j = j + 1
         IF (j > nn) EXIT !-- exit infinite loop
         jj = jj + kk
         DO WHILE (jj >= k2)
            jj = jj - k2
            k2 = kk
            k = k + 1
            kk = factor(k)
            jj = jj + kk
         END DO
         perm (j) = jj
      END DO
      !--  determine the permutation cycles of length greater than 1
      j = 0
      DO
         DO
            j = j + 1
            kk = perm(j)
            IF (kk >= 0) EXIT
         END DO
         IF (kk /= j) THEN
            DO
               k = kk
               kk = perm (k)
               perm (k) = -kk
               IF (kk == j) EXIT
            END DO
            k3 = kk
         ELSE
            perm (j) = -j
            IF (j == nn) EXIT !-- exit infinite loop
         END IF
      END DO
      !--  reorder a and b, following the permutation cycles
      DO
         j = k3 + 1
         nt = nt - ispan
         ii = nt - 1 + 1
         IF (nt < 0) EXIT !-- exit infinite loop
         DO
            DO
               j = j-1
               IF (perm(j) >= 0) EXIT
            END DO
            jj = jc
            DO
               kspan = jj
               IF (jj > maxfactor) kspan = maxfactor
               jj = jj - kspan
               k = perm(j)
               kk = jc * k + ii + jj
               k1 = kk + kspan
               k2 = 0
               DO
                  k2 = k2 + 1
                  ctmp(k2) = array(k1)
                  k1 = k1 - 1
                  IF (k1 == kk) EXIT
               END DO
               DO
                  k1 = kk + kspan
                  k2 = k1 - jc * (k + perm(k))
                  k = -perm(k)
                  DO
                     array(k1) = array(k2)
                     k1 = k1 - 1
                     k2 = k2 - 1
                     IF (k1 == kk) EXIT
                  END DO
                  kk = k2
                  IF (k == j) EXIT
               END DO
               k1 = kk + kspan
               k2 = 0
               DO
                  k2 = k2 + 1
                  array(k1) = ctmp(k2)
                  k1 = k1 - 1
                  IF (k1 == kk) EXIT
               END DO
               IF (jj == 0) EXIT
            END DO
            IF (j == 1) EXIT
         END DO
      END DO

      DEALLOCATE(perm, ctmp)
      RETURN
    END SUBROUTINE permute

  END SUBROUTINE fftradix

END MODULE singleton
solve.F         1587424407  1602  20    100644  150364    `
!-----------------------------------------------------------------------
!
!  CM1 Numerical Model, Release 18.3  (cm1r18.3)
!  7 October 2015
!  http://www2.mmm.ucar.edu/people/bryan/cm1/
!
!  Copyright (c) 2000-2015 by George H. Bryan, National Center for 
!  Atmospheric Research, Boulder, Colorado, USA. 
!
!-----------------------------------------------------------------------
!  Quick Index:
!    ua/u3d     = velocity in x-direction (m/s)
!    va/v3d     = velocity in y-direction (m/s)
!    wa/w3d     = velocity in z-direction (m/s)
!    tha/th3d   = perturbation potential temperature (K)
!    ppi/pp3d   = perturbation nondimensional pressure ("Exner function")
!    qa/q3d     = mixing ratios of moisture (kg/kg)
!    tkea/tke3d = SUBGRID turbulence kinetic energy (m^2/s^2)
!    kmh/kmv    = turbulent diffusion coefficients for momentum (m^2/s)
!    khh/khv    = turbulent diffusion coefficients for scalars (m^2/s)
!                 (h = horizontal, v = vertical)
!    prs        = pressure (Pa)
!    rho        = density (kg/m^3)
!
!    th0,pi0,prs0,etc = base-state arrays
!
!    xh         = x (m) at scalar points
!    xf         = x (m) at u points
!    yh         = y (m) at scalar points
!    yf         = y (m) at v points
!    zh         = z (m above sea level) of scalar points (aka, "half levels")
!    zf         = z (m above sea level) of w points (aka, "full levels")
!
!    For the axisymmetric model (axisymm=1), xh and xf are radius (m).
!
!  See "The governing equations for CM1" for more details:
!        http://www2.mmm.ucar.edu/people/bryan/cm1/cm1_equations.pdf
!-----------------------------------------------------------------------
!  Some notes:
!
!  - Upon entering solve, the arrays ending in "a" (eg, ua,wa,tha,qa,etc)
!    are equivalent to the arrays ending in "3d" (eg, u3d,w3d,th3d,q3d,etc).
!  - The purpose of solve is to update the variables from time "t" to time
!    "t+dt".  Values at time "t+dt" are stored in the "3d" arrays.
!  - The "ghost zones" (boundaries beyond the computational subdomain) are
!    filled out completely (3 rows/columns) for the "3d" arrays.  To save 
!    unnecessary computations, starting with cm1r15 the "ghost zones" of 
!    the "a" arrays are only filled out to 1 row/column.  Hence, if you 
!    need to do calculations that use a large stencil, you must use the 
!    "3d" arrays (not the "a") arrays.
!  - Arrays named "ten" store tendencies.  Those ending "ten1" store
!    pre-RK tendencies that are calculated once and then held fixed during
!    the RK (Runge-Kutta) sub-steps. 
!  - CM1 uses a low-storage three-step Runge-Kutta scheme.  See Wicker
!    and Skamarock (2002, MWR, p 2088) for more information.
!  - CM1 uses a staggered C grid.  Hence, u arrays have one more grid point
!    in the i direction, v arrays have one more grid point in the j 
!    direction, and w arrays have one more grid point in the k direction
!    (compared to scalar arrays).
!  - CM1 assumes the subgrid turbulence parameters (tke,km,kh) are located
!    at the w points. 
!-----------------------------------------------------------------------

      subroutine solve(nstep,nrec,prec,nwrite,nrst,rbufsz,num_soil_layers,ndt,ntdiag,nqdiag, &
                   dt,dtlast,mtime,stattim,taptim,rsttim,radtim,prcltim,adt,acfl,dbldt,mass1,mass2, &
                   dosfcflx,cloudvar,rhovar,qname,budname,bud,bud2,qbudget,asq,bsq, &
                   xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf,yh,vh,rvh,yf,vf,rvf,   &
                   xfref,yfref,dumk1,dumk2,rds,sigma,rdsf,sigmaf,    &
                   tauh,taus,zh,mh,rmh,c1,c2,tauf,zf,mf,rmf,         &
                   rstat,rho0s,pi0s,prs0s,rth0s,pi0,rho0,prs0,thv0,th0,rth0,qv0,qc0, &
                   qi0,rr0,rf0,rrf0,                                 &
                   zs,gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy,gx,gxu,gy,gyv, &
                   rain,sws,svs,sps,srs,sgs,sus,shs,                 &
                   tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,tlh,          &
                   radbcw,radbce,radbcs,radbcn,                      &
                   dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,          &
                   divx,rho,rr,rf,prs,                               &
                   t11,t12,t13,t22,t23,t33,                          &
                   u0,rru,us,ua,u3d,uten,uten1,                      &
                   v0,rrv,vs,va,v3d,vten,vten1,                      &
                   rrw,ws,wa,w3d,wten,wten1,                         &
                   ppi,pp3d,piadv,ppten,sten,ppx,                    &
                   tha,th3d,thadv,thten,thten1,thterm,               &
                   qpten,qtten,qvten,qcten,qa,q3d,qten,              &
                   kmh,kmv,khh,khv,tkea,tke3d,tketen,                &
                   nm,defv,defh,dissten,                             &
                   thpten,qvpten,qcpten,qipten,upten,vpten,          &
                   swten,lwten,o30,radsw,rnflx,radswnet,radlwin,dsr,olr,rad2d,  &
                   effc,effi,effs,effr,effg,effis,                   &
                   lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,znt,ust,  &
                   hpbl,wspd,psim,psih,gz1oz0,br,                    &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                    &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                 &
                   CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,    &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh,  &
                   mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d,   &
                   slab_zs,slab_dzs,tslb,tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,       &
                   pta,pt3d,ptten,pdata,packet,ploc,                 &
                   cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans,flag,      &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk,reqs_q,reqs_t, &
                   nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                  &
                   n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,          &
                   ww1,ww2,we1,we2,ws1,ws2,wn1,wn2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,          &
                   ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,          &
                   sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,          &
                   rw31,rw32,re31,re32,rs31,rs32,rn31,rn32,          &
                   qw31,qw32,qe31,qe32,qs31,qs32,qn31,qn32,          &
                   tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2,          &
                   kw1,kw2,ke1,ke2,ks1,ks2,kn1,kn2,                  &
                   tw1,tw2,te1,te2,ts1,ts2,tn1,tn2,                  &
                   dat1,dat2,dat3,reqt,tdiag,qdiag)
        ! end_solve
      use module_mp_thompson
      use module_mp_graupel
      use module_mp_nssl_2mom, only : zscale, nssl_2mom_driver
#ifdef MPI
      use mpi
#endif
      use module_restart
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'radcst.incl'
      include 'timestat.incl'

!-----------------------------------------------------------------------
! Arrays and variables passed into solve

      integer, intent(in) :: nstep
      integer, intent(inout) :: nrec,prec,nwrite,nrst
      integer, intent(in) :: rbufsz,num_soil_layers
      integer, intent(inout) :: ndt
      integer, intent(in) :: ntdiag,nqdiag
      real, intent(inout) :: dt,dtlast
      double precision, intent(inout) :: mtime,stattim,taptim,rsttim,radtim,prcltim
      double precision, intent(inout) :: adt,acfl,dbldt
      double precision, intent(in   ) :: mass1
      double precision, intent(inout) :: mass2
      logical, intent(in) :: dosfcflx
      logical, intent(in), dimension(maxq) :: cloudvar,rhovar
      character*3, intent(in), dimension(maxq) :: qname
      character*6, intent(in), dimension(maxq) :: budname
      double precision, intent(inout), dimension(nk) :: bud
      double precision, intent(inout), dimension(nj) :: bud2
      double precision, intent(inout), dimension(nbudget) :: qbudget
      double precision, intent(inout), dimension(numq) :: asq,bsq
      real, intent(in), dimension(ib:ie) :: xh,rxh,arh1,arh2,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf,ruf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf,rvf
      real, intent(in), dimension(-2:nx+4) :: xfref
      real, intent(in), dimension(-2:ny+4) :: yfref
      double precision, intent(inout), dimension(kb:ke) :: dumk1,dumk2
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: tauh,taus,zh,mh,rmh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: tauf,zf,mf,rmf
      real, intent(inout), dimension(stat_out) :: rstat
      real, intent(in), dimension(ib:ie,jb:je) :: rho0s,pi0s,prs0s,rth0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,prs0,thv0,th0,rth0,qv0,qc0
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: qi0,rr0,rf0,rrf0
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, intent(inout), dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,znt,ust,thflux,qvflux,cd,ch,cq,u1,v1,s1,xland,psfc,tlh
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: divx,rho,rr,rf,prs
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: rru,us,ua,u3d,uten,uten1
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: rrv,vs,va,v3d,vten,vten1
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: rrw,ws,wa,w3d,wten,wten1
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,piadv,ppten,sten,ppx
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thadv,thten,thten1,thterm
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem) :: qpten,qtten,qvten,qcten
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,q3d,qten
      real, intent(inout), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d,tketen
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: nm,defv,defh,dissten
      real, intent(inout), dimension(ibb:ieb,jbb:jeb,kbb:keb) :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: swten,lwten
      real, intent(in), dimension(ibr:ier,jbr:jer,kbr:ker) :: o30
      real, intent(inout), dimension(ni,nj) :: radsw,rnflx,radswnet,radlwin,dsr,olr
      real, intent(inout), dimension(ni,nj,nrad2d) :: rad2d
      real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: effc,effi,effs,effr,effg,effis
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: lu_index
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: kpbl2d
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: u10,v10,s10,hfx,qfx, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,       &
                                      CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d
      real, intent(in), dimension(num_soil_layers) :: slab_zs,slab_dzs
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, intent(inout), dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta,pt3d,ptten
      real, intent(inout), dimension(npvals,nparcels) :: pdata,packet
      real, intent(inout), dimension(3,nparcels) :: ploc
      real, intent(in), dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, intent(in), dimension(kpb:kpe) :: cfa,cfc,ad1,ad2
      complex, intent(inout), dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, intent(inout), dimension(ipb:ipe,jpb:jpe) :: rhs,trans
      logical, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: flag
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk
      integer, intent(inout), dimension(rmp,numq) :: reqs_q
      integer, intent(inout), dimension(rmp,npt) :: reqs_t
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(cmp,cmp,kmt+1) :: n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2
      real, intent(inout), dimension(jmp,kmp-1) :: ww1,ww2,we1,we2
      real, intent(inout), dimension(imp,kmp-1) :: ws1,ws2,wn1,wn2
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      real, intent(inout), dimension(jmp,kmp) :: vw1,vw2,ve1,ve2
      real, intent(inout), dimension(imp,kmp) :: vs1,vs2,vn1,vn2
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, intent(inout), dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(inout), dimension(cmp,jmp,kmp,2) :: rw31,rw32,re31,re32
      real, intent(inout), dimension(imp,cmp,kmp,2) :: rs31,rs32,rn31,rn32
      real, intent(inout), dimension(cmp,jmp,kmp,numq) :: qw31,qw32,qe31,qe32
      real, intent(inout), dimension(imp,cmp,kmp,numq) :: qs31,qs32,qn31,qn32
      real, intent(inout), dimension(cmp,jmp,kmt)   :: tkw1,tkw2,tke1,tke2
      real, intent(inout), dimension(imp,cmp,kmt)   :: tks1,tks2,tkn1,tkn2
      real, intent(inout), dimension(jmp,kmt,4)     :: kw1,kw2,ke1,ke2
      real, intent(inout), dimension(imp,kmt,4)     :: ks1,ks2,kn1,kn2
      real, intent(inout), dimension(cmp,jmp,kmp,npt) :: tw1,tw2,te1,te2
      real, intent(inout), dimension(imp,cmp,kmp,npt) :: ts1,ts2,tn1,tn2
      real, intent(inout), dimension(ni+1,nj+1) :: dat1
      real, intent(inout), dimension(d2i,d2j) :: dat2
      real, intent(inout), dimension(d3i,d3j,d3n) :: dat3
      integer, intent(inout), dimension(d3t) :: reqt
      real, intent(inout) , dimension(ibd:ied,jbd:jed,kbd:ked,ntdiag) :: tdiag
      real, intent(inout) , dimension(ibd:ied,jbd:jed,kbd:ked,nqdiag) :: qdiag

!-----------------------------------------------------------------------
! Arrays and variables defined inside solve

      integer :: i,j,k,n,nrk,bflag,pdef,nn,fnum,diffit,k1

      real :: delqv,delpi,delth,delt,fac,epsd,dheat,dz1,xs
      real :: foo1,foo2
      real :: dttmp,rtime,rdt,tem,tem0,thrad,prad,ql
      real :: cpm,cvm
      real :: r1,r2,tnew,pnew,pinew,thnew,qvnew
      real :: gamm,aiu

      double precision :: weps,afoo,bfoo,p0,p2,tout

      logical :: getdbz,getvt
      logical :: dorad,reset
      logical :: doirrad,dosorad
      logical :: get_time_avg,dostat,dowrite,dorestart,doprclout

      real :: saltitude,sazimuth,zen
      real, dimension(2) :: x1
      real, dimension(2) :: y1

      ! 1d arrays for radiation scheme:
      real, dimension(rbufsz) :: radbuf
      real, dimension(nkr) :: swtmp,lwtmp
      real, dimension(nkr) :: tem1,tem2,tem3,tem4,tem5,   &
                              tem6,tem7,tem8,tem9,tem10,   &
                              tem11,tem12,tem13,tem14,tem15,   &
                              tem16,tem17
      real, dimension(nkr) :: teffc,teffi,teffs,teffr,teffg,teffis
      real, dimension(nkr) :: ptprt,pprt,qv,qc,qr,qi,qs,qh,cvr,   &
                              ptbar,pbar,appi,rhostr,zpp,o31

      real :: rad2deg,albedo,albedoz,tema,temb,frac_snowcover

      real, parameter  ::  cfl_limit   =  0.95    ! maximum CFL allowed  (actually a "target" value)
      real, parameter  ::  max_change  =  0.10    ! maximum (percentage) change in timestep

!--------------------------------------------------------------------

      if( adapt_dt.eq.1 .and. myid.eq.0 ) print *,'cflmax,dt,nsound:',cflmax,dt,nsound

#ifdef MPI
      nf=0
      nu=0
      nv=0
      nw=0
#endif

      afoo=0.0d0
      bfoo=0.0d0

      dowrite = .false.

      ! check if writeout will be called at end of timestep:
      if( (mtime+dt).ge.(taptim-0.1*dt) ) dowrite = .true.
      IF( myid.eq.0 .and. dowrite ) print *,'  dowrite = ',dowrite

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   radiation  ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      IF( radopt.ge.1 )THEN

        ! just to be sure:
        call setradwrk(nir,njr,nkr)

        ! time at beginning of timestep:
        rtime=sngl(mtime)
        dorad = .false.
        IF( mtime.ge.(radtim-0.1*dt) ) dorad = .true.
        dtrad = max( dtrad , dt )

        IF( dorad )THEN
          i = 1
          j = 1
          rtime=sngl(mtime+dt)
          if(dowr) write(outfile,*) '  Calculating radiation tendency:'
          if(timestats.ge.1) time_rad=time_rad+mytime()
          call bcs(prs)
          CALL zenangl( ni,nj,      zf(1,1,1),    &
                rad2d(1,1,ncosz), rad2d(1,1,ncosss), radsw,              &
                dum1(1,1,1),dum1(1,1,2),dum1(1,1,3),dum1(1,1,4),        &
                dum2(1,1,1),dum2(1,1,2),dum2(1,1,3),dum2(1,1,4),        &
                saltitude,sazimuth,dx,dy,dt,rtime,                     &
                ctrlat,ctrlon,year,month,day,hour,minute,second,jday )
          if(myid.eq.0)then
            print *,'    solar zenith angle  (degrees) = ',   &
                                   acos(rad2d(ni,nj,ncosz))*degdpi
            print *,'    solar azimuth angle (degrees) = ',sazimuth*degdpi
          endif
!-----------------------------------------------------------------------
!
!  Calculate surface albedo which is dependent on solar zenith angle
!  and soil moisture. Set the albedo for different types of solar
!  flux to be same.
!
!    rsirbm   Solar IR surface albedo for beam radiation
!    rsirdf   Solar IR surface albedo for diffuse radiation
!    rsuvbm   Solar UV surface albedo for beam radiation
!    rsuvdf   Solar UV surface albedo for diffuse radiation
!
!-----------------------------------------------------------------------
!
  rad2deg = 180.0/3.141592654

          radbuf = 0.0
          tem1 = 0.0
          tem2 = 0.0
          tem3 = 0.0
          tem4 = 0.0
          tem5 = 0.0
          tem6 = 0.0
          tem7 = 0.0
          tem8 = 0.0
          tem9 = 0.0
          tem10 = 0.0
          tem11 = 0.0
          tem12 = 0.0
          tem13 = 0.0
          tem14 = 0.0
          tem15 = 0.0
          tem16 = 0.0
          tem17 = 0.0
          ptprt = 0.0
          pprt = 0.0
          qv = 0.0
          qc = 0.0
          qr = 0.0
          qi = 0.0
          qs = 0.0
          qh = 0.0
          cvr = 0.0
          ptbar = 0.0
          pbar = 0.0
          appi = 0.0
          rhostr = 0.0
          zpp = 0.0
          o31 = 0.0

!$omp parallel do default(shared)  &
!$omp private(i,j,albedo,albedoz,frac_snowcover,tema)
  DO j=1,nj
    DO i=1,ni

      ! let's just use MM5/WRF value, instead:
      albedo = albd(i,j)

      ! arps code for albedo:
      ! (not sure I trust this.....)

!      albedoz = 0.01 * ( EXP( 0.003286         & ! zenith dependent albedo
!          * SQRT( ( ACOS(rad2d(i,j,ncosz))*rad2deg ) ** 3 ) ) - 1.0 )
!
!      IF ( soilmodel == 0 ) THEN             ! soil type not defined
!!!!        stop 12321
!        tema = 0
!      ELSE
!        tema = qsoil(i,j,1)/wsat(soiltyp(i,j))
!      END IF
!
!      frac_snowcover = MIN(snowdpth(i,j)/snowdepth_crit, 1.0)
!
!      IF ( tema > 0.5 ) THEN
!        albedo = albedoz + (1.-frac_snowcover)*0.14                     &
!                         + frac_snowcover*snow_albedo
!      ELSE
!        albedo = albedoz + (1.-frac_snowcover)*(0.31 - 0.34 * tema)     &
!                         + frac_snowcover*snow_albedo
!      END IF
!        albedo = albedoz

      rad2d(i,j,nrsirbm) = albedo
      rad2d(i,j,nrsirdf) = albedo
      rad2d(i,j,nrsuvbm) = albedo
      rad2d(i,j,nrsuvdf) = albedo

    END DO
  END DO
          ! big OpenMP parallelization loop:
!$omp parallel do default(shared)  &
!$omp private(i,j,k,ptprt,pprt,qv,qc,qr,qi,qs,qh,cvr,appi,o31,        &
!$omp tem1,tem2,tem3,tem4,tem5,tem6,tem7,tem8,tem9,tem10,        &
!$omp tem11,tem12,tem13,tem14,tem15,tem16,tem17,radbuf,swtmp,lwtmp,   &
!$omp doirrad,dosorad,zpp,ptbar,pbar,rhostr,x1,y1,  &
!$omp teffc,teffi,teffs,teffr,teffg,teffis)
        do j=1,nj
        do i=1,ni
          swtmp = 0.0
          lwtmp = 0.0
          do k=1,nk+2
            ptprt(k) =  tha(i,j,k-1)
             pprt(k) =  prs(i,j,k-1) - prs0(i,j,k-1)
               qv(k) =   qa(i,j,k-1,nqv)
               qc(k) =   0.0
               if( nqc.ge.1 ) qc(k) = qa(i,j,k-1,nqc)
               qr(k) =   0.0
               if( nqr.ge.1 ) qr(k) = qa(i,j,k-1,nqr)
               qi(k) =   0.0
               if( nqi.ge.1 ) qi(k) = qa(i,j,k-1,nqi)
               qs(k) =   0.0
               if( nqs.ge.1 ) qs(k) = qa(i,j,k-1,nqs)
               qh(k) =   0.0
               if( nqg.ge.1 ) qh(k) = qa(i,j,k-1,nqg)
              cvr(k) = cv+cvv*qv(k)+cpl*(qc(k)+qr(k))+cpi*(qi(k)+qs(k)+qh(k))
             appi(k) =  pi0(i,j,k-1) + ppi(i,j,k-1)
              o31(k) =  o30(i,j,k-1)
            teffc(k) = effc(i,j,k-1)
            teffi(k) = effi(i,j,k-1)
            teffs(k) = effs(i,j,k-1)
            teffr(k) = effr(i,j,k-1)
            teffg(k) = effg(i,j,k-1)
           teffis(k) = effis(i,j,k-1)
          enddo
          ptprt(1) = ptprt(2)
           pprt(1) =  pprt(2)
          ptprt(nk+2) = ptprt(nk+1)
           pprt(nk+2) =  pprt(nk+1)
          x1(1) = xf(i)
          x1(2) = xf(i+1)
          y1(1) = yf(j)
          y1(2) = yf(j+1)
          do k=1,nk+3
            zpp(k) =   zf(i,j,k-1)
          enddo
          do k=1,nk+2
            ptbar(k) =  th0(i,j,k-1)
             pbar(k) = prs0(i,j,k-1)
           rhostr(k) =  rho(i,j,k-1)
          enddo
            ptbar(1) = rth0s(i,j)**(-1)
             pbar(1) = prs0s(i,j)
           rhostr(1) = rho0s(i,j)
            doirrad = .true.
            dosorad = .true.
          CALL radtrns(nir,njr,nkr, rbufsz, 0,myid,dx,dy,            &
                 ib,ie,jb,je,kb,ke,xh,yh,prs0s(i,j),olr(i,j),dsr(i,j),  &  ! MS add olr,dsr
                 ptprt,pprt,qv,qc,qr,qi,qs,qh,cvr,                      &
                 ptbar,pbar,appi,o31,rhostr, tsk(i,j), zpp ,                                 &
                 radsw(i,j),rnflx(i,j),radswnet(i,j),radlwin(i,j), rad2d(i,j,ncosss),            &
                 rad2d(i,j,nrsirbm),rad2d(i,j,nrsirdf),rad2d(i,j,nrsuvbm),                       &
                 rad2d(i,j,nrsuvdf), rad2d(i,j,ncosz),sazimuth,                                  &
                 rad2d(i,j,nfdirir),rad2d(i,j,nfdifir),rad2d(i,j,nfdirpar),rad2d(i,j,nfdifpar),  &
                 tem1, tem2, tem3, tem4, tem5,                &
                 tem6, tem7, tem8, tem9, tem10,               &
                 tem11,tem12,tem13,tem14,tem15,tem16,         &
                 radbuf(1), tem17,swtmp,lwtmp,doirrad,dosorad, &
                 teffc,teffi,teffs,teffr,teffg,teffis,        &
                 cgs1,cgs2,cgs3,cgt1,cgt2,cgt3,ptype,g,cp)
          do k=1,nk
            swten(i,j,k) = swtmp(k+1)
            lwten(i,j,k) = lwtmp(k+1)
          enddo
        enddo
        enddo
          radtim=radtim+dtrad
        ENDIF
        if(timestats.ge.1) time_rad=time_rad+mytime()

      ENDIF


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   subgrid turbulence schemes  cccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!--------------------------------------------------------------------
!  get RHS for tke scheme:

      IF(iturb.eq.1)THEN
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k=2,nk
          !  Buoyancy, Dissipation, and Shear terms:
          do j=1,nj
          do i=1,ni
            tketen(i,j,k) = -khv(i,j,k)*nm(i,j,k)  &
                            -dissten(i,j,k)
          enddo
          enddo
          ! Shear term 
          IF(tconfig.eq.1)THEN
            do j=1,nj
            do i=1,ni
              tketen(i,j,k)=tketen(i,j,k)+kmv(i,j,k)*max(0.0,(defv(i,j,k)+defh(i,j,k)))
            enddo
            enddo
          ELSEIF(tconfig.eq.2)THEN
            do j=1,nj
            do i=1,ni
              tketen(i,j,k)=tketen(i,j,k)+kmv(i,j,k)*max(0.0,defv(i,j,k))   &
                                         +kmh(i,j,k)*max(0.0,defh(i,j,k))
            enddo
            enddo
          ENDIF
        ENDDO
        if(timestats.ge.1) time_turb=time_turb+mytime()

        call turbt(dt,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho,rr,rf,  &
                   rds,sigma,gz,rgz,gzu,rgzu,gzv,rgzv,        &
                   dum1,dum2,dum3,dum4,dum5,sten,tkea,tketen,kmh,kmv)

      ENDIF


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   Pre-RK calculations   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

!--------------------------------------------------------------------
!  radbc
 
      if(irbc.eq.1)then

        if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,ua)
 
        if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,va)

      endif

!--------------------------------------------------------------------
!  U-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
!!!        uten1(i,j,k)=0.
        uten1(i,j,k)=-rdalpha*0.5*(tauh(i-1,j,k)+tauh(i,j,k))*(ua(i,j,k)-u0(i,j,k))
      enddo
      enddo
      enddo

      IF( iinit.eq.10 .and. mtime.lt.t2_uforce )THEN
        ! u-forcing for squall-line initialization:
        ! (Morrison et al, 2015, JAS, pg 315)
        gamm = 1.0
        if(mtime.ge.t1_uforce)THEN
          gamm = 1.0+(0.0-1.0)*(mtime-t1_uforce)/(t2_uforce-t1_uforce)
        endif
        if(myid.eq.0) print *,'  mtime,gamm = ',mtime,gamm
!$omp parallel do default(shared)  &
!$omp private(i,j,k,aiu)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          if( abs(xf(i)-xc_uforce).lt.xr_uforce .and. abs(zf(i,j,k)-zs(i,j)).lt.zr_uforce )then
            aiu = alpha_uforce*cos(0.5*pi*(xf(i)-xc_uforce)/xr_uforce)   &
                              *((cosh(2.5*(zf(i,j,k)-zs(i,j))/zr_uforce))**(-2))
            uten1(i,j,k)=uten1(i,j,k)+gamm*aiu
          endif
        enddo
        enddo
        enddo
      ENDIF
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.ge.1)then
        if(difforder.eq.2)then
          call diff2u(1,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                      dum1,dum2,dum3,dum4,uten1,ust,rho,rr,rf,divx,t11,t12,t13)
        endif
      endif

      if(dns.eq.1)then
        call diff2u(2,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                    dum1,dum2,dum3,dum4,uten1,ust,rho,rr,rf,divx,t11,t12,t13)
      endif
 
      if(iturb.ge.1)then
        call turbu(dt,xh,ruh,xf,rxf,arf1,arf2,uf,vh,mh,mf,rmf,rho,rf,  &
                   zs,gz,rgz,gzu,gzv,rds,sigma,rdsf,sigmaf,gxu,     &
                   dum1,dum2,dum3,dum4,dum5,dum6,ua,uten1,wa,t11,t12,t13,t22,kmv)
      endif

      if(ipbl.ge.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten1(i,j,k) = uten1(i,j,k) + 0.5*( upten(i-1,j,k)+ upten(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
      endif

!--------------------------------------------------------------------
!  V-equation
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
!!!        vten1(i,j,k)=0.
        vten1(i,j,k)=-rdalpha*0.5*(tauh(i,j-1,k)+tauh(i,j,k))*(va(i,j,k)-v0(i,j,k))
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.ge.1)then
        if(difforder.eq.2)then
          call diff2v(1,xh,arh1,arh2,uh,rxf,arf1,arf2,uf,vh,vf,mh,mf,  &
                      dum1,dum2,dum3,dum4,vten1,ust,rho,rr,rf,divx,t22,t12,t23)
        endif
      endif

      if(dns.eq.1)then
        call diff2v(2,xh,arh1,arh2,uh,rxf,arf1,arf2,uf,vh,vf,mh,mf,  &
                    dum1,dum2,dum3,dum4,vten1,ust,rho,rr,rf,divx,t22,t12,t23)
      endif
 
      if(iturb.ge.1)then
        call turbv(dt,xh,rxh,arh1,arh2,uh,xf,rvh,vf,mh,mf,rho,rr,rf,   &
                   zs,gz,rgz,gzu,gzv,rds,sigma,rdsf,sigmaf,gyv,  &
                   dum1,dum2,dum3,dum4,dum5,dum6,va,vten1,wa,t12,t22,t23,kmv)
      endif

      if(ipbl.ge.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten1(i,j,k) = vten1(i,j,k) + 0.5*( vpten(i,j-1,k)+ vpten(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
      endif
 
!--------------------------------------------------------------------
!  W-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k,xs)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
!!!        wten1(i,j,k)=0.0
        wten1(i,j,k)=-rdalpha*tauf(i,j,k)*wa(i,j,k)
!!!        ! forcing term from Nolan (2005, JAS):
!!!        xs = sqrt( ((zf(i,j,k)-3000.0)**2)/(2000.0**2) &
!!!                  +(xh(i)**2)/(1000.0**2) )
!!!        if( xs.lt.1.0 ) wten1(i,j,k)=wten1(i,j,k)+1.26*cos(0.5*pi*xs)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.ge.1)then
        if(difforder.eq.2)then
          call diff2w(1,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                      dum1,dum2,dum3,dum4,wten1,rho,rr,rf,divx,t33,t13,t23)
        endif
      endif

      if(dns.eq.1)then
        call diff2w(2,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                    dum1,dum2,dum3,dum4,wten1,rho,rr,rf,divx,t33,t13,t23)
      endif
 
      if(iturb.ge.1)then
        call turbw(dt,xh,rxh,arh1,arh2,uh,xf,vh,mh,mf,rho,rf,gz,rgzu,rgzv,rds,sigma,   &
                   dum1,dum2,dum3,dum4,dum5,dum6,wa,wten1,t13,t23,t33,t22,kmh)
      endif

!--------------------------------------------------------------------
!  Arrays for vimpl turbs:
!    NOTE:  do not change dum7,dum8 from here to RK loop

      if(iturb.ge.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum7(i,j,k) = khv(i,j,k  )*mf(i,j,k  )*rf(i,j,k  )*mh(i,j,k)*rr(i,j,k)
          dum8(i,j,k) = khv(i,j,k+1)*mf(i,j,k+1)*rf(i,j,k+1)*mh(i,j,k)*rr(i,j,k)
        enddo
        enddo
        enddo
      endif

!--------------------------------------------------------------------
!  THETA-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
!!!        thten1(i,j,k)=0.0
        thten1(i,j,k)=-rdalpha*taus(i,j,k)*tha(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.eq.1)then
        if(difforder.eq.2)then
          call diff2s(1,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                      dum1,dum2,dum3,dum4,tha,thten1,rho,rr,rf)
        endif
      endif

      !----- cvm (if needed) -----!

      IF( eqtset.eq.2 .and. imoist.eq.1 .and. (idiss.eq.1.or.rterm.eq.1) )THEN
        ! for energy-conserving moist thermodynamics:
        ! store cvm in dum1:
        ! store ql  in dum2:
        ! store qi  in dum3:
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
        DO k=1,nk
          do j=1,nj
          do i=1,ni
            dum2(i,j,k)=qa(i,j,k,nql1)
          enddo
          enddo
          do n=nql1+1,nql2
            do j=1,nj
            do i=1,ni
              dum2(i,j,k)=dum2(i,j,k)+qa(i,j,k,n)
            enddo
            enddo
          enddo
          IF(iice.eq.1)THEN
            do j=1,nj
            do i=1,ni
              dum3(i,j,k)=qa(i,j,k,nqs1)
            enddo
            enddo
            do n=nqs1+1,nqs2
              do j=1,nj
              do i=1,ni
                dum3(i,j,k)=dum3(i,j,k)+qa(i,j,k,n)
              enddo
              enddo
            enddo
          ELSE
            do j=1,nj
            do i=1,ni
              dum3(i,j,k)=0.0
            enddo
            enddo
          ENDIF
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=cv+cvv*qa(i,j,k,nqv)+cpl*dum2(i,j,k)+cpi*dum3(i,j,k)
          enddo
          enddo
        ENDDO
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
        DO k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=cv
          enddo
          enddo
        ENDDO
      ENDIF

      !----- store appropriate rho for budget calculations in dum2 -----!

      IF(axisymm.eq.1)THEN
       ! for axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum2(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
        enddo
        enddo
        enddo
      ELSE
       ! for Cartesian grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum2(i,j,k) = rho(i,j,k)
        enddo
        enddo
        enddo
      ENDIF

      !-------------------------------------------------------------

      !  budget calculations:
      if(dosfcflx.and.imoist.eq.1)then
        tem0 = dt*dx*dy*dz
!$omp parallel do default(shared)  &
!$omp private(i,j,k,delpi,delth,delqv,delt,n)
        do j=1,nj
        bud2(j) = 0.0d0
        do i=1,ni
          k = 1
          delth = rf0(i,j,1)*rr0(i,j,1)*rdz*mh(i,j,1)*thflux(i,j)
          delqv = rf0(i,j,1)*rr0(i,j,1)*rdz*mh(i,j,1)*qvflux(i,j)
          delpi = rddcv*(pi0(i,j,1)+ppi(i,j,1))*(           &
                                delqv/(eps+qa(i,j,1,nqv))   &
                               +delth/(th0(i,j,1)+tha(i,j,1))  )
          delt = (pi0(i,j,k)+ppi(i,j,k))*delth   &
                +(th0(i,j,k)+tha(i,j,k))*delpi
          bud2(j) = bud2(j) + dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*(        &
                  cv*delt                                                   &
                + cvv*qa(i,j,k,nqv)*delt                                    &
                + cvv*(pi0(i,j,k)+ppi(i,j,k))*(th0(i,j,k)+tha(i,j,k))*delqv &
                + g*zh(i,j,k)*delqv   )
          do n=nql1,nql2
            bud2(j) = bud2(j) + dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*cpl*qa(i,j,k,n)*delt
          enddo
          if(iice.eq.1)then
            do n=nqs1,nqs2
              bud2(j) = bud2(j) + dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*cpi*qa(i,j,k,n)*delt
            enddo
          endif
        enddo
        enddo
        do j=1,nj
          qbudget(9) = qbudget(9) + tem0*bud2(j)
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()
      endif

      !---- Dissipative heating term:

      IF(idiss.eq.1)THEN
        IF( output_dissheat.eq.1 .and. dowrite  )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            tdiag(i,j,k,td_diss) = thten1(i,j,k)
          enddo
          enddo
          enddo
        ENDIF
        ! note:  dissten array stores epsilon (dissipation rate) at w points
        if( bbc.eq.3 )then
          k1 = 2
        else
          k1 = 1
        endif
        if(imoist.eq.1.and.eqtset.eq.2)then
          ! moist, new equations:
!$omp parallel do default(shared)  &
!$omp private(i,j,k,epsd,dheat)
          do k=k1,nk
          do j=1,nj
          do i=1,ni
            epsd = 0.5*(dissten(i,j,k)+dissten(i,j,k+1))
            dheat=epsd/( cpdcv*dum1(i,j,k)*(pi0(i,j,k)+ppi(i,j,k)) )
            thten1(i,j,k)=thten1(i,j,k)+dheat
          enddo
          enddo
          enddo
          if( bbc.eq.3 )then
            k = 1
!$omp parallel do default(shared)  &
!$omp private(i,j,dz1,epsd,dheat)
            do j=1,nj
            do i=1,ni
              dz1 = zf(i,j,2)-zf(i,j,1)
              epsd = (ust(i,j)**3)*alog((dz1+znt(i,j))/znt(i,j))/(karman*dz1)
              dheat=epsd/( cpdcv*dum1(i,j,k)*(pi0(i,j,k)+ppi(i,j,k)) )
              thten1(i,j,k)=thten1(i,j,k)+dheat
            enddo
            enddo
          endif
        else
          ! traditional cloud-modeling equations (also dry equations):
!$omp parallel do default(shared)  &
!$omp private(i,j,k,epsd,dheat)
          do k=k1,nk
          do j=1,nj
          do i=1,ni
            epsd = 0.5*(dissten(i,j,k)+dissten(i,j,k+1))
            dheat=epsd/( cp*(pi0(i,j,k)+ppi(i,j,k)) )
            thten1(i,j,k)=thten1(i,j,k)+dheat
          enddo
          enddo
          enddo
          if( bbc.eq.3 )then
            k = 1
!$omp parallel do default(shared)  &
!$omp private(i,j,dz1,epsd,dheat)
            do j=1,nj
            do i=1,ni
              dz1 = zf(i,j,2)-zf(i,j,1)
              epsd = (ust(i,j)**3)*alog((dz1+znt(i,j))/znt(i,j))/(karman*dz1)
              dheat=epsd/( cp*(pi0(i,j,k)+ppi(i,j,k)) )
              thten1(i,j,k)=thten1(i,j,k)+dheat
            enddo
            enddo
          endif
        endif
        IF( output_dissheat.eq.1 .and. dowrite )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            tdiag(i,j,k,td_diss) = thten1(i,j,k)-tdiag(i,j,k,td_diss)
            if( abs(tdiag(i,j,k,td_diss)).lt.1.0e-14 ) tdiag(i,j,k,td_diss) = 0.0
          enddo
          enddo
          enddo
        ENDIF
      ENDIF

      !---- Rotunno-Emanuel "radiation" term
      !---- (currently capped at 2 K/day ... see RE87 p 546)

      IF(rterm.eq.1)THEN
        tem0 = dt*dx*dy*dz
!$omp parallel do default(shared)  &
!$omp private(i,j,k,thrad,prad)
        do k=1,nk
        bud(k)=0.0d0
        do j=1,nj
        do i=1,ni
          ! NOTE:  thrad is a POTENTIAL TEMPERATURE tendency
          thrad = -tha(i,j,k)/(12.0*3600.0)
          if( tha(i,j,k).gt. 1.0 ) thrad = -1.0/(12.0*3600.0)
          if( tha(i,j,k).lt.-1.0 ) thrad =  1.0/(12.0*3600.0)
          thten1(i,j,k)=thten1(i,j,k)+thrad
          ! associated pressure tendency:
          prad = (pi0(i,j,k)+ppi(i,j,k))*rddcv*thrad/(th0(i,j,k)+tha(i,j,k))
          ! budget:
          bud(k) = bud(k) + dum1(i,j,k)*dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*( &
                            thrad*(pi0(i,j,k)+ppi(i,j,k))    &
                           + prad*(th0(i,j,k)+tha(i,j,k)) )
        enddo
        enddo
        enddo
        do k=1,nk
          qbudget(10) = qbudget(10) + tem0*bud(k)
        enddo
      ENDIF
      if(timestats.ge.1) time_misc=time_misc+mytime()

      if( (dns.eq.1).or.(radopt.ge.1) )then
        ! use thadv to store total potential temperature:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          thadv(i,j,k)=th0(i,j,k)+tha(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(dns.eq.1)then
        call diff2s(2,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                    dum1,dum2,dum3,dum4,thadv,thten1,rho,rr,rf)
      endif

      IF( radopt.ge.1 )THEN
        ! tendency from radiation scheme:
        rdt = 1.0/dt
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tnew,pnew,thnew)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ! cm1r17:  swten and lwten now store TEMPERATURE tendencies:
          ! NOTE:  thadv stores theta (see above)
          tnew = thadv(i,j,k)*(pi0(i,j,k)+ppi(i,j,k)) + dt*(swten(i,j,k)+lwten(i,j,k))
          pnew = rho(i,j,k)*(rd+rv*qa(i,j,k,nqv))*tnew
          thnew = tnew/((pnew*rp00)**rovcp)
          thten1(i,j,k) = thten1(i,j,k) + (thnew-thadv(i,j,k))*rdt
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_rad=time_rad+mytime()
      ENDIF

      IF( ipbl.ge.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          thten1(i,j,k) = thten1(i,j,k) + thpten(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
      ENDIF

      if(iturb.ge.1)then
        ! cm1r18: subtract th0r from theta (as in advection scheme)
        !         (reduces roundoff error)
        IF(.not.terrain_flag)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
          do k=1,nk
          tem = th0(1,1,k)-th0r
          do j=0,nj+1
          do i=0,ni+1
            thadv(i,j,k)=tem+tha(i,j,k)
          enddo
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            thadv(i,j,k)=(th0(i,j,k)-th0r)+tha(i,j,k)
          enddo
          enddo
          enddo
        ENDIF
        call turbs(1,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,thflux,   &
                   rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                   dum1,dum2,dum3,dum4,dum5,sten,rho,rr,rf,thadv,thten1,khh,khv,dum7,dum8)
      endif

!-------------------------------------------------------------------
!  Passive Tracers

      if(iptra.eq.1)then
        do n=1,npt
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ptten(i,j,k,n)=0.0
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()
          if(idiff.eq.1)then
            if(difforder.eq.2)then
              call diff2s(1,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                          dum1,dum2,dum3,dum4,pta(ib,jb,kb,n),ptten(ib,jb,kb,n),rho,rr,rf)
            endif
          endif
          if(iturb.ge.1)then
            call turbs(0,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,qvflux,   &
                       rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                       dum1,dum2,dum3,dum4,dum5,sten,rho,rr,rf,pta(ib,jb,kb,n),ptten(ib,jb,kb,n),khh,khv,dum7,dum8)
          endif
        enddo
      endif

!-------------------------------------------------------------------
!  Moisture

      if(imoist.eq.1)then
        DO n=1,numq
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qten(i,j,k,n)=0.0
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()
!---------------------------
          ! qv:
          if(n.eq.nqv)then
            if(idiff.eq.1)then
              if(difforder.eq.2)then
                call diff2s(1,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                            dum1,dum2,dum3,dum4,qa(ib,jb,kb,n),qten(ib,jb,kb,n),rho,rr,rf)
              endif
            endif
            if(iturb.ge.1)then
              call turbs(1,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,qvflux,   &
                         rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                         dum1,dum2,dum3,dum4,dum5,sten,rho,rr,rf,qa(ib,jb,kb,n),qten(ib,jb,kb,n),khh,khv,dum7,dum8)
            endif
            if(ipbl.ge.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                qten(i,j,k,nqv) = qten(i,j,k,nqv) + qvpten(i,j,k)
              enddo
              enddo
              enddo
              if(timestats.ge.1) time_pbl=time_pbl+mytime()
            endif
!---------------------------
          ! not qv:
          else
            if(idiff.eq.1)then
              if(difforder.eq.2)then
                call diff2s(1,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,mh,mf,  &
                            dum1,dum2,dum3,dum4,qa(ib,jb,kb,n),qten(ib,jb,kb,n),rho,rr,rf)
              endif
            endif
            if(iturb.ge.1)then
              call turbs(0,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,qvflux,   &
                         rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                         dum1,dum2,dum3,dum4,dum5,sten,rho,rr,rf,qa(ib,jb,kb,n),qten(ib,jb,kb,n),khh,khv,dum7,dum8)
            endif
          endif
!---------------------------
        ENDDO
        IF(ipbl.ge.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if(nqc.ne.0)   &
            qten(i,j,k,nqc) = qten(i,j,k,nqc) + qcpten(i,j,k)
            if(nqi.ne.0)   &
            qten(i,j,k,nqi) = qten(i,j,k,nqi) + qipten(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_pbl=time_pbl+mytime()
        ENDIF
      endif

!-------------------------------------------------------------------
!    NOTE:  now ok to change dum7,dum8
!-------------------------------------------------------------------
!  contribution to pressure tendency from potential temperature:
!  (for mass conservation)
!  plus, some other stuff:

      IF(eqtset.eq.1)THEN
        ! traditional cloud modeling:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k)=0.0
        enddo
        enddo
        enddo
      ELSE
        ! mass-conserving pressure eqt:  different sections for moist/dry cases:
        rdt = 1.0/dt
        tem = 0.0001*tsmall
        IF(imoist.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tnew,pnew,pinew,thnew,qvnew)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            !-----
            ! cm1r17:
            ! note:  nothing in pre-RK section should modify rho
            IF( abs(dt*thten1(i,j,k)).gt.tem .or.  &
                abs(dt*qten(i,j,k,nqv)).gt.qsmall )THEN
              thnew = tha(i,j,k)+dt*thten1(i,j,k)
              qvnew = qa(i,j,k,nqv)+dt*qten(i,j,k,nqv)
              pinew = (rho(i,j,k)*(th0(i,j,k)+thnew)*(rd+rv*qvnew)*rp00)**rddcv - pi0(i,j,k)
              ppten(i,j,k) = (pinew-ppi(i,j,k))*rdt
            ELSE
              ppten(i,j,k) = 0.0
            ENDIF
            !-----
            ! use diabatic tendencies from last timestep as a good estimate:
            ppten(i,j,k)=ppten(i,j,k)+qpten(i,j,k)
            thten1(i,j,k)=thten1(i,j,k)+qtten(i,j,k)
            qten(i,j,k,nqv)=qten(i,j,k,nqv)+qvten(i,j,k)
            qten(i,j,k,nqc)=qten(i,j,k,nqc)+qcten(i,j,k)
          enddo
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tnew,pnew,pinew,thnew,qvnew)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            !-----
            ! cm1r17:
            ! note:  nothing in pre-RK section should modify rho
            IF( abs(dt*thten1(i,j,k)).gt.tem )THEN
              thnew = tha(i,j,k)+dt*thten1(i,j,k)
              pinew = (rho(i,j,k)*(th0(i,j,k)+thnew)*rd*rp00)**rddcv - pi0(i,j,k)
              ppten(i,j,k) = (pinew-ppi(i,j,k))*rdt
            ELSE
              ppten(i,j,k)=0.0
            ENDIF
            !-----
          enddo
          enddo
          enddo
        ENDIF  ! endif for moist/dry
      ENDIF    ! endif for eqtset 1/2

        if(timestats.ge.1) time_integ=time_integ+mytime()


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   Begin RK section   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      ! time at end of full timestep:
      rtime=sngl(mtime+dt)

!--------------------------------------------------------------------
! RK3 begin

      DO NRK=1,3

        dttmp=dt/float(4-nrk)

!--------------------------------------------------------------------
        IF(nrk.ge.2)THEN
#ifdef MPI
          call comm_3u_end(u3d,uw31,uw32,ue31,ue32,   &
                               us31,us32,un31,un32,reqs_u)
          call comm_3v_end(v3d,vw31,vw32,ve31,ve32,   &
                               vs31,vs32,vn31,vn32,reqs_v)
          call comm_3w_end(w3d,ww31,ww32,we31,we32,   &
                               ws31,ws32,wn31,wn32,reqs_w)
#endif
          if(terrain_flag)then
            call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)
            call bc2d(w3d(ib,jb,1))
          endif
        ENDIF
!--------------------------------------------------------------------
!  Get rru,rrv,rrw,divx
!  (NOTE:  do not change these arrays until after RK steps)

    IF(.not.terrain_flag)THEN
      ! without terrain:

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      DO k=1,nk
        do j=0,nj+1
        do i=0,ni+2
          rru(i,j,k)=rho0(1,1,k)*u3d(i,j,k)
        enddo
        enddo
        do j=0,nj+2
        do i=0,ni+1
          rrv(i,j,k)=rho0(1,1,k)*v3d(i,j,k)
        enddo
        enddo
        IF(k.eq.1)THEN
          do j=0,nj+1
          do i=0,ni+1
            rrw(i,j,   1) = 0.0
            rrw(i,j,nk+1) = 0.0
          enddo
          enddo
        ELSE
          do j=0,nj+1
          do i=0,ni+1
            rrw(i,j,k)=rf0(1,1,k)*w3d(i,j,k)
          enddo
          enddo
        ENDIF
      ENDDO

    ELSE
      ! with terrain:

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      DO k=1,nk
        do j=0,nj+1
        do i=0,ni+2
          rru(i,j,k)=0.5*(rho0(i-1,j,k)+rho0(i,j,k))*u3d(i,j,k)*rgzu(i,j)
        enddo
        enddo
        do j=0,nj+2
        do i=0,ni+1
          rrv(i,j,k)=0.5*(rho0(i,j-1,k)+rho0(i,j,k))*v3d(i,j,k)*rgzv(i,j)
        enddo
        enddo
      ENDDO

!$omp parallel do default(shared)  &
!$omp private(i,j,k,r1,r2)
      DO k=1,nk
        IF(k.eq.1)THEN
          do j=0,nj+1
          do i=0,ni+1
            rrw(i,j,   1) = 0.0
            rrw(i,j,nk+1) = 0.0
          enddo
          enddo
        ELSE
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do j=0,nj+1
          do i=0,ni+1
            rrw(i,j,k)=rf0(i,j,k)*w3d(i,j,k)                                  &
                      +0.5*( ( r2*(rru(i,j,k  )+rru(i+1,j,k  ))               &
                              +r1*(rru(i,j,k-1)+rru(i+1,j,k-1)) )*dzdx(i,j)   &
                            +( r2*(rrv(i,j,k  )+rrv(i,j+1,k  ))               &
                              +r1*(rrv(i,j,k-1)+rrv(i,j+1,k-1)) )*dzdy(i,j)   &
                           )*(sigmaf(k)-zt)*gz(i,j)*rzt
          enddo
          enddo
        ENDIF
      ENDDO

    ENDIF
    if(timestats.ge.1) time_advs=time_advs+mytime()

        IF(terrain_flag)THEN
          call bcw(rrw,0)
#ifdef MPI
          call comm_1w_start(rrw,ww1,ww2,we1,we2,   &
                                 ws1,ws2,wn1,wn2,reqs_w)
          call comm_1w_end(rrw,ww1,ww2,we1,we2,   &
                               ws1,ws2,wn1,wn2,reqs_w)
#endif
        ENDIF

      IF(.not.terrain_flag)THEN
        IF(axisymm.eq.0)THEN
          ! Cartesian without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)        &
                       +(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)        &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(1,1,k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo
          enddo
        ELSE
          ! axisymmetric:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(arh2(i)*rru(i+1,j,k)-arh1(i)*rru(i,j,k))*rdx*uh(i)   &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(1,1,k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo
          enddo
        ENDIF
      ELSE
          ! Cartesian with terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)        &
                       +(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)        &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdsf(k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo
          enddo
      ENDIF
      if(timestats.ge.1) time_divx=time_divx+mytime()

!--------------------------------------------------------------------
#ifdef MPI
        IF(nrk.ge.2)THEN
          call comm_1s_end(rho,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
          call getcorner(rho,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
          call bcs2(rho)
        ENDIF
#endif
!--------------------------------------------------------------------
!  U-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten(i,j,k)=uten1(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()


        ! Coriolis acceleration:
        if(icor.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
          IF(axisymm.eq.0)THEN
            ! for Cartesian grid:
            if(pertcor.eq.1)then
              do j=1,nj+1
              do i=0,ni+1
                dum1(i,j,k)=v3d(i,j,k)-v0(i,j,k)
              enddo
              enddo
            else
              do j=1,nj+1
              do i=0,ni+1
                dum1(i,j,k)=v3d(i,j,k)
              enddo
              enddo
            endif
            do j=1,nj
            do i=1,ni+1
              uten(i,j,k)=uten(i,j,k)+fcor*             &
               0.25*( (dum1(i  ,j,k)+dum1(i  ,j+1,k))   &
                     +(dum1(i-1,j,k)+dum1(i-1,j+1,k)) )
            enddo
            enddo
          ELSE
            ! for axisymmetric grid:
            do j=1,nj
            do i=2,ni+1
              uten(i,j,k)=uten(i,j,k)+fcor*0.5*(v3d(i,j,k)+v3d(i-1,j,k))
            enddo
            enddo
          ENDIF
        enddo
        if(timestats.ge.1) time_cor=time_cor+mytime()
        endif


        ! inertial term for axisymmetric grid:
        if(axisymm.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
            do i=1,ni+1
              dum1(i,j,k)=(v3d(i,j,k)**2)*rxh(i)
            enddo
            if(ebc.eq.3)then
              dum1(ni+1,j,k) = -dum1(ni,j,k)
            endif
            do i=2,ni+1
              uten(i,j,k)=uten(i,j,k)+0.5*(dum1(i-1,j,k)+dum1(i,j,k))
            enddo
          enddo
          enddo
        endif


          call advu(nrk,arh1,arh2,xf,rxf,arf1,arf2,uf,vh,gz,rgz,gzu,mh,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                     rru,u3d,uten,rrv,rrw,rdsf,c1,c2,rho,dttmp)

!--------------------------------------------------------------------
!  V-equation
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten(i,j,k)=vten1(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()


        ! Coriolis acceleration:
        ! note for axisymmetric grid: since cm1r18, this term is included in advvaxi
        if( icor.eq.1 .and. axisymm.eq.0 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
            ! for Cartesian grid:
            if(pertcor.eq.1)then
              do j=0,nj+1
              do i=1,ni+1
                dum1(i,j,k)=u3d(i,j,k)-u0(i,j,k)
              enddo
              enddo
            else
              do j=0,nj+1
              do i=1,ni+1
                dum1(i,j,k)=u3d(i,j,k)
              enddo
              enddo
            endif
            do j=1,nj+1
            do i=1,ni
              vten(i,j,k)=vten(i,j,k)-fcor*             &
               0.25*( (dum1(i,j  ,k)+dum1(i+1,j  ,k))   &
                     +(dum1(i,j-1,k)+dum1(i+1,j-1,k)) )
            enddo
            enddo
        enddo
        if(timestats.ge.1) time_cor=time_cor+mytime()
        endif


!!!        ! since cm1r17, this term is included in advvaxi
!!!        if(axisymm.eq.1)then
!!!          ! for axisymmetric grid:
!!!
!!!!$omp parallel do default(shared)  &
!!!!$omp private(i,j,k)
!!!          do k=1,nk
!!!          do j=1,nj
!!!          do i=1,ni
!!!            vten(i,j,k)=vten(i,j,k)-(v3d(i,j,k)*rxh(i))*0.5*(xf(i)*u3d(i,j,k)+xf(i+1)*u3d(i+1,j,k))*rxh(i)
!!!          enddo
!!!          enddo
!!!          enddo
!!!
!!!        endif


          call advv(nrk,xh,rxh,arh1,arh2,uh,xf,vf,gz,rgz,gzv,mh,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                     rru,rrv,v3d,vten,rrw,rdsf,c1,c2,rho,dttmp)


!--------------------------------------------------------------------
!  finish comms for q/theta:
#ifdef MPI
        IF(nrk.ge.2)THEN
          call comm_3r_end(th3d,pp3d,rw31,rw32,re31,re32,   &
                                     rs31,rs32,rn31,rn32,reqs_p)
          if(imoist.eq.1)then
            call comm_3q_end(q3d,qw31,qw32,qe31,qe32,   &
                                 qs31,qs32,qn31,qn32,reqs_q(1,1))
          endif
        ENDIF
#endif
!--------------------------------------------------------------------
!  Calculate misc. variables
!
!    These arrays store variables that are used later in the
!    SOUND subroutine.  Do not modify t11 or t22 until after sound!
!
!    dum1 = vapor
!    dum2 = all liquid
!    dum3 = all solid
!    t11 = theta_rho
!    t22 = ppterm

        IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,cpm,cvm)
          do k=1,nk

            do j=1,nj
            do i=1,ni
              dum2(i,j,k)=q3d(i,j,k,nql1)
            enddo
            enddo
            do n=nql1+1,nql2
              do j=1,nj
              do i=1,ni
                dum2(i,j,k)=dum2(i,j,k)+q3d(i,j,k,n)
              enddo
              enddo
            enddo
            IF(iice.eq.1)THEN
              do j=1,nj
              do i=1,ni
                dum3(i,j,k)=q3d(i,j,k,nqs1)
              enddo
              enddo
              do n=nqs1+1,nqs2
                do j=1,nj
                do i=1,ni
                  dum3(i,j,k)=dum3(i,j,k)+q3d(i,j,k,n)
                enddo
                enddo
              enddo
            ELSE
              do j=1,nj
              do i=1,ni
                dum3(i,j,k)=0.0
              enddo
              enddo
            ENDIF
            ! save qv,ql,qi for buoyancy calculation:
          IF(eqtset.eq.2)THEN
            do j=1,nj
            do i=1,ni
              t12(i,j,k)=max(q3d(i,j,k,nqv),0.0)
              t13(i,j,k)=max(0.0,dum2(i,j,k)+dum3(i,j,k))
              t11(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(1.0+reps*t12(i,j,k))     &
                         /(1.0+t12(i,j,k)+t13(i,j,k))
      ! terms in theta and pi equations for proper mass/energy conservation
      ! Reference:  Bryan and Fritsch (2002, MWR), Bryan and Morrison (2012, MWR)
              dum4(i,j,k)=cpl*max(0.0,dum2(i,j,k))+cpi*max(0.0,dum3(i,j,k))
              cpm=cp+cpv*t12(i,j,k)+dum4(i,j,k)
              cvm=1.0/(cv+cvv*t12(i,j,k)+dum4(i,j,k))
              thterm(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*( rd+rv*t12(i,j,k)-rovcp*cpm )*cvm
              t22(i,j,k)=(pi0(i,j,k)+pp3d(i,j,k))*rovcp*cpm*cvm
            enddo
            enddo
          ELSEIF(eqtset.eq.1)THEN
            do j=1,nj
            do i=1,ni
              t12(i,j,k)=max(q3d(i,j,k,nqv),0.0)
              t13(i,j,k)=max(0.0,dum2(i,j,k)+dum3(i,j,k))
              t11(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(1.0+reps*t12(i,j,k))     &
                         /(1.0+t12(i,j,k)+t13(i,j,k))
              t22(i,j,k)=(pi0(i,j,k)+pp3d(i,j,k))*rddcv
            enddo
            enddo
          ENDIF

          enddo

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            t11(i,j,k)=th0(i,j,k)+th3d(i,j,k)
            t22(i,j,k)=(pi0(i,j,k)+pp3d(i,j,k))*rddcv
          enddo
          enddo
          enddo

        ENDIF

        if(timestats.ge.1) time_buoyan=time_buoyan+mytime()

!--------------------------------------------------------------------
        call bcs(t11)
#ifdef MPI
        call comm_1s_start(t11,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
#endif
!--------------------------------------------------------------------
!  W-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=wten1(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()
 
        if( imoist.eq.1 )then
          ! buoyancy (moisture terms):
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do j=1,nj
            do k=1,nk
            do i=1,ni
              dum2(i,j,k) = repsm1*(t12(i,j,k)-qv0(i,j,k)) - (t13(i,j,k)-qc0(i,j,k)-qi0(i,j,k))
            enddo
            enddo
            do k=2,nk
            do i=1,ni
              wten(i,j,k)=wten(i,j,k)+g*(c1(i,j,k)*dum2(i,j,k-1)+c2(i,j,k)*dum2(i,j,k))
            enddo
            enddo
          enddo
          if(timestats.ge.1) time_buoyan=time_buoyan+mytime()
        endif

        if(psolver.eq.1.or.psolver.eq.4.or.psolver.eq.5)then
          ! buoyancy for non-time-split solvers
          ! (i.e.,truly-compressible/anelastic/incompressible solvers:)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do j=1,nj
            do k=1,nk
            do i=1,ni
              dum2(i,j,k) = th3d(i,j,k)*rth0(i,j,k)
            enddo
            enddo
            do k=2,nk
            do i=1,ni
              wten(i,j,k)=wten(i,j,k)+g*(c1(i,j,k)*dum2(i,j,k-1)+c2(i,j,k)*dum2(i,j,k))
            enddo
            enddo
          enddo
          if(timestats.ge.1) time_buoyan=time_buoyan+mytime()
        endif

          call advw(nrk,xh,rxh,arh1,arh2,uh,xf,vh,gz,rgz,mf,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                     rru,rrv,rrw,w3d,wten,rds,c1,c2,rho,dttmp)

!--------------------------------------------------------------------
!  THETA-equation

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          thten(i,j,k)=thten1(i,j,k)
        enddo
        enddo
        IF(.not.terrain_flag)THEN
          tem = th0(1,1,k)-th0r
          do j=jb,je
          do i=ib,ie
            thadv(i,j,k)=tem+th3d(i,j,k)
          enddo
          enddo
        ELSE
          do j=jb,je
          do i=ib,ie
            thadv(i,j,k)=(th0(i,j,k)-th0r)+th3d(i,j,k)
          enddo
          enddo
        ENDIF
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()


        weps = 10.0*epsilon
        diffit = 0
        if( idiff.eq.1 .and. difforder.eq.6 ) diffit = 1
        call advs(nrk,1,0,bfoo,xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,gz,rgz,mh,rmh, &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,dum5,dum6,   &
                   rru,rrv,rrw,tha,thadv,thten,0,dttmp,weps,           &
                   flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,rdsf,c1,c2,rho,rr,diffit)

!--------------------------------------------------------------------
!  Pressure equation

      IF( psolver.eq.1 .or. psolver.eq.2 .or. psolver.eq.3 )THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          sten(i,j,k)=ppten(i,j,k)
        enddo
        enddo
        IF(.not.terrain_flag)THEN
          tem = pi0(1,1,k)
          do j=jb,je
          do i=ib,ie
            piadv(i,j,k)=tem+pp3d(i,j,k)
          enddo
          enddo
        ELSE
          do j=jb,je
          do i=ib,ie
            piadv(i,j,k)=pi0(i,j,k)+pp3d(i,j,k)
          enddo
          enddo
        ENDIF
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()


          weps = epsilon
          diffit = 0
          call advs(nrk,0,0,bfoo,xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,gz,rgz,mh,rmh, &
                     rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,dum5,dum6,   &
                     rru,rrv,rrw,ppi,piadv,sten,0,dttmp,weps,            &
                     flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,rdsf,c1,c2,rho,rr,diffit)

      ENDIF

!--------------------------------------------------------------------
#ifdef MPI
        call comm_1s_end(  t11,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
#endif
!--------------------------------------------------------------------
!  call sound

        get_time_avg = .false.
        IF( psolver.eq.2 .or. psolver.eq.3 .or. psolver.eq.6 )THEN
          IF( imoist.eq.1 .and. numq.ge.1    ) get_time_avg = .true.
          IF( iptra.eq.1 .and. npt.ge.1      ) get_time_avg = .true.
          IF( iturb.eq.1                     ) get_time_avg = .true.
          IF( iprcl.eq.1                     ) get_time_avg = .true.
        ENDIF


        IF(psolver.eq.1)THEN

          call   soundns(xh,rxh,arh1,arh2,uh,xf,uf,yh,vh,yf,vf,           &
                         zh,mh,c1,c2,mf,pi0,thv0,rr0,rf0,                 &
                         rds,sigma,rdsf,sigmaf,                           &
                         zs,gz,rgz,gzu,rgzu,gzv,rgzv,                     &
                         dzdx,dzdy,gx,gxu,gy,gyv,                         &
                         radbcw,radbce,radbcs,radbcn,                     &
                         dum1,dum2,dum3,dum4,                             &
                         u0,ua,u3d,uten,                                  &
                         v0,va,v3d,vten,                                  &
                         wa,w3d,wten,                                     &
                         ppi,pp3d, sten,t11,   t22,dttmp,nrk,rtime,       &
                         th0,tha,th3d,thten,thterm)

        ELSEIF(psolver.eq.2)THEN

          ! NOTE:  rr,rf,prs are used as dummy arrays by sounde

          call   sounde(dt,xh,arh1,arh2,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                        rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,mf,         &
                        pi0,rho0,rr0,rf0,rrf0,th0,rth0,zs,                &
                        gz,rgz,gzu,rgzu,gzv,rgzv,                         &
                        dzdx,dzdy,gx,gxu,gy,gyv,                          &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,dum4,dum5,dum6,                    &
                        dum7,dum8,rr ,rf ,prs,t12,t13,t23,t33,            &
                        u0,rru,us,ua,u3d,uten,                            &
                        v0,rrv,vs,va,v3d,vten,                            &
                        rrw,ws,wa,w3d,wten,                               &
                        ppi,pp3d,piadv,sten ,ppx,                         &
                        tha,th3d,thadv,thten,thterm,                      &
                        t11,t22   ,nrk,dttmp,rtime,get_time_avg,          &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)

        ELSEIF(psolver.eq.3)THEN

          ! NOTE:  rr,rf,prs are used as dummy arrays by sound

          call   sound( dt,xh,arh1,arh2,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                        rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,mf,         &
                        pi0,rho0,rr0,rf0,rrf0,th0,rth0,zs,                &
                        gz,rgz,gzu,rgzu,gzv,rgzv,                         &
                        dzdx,dzdy,gx,gxu,gy,gyv,                          &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,dum4,dum5,dum6,                    &
                        dum7,dum8,rr ,rf ,prs,t12,t13,t23,t33,            &
                        u0,rru,us,ua,u3d,uten,                            &
                        v0,rrv,vs,va,v3d,vten,                            &
                        rrw,ws,wa,w3d,wten,                               &
                        ppi,pp3d,piadv,sten ,ppx,                         &
                        tha,th3d,thadv,thten,thterm,                      &
                        t11,t22   ,nrk,dttmp,rtime,get_time_avg,          &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)

        ELSEIF(psolver.eq.4.or.psolver.eq.5)THEN
          ! anelastic/incompressible solver:

          call   anelp(xh,uh,xf,uf,yh,vh,yf,vf,                     &
                       zh,mh,rmh,mf,rmf,pi0,thv0,rho0,prs0,rf0,     &
                       radbcw,radbce,radbcs,radbcn,dum1,divx,       &
                       u0,us,ua,u3d,uten,                           &
                       v0,vs,va,v3d,vten,                           &
                       ws,wa,w3d,wten,                              &
                       ppi,pp3d,tha,th3d,thten,t11,cfb,cfa,cfc,     &
                       ad1,ad2,pdt,deft,rhs,trans,dttmp,nrk,rtime)

        ELSEIF(psolver.eq.6)THEN

          ! NOTE:  rr,rf,prs are used as dummy arrays

          call   soundcb(dt,xh,arh1,arh2,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,    &
                        rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,mf,         &
                        pi0,rho0,rr0,rf0,rrf0,th0,rth0,zs,                &
                        gz,rgz,gzu,rgzu,gzv,rgzv,                         &
                        dzdx,dzdy,gx,gxu,gy,gyv,                          &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,dum4,dum5,dum6,                    &
                        dum7,dum8,rr ,rf ,prs,t12,t13,t23,t33,            &
                        u0,rru,us,ua,u3d,uten,                            &
                        v0,rrv,vs,va,v3d,vten,                            &
                        rrw,ws,wa,w3d,wten,                               &
                        ppi,pp3d,piadv,sten ,ppx,                         &
                        tha,th3d,thadv,thten,thterm,                      &
                        t11,t22   ,nrk,dttmp,rtime,get_time_avg,          &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)

        ENDIF


!--------------------------------------------------------------------
!  re-compute divx if using time-averaged velocities:

    IF( get_time_avg )THEN
      IF(.not.terrain_flag)THEN
        IF(axisymm.eq.0)THEN
          ! Cartesian without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            divx(i,j,k)=(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)        &
                       +(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)        &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(1,1,k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo
          enddo
        ELSE
          ! axisymmetric:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            divx(i,j,k)=(arh2(i)*rru(i+1,j,k)-arh1(i)*rru(i,j,k))*rdx*uh(i)   &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(1,1,k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo
          enddo
        ENDIF
      ELSE
          ! Cartesian with terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            divx(i,j,k)=(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)        &
                       +(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)        &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdsf(k)
            if(abs(divx(i,j,k)).lt.smeps) divx(i,j,k)=0.0
          enddo
          enddo
          enddo
      ENDIF
      if(timestats.ge.1) time_divx=time_divx+mytime()
    ENDIF

!--------------------------------------------------------------------
!  Update v for axisymmetric model simulations:

        IF(axisymm.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()

          call bcv(v3d)

        ENDIF

!--------------------------------------------------------------------

        IF( nrk.eq.3 )THEN
          call calccflquick(dt,uh,vh,mh,u3d,v3d,w3d)
        ENDIF

!--------------------------------------------------------------------
!  radbc

        if(irbc.eq.4)then

          if(ibw.eq.1 .or. ibe.eq.1)then
            call radbcew4(ruf,radbcw,radbce,ua,u3d,dttmp)
          endif

          if(ibs.eq.1 .or. ibn.eq.1)then
            call radbcns4(rvf,radbcs,radbcn,va,v3d,dttmp)
          endif

        endif

!--------------------------------------------------------------------
!  Moisture:

  IF(imoist.eq.1)THEN

    DO n=1,numq

      ! t33 = dummy

      bflag=0
      if(stat_qsrc.eq.1 .and. nrk.eq.3) bflag=1

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=qten(i,j,k,n)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()

      if(nrk.eq.3)then
        pdef = 1
      else
        pdef = 0
      endif


      ! Note: epsilon = 1.0e-18
      weps = 0.01*epsilon
      IF( idm.eq.1 .and. n.ge.nnc1 .and. n .le. nnc2 ) weps = 1.0e5*epsilon
      IF( idmplus.eq.1 .and. n.ge.nzl1 .and. n .le. nzl2 ) weps = 1.d-30/zscale
      diffit = 0
      if( idiff.eq.1 .and. difforder.eq.6 ) diffit = 1
      call advs(nrk,1,bflag,bsq(n),xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,gz,rgz,mh,rmh,    &
                 rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,dum5,dum6,   &
                 rru,rrv,rrw,qa(ib,jb,kb,n),q3d(ib,jb,kb,n),sten,pdef,dttmp,weps, &
                 flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,rdsf,c1,c2,rho,rr,diffit)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        q3d(i,j,k,n)=qa(i,j,k,n)+dttmp*sten(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

      IF(nrk.lt.3)THEN
        call bcs(q3d(ib,jb,kb,n))
      ENDIF

    ENDDO   ! enddo for n loop

  ENDIF    ! endif for imoist=1

!--------------------------------------------------------------------
!  Get pressure
!  Get density

    pscheck:  IF(psolver.eq.4.or.psolver.eq.5.or.psolver.eq.6)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        prs(i,j,k)=prs0(i,j,k)
        rho(i,j,k)=rho0(i,j,k)
        rr(i,j,k)=rr0(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_prsrho=time_prsrho+mytime()

    ELSE

      IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk

          IF(nrk.eq.3.and.eqtset.eq.2)THEN
          do j=1,nj
          do i=1,ni
            ! subtract-off estimated diabatic terms used during RK steps:
            pp3d(i,j,k)=pp3d(i,j,k)-dt*qpten(i,j,k)
            th3d(i,j,k)=th3d(i,j,k)-dt*qtten(i,j,k)
            q3d(i,j,k,nqv)=q3d(i,j,k,nqv)-dt*qvten(i,j,k)
            q3d(i,j,k,nqc)=q3d(i,j,k,nqc)-dt*qcten(i,j,k)
            ! save values before calculating microphysics:
            qpten(i,j,k)=pp3d(i,j,k)
            qtten(i,j,k)=th3d(i,j,k)
            qvten(i,j,k)=q3d(i,j,k,nqv)
            qcten(i,j,k)=q3d(i,j,k,nqc)
          enddo
          enddo
          ENDIF

          do j=1,nj
          do i=1,ni
            prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
            rho(i,j,k)=prs(i,j,k)                         &
               /( (th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))     &
                 *(rd+max(0.0,q3d(i,j,k,nqv))*rv) )
            rr(i,j,k) = 1.0/rho(i,j,k)
          enddo
          enddo

        enddo

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
          rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k)))
          rr(i,j,k) = 1.0/rho(i,j,k)
        enddo
        enddo
        enddo

      ENDIF


      !-----------------------------------------------
      pmod:  IF( apmasscon.eq.1 .and. nrk.eq.3 )THEN
        ! cm1r18:  adjust average pressure perturbation to ensure 
        !          conservation of total dry-air mass

        dumk1 = 0.0
        dumk2 = 0.0

        IF( axisymm.eq.0 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dumk1(k) = dumk1(k) + rho(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
            dumk2(k) = dumk2(k) + (pi0(i,j,k)+pp3d(i,j,k))
          enddo
          enddo
          enddo
        ELSEIF( axisymm.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dumk1(k) = dumk1(k) + rho(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)
            dumk2(k) = dumk2(k) + (pi0(i,j,k)+pp3d(i,j,k))
          enddo
          enddo
          enddo
        ENDIF

        mass2 = 0.0
        p2 = 0.0

        do k=1,nk
          mass2 = mass2 + dumk1(k) 
          p2 = p2 + dumk2(k) 
        enddo

#ifdef MPI
        p0=0.0d0
        call MPI_ALLREDUCE(mass2,p0,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        mass2 = p0*(dx*dy*dz)
        !---
        p0=0.0d0
        call MPI_ALLREDUCE(p2,p0,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        p2 = p0/dble(nx*ny*nz)
#else
        mass2 = mass2*(dx*dy*dz)
        p2 = p2/dble(nx*ny*nz)
#endif

        tem = ( (mass1/mass2)**(dble(rd)/dble(cv)) - 1.0d0 )*p2

        IF( imoist.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            pp3d(i,j,k) = pp3d(i,j,k) + tem
            prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
            rho(i,j,k)=prs(i,j,k)                         &
               /( (th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))     &
                 *(rd+max(0.0,q3d(i,j,k,nqv))*rv) )
            rr(i,j,k) = 1.0/rho(i,j,k)
          enddo
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            pp3d(i,j,k) = pp3d(i,j,k) + tem
            prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
            rho(i,j,k)=prs(i,j,k)   &
               /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k)))
            rr(i,j,k) = 1.0/rho(i,j,k)
          enddo
          enddo
          enddo
        ENDIF

      ENDIF  pmod
      !-----------------------------------------------

      if(timestats.ge.1) time_prsrho=time_prsrho+mytime()

    ENDIF  pscheck

      call bcs(rho)

!--------------------------------------------------------------------
#ifdef MPI
      call comm_3u_start(u3d,uw31,uw32,ue31,ue32,   &
                             us31,us32,un31,un32,reqs_u)
      call comm_3v_start(v3d,vw31,vw32,ve31,ve32,   &
                             vs31,vs32,vn31,vn32,reqs_v)
      call comm_3w_start(w3d,ww31,ww32,we31,we32,   &
                             ws31,ws32,wn31,wn32,reqs_w)
      call comm_1s_start(rho,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
      if(nrk.lt.3)then
        call comm_3r_start(th3d,pp3d,rw31,rw32,re31,re32,   &
                                     rs31,rs32,rn31,rn32,reqs_p)
      endif
      IF(imoist.eq.1)THEN
        !  start comms for q:
        ! dont communicate on last rk step
        if(nrk.lt.3)then
          call comm_3q_start(q3d,qw31,qw32,qe31,qe32,   &
                                 qs31,qs32,qn31,qn32,reqs_q(1,1))
        endif
      ENDIF
#endif
!--------------------------------------------------------------------
!  TKE advection
 
        IF(iturb.eq.1)THEN

          ! use wten for tke tendency, step tke forward:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            wten(i,j,k)=tketen(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()

#ifdef MPI
        IF(nrk.ge.2)THEN
          call comm_3t_end(tke3d,tkw1,tkw2,tke1,tke2,   &
                                 tks1,tks2,tkn1,tkn2,reqs_tk)
        ENDIF
#endif

            call advw(nrk,xh,rxh,arh1,arh2,uh,xf,vh,gz,rgz,mf,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                       rru,rrv,rrw,tke3d,wten,rds,c1,c2,rho,dttmp)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
          do j=1,nj
          do i=1,ni
            tke3d(i,j,k)=tkea(i,j,k)+dttmp*wten(i,j,k)
            if(tke3d(i,j,k).lt.1.0e-6) tke3d(i,j,k)=0.0
          enddo
          enddo
        enddo
        if(timestats.ge.1) time_integ=time_integ+mytime()


          call bcw(tke3d,1)
#ifdef MPI
          call comm_3t_start(tke3d,tkw1,tkw2,tke1,tke2,   &
                                   tks1,tks2,tkn1,tkn2,reqs_tk)
#endif

        ENDIF

!--------------------------------------------------------------------
!  Passive Tracers

    if(iptra.eq.1)then

      if( nrk.eq.3 .and. pdtra.eq.1 )then
        pdef = 1
      else
        pdef = 0
      endif

    DO n=1,npt

      ! t33 = dummy

      bflag=0
      if(stat_qsrc.eq.1 .and. nrk.eq.3) bflag=1

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=ptten(i,j,k,n)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()


#ifdef MPI
          IF(nrk.ge.2)THEN
            call comm_3s_end(pt3d(ib,jb,kb,n),                           &
                  tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n),   &
                  ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n),   &
                  reqs_t(1,n))
          ENDIF
#endif

      weps = 1.0*epsilon
      diffit = 0
      if( idiff.eq.1 .and. difforder.eq.6 ) diffit = 1
      call advs(nrk,1,bflag,bfoo,xh,rxh,arh1,arh2,uh,ruh,xf,vh,rvh,gz,rgz,mh,rmh,        &
                 rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,dum5,dum6,     &
                 rru,rrv,rrw,pta(ib,jb,kb,n),pt3d(ib,jb,kb,n),sten,pdef,dttmp,weps, &
                 flag,sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,rdsf,c1,c2,rho,rr,diffit)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pt3d(i,j,k,n)=pta(i,j,k,n)+dttmp*sten(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

      IF(nrk.le.2)THEN
        call bcs(pt3d(ib,jb,kb,n))
#ifdef MPI
        call comm_3s_start(pt3d(ib,jb,kb,n)   &
                     ,tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n)     &
                     ,ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n)     &
                     ,reqs_t(1,n) )
#endif
      ENDIF

    ENDDO
    endif

!--------------------------------------------------------------------
! RK loop end

      ENDDO


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   End of RK section   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


!--------------------------------------------------------------------
!  Final step for Passive Tracers
!  (using final value of rho)

    if(iptra.eq.1)then
      DO n=1,npt
        if( pdtra.eq.1 ) call pdefq(0.0,afoo,ruh,rvh,rmh,rho,pt3d(ib,jb,kb,n))
        call bcs(pt3d(ib,jb,kb,n))
#ifdef MPI
        call comm_3s_start(pt3d(ib,jb,kb,n)   &
                     ,tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n)     &
                     ,ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n)     &
                     ,reqs_t(1,n) )
#endif
      ENDDO
    endif


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   BEGIN microphysics   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IF(imoist.eq.1)THEN

        getdbz = .false.
        IF(output_dbz.eq.1)THEN
          if( ((mtime+dbldt).ge.(taptim-0.1*dt)) .or. stopit )then
            getdbz = .true.
          endif
          if( ((mtime+dbldt).ge.(rsttim-0.1*dt)) .and. rstfrq.gt.0.0001 )then
            getdbz = .true.
          endif
          if( iprcl.eq.1 )then
            if( ((mtime+dbldt).ge.(prcltim-0.1*dt)) .or. prclfrq.le.0.0 )then
              getdbz = .true.
            endif
          endif
          if(getdbz)then
            if(dowr) write(outfile,*) '  Getting dbz ... '
          endif
        ENDIF

        getvt = .false.
        IF( efall.eq.1 ) getvt = .true.
        IF( dowrite .and. output_fallvel.eq.1 ) getvt = .true.

        ! sten = dbz
        ! dum1 = T
        ! dum3 = appropriate rho for budget calculations
        ! store copy of T in thten array:

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
        DO k=1,nk

          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
            thten(i,j,k)=dum1(i,j,k)
            qten(i,j,k,nqv)=q3d(i,j,k,nqv)
          enddo
          enddo

          if(getdbz)then
            ! store dbz in sten array:
            do j=1,nj
            do i=1,ni
              sten(i,j,k)=0.0
            enddo
            enddo
          endif

          IF(axisymm.eq.0)THEN
            ! for Cartesian grid:
            do j=1,nj
            do i=1,ni
              dum3(i,j,k)=rho(i,j,k)
            enddo
            enddo
          ELSE
            ! for axisymmetric grid:
            do j=1,nj
            do i=1,ni
              dum3(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
            enddo
            enddo
          ENDIF

          IF( output_mptend.eq.1 .and. dowrite  )THEN
            do j=1,nj
            do i=1,ni
              tdiag(i,j,k,td_mptend) = th3d(i,j,k)
            enddo
            enddo
          ENDIF

        ENDDO


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  NOTES:
!           sten       is used for     dbz
!
!           dum1   is   T
!           dum3   is   rho for budget calculations
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Kessler scheme   cccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        IF(ptype.eq.1)THEN
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq( qsmall,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq( qsmall,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call k_fallout(rho,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call geterain(dt,cpl,lv1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          if(efall.ge.1)then
            call getcvm(dum2,q3d)
            call getefall(1,cpl,mf,dum1,dum2,dum4,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk-1
            do j=1,nj
            do i=1,ni
              if( abs(dt*dum4(i,j,k)).ge.tsmall )then
                dum1(i,j,k) = dum1(i,j,k) + dt*dum4(i,j,k)
                prs(i,j,k)=rho(i,j,k)*rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps)
                pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
              endif
            enddo
            enddo
            enddo
          endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call kessler(dt,qbudget(3),qbudget(4),qbudget(5),ruh,rvh,rmh,pi0,th0,dum1,   &
                       rho,dum3,pp3d,th3d,prs,                            &
                       q3d(ib,jb,kb,nqv),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3))
          call satadj(4,dt,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                      rho,dum3,pp3d,prs,th3d,q3d)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Goddard LFO scheme   cccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        ELSEIF(ptype.eq.2)THEN
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq( qsmall,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq( qsmall,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq( qsmall,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq( qsmall,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq( qsmall,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
          call goddard(dt,qbudget(3),qbudget(4),qbudget(5),ruh,rvh,rmh,pi0,th0,             &
                       rho,dum3,prs,pp3d,th3d,                            &
     q3d(ib,jb,kb,1), q3d(ib,jb,kb,2),q3d(ib,jb,kb,3),qten(ib,jb,kb,3),   &
     q3d(ib,jb,kb,4),qten(ib,jb,kb,4),q3d(ib,jb,kb,5),qten(ib,jb,kb,5),   &
     q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          call satadj_ice(4,dt,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,     &
                          rho,dum3,pp3d,prs,th3d,                     &
              q3d(ib,jb,kb,1),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3),   &
              q3d(ib,jb,kb,4),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6))
          call geterain(dt,cpl,lv1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call geterain(dt,cpi,ls1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,4),qten(ib,jb,kb,4))
          call geterain(dt,cpi,ls1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,5),qten(ib,jb,kb,5))
          call geterain(dt,cpi,ls1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          if(efall.ge.1)then
            call getcvm(dum2,q3d)
            call getefall(1,cpl,mf,dum1,dum2,dum4,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
            call getefall(0,cpi,mf,dum1,dum2,dum4,q3d(ib,jb,kb,4),qten(ib,jb,kb,4))
            call getefall(0,cpi,mf,dum1,dum2,dum4,q3d(ib,jb,kb,5),qten(ib,jb,kb,5))
            call getefall(0,cpi,mf,dum1,dum2,dum4,q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk-1
            do j=1,nj
            do i=1,ni
              if( abs(dt*dum4(i,j,k)).ge.tsmall )then
                dum1(i,j,k) = dum1(i,j,k) + dt*dum4(i,j,k)
                prs(i,j,k)=rho(i,j,k)*rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps)
                pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
              endif
            enddo
            enddo
            enddo
          endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,4),qten(ib,jb,kb,4))
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,5),qten(ib,jb,kb,5))
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          if(getdbz) call calcdbz(rho,q3d(ib,jb,kb,3),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6),sten)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Thompson scheme   ccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        ELSEIF(ptype.eq.3)THEN
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq( qsmall,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq( qsmall,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq( qsmall,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq( qsmall,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq( qsmall,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
!!!          call pdefq(    1.0,asq(7),ruh,rvh,rmh,rho,q3d(ib,jb,kb,7))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ! cm1r17:  to make things easier to understand, use same arrays 
            !          that are used for morrison code:
            ! dum1 = T  (this should have been calculated already)
            ! dum2 = pi (nondimensional pressure)
            ! dum4 = dz
            ! thten = copy of T  (this should have been calculated already)
            dum2(i,j,k)=pi0(i,j,k)+pp3d(i,j,k)
            dum4(i,j,k)=dz*rmh(i,j,k)
          enddo
          enddo
          enddo
          call mp_gt_driver(q3d(ib,jb,kb,1),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3), &
                            q3d(ib,jb,kb,4),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6), &
                            q3d(ib,jb,kb,7),q3d(ib,jb,kb,8),                 &
                            th0,dum1,dum2,prs,dum4,dt,rain,                  &
                            qbudget(1),qbudget(2),qbudget(5),qbudget(6),     &
                            ruh,rvh,rmh,rho,dum3,sten,getdbz)
          ! Get final values for th3d,pp3d,prs:
          ! Note:  dum1 stores temperature, thten stores old temperature:
          IF( eqtset.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              if( abs(dum1(i,j,k)-thten(i,j,k)).ge.tsmall .or.  &
                  abs(q3d(i,j,k,nqv)-qten(i,j,k,nqv)).ge.qsmall )then
                prs(i,j,k)=rho(i,j,k)*(rd+rv*q3d(i,j,k,nqv))*dum1(i,j,k)
                pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
              endif
            enddo
            enddo
            enddo
          ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              if( abs(dum1(i,j,k)-thten(i,j,k)).ge.tsmall .or.  &
                  abs(q3d(i,j,k,nqv)-qten(i,j,k,nqv)).ge.qsmall )then
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
                rho(i,j,k)=prs(i,j,k)/(rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps))
              endif
            enddo
            enddo
            enddo
          ENDIF
          if(timestats.ge.1) time_microphy=time_microphy+mytime()

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   GSR LFO scheme   cccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        ELSEIF(ptype.eq.4)THEN
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq( qsmall,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq( qsmall,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq( qsmall,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq( qsmall,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq( qsmall,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
          call lfo_ice_drive(dt, mf, pi0, prs0, pp3d, prs, th0, th3d,    &
                             qv0, rho0, q3d, qten, dum1)
          do n=2,numq
            call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                         q3d(ib,jb,kb,n),qten(ib,jb,kb,n))
          enddo

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Morrison scheme   cccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        ELSEIF(ptype.eq.5)THEN
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq( qsmall,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq( qsmall,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq( qsmall,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq( qsmall,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq( qsmall,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
!!!          call pdefq(    1.0,asq(7),ruh,rvh,rmh,rho,q3d(ib,jb,kb,7))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ! dum1 = T  (this should have been calculated already)
            ! dum4 = dz
            ! thten = copy of T  (this should have been calculated already)
            dum4(i,j,k)=dz*rmh(i,j,k)
          enddo
          enddo
          enddo
          IF(numq.eq.11)THEN
            ! ppten stores ncc:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              ppten(i,j,k) = q3d(i,j,k,11)
            enddo
            enddo
            enddo
          ENDIF
          ! cm1r17:  get fall velocities (store in qten array)
          call MP_GRAUPEL(nstep,dum1,                                 &
                          q3d(ib,jb,kb, 1),q3d(ib,jb,kb, 2),q3d(ib,jb,kb, 3), &
                          q3d(ib,jb,kb, 4),q3d(ib,jb,kb, 5),q3d(ib,jb,kb, 6), &
                          q3d(ib,jb,kb, 7),q3d(ib,jb,kb, 8),q3d(ib,jb,kb, 9), &
                          q3d(ib,jb,kb,10),ppten,                             &
                               prs,rho,dt,dum4,w3d,rain,                      &
                          effc,effi,effs,effr,effg,effis,                     &
                          qbudget(1),qbudget(2),qbudget(5),qbudget(6),        &
                          ruh,rvh,rmh,dum3,sten,getdbz,                       &
                          qten(ib,jb,kb,nqc),qten(ib,jb,kb,nqr),qten(ib,jb,kb,nqi),  &
                          qten(ib,jb,kb,nqs),qten(ib,jb,kb,nqg),getvt)
          IF(numq.eq.11)THEN
            ! ppten stores ncc:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              q3d(i,j,k,11) = ppten(i,j,k)
            enddo
            enddo
            enddo
          ENDIF
          if(timestats.ge.1) time_microphy=time_microphy+mytime()
          IF(efall.eq.1)THEN
            ! dum1 = T
            ! dum2 = cvm
            ! dum4 = T tendency
            call getcvm(dum2,q3d)
            call getefall(1,cpl,mf,dum1,dum2,dum4,q3d(ib,jb,kb,nqc),qten(ib,jb,kb,nqc))
            call getefall(0,cpl,mf,dum1,dum2,dum4,q3d(ib,jb,kb,nqr),qten(ib,jb,kb,nqr))
            call getefall(0,cpi,mf,dum1,dum2,dum4,q3d(ib,jb,kb,nqi),qten(ib,jb,kb,nqi))
            call getefall(0,cpi,mf,dum1,dum2,dum4,q3d(ib,jb,kb,nqs),qten(ib,jb,kb,nqs))
            call getefall(0,cpi,mf,dum1,dum2,dum4,q3d(ib,jb,kb,nqg),qten(ib,jb,kb,nqg))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk-1
            do j=1,nj
            do i=1,ni
              dum1(i,j,k) = dum1(i,j,k) + dt*dum4(i,j,k)
            enddo
            enddo
            enddo
          ENDIF
          ! Get final values for th3d,pp3d,prs:
          ! Note:  dum1 stores temperature, thten stores old temperature:
          IF( eqtset.eq.2 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              if( abs(dum1(i,j,k)-thten(i,j,k)).ge.tsmall .or.  &
                  abs(q3d(i,j,k,nqv)-qten(i,j,k,nqv)).ge.qsmall )then
                prs(i,j,k)=rho(i,j,k)*(rd+rv*q3d(i,j,k,nqv))*dum1(i,j,k)
                pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
              endif
            enddo
            enddo
            enddo
          ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              if( abs(dum1(i,j,k)-thten(i,j,k)).ge.tsmall .or.  &
                  abs(q3d(i,j,k,nqv)-qten(i,j,k,nqv)).ge.qsmall )then
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
                rho(i,j,k)=prs(i,j,k)/(rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps))
              endif
            enddo
            enddo
            enddo
          ENDIF
          IF( output_fallvel.eq.1 .and. dowrite  )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              qdiag(i,j,k,qd_vtc) = qten(i,j,k,nqc)
              qdiag(i,j,k,qd_vtr) = qten(i,j,k,nqr)
              qdiag(i,j,k,qd_vts) = qten(i,j,k,nqs)
              qdiag(i,j,k,qd_vtg) = qten(i,j,k,nqg)
              qdiag(i,j,k,qd_vti) = qten(i,j,k,nqi)
            enddo
            enddo
            enddo
          ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   RE87 scheme   ccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        ELSEIF(ptype.eq.6)THEN
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq( qsmall,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if(q3d(i,j,k,2).gt.0.001)then
              qten(i,j,k,2) = v_t
            else
              qten(i,j,k,2) = 0.0
            endif
          enddo
          enddo
          enddo
          call geterain(dt,cpl,lv1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,2),qten(ib,jb,kb,2))
          if(efall.ge.1)then
            call getcvm(dum2,q3d)
            call getefall(1,cpl,mf,dum1,dum2,dum4,q3d(ib,jb,kb,2),qten(ib,jb,kb,2))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk-1
            do j=1,nj
            do i=1,ni
              if( abs(dt*dum4(i,j,k)).ge.tsmall )then
                dum1(i,j,k) = dum1(i,j,k) + dt*dum4(i,j,k)
                prs(i,j,k)=rho(i,j,k)*rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps)
                pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
                th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
              endif
            enddo
            enddo
            enddo
          endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,2),qten(ib,jb,kb,2))
          call satadj(4,dt,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                      rho,dum3,pp3d,prs,th3d,q3d)

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Ziegler/Mansell (NSSL) two-moment scheme
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
        ELSEIF(ptype.ge.26)THEN
          IF ( ptype .eq. 26 ) THEN
            j = 13
          ELSEIF ( ptype .eq. 27 ) THEN
            j = 16
          ELSEIF ( ptype .eq. 28) THEN ! single moment
            j = 6
          ELSEIF ( ptype .eq. 29 ) THEN
            j = 19
          ENDIF
          DO i = 1,j
            call pdefq(0.0,asq(i),ruh,rvh,rmh,rho,q3d(ib,jb,kb,i))
          ENDDO

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k) = pi0(i,j,k)+pp3d(i,j,k)
            dum2(i,j,k) = dz*rmh(i,j,k)
            dum4(i,j,k) = th0(i,j,k)+th3d(i,j,k)
            ! store old theta in thten array:
            thten(i,j,k)=dum4(i,j,k)
          enddo
          enddo
          enddo
          
          IF ( ptype .eq. 26 ) THEN  ! graupel only
             call nssl_2mom_driver(                          &
                               th  = dum4,                   &
                               qv  = q3d(ib,jb,kb, 1),       &
                               qc  = q3d(ib,jb,kb, 2),       &
                               qr  = q3d(ib,jb,kb, 3),       &
                               qi  = q3d(ib,jb,kb, 4),       &
                               qs  = q3d(ib,jb,kb, 5),       &
                               qh  = q3d(ib,jb,kb, 6),       &
                               cn  = q3d(ib,jb,kb, 7),       &
                               ccw = q3d(ib,jb,kb, 8),       &
                               crw = q3d(ib,jb,kb, 9),       &
                               cci = q3d(ib,jb,kb, 10),      &
                               csw = q3d(ib,jb,kb, 11),      &
                               chw = q3d(ib,jb,kb, 12),      &
                               vhw = q3d(ib,jb,kb, 13),      &
                               pii = dum1,                   &
                               p   =  prs,                   &
                               w   =  w3d,                   &
                               dn  =  rho,                   &
                               dz  =  dum2,                  &
                               dtp = dt,                     &
                               itimestep = nstep,            &
                              RAIN = rain,                   &
                              nrain = nrain,                 &
                              dbz = sten,                    &
                              ruh = ruh, rvh = rvh, rmh = rmh, &
                              dx = dx, dy = dy,              &
                              tcond = qbudget(1),            &
                              tevac = qbudget(2),            &
                              tevar = qbudget(5),            &
                              train = qbudget(6),            &
                              rr    = dum3,                  &
                              diagflag = getdbz,                  &
                              ims = ib ,ime = ie , jms = jb ,jme = je, kms = kb,kme = ke,  &  
                              its = 1 ,ite = ni, jts = 1,jte = nj, kts = 1,kte = nk)
         ELSEIF ( ptype .eq. 27 ) THEN
             call nssl_2mom_driver(                          &
                               th  = dum4,                   &
                               qv  = q3d(ib,jb,kb, 1),       &
                               qc  = q3d(ib,jb,kb, 2),       &
                               qr  = q3d(ib,jb,kb, 3),       &
                               qi  = q3d(ib,jb,kb, 4),       &
                               qs  = q3d(ib,jb,kb, 5),       &
                               qh  = q3d(ib,jb,kb, 6),       &
                               qhl = q3d(ib,jb,kb, 7),       &
                               cn  = q3d(ib,jb,kb, 8),       &
                               ccw = q3d(ib,jb,kb, 9),       &
                               crw = q3d(ib,jb,kb,10),       &
                               cci = q3d(ib,jb,kb, 11),      &
                               csw = q3d(ib,jb,kb, 12),      &
                               chw = q3d(ib,jb,kb, 13),      &
                               chl = q3d(ib,jb,kb, 14),      &
                               vhw = q3d(ib,jb,kb, 15),      &
                               vhl = q3d(ib,jb,kb, 16),      &
                               pii = dum1,                   &
                               p   =  prs,                   &
                               w   =  w3d,                   &
                               dn  =  rho,                   &
                               dz  =  dum2,                  &
                               dtp = dt,                     &
                               itimestep = nstep,            &
                              RAIN = rain,                   &
                              nrain = nrain,                 &
                              dbz = sten,                    &
                              ruh = ruh, rvh = rvh, rmh = rmh, &
                              dx = dx, dy = dy,              &
                              tcond = qbudget(1),            &
                              tevac = qbudget(2),            &
                              tevar = qbudget(5),            &
                              train = qbudget(6),            &
                              rr    = dum3,                  &
                              diagflag = getdbz,             &
                              ims = ib ,ime = ie , jms = jb ,jme = je, kms = kb,kme = ke,  &  
                              its = 1 ,ite = ni, jts = 1,jte = nj, kts = 1,kte = nk)
          ELSEIF ( ptype .eq. 28 ) THEN  ! single moment
             call nssl_2mom_driver(                          &
                               th  = dum4,                   &
                               qv  = q3d(ib,jb,kb, 1),       &
                               qc  = q3d(ib,jb,kb, 2),       &
                               qr  = q3d(ib,jb,kb, 3),       &
                               qi  = q3d(ib,jb,kb, 4),       &
                               qs  = q3d(ib,jb,kb, 5),       &
                               qh  = q3d(ib,jb,kb, 6),       &
                               pii = dum1,                   &
                               p   =  prs,                   &
                               w   =  w3d,                   &
                               dn  =  rho,                   &
                               dz  =  dum2,                  &
                               dtp = dt,                     &
                               itimestep = nstep,            &
                              RAIN = rain,                   &
                              nrain = nrain,                 &
                              dbz = sten,                    &
                              ruh = ruh, rvh = rvh, rmh = rmh, &
                              dx = dx, dy = dy,              &
                              tcond = qbudget(1),            &
                              tevac = qbudget(2),            &
                              tevar = qbudget(5),            &
                              train = qbudget(6),            &
                              rr    = dum3,                  &
                              diagflag = getdbz,                  &
                              ims = ib ,ime = ie , jms = jb ,jme = je, kms = kb,kme = ke,  &  
                              its = 1 ,ite = ni, jts = 1,jte = nj, kts = 1,kte = nk)

!         ELSEIF ( ptype .eq. 29 ) THEN ! 3-moment
!             call nssl_2mom_driver(                          &
!                               th  = dum4,                   &
!                               qv  = q3d(ib,jb,kb, 1),       &
!                               qc  = q3d(ib,jb,kb, 2),       &
!                               qr  = q3d(ib,jb,kb, 3),       &
!                               qi  = q3d(ib,jb,kb, 4),       &
!                               qs  = q3d(ib,jb,kb, 5),       &
!                               qh  = q3d(ib,jb,kb, 6),       &
!                               qhl = q3d(ib,jb,kb, 7),       &
!                               cn  = q3d(ib,jb,kb, 8),       &
!                               ccw = q3d(ib,jb,kb, 9),       &
!                               crw = q3d(ib,jb,kb,10),       &
!                               cci = q3d(ib,jb,kb, 11),      &
!                               csw = q3d(ib,jb,kb, 12),      &
!                               chw = q3d(ib,jb,kb, 13),      &
!                               chl = q3d(ib,jb,kb, 14),      &
!                               zrw = q3d(ib,jb,kb, 15),      &
!                               zhw = q3d(ib,jb,kb, 16),      &
!                               zhl = q3d(ib,jb,kb, 17),      &
!                               vhw = q3d(ib,jb,kb, 18),      &
!                               vhl = q3d(ib,jb,kb, 19),      &
!                               pii = dum1,                   &
!                               p   =  prs,                   &
!                               w   =  w3d,                   &
!                               dn  =  rho,                   &
!                               dz  =  dum2,                  &
!                               dtp = dt,                     &
!                               itimestep = nstep,            &
!                              RAIN = rain,                   &
!                              nrain = nrain,                 &
!                              dbz = sten,                    &
!                              ruh = ruh, rvh = rvh, rmh = rmh, &
!                              dx = dx, dy = dy,              &
!                              tcond = qbudget(1),            &
!                              tevac = qbudget(2),            &
!                              tevar = qbudget(5),            &
!                              train = qbudget(6),            &
!                              rr    = dum3,                  &
!                              diagflag = getdbz,             &
!                              ims = ib ,ime = ie , jms = jb ,jme = je, kms = kb,kme = ke,  &  
!                              its = 1 ,ite = ni, jts = 1,jte = nj, kts = 1,kte = nk)
!          
          ENDIF

        IF(eqtset.eq.2)THEN
          ! for mass conservation:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if( abs(dum4(i,j,k)-thten(i,j,k)).ge.tsmall .or.  &
                abs(q3d(i,j,k,nqv)-qten(i,j,k,nqv)).ge.qsmall )then
              prs(i,j,k) = rho(i,j,k)*rd*dum4(i,j,k)*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps)
              pp3d(i,j,k) = (prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
              th3d(i,j,k) = dum4(i,j,k)*dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
            endif
          enddo
          enddo
          enddo
        ELSE
          ! traditional thermodynamics:  p,pi remain unchanged
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if( abs(dum4(i,j,k)-thten(i,j,k)).ge.tsmall .or.  &
                abs(q3d(i,j,k,nqv)-qten(i,j,k,nqv)).ge.qsmall )then
              th3d(i,j,k)= dum4(i,j,k) - th0(i,j,k)
              rho(i,j,k)=prs(i,j,k)/(rd*dum4(i,j,k)*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps))
            endif
          enddo
          enddo
          enddo
        ENDIF

          if(timestats.ge.1) time_microphy=time_microphy+mytime()

!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  insert new microphysics schemes here
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!        ELSEIF(ptype.eq.8)THEN
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! otherwise, stop for undefined ptype
        ELSE
          print *,'  Undefined ptype!'
          call stopcm1
        ENDIF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   END microphysics   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

          IF( output_mptend.eq.1 .and. dowrite  )THEN
            rdt = 1.0/dt
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              tdiag(i,j,k,td_mptend) = (th3d(i,j,k)-tdiag(i,j,k,td_mptend))*rdt
            enddo
            enddo
            enddo
          ENDIF

        if(timestats.ge.1) time_microphy=time_microphy+mytime()
      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!Begin:  message passing

          call bcs(th3d)
          call bcs(pp3d)
#ifdef MPI
          call comm_3r_start(th3d,pp3d,rw31,rw32,re31,re32,   &
                                       rs31,rs32,rn31,rn32,reqs_p)
#endif

      IF( imoist.eq.1 )THEN
          DO n=1,numq
            call bcs(q3d(ib,jb,kb,n))
          ENDDO
#ifdef MPI
          call comm_3q_start(q3d,qw31,qw32,qe31,qe32,   &
                                 qs31,qs32,qn31,qn32,reqs_q(1,1))
#endif
      ENDIF

!Done:  message passing
!-----------------------------------------------------------------
!  cm1r17:  diabatic tendencies for next timestep:

        IF(imoist.eq.1.and.eqtset.eq.2)THEN
          ! get diabatic tendencies (will be used in next timestep):
          rdt = 1.0/dt
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qpten(i,j,k)=(pp3d(i,j,k)-qpten(i,j,k))*rdt
            qtten(i,j,k)=(th3d(i,j,k)-qtten(i,j,k))*rdt
            qvten(i,j,k)=(q3d(i,j,k,nqv)-qvten(i,j,k))*rdt
            qcten(i,j,k)=(q3d(i,j,k,nqc)-qcten(i,j,k))*rdt
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_microphy=time_microphy+mytime()
        ENDIF

!-----------------------------------------------------------------
!  Equate the two arrays

#ifdef MPI
      call comm_3u_end(u3d,uw31,uw32,ue31,ue32,   &
                           us31,us32,un31,un32,reqs_u)
      call comm_3v_end(v3d,vw31,vw32,ve31,ve32,   &
                           vs31,vs32,vn31,vn32,reqs_v)
      call comm_3w_end(w3d,ww31,ww32,we31,we32,   &
                           ws31,ws32,wn31,wn32,reqs_w)
#endif

      if(terrain_flag)then
        call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)
        call bc2d(w3d(ib,jb,1))
      endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=0,nj+1
        do i=0,ni+2
          ua(i,j,k)=u3d(i,j,k)
        enddo
        enddo
        do j=0,nj+2
        do i=0,ni+1
          va(i,j,k)=v3d(i,j,k)
        enddo
        enddo
        do j=0,nj+1
        do i=0,ni+1
          wa(i,j,k)=w3d(i,j,k)
        enddo
        enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

!----------

      if(iturb.eq.1)then
#ifdef MPI
        call comm_3t_end(tke3d,tkw1,tkw2,tke1,tke2,   &
                               tks1,tks2,tkn1,tkn2,reqs_tk)
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=0,nj+1
        do i=0,ni+1
          tkea(i,j,k)=tke3d(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_integ=time_integ+mytime()
      endif

!----------

      if(iptra.eq.1)then
        do n=1,npt
#ifdef MPI
          call comm_3s_end(pt3d(ib,jb,kb,n),                           &
                tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n),   &
                ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n),   &
                reqs_t(1,n))
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            pta(i,j,k,n)=pt3d(i,j,k,n)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_integ=time_integ+mytime()
        enddo
      endif

!----------

#ifdef MPI
      call comm_3r_end(th3d,pp3d,rw31,rw32,re31,re32,   &
                                 rs31,rs32,rn31,rn32,reqs_p)
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          ppi(i,j,k)=pp3d(i,j,k)
        enddo
        enddo
        do j=0,nj+1
        do i=0,ni+1
          tha(i,j,k)=th3d(i,j,k)
        enddo
        enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

!----------

      if(imoist.eq.1)then
#ifdef MPI
        call comm_3q_end(q3d,qw31,qw32,qe31,qe32,   &
                             qs31,qs32,qn31,qn32,reqs_q(1,1))
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
        do k=1,nk
          do n=1,numq
          do j=0,nj+1
          do i=0,ni+1
            qa(i,j,k,n)=q3d(i,j,k,n)
          enddo
          enddo
          enddo
        enddo
        if(timestats.ge.1) time_integ=time_integ+mytime()
      endif

!----------

#ifdef MPI
        call comm_1s_end(rho,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
        call getcorner(rho,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
        call bcs2(rho)
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=0,nj+1
          k = 1
          do i=0,ni+1
            ! cm1r17, 2nd-order extrapolation:
            rf(i,j,1) = cgs1*rho(i,j,1)+cgs2*rho(i,j,2)+cgs3*rho(i,j,3)
            rr(i,j,1) = 1.0/rho(i,j,1)
          enddo
          do k=2,nk
          do i=0,ni+1
            rf(i,j,k) = (c1(i,j,k)*rho(i,j,k-1)+c2(i,j,k)*rho(i,j,k))
            rr(i,j,k) = 1.0/rho(i,j,k)
          enddo
          enddo
          do i=0,ni+1
            ! cm1r17, 2nd-order extrapolation:
            rf(i,j,nk+1) = cgt1*rho(i,j,nk)+cgt2*rho(i,j,nk-1)+cgt3*rho(i,j,nk-2)
          enddo
        enddo
        if(timestats.ge.1) time_prsrho=time_prsrho+mytime()

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  Update parcel locations  ccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      IF(iprcl.eq.1)THEN
        ! cm1r18:  use velocities averaged over small time steps (for psolver=2,3,6)
        !          (note:  parcel_driver assumes no terrain)
        IF( psolver.eq.2 .or. psolver.eq.3 .or. psolver.eq.6 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
            do j=1,nj
            do i=1,ni+1
              us(i,j,k)=rru(i,j,k)*rr0(1,1,k)
            enddo
            enddo
            IF(axisymm.eq.0)THEN
              ! Cartesian grid:
              do j=1,nj+1
              do i=1,ni
                vs(i,j,k)=rrv(i,j,k)*rr0(1,1,k)
              enddo
              enddo
            ENDIF
            IF(k.gt.1)THEN
              do j=1,nj
              do i=1,ni
                ws(i,j,k)=rrw(i,j,k)*rrf0(1,1,k)
              enddo
              enddo
            ENDIF
          enddo
        ELSE
          ! psolver=1,4,5:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
            do j=1,nj
            do i=1,ni+1
              us(i,j,k)=u3d(i,j,k)
            enddo
            enddo
            IF(axisymm.eq.0)THEN
              ! Cartesian grid:
              do j=1,nj+1
              do i=1,ni
                vs(i,j,k)=v3d(i,j,k)
              enddo
              enddo
            ENDIF
            IF(k.gt.1)THEN
              do j=1,nj
              do i=1,ni
                ws(i,j,k)=w3d(i,j,k)
              enddo
              enddo
            ENDIF
          enddo
        ENDIF
        if(timestats.ge.1) time_parcels=time_parcels+mytime()
        call     parcel_driver(dt,xh,uh,ruh,xf,yh,vh,rvh,yf,zh,mh,rmh,zf,mf,    &
                               znt,rho,us,vs,ws,pdata,packet(1,1),ploc,         &
                               reqs_p,reqs_u,reqs_v,reqs_w,                     &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                 &
                               nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                               n3w1,n3w2,n3e1,n3e2,s3w1,s3w2,s3e1,s3e2,         &
                               uw31,uw32,ue31,ue32,us31,us32,un31,un32,         &
                               vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,         &
                               ww31,ww32,we31,we32,ws31,ws32,wn31,wn32)
        if(timestats.ge.1) time_parcels=time_parcels+mytime()
      ENDIF


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   All done   cccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!!!#ifdef MPI
!!!      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
!!!      if(timestats.ge.1) time_mpb=time_mpb+mytime()
!!!#endif

!--------------------------------------------------------------------
!  Calculate surface "swaths."  Move surface (if necessary). 
!--------------------------------------------------------------------

    IF( output_rain.eq.1 )THEN

      if(imove.eq.1.and.imoist.eq.1)then
        weps = 10.0*epsilon
        call movesfc(0.0,dt,weps,uh,vh,rain(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3), &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif

    ENDIF

!--------------------------------------------------------------------
! Maximum horizontal wind speed at lowest model level: 
! (include domain movement in calculation)

    IF( output_sws.eq.1 )THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = sqrt( (umove+0.5*(ua(i,j,1)+ua(i+1,j,1)))**2    &
                   +(vmove+0.5*(va(i,j,1)+va(i,j+1,1)))**2 ) 
        do n=1,nrain
          sws(i,j,n)=max(sws(i,j,n),tem)
        enddo
      enddo
      enddo
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 10.0*epsilon
        call movesfc(0.0,dt,weps,uh,vh,sws(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3),  &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif

    ENDIF

!--------------------------------------------------------------------
!  Maximum vertical vorticity at lowest model level:

  IF( output_svs.eq.1 )THEN

  IF(axisymm.eq.0)THEN
    IF(.not.terrain_flag)THEN
      ! Cartesian grid, without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj+1
      do i=1,ni+1
        tem = (va(i,j,1)-va(i-1,j,1))*rdx*uf(i)   &
             -(ua(i,j,1)-ua(i,j-1,1))*rdy*vf(j)
        do n=1,nrain
          svs(i,j,n)=max(svs(i,j,n),tem)
        enddo
      enddo
      enddo
    ELSE
      ! Cartesian grid, with terrain:
      ! dum1 stores u at w-pts:
      ! dum2 stores v at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do j=0,nj+2
        ! lowest model level:
        do i=0,ni+2
          dum1(i,j,1) = cgs1*ua(i,j,1)+cgs2*ua(i,j,2)+cgs3*ua(i,j,3)
          dum2(i,j,1) = cgs1*va(i,j,1)+cgs2*va(i,j,2)+cgs3*va(i,j,3)
        enddo
        ! interior:
        do k=2,2
        r2 = (sigmaf(k)-sigma(k-1))*rds(k)
        r1 = 1.0-r2
        do i=0,ni+2
          dum1(i,j,k) = r1*ua(i,j,k-1)+r2*ua(i,j,k)
          dum2(i,j,k) = r1*va(i,j,k-1)+r2*va(i,j,k)
        enddo
        enddo
      enddo
      k = 1
!$omp parallel do default(shared)  &
!$omp private(i,j,n,r1,tem)
      do j=1,nj+1
      do i=1,ni+1
        r1 = zt/(zt-0.25*((zs(i-1,j-1)+zs(i,j))+(zs(i-1,j)+zs(i,j-1))))
        tem = ( r1*(va(i,j,k)*rgzv(i,j)-va(i-1,j,k)*rgzv(i-1,j))*rdx*uf(i)  &
               +0.5*( (zt-sigmaf(k+1))*(dum2(i-1,j,k+1)+dum2(i,j,k+1))      &
                     -(zt-sigmaf(k  ))*(dum2(i-1,j,k  )+dum2(i,j,k  ))      &
                    )*rdsf(k)*r1*(rgzv(i,j)-rgzv(i-1,j))*rdx*uf(i) )        &
             -( r1*(ua(i,j,k)*rgzu(i,j)-ua(i,j-1,k)*rgzu(i,j-1))*rdy*vf(j)  &
               +0.5*( (zt-sigmaf(k+1))*(dum1(i,j-1,k+1)+dum1(i,j,k+1))      &
                     -(zt-sigmaf(k  ))*(dum1(i,j-1,k  )+dum1(i,j,k  ))      &
                    )*rdsf(k)*r1*(rgzu(i,j)-rgzu(i,j-1))*rdy*vf(j) )
        do n=1,nrain
          svs(i,j,n)=max(svs(i,j,n),tem)
        enddo
      enddo
      enddo
    ENDIF
  ELSE
      ! Axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj+1
      do i=1,ni+1
        tem = (va(i,j,1)*xh(i)-va(i-1,j,1)*xh(i-1))*rdx*uf(i)*rxf(i)
        do n=1,nrain
          svs(i,j,n)=max(svs(i,j,n),tem)
        enddo
      enddo
      enddo
  ENDIF
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 1.0*epsilon
        call movesfc(-1000.0,dt,weps,uh,vh,svs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3), &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif

  ENDIF

!--------------------------------------------------------------------
!  Minimum pressure perturbation at lowest model level:

  IF( output_sps.eq.1 )THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = prs(i,j,1)-prs0(i,j,1)
        do n=1,nrain
          sps(i,j,n)=min(sps(i,j,n),tem)
        enddo
      enddo
      enddo
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 1000.0*epsilon
        call movesfc(-200000.0,dt,weps,uh,vh,sps(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3), &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif

  ENDIF

!--------------------------------------------------------------------
!  Maximum rainwater mixing ratio (qr) at lowest model level:

  IF( output_srs.eq.1 )THEN

    IF(imoist.eq.1.and.nqr.ne.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = qa(i,j,1,nqr)
        do n=1,nrain
          srs(i,j,n)=max(srs(i,j,n),tem)
        enddo
      enddo
      enddo
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 0.01*epsilon
        call movesfc(0.0,dt,weps,uh,vh,srs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3),  &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif
    ENDIF

  ENDIF

!--------------------------------------------------------------------
!  Maximum graupel/hail mixing ratio (qg) at lowest model level:

  IF( output_sgs.eq.1 )THEN

    IF(imoist.eq.1.and.nqg.ne.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = qa(i,j,1,nqg)
        do n=1,nrain
          sgs(i,j,n)=max(sgs(i,j,n),tem)
        enddo
      enddo
      enddo
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 0.01*epsilon
        call movesfc(0.0,dt,weps,uh,vh,sgs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3),  &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif
    ENDIF

  ENDIF

!--------------------------------------------------------------------

  IF( output_sus.eq.1 )THEN

      ! get height AGL:
      if( .not. terrain_flag )then
        ! without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dum3(i,j,k) = zh(i,j,k)
          wten(i,j,k) = zf(i,j,k)
        enddo
        enddo
        enddo
      else
        ! get height AGL:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dum3(i,j,k) = zh(i,j,k)-zs(i,j)
          wten(i,j,k) = zf(i,j,k)-zs(i,j)
        enddo
        enddo
        enddo
      endif

!--------------------------------------------------------------------
!  Maximum updraft velocity (w) at 5 km AGL:

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tem)
      do j=1,nj
      do i=1,ni
        k = 2
        ! wten is height AGL:
        do while( wten(i,j,k).lt.5000.0 .and. k.lt.nk )
          k = k + 1
        enddo
        tem = w3d(i,j,k)
        do n=1,nrain
          sus(i,j,n)=max(sus(i,j,n),tem)
        enddo
      enddo
      enddo
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 10.0*epsilon
        call movesfc(-1000.0,dt,weps,uh,vh,sus(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3), &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif

    ENDIF

!--------------------------------------------------------------------
!  Maximum integrated updraft helicity:

    IF( output_shs.eq.1 )THEN

      ! dum3 is zh (agl), wten is zf (agl)
      call calcuh(uf,vf,dum3,wten,ua,va,wa,dum1(ib,jb,1),dum2,dum5,dum6, &
                  zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf)
!$omp parallel do default(shared)  &
!$omp private(i,j,n)
      do j=1,nj
      do i=1,ni
        do n=1,nrain
          shs(i,j,n)=max(shs(i,j,n),dum1(i,j,1))
        enddo
      enddo
      enddo
      if(timestats.ge.1) time_swath=time_swath+mytime()

      if(imove.eq.1)then
        weps = 100.0*epsilon
        call movesfc(0.0,dt,weps,uh,vh,shs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3),  &
                     reqs_s,sw31(1,1,1),sw32(1,1,1),se31(1,1,1),se32(1,1,1),               &
                            ss31(1,1,1),ss32(1,1,1),sn31(1,1,1),sn32(1,1,1))
      endif

    ENDIF

!  Done with "swaths"
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Step time forward, take care of a few odds and ends .... 
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      mtime = mtime + dbldt

      if( convinit.eq.1 )then
        if( mtime.gt.convtime ) convinit = 0
      endif

      rtime=sngl(mtime)

      dostat = .false.
      dowrite = .false.
      dorestart = .false.
      doprclout = .false.

      if( mtime.ge.(stattim-0.1*dt) .or. statfrq.lt.0.0 .or. stopit ) dostat = .true.
      if( mtime.ge.(taptim-0.1*dt) .or. stopit ) dowrite = .true.
      if( mtime.ge.(rsttim-0.1*dt) .and. rstfrq.gt.0.0 ) dorestart = .true.
      if(iprcl.eq.1)then
        IF( mtime.ge.(prcltim-0.1*dt) .or. prclfrq.lt.0.0 ) doprclout = .true.
      endif

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! Adaptive timestepping:
!   (assumes cflmax has already been calculated)
!  cm1r18:  get new timestep before calling sfc_and_turb
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      IF( adapt_dt.eq.1 )THEN
        dtlast = dt

      IF( myid.eq.0 )THEN
        ! only processor 0 does this:

        cflmax = max(cflmax,1.0e-10)

        IF( cflmax.gt.cfl_limit )THEN
          ! decrease timestep:
          dbldt = dt*cfl_limit/cflmax
        ELSE
          ! increase timestep:
          dbldt = min( 1.0+max_change , cfl_limit/cflmax )*dt
        ENDIF

        ! don't allow dt to exceed twice initial timestep
        dbldt = min( dbldt , dble(2.0*dtl) )

      IF( taptim.gt.0.0 )THEN
        ! ramp-down timestep when approaching output time
        if( dowrite )then
          tout = ( ( taptim - mtime ) + tapfrq )
        else
          tout = ( taptim - mtime )
        endif
        if( tout.gt.(2.0*dbldt) .and. tout.le.(3.0*dbldt)  )then
          dbldt = tout/3.0
        elseif( tout.gt.dbldt .and. tout.le.(2.0*dbldt)  )then
          dbldt = tout/2.0
        elseif( tout.le.dbldt )then
          dbldt = tout
        endif
      ENDIF

      IF( rsttim.gt.0.0 )THEN
        ! ramp-down timestep when approaching restart time
        if( dorestart )then
          tout = ( ( rsttim - mtime ) + rstfrq )
        else
          tout = ( rsttim - mtime )
        endif
        if( tout.gt.(2.0*dbldt) .and. tout.le.(3.0*dbldt)  )then
          dbldt = tout/3.0
        elseif( tout.gt.dbldt .and. tout.le.(2.0*dbldt)  )then
          dbldt = tout/2.0
        elseif( tout.le.dbldt )then
          dbldt = tout
        endif
      ENDIF

      IF( stattim.gt.0.0 )THEN
        ! ramp-down timestep when approaching stat time
        if( dostat )then
          tout = ( ( stattim - mtime ) + statfrq )
        else
          tout = ( stattim - mtime )
        endif
        if( tout.gt.(2.0*dbldt) .and. tout.le.(3.0*dbldt)  )then
          dbldt = tout/3.0
        elseif( tout.gt.dbldt .and. tout.le.(2.0*dbldt)  )then
          dbldt = tout/2.0
        elseif( tout.le.dbldt )then
          dbldt = tout
        endif
      ENDIF

        ! end of processor 0 stuff
      ENDIF

        ! all processors:
#ifdef MPI
        call MPI_BCAST(dbldt ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
!!!        call MPI_BCAST(dt    ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
!!!        call MPI_BCAST(nsound,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
#endif
        dt = dbldt
        call dtsmall(dt)
        ndt = ndt + 1
        adt = adt + dt
        acfl = acfl + cflmax
        if(timestats.ge.1) time_misc=time_misc+mytime()
        IF( dt.ne.dtlast )THEN
          IF( (imoist.eq.1).and.(ptype.eq.2) )then
            call consat2(dt)
            if(timestats.ge.1) time_microphy=time_microphy+mytime()
          ENDIF
          IF( (imoist.eq.1).and.(ptype.eq.4) )then
            call lfoice_init(dt)
            if(timestats.ge.1) time_microphy=time_microphy+mytime()
          ENDIF
        ENDIF
      ENDIF

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   Prepare turbulence vars for next time step   cccccccccccccccccc
!cc     (new since cm1r17)                         cccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      call sfc_and_turb(.true.,nstep,dt,dosfcflx,cloudvar,qbudget,   &
                   xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf,  &
                   yh,vh,rvh,yf,vf,rvf,                              &
                   rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,zf,mf,rmf,  &
                   pi0s,rth0s,pi0,rho0,prs0,thv0,th0,qv0,            &
                   zs,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv,        &
                   tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,tlh,          &
                   dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,          &
                   divx,rho,rr,rf,prs,                               &
                   t11,t12,t13,t22,t23,t33,                          &
                   u0,ua,v0,va,wa,                                   &
                   ppi,pp3d,ppten,                                   &
                   tha,th3d,thten,thten1,qa,                         &
                   kmh,kmv,khh,khv,tkea,tke3d,                       &
                   nm,defv,defh,dissten,radsw,radswnet,radlwin,      &
                   thpten,qvpten,qcpten,qipten,upten,vpten,          &
                   lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,znt,ust,    &
                   hpbl,wspd,psim,psih,gz1oz0,br,                    &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                    &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                 &
                   CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,    &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh,  &
                   mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d,   &
                   num_soil_layers,slab_zs,slab_dzs,tslb,tmn,        &
                   tml,t0ml,hml,h0ml,huml,hvml,tmoml,                &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,               &
                   nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   kw1,kw2,ke1,ke2,ks1,ks2,kn1,kn2,                  &
                   rtime,ntdiag,tdiag,.true.)
        ! end_sfc_and_turb

!--------------------------------------------------------------------
!  get stress terms for explicit diffusion scheme:

      IF( ((idiff.ge.1).and.(difforder.eq.2)) .or. (dns.eq.1) )THEN
        call diff2def(uh,arh1,arh2,uf,arf1,arf2,vh,vf,mh,c1,c2,mf,ust,znt,u1,v1,s1,  &
                      divx,rho,rr,rf,t11,t12,t13,t22,t23,t33,ua,va,wa,dissten)
      ENDIF

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Get statistics
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      reset = .false.

      if( dostat )then
        IF(axisymm.eq.0)THEN
          ! for Cartesian grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ppten(i,j,k)=rho(i,j,k)
          enddo
          enddo
          enddo
        ELSE
          ! for axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ppten(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
          enddo
          enddo
          enddo
        ENDIF
        call     statpack(nrec,ndt,dt,dtlast,rtime,adt,acfl,cloudvar,qname,budname,qbudget,asq,bsq, &
                          xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,vf,zh,mh,rmh,mf,    &
                          zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf,               &
                          rstat,pi0,rho0,thv0,th0,qv0,u0,v0,                &
                          dum1,dum2,dum3,dum4,dum5,ppten,prs,               &
                          ua,va,wa,ppi,tha,qa,qten,kmh,kmv,khh,khv,tkea,pta,u10,v10,reset)
        if(statfrq.gt.0.0) stattim=stattim+statfrq
      endif

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Writeout and stuff
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      if(myid.eq.0)then
        if(timeformat.eq.1)then
          write(6,110) nstep,rtime,' sec '
        elseif(timeformat.eq.2)then
          write(6,110) nstep,rtime/60.0,' min '
        elseif(timeformat.eq.3)then
          write(6,110) nstep,rtime/3600.0,' hour'
        elseif(timeformat.eq.4)then
          write(6,110) nstep,rtime/86400.0,' day '
        else
          write(6,110) nstep,rtime,' sec'
        endif
110     format(2x,i12,4x,f18.6,a5)
      endif
      if(timestats.ge.1) time_misc=time_misc+mytime()

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      if( dowrite )then
        nwrite=nwrite+1
      IF(output_format.eq.1.or.output_format.eq.2)THEN
        nn = 1
        if(terrain_flag .and. output_interp.eq.1) nn = 2
        if(output_format.eq.2) nn = 1
        DO n=1,nn
          if(n.eq.1)then
            fnum = 51
          else
            fnum = 71
          endif
          IF( stopit )THEN
            ! diag code does not account for stopit, so just set arrays to zero
            ! to avoid confusion
            tdiag = 0.0
            qdiag = 0.0
          ENDIF
          call writeout(rtime,dt,fnum,nwrite,qname,xh,xf,uf,yh,yf,vf,xfref,yfref,              &
                        rds,sigma,rdsf,sigmaf,zh,zf,mf,gx,gy,                                  &
                        pi0,prs0,rho0,rr0,rf0,rrf0,th0,qv0,u0,v0,                              &
                        zs,rgzu,rgzv,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,psfc,      &
                        rxh,arh1,arh2,uh,ruh,rxf,arf1,arf2,vh,rvh,mh,rmf,rr,rf,                &
                        gz,rgz,gzu,gzv,gxu,gyv,dzdx,dzdy,c1,c2,                                &
                        cd,ch,cq,tlh,dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,                  &
                        t11,t12,t13,t22,t23,t33,rho,prs,sten,                                  &
                        rru,ua,u3d,uten,rrv,va,v3d,vten,rrw,wa,w3d,wten,ppi,tha,               &
                        us,vs,ws,thadv,thten,nm,defv,defh,dissten,                             &
                        thpten,qvpten,qcpten,qipten,upten,vpten,                               &
                        lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,  &
                        qa,kmh,kmv,khh,khv,tkea,swten,lwten,                                   &
                        radsw,rnflx,radswnet,radlwin,dsr,olr,pta,                              &
                        num_soil_layers,u10,v10,t2,q2,znt,ust,u1,v1,s1,                        &
                        hpbl,zol,mol,br,psim,psih,qsfc,                                        &
                        dat1,dat2,dat3,reqt,ntdiag,nqdiag,tdiag,qdiag,                         &
                        nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
        ENDDO
#ifdef HDFOUT
      ELSEIF(output_format.ge.3)THEN
        call writeout_mult_hdf5(rtime,qname,rds,sigma,rdsf,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf, &
                      pi0,prs0,rho0,th0,qv0,u0,v0,                     &
                      zs,gz,rgz,rgzu,rgzv,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cd,ch,cq,dum1,dum2,dum3,dum4,  &
                      dum5,dum6,rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,    &
                      qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,   &
                      dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
! See above note about sten being used for dbz calculation
#endif
      ENDIF
        if(tapfrq.gt.0.0) taptim=taptim+tapfrq
        if(timestats.ge.1) time_write=time_write+mytime()
      endif

!--------------------------------------------------------------------
!  Write parcel data:
!--------------------------------------------------------------------

      if(iprcl.eq.1)then
      IF( doprclout )THEN
        call     parcel_interp(dt,xh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                               zh,mh,rmh,zf,mf,znt,ust,c1,c2,          &
                               pi0,th0,thv0,qv0,qc0,qi0,rth0,          &
                               dum1,dum2,dum3,dum4,dum5,dum6,prs,rho,  &
                               sten,dum7,dum8,wten,wten1,              &
                               u3d,v3d,w3d,pp3d,thten,thten1,th3d,q3d, &
                               kmh,kmv,khh,khv,tke3d,pt3d,pdata,       &
                               packet,reqs_p,                          &
                               pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,        &
                               nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
        call parcel_write(prec,rtime,qname,pdata,ploc)
        if(prclfrq.gt.0.0) prcltim = prcltim + prclfrq
        if(timestats.ge.1) time_parcels=time_parcels+mytime()
      ENDIF
      endif

!-------------------------------------------------------------------

      if( dorestart )then
        nrst=nrst+1
        if(rstfrq.gt.0.0) rsttim=rsttim+rstfrq
        call     write_restart(nstep,nrec,prec,nwrite,nrst,num_soil_layers,         &
                               dt,dtlast,mtime,ndt,adt,acfl,dbldt,mass1,            &
                               stattim,taptim,rsttim,radtim,prcltim,                &
                               qbudget,asq,bsq,qname,                               &
                               xfref,yfref,zh,zf,sigma,sigmaf,zs,                   &
                               th0,prs0,pi0,rho0,qv0,u0,v0,                         &
                               rain,sws,svs,sps,srs,sgs,sus,shs,                    &
                               tsk,znt,ust,cd,ch,cq,u1,v1,s1,thflux,qvflux,         &
                               radbcw,radbce,radbcs,radbcn,                         &
                               rho,prs,ua,va,wa,ppi,tha,qa,tkea,                    &
                               swten,lwten,radsw,rnflx,radswnet,radlwin,rad2d,      &
                               effc,effi,effs,effr,effg,effis,                      &
                               lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,      &
                               hpbl,wspd,psim,psih,gz1oz0,br,                       &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                       &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                    &
                               CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,       &
                               f2d,gsw,glw,chklowq,capg,snowc,fm,fh,tslb,           &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,               &
                               qpten,qtten,qvten,qcten,pta,pdata,ploc,ppx,sten,     &
                               ntdiag,nqdiag,tdiag,qdiag,                           &
                               dum1,dat1,dat2,dat3,reqt)
        if(timestats.ge.1) time_restart=time_restart+mytime()
      endif

!-------------------------------------------------------------------

      IF( adapt_dt.eq.1 .and. reset )THEN
        ndt  = 0
        adt  = 0.0
        acfl = 0.0
      ENDIF

      if(stopit)then
        if(myid.eq.0)then
          print *
          print *,' Courant number has exceeded 1.5 '
          print *
          print *,' Stopping model .... '
          print *
        endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        call stopcm1
      endif

      return
      end subroutine solve

sounde.F        1587424407  1602  20    100644  27283     `


      subroutine sounde(dt,xh,arh1,arh2,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                        rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,mf,         &
                        pi0,rho0,rr0,rf0,rrf0,th0,rth0,zs,                &
                        gz,rgz,gzu,rgzu,gzv,rgzv,                         &
                        dzdx,dzdy,gx,gxu,gy,gyv,                          &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,dum4,dum5,dum6,                    &
                        ppd ,fpk ,qk ,pk1,pk2,ftk,sk ,tk1,tk2,            &
                        u0,rru,us,ua,u3d,uten,                            &
                        v0,rrv,vs,va,v3d,vten,                            &
                        rrw,ws,wa,w3d,wten,                               &
                        ppi,pp3d,piadv,ppten,ppx,                         &
                        tha,th3d,thadv,thten,thterm,                      &
                        thv,ppterm,nrk,dttmp,rtime,get_time_avg,          &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,arh1,arh2,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,rr0,rf0,rrf0,th0,rth0
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,dum5,dum6
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppd,fpk,qk,pk1,pk2,ftk,sk,tk1,tk2
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: rru,us,ua,u3d,uten
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: rrv,vs,va,v3d,vten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: rrw,ws,wa,w3d,wten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,piadv,ppten,ppx
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thadv,thten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: thterm,thv,ppterm
      integer, intent(in) :: nrk
      real, intent(in)  :: dttmp,rtime
      logical, intent(in) :: get_time_avg
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      integer, intent(inout), dimension(rmp) :: reqs_p

!-----

      integer :: i,j,k,n,nloop
      real :: tem,tem1,tem2,tem3,tem4,r1,r2,dts

      real :: temx,temy,u1,u2,v1,v2,w1,w2,ww,tavg,div

!---------------------------------------------------------------------

      if(nrk.eq.1)then
!!!        nloop=1
!!!        dts=dt/3.
        nloop=nint(float(nsound)/3.0)
        dts=dt/(nloop*3.0)
        if( dts.gt.(dt/nsound) )then
          nloop=nloop+1
          dts=dt/(nloop*3.0)
        endif
      elseif(nrk.eq.2)then
        nloop=0.5*nsound
        dts=dt/nsound
      elseif(nrk.eq.3)then
        nloop=nsound
        dts=dt/nsound
      endif

!!!      print *,'  nloop,dts,dttmp = ',nloop,dts,nloop*dts

!-----------------------------------------------------------------
!  define ppd first, then start comm:

      if( nrk.eq.1 )then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=ppi(i,j,k)+ppx(i,j,k)
        enddo
        enddo
        enddo

      else

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=ppi(i,j,k)+ppx(i,j,k)
          pp3d(i,j,k)=ppi(i,j,k)
        enddo
        enddo
        enddo

      endif
      if(timestats.ge.1) time_sound=time_sound+mytime()

      call bcs(ppd)
#ifdef MPI
      call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                             ps1,ps2,pn1,pn2,reqs_p)
#endif

!---------------------------------------------------------------------
!  Arrays for vadv:

      IF(.not.terrain_flag)THEN

        ! without terrain:
        ! "s" velocities ARE NOT coupled with reference density
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem,tem1,r1,r2)
        do k=1,nk
          r2 = dts*rdz*mh(1,1,k)*rr0(1,1,k)*rf0(1,1,k+1)
          r1 = dts*rdz*mh(1,1,k)*rr0(1,1,k)*rf0(1,1,k)
          do j=1,nj
          do i=1,ni
            pk2(i,j,k) = r2*( -c2(1,1,k+1)*piadv(i,j,k+1)+(1.0-c1(1,1,k+1))*piadv(i,j,k) )
            pk1(i,j,k) = r1*( +c1(1,1,k  )*piadv(i,j,k-1)+(c2(1,1,k  )-1.0)*piadv(i,j,k) )
            tk2(i,j,k) = r2*( -c2(1,1,k+1)*thadv(i,j,k+1)+(1.0-c1(1,1,k+1))*thadv(i,j,k) )
            tk1(i,j,k) = r1*( +c1(1,1,k  )*thadv(i,j,k-1)+(c2(1,1,k  )-1.0)*thadv(i,j,k) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni+1
            us(i,j,k)=u3d(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              vs(i,j,k)=v3d(i,j,k)
            enddo
            enddo
          ENDIF
          IF(k.gt.1)THEN
            do j=1,nj
            do i=1,ni
              ws(i,j,k)=w3d(i,j,k)
            enddo
            enddo
          ENDIF
        enddo

      ELSE

        ! with terrain:
        ! "s" velocities ARE coupled with reference density
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem,tem1,r1,r2)
        do k=1,nk
          do j=1,nj
          do i=1,ni
            r2 = dts*gz(i,j)*rdsf(k)*rr0(i,j,k)*rf0(i,j,k+1)
            r1 = dts*gz(i,j)*rdsf(k)*rr0(i,j,k)*rf0(i,j,k)
            pk2(i,j,k) = r2*( -c2(i,j,k+1)*piadv(i,j,k+1)+(1.0-c1(i,j,k+1))*piadv(i,j,k) )
            pk1(i,j,k) = r1*( +c1(i,j,k  )*piadv(i,j,k-1)+(c2(i,j,k  )-1.0)*piadv(i,j,k) )
            tk2(i,j,k) = r2*( -c2(i,j,k+1)*thadv(i,j,k+1)+(1.0-c1(i,j,k+1))*thadv(i,j,k) )
            tk1(i,j,k) = r1*( +c1(i,j,k  )*thadv(i,j,k-1)+(c2(i,j,k  )-1.0)*thadv(i,j,k) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni+1
            us(i,j,k)=rru(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              vs(i,j,k)=rrv(i,j,k)
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              ws(i,j,k)=rrw(i,j,k)
            enddo
            enddo
          ELSE
            do j=1,nj
            do i=1,ni
              dum3(i,j,1)=0.0
              dum3(i,j,nk+1)=0.0
            enddo
            enddo
          ENDIF
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        pk1(i,j,1) = 0.0
        tk1(i,j,1) = 0.0
        pk2(i,j,nk) = 0.0
        tk2(i,j,nk) = 0.0
      enddo
      enddo

!---------------------------------------------------------------------
!  Prepare for acoustic steps

      if( nrk.ge.2 )then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1,ni+1
            u3d(i,j,k)=ua(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              v3d(i,j,k)=va(i,j,k)
            enddo
            enddo
          ENDIF
          IF(k.ge.2)THEN
            do j=1,nj
            do i=1,ni
              w3d(i,j,k)=wa(i,j,k)
            enddo
            enddo
          ENDIF
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=tha(i,j,k)
          enddo
          enddo
        enddo

      endif

!---------------------------------------------------------------------

      IF( get_time_avg )THEN
        tavg = 1.0/float(nloop)
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
          do k=1,nk
            do j=1,nj
            do i=1,ni+1
              rru(i,j,k)=0.0
            enddo
            enddo
            IF(axisymm.eq.0)THEN
              ! Cartesian grid:
              do j=1,nj+1
              do i=1,ni
                rrv(i,j,k)=0.0
              enddo
              enddo
            ENDIF
            IF(k.ge.2)THEN
              do j=1,nj
              do i=1,ni
                rrw(i,j,k)=0.0
              enddo
              enddo
            ENDIF
          enddo
    ENDIF      ! endif for get_time_avg check


      if(timestats.ge.1) time_sound=time_sound+mytime()

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  Begin small steps:

      small_step_loop:  DO N=1,NLOOP

!-----

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,u3d)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,v3d)
 
        endif

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  Open boundary conditions:

        IF(wbc.eq.2.and.ibw.eq.1)THEN
          ! west open bc tendency:
          call   ssopenbcw(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbcw,dum1,u3d,uten,dts)
        ENDIF
        IF(ebc.eq.2.and.ibe.eq.1)THEN
          ! east open bc tendency:
          call   ssopenbce(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbce,dum1,u3d,uten,dts)
        ENDIF

        IF(roflux.eq.1)THEN
          call restrict_openbc_we(rvh,rmh,rho0,u3d)
        ENDIF

!-----

      IF(axisymm.eq.0)THEN
        IF(sbc.eq.2.and.ibs.eq.1)THEN
          ! south open bc tendency:
          call   ssopenbcs(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcs,dum1,v3d,vten,dts)
        ENDIF
        IF(nbc.eq.2.and.ibn.eq.1)THEN
          ! north open bc tendency:
          call   ssopenbcn(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcn,dum1,v3d,vten,dts)
        ENDIF

        IF(roflux.eq.1)THEN
          call restrict_openbc_sn(ruh,rmh,rho0,v3d)
        ENDIF
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  integrate u,v forward in time:

#ifdef MPI
          call comm_1s_end(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
#endif

!-----

    IF(.not.terrain_flag)THEN

      IF(axisymm.eq.0)THEN
        ! Cartesian grid without terrain:

        tem1 = rdx*cp*0.5
        tem2 = rdy*cp*0.5
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)         &
                   -tem1*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i)    &
                        *(thv(i,j,k)+thv(i-1,j,k)) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)         &
                   -tem2*(ppd(i,j,k)-ppd(i,j-1,k))*vf(j)    &
                        *(thv(i,j,k)+thv(i,j-1,k)) )
          enddo
          enddo
        enddo

      ELSE
        ! axisymmetric grid:

        tem1 = rdx*cp*0.5
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)         &
                   -tem1*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i)    &
                        *(thv(i,j,k)+thv(i-1,j,k)) )
          enddo
          enddo
        enddo

      ENDIF

    ELSE

        ! Cartesian grid with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+1
          ! dum1 stores ppd at w-pts:
          ! lowest model level:
          do i=0,ni+1
            dum1(i,j,1) = cgs1*ppd(i,j,1)+cgs2*ppd(i,j,2)+cgs3*ppd(i,j,3)
          enddo
          ! upper-most model level:
          do i=0,ni+1
            dum1(i,j,nk+1) = cgt1*ppd(i,j,nk)+cgt2*ppd(i,j,nk-1)+cgt3*ppd(i,j,nk-2)
          enddo
          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+1
            dum1(i,j,k) = r1*ppd(i,j,k-1)+r2*ppd(i,j,k)
          enddo
          enddo
        enddo

        tem1 = rdx*cp*0.5
        tem2 = rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          ! x-dir
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)               &
                   -cp*0.5*(thv(i,j,k)+thv(i-1,j,k))*(            &
                   ( ppd(i  ,j,k)*rgz(i  ,j)                      &
                    -ppd(i-1,j,k)*rgz(i-1,j)                      &
                   )*gzu(i,j)*rdx*uf(i)                           &
              +0.5*( gxu(i,j,k+1)*(dum1(i,j,k+1)+dum1(i-1,j,k+1)) &
                    -gxu(i,j,k  )*(dum1(i,j,k  )+dum1(i-1,j,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)               &
                   -cp*0.5*(thv(i,j,k)+thv(i,j-1,k))*(            &
                   ( ppd(i,j  ,k)*rgz(i,j  )                      &
                    -ppd(i,j-1,k)*rgz(i,j-1)                      &
                   )*gzv(i,j)*rdy*vf(j)                           &
              +0.5*( gyv(i,j,k+1)*(dum1(i,j,k+1)+dum1(i,j-1,k+1)) &
                    -gyv(i,j,k  )*(dum1(i,j,k  )+dum1(i,j-1,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
        enddo

    ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

      ENDIF

      if(timestats.ge.1) time_sound=time_sound+mytime()

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  integrate w forward in time:

      IF(.not.terrain_flag)THEN
        ! without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem1)
        do k=2,nk
        tem1 = rdz*cp*mf(1,1,k)
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=w3d(i,j,k)+dts*( wten(i,j,k)                     &
                  -tem1*(ppd(i,j,k)-ppd(i,j,k-1))                     &
                       *(c2(1,1,k)*thv(i,j,k)+c1(1,1,k)*thv(i,j,k-1)) &
                +g*( c2(1,1,k)*th3d(i,j,k)*rth0(1,1,k)                &
                    +c1(1,1,k)*th3d(i,j,k-1)*rth0(1,1,k-1) ) )
        enddo
        enddo
        enddo

      ELSE
        ! with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem1)
        do k=2,nk
        tem1 = rds(k)*cp
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=w3d(i,j,k)+dts*( wten(i,j,k)                     &
                  -tem1*(ppd(i,j,k)-ppd(i,j,k-1))*gz(i,j)             &
                       *(c2(i,j,k)*thv(i,j,k)+c1(i,j,k)*thv(i,j,k-1)) &
                +g*( c2(i,j,k)*th3d(i,j,k)*rth0(i,j,k)                &
                    +c1(i,j,k)*th3d(i,j,k-1)*rth0(i,j,k-1) ) )
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)

      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  get terms for div,vadv (terrain only):

      IF(terrain_flag)THEN
        ! Cartesian grid with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,k)=u3d(i,j,k)*rgzu(i,j)
            dum4(i,j,k)=0.5*(rho0(i-1,j,k)+rho0(i,j,k))*dum1(i,j,k)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            dum2(i,j,k)=v3d(i,j,k)*rgzv(i,j)
            dum5(i,j,k)=0.5*(rho0(i,j-1,k)+rho0(i,j,k))*dum2(i,j,k)
          enddo
          enddo
        ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        DO k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do j=1,nj
          do i=1,ni
            dum3(i,j,k)=w3d(i,j,k)                                               &
                       +0.5*( ( r2*(dum1(i,j,k  )+dum1(i+1,j,k  ))               &
                               +r1*(dum1(i,j,k-1)+dum1(i+1,j,k-1)) )*dzdx(i,j)   &
                             +( r2*(dum2(i,j,k  )+dum2(i,j+1,k  ))               &
                               +r1*(dum2(i,j,k-1)+dum2(i,j+1,k-1)) )*dzdy(i,j)   &
                            )*(sigmaf(k)-zt)*gz(i,j)*rzt
            ! NOTE:  dum6 is NOT coupled with density
            dum6(i,j,k)=w3d(i,j,k)                                               &
                       +0.5*( ( r2*(dum4(i,j,k  )+dum4(i+1,j,k  ))               &
                               +r1*(dum4(i,j,k-1)+dum4(i+1,j,k-1)) )*dzdx(i,j)   &
                             +( r2*(dum5(i,j,k  )+dum5(i,j+1,k  ))               &
                               +r1*(dum5(i,j,k-1)+dum5(i,j+1,k-1)) )*dzdy(i,j)   &
                            )*(sigmaf(k)-zt)*gz(i,j)*rzt * rrf0(i,j,k)
          enddo
          enddo
        ENDDO
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  get new pp,th

      temx = dts*0.5*rdx
      temy = dts*0.5*rdy

!$omp parallel do default(shared)   &
!$omp private(i,j,k,div,u1,u2,v1,v2,w1,w2,tem)
      DO k=1,nk

    IF( axisymm.eq.0 )THEN
      IF(.not.terrain_flag)THEN
        ! Cartesian grid, without terrain:
        do j=1,nj
        do i=1,ni
          div=(u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)    &
             +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)    &
             +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(1,1,k)
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(u3d(i+1,j,k)-us(i+1,j,k))*uh(i)
          u1 = temx*(u3d(i  ,j,k)-us(i  ,j,k))*uh(i)
          v2 = temy*(v3d(i,j+1,k)-vs(i,j+1,k))*vh(j)
          v1 = temy*(v3d(i,j  ,k)-vs(i,j  ,k))*vh(j)
          w2 = w3d(i,j,k+1)-ws(i,j,k+1)
          w1 = w3d(i,j,k  )-ws(i,j,k  )
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+dts*( ppten(i,j,k)-ppterm(i,j,k)*div )  &
                 +( -( u2*(piadv(i+1,j,k)-piadv(i  ,j,k))                 &
                      +u1*(piadv(i  ,j,k)-piadv(i-1,j,k)) )               &
                    -( v2*(piadv(i,j+1,k)-piadv(i,j  ,k))                 &
                      +v1*(piadv(i,j  ,k)-piadv(i,j-1,k)) ) )             &
                    +( w1*pk1(i,j,k)+w2*pk2(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+dts*( thten(i,j,k)-thterm(i,j,k)*div )  &
                 +( -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    -( v2*(thadv(i,j+1,k)-thadv(i,j  ,k))                 &
                      +v1*(thadv(i,j  ,k)-thadv(i,j-1,k)) ) )             &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
      ELSE
        ! Cartesian grid, with terrain:
        do j=1,nj
        do i=1,ni
          div = gz(i,j)*( (dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)  &
                         +(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)  &
                         +(dum3(i,j,k+1)-dum3(i,j,k))*rdsf(k) )
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(dum4(i+1,j,k)-us(i+1,j,k))*uh(i)
          u1 = temx*(dum4(i  ,j,k)-us(i  ,j,k))*uh(i)
          v2 = temy*(dum5(i,j+1,k)-vs(i,j+1,k))*vh(j)
          v1 = temy*(dum5(i,j  ,k)-vs(i,j  ,k))*vh(j)
          w2 = dum6(i,j,k+1)-ws(i,j,k+1)*rrf0(i,j,k+1)
          w1 = dum6(i,j,k  )-ws(i,j,k  )*rrf0(i,j,k  )
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+dts*( ppten(i,j,k)-ppterm(i,j,k)*div )  &
                 +( -( u2*(piadv(i+1,j,k)-piadv(i  ,j,k))                 &
                      +u1*(piadv(i  ,j,k)-piadv(i-1,j,k)) )               &
                    -( v2*(piadv(i,j+1,k)-piadv(i,j  ,k))                 &
                      +v1*(piadv(i,j  ,k)-piadv(i,j-1,k)) ) )*rr0(i,j,k)*gz(i,j) &
                    +( w1*pk1(i,j,k)+w2*pk2(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+dts*( thten(i,j,k)-thterm(i,j,k)*div )  &
                 +( -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    -( v2*(thadv(i,j+1,k)-thadv(i,j  ,k))                 &
                      +v1*(thadv(i,j  ,k)-thadv(i,j-1,k)) ) )*rr0(i,j,k)*gz(i,j) &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
      ENDIF
    ELSE
        ! axisymmetric grid:
        do j=1,nj
        do i=1,ni
          div=(arh2(i)*u3d(i+1,j,k)-arh1(i)*u3d(i,j,k))*rdx*uh(i)   &
             +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(1,1,k)
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(u3d(i+1,j,k)-us(i+1,j,k))*uh(i)*arh2(i)
          u1 = temx*(u3d(i  ,j,k)-us(i  ,j,k))*uh(i)*arh1(i)
          w2 = w3d(i,j,k+1)-ws(i,j,k+1)
          w1 = w3d(i,j,k  )-ws(i,j,k  )
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+dts*( ppten(i,j,k)-ppterm(i,j,k)*div )  &
                    -( u2*(piadv(i+1,j,k)-piadv(i  ,j,k))                 &
                      +u1*(piadv(i  ,j,k)-piadv(i-1,j,k)) )               &
                    +( w1*pk1(i,j,k)+w2*pk2(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+dts*( thten(i,j,k)-thterm(i,j,k)*div )  &
                    -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
    ENDIF

      ENDDO
      if(timestats.ge.1) time_sound=time_sound+mytime()

        IF( n.lt.nloop )THEN
          call bcs(ppd)
#ifdef MPI
          call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                                 ps1,ps2,pn1,pn2,reqs_p)
#endif
        ENDIF

!--------------------------------------------------------------------
!  time-averaged velocities:

    IF( get_time_avg )THEN
      IF(.not.terrain_flag)THEN
        !-----
        ! without terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
        DO k=1,nk
          tem = rho0(1,1,k)*tavg
          do j=1,nj
          do i=1,ni+1
            rru(i,j,k)=rru(i,j,k)+u3d(i,j,k)*tem
          enddo
          enddo
          IF( axisymm.eq.0 )THEN
            do j=1,nj+1
            do i=1,ni
              rrv(i,j,k)=rrv(i,j,k)+v3d(i,j,k)*tem
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            tem = rf0(1,1,k)*tavg
            do j=1,nj
            do i=1,ni
              rrw(i,j,k)=rrw(i,j,k)+w3d(i,j,k)*tem
            enddo
            enddo
          ENDIF
        ENDDO
        !-----
      ELSE
        !-----
        ! with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            rru(i,j,k)=rru(i,j,k)+dum4(i,j,k)*tavg
          enddo
          enddo
          IF( axisymm.eq.0 )THEN
            do j=1,nj+1
            do i=1,ni
              rrv(i,j,k)=rrv(i,j,k)+dum5(i,j,k)*tavg
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              rrw(i,j,k)=rrw(i,j,k)+dum6(i,j,k)*rf0(i,j,k)*tavg
            enddo
            enddo
          ENDIF
        ENDDO
        !-----
      ENDIF    ! endif for terrain check
    ENDIF      ! endif for get_time_avg check
      if(timestats.ge.1) time_sound=time_sound+mytime()

!--------------------------------------------------------------------

      ENDDO  small_step_loop

!  end of small steps
!--------------------------------------------------------------------

      IF( nrk.eq.3 )THEN
        ! pressure tendency term: save for next timestep:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppx(i,j,k)=dum1(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
      if(timestats.ge.1) time_sound=time_sound+mytime()


      call bcu(u3d)
      IF(axisymm.eq.0)THEN
        call bcv(v3d)
      ENDIF
      call bcw(w3d,1)
      if(terrain_flag) call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)
      if(nrk.lt.3)then
        call bcs(th3d)
        call bcs(pp3d)
      endif


      end subroutine sounde



sound.F         1587424407  1602  20    100644  35196     `


      subroutine sound( dt,xh,arh1,arh2,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,     &
                        rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,mf,         &
                        pi0,rho0,rr0,rf0,rrf0,th0,rth0,zs,                &
                        gz,rgz,gzu,rgzu,gzv,rgzv,                         &
                        dzdx,dzdy,gx,gxu,gy,gyv,                          &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,fwk ,mm  ,bk  ,                    &
                        ppd ,fpk ,qk ,pk1,pk2,ftk,sk ,tk1,tk2,            &
                        u0,rru,us,ua,u3d,uten,                            &
                        v0,rrv,vs,va,v3d,vten,                            &
                        rrw,ws,wa,w3d,wten,                               &
                        ppi,pp3d,piadv,ppten,ppx,                         &
                        tha,th3d,thadv,thten,thterm,                      &
                        thv,ppterm,nrk,dttmp,rtime,get_time_avg,          &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,arh1,arh2,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,rr0,rf0,rrf0,th0,rth0
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,fwk,mm,bk
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppd,fpk,qk,pk1,pk2,ftk,sk,tk1,tk2
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: rru,us,ua,u3d,uten
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: rrv,vs,va,v3d,vten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: rrw,ws,wa,w3d,wten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,piadv,ppten,ppx
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thadv,thten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: thterm,thv,ppterm
      integer, intent(in) :: nrk
      real, intent(in)  :: dttmp,rtime
      logical, intent(in) :: get_time_avg
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      integer, intent(inout), dimension(rmp) :: reqs_p

!-----

      integer :: i,j,k,n,nloop
      real :: tem,tem1,tem2,tem3,tem4,r1,r2,dts
      real :: beta,aa,bb,cc,dd,asq

      real :: temx,temy,u1,u2,v1,v2,w1,w2,ww,tavg,div

!---------------------------------------------------------------------
      ! beta = backward weight
      ! alph = forward weight

      beta=1.0-alph
      asq=alph*alph

      if(nrk.eq.1)then
!!!        nloop=1
!!!        dts=dt/3.
        nloop=nint(float(nsound)/3.0)
        dts=dt/(nloop*3.0)
        if( dts.gt.(dt/nsound) )then
          nloop=nloop+1
          dts=dt/(nloop*3.0)
        endif
      elseif(nrk.eq.2)then
        nloop=0.5*nsound
        dts=dt/nsound
      elseif(nrk.eq.3)then
        nloop=nsound
        dts=dt/nsound
      endif

!!!      print *,'  nloop,dts,dttmp = ',nloop,dts,nloop*dts

!-----------------------------------------------------------------
!  define ppd first, then start comm:

      if( nrk.eq.1 )then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=ppi(i,j,k)+ppx(i,j,k)
        enddo
        enddo
        enddo

      else

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=ppi(i,j,k)+ppx(i,j,k)
          pp3d(i,j,k)=ppi(i,j,k)
        enddo
        enddo
        enddo

      endif
      if(timestats.ge.1) time_sound=time_sound+mytime()

      call bcs(ppd)
#ifdef MPI
      call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                             ps1,ps2,pn1,pn2,reqs_p)
#endif

!---------------------------------------------------------------------
!  Arrays for vertically implicit solver

      IF(.not.terrain_flag)THEN

        ! without terrain:
        ! "s" velocities ARE NOT coupled with reference density
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem,tem1,r1,r2)
        do k=1,nk
          tem = dts*rdz*mh(1,1,k)
          r2 = dts*rdz*mh(1,1,k)*rr0(1,1,k)*rf0(1,1,k+1)
          r1 = dts*rdz*mh(1,1,k)*rr0(1,1,k)*rf0(1,1,k)
          do j=1,nj
          do i=1,ni
            qk(i,j,k) = tem*ppterm(i,j,k)
            sk(i,j,k) = tem*thterm(i,j,k)
            pk2(i,j,k) = r2*( -c2(1,1,k+1)*piadv(i,j,k+1)+(1.0-c1(1,1,k+1))*piadv(i,j,k) )
            pk1(i,j,k) = r1*( +c1(1,1,k  )*piadv(i,j,k-1)+(c2(1,1,k  )-1.0)*piadv(i,j,k) )
            tk2(i,j,k) = r2*( -c2(1,1,k+1)*thadv(i,j,k+1)+(1.0-c1(1,1,k+1))*thadv(i,j,k) )
            tk1(i,j,k) = r1*( +c1(1,1,k  )*thadv(i,j,k-1)+(c2(1,1,k  )-1.0)*thadv(i,j,k) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni+1
            us(i,j,k)=u3d(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              vs(i,j,k)=v3d(i,j,k)
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              ws(i,j,k)=w3d(i,j,k)
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            tem = dts*g/(c2(1,1,k)*th0(1,1,k)+c1(1,1,k)*th0(1,1,k-1))
            tem1 = dts*rdz*cp*mf(1,1,k)
            do j=1,nj
            do i=1,ni
              bk(i,j,k) = tem
              mm(i,j,k) = tem1*(c2(1,1,k)*thv(i,j,k)+c1(1,1,k)*thv(i,j,k-1))
            enddo
            enddo
          ENDIF
        enddo

      ELSE

        ! with terrain:
        ! "s" velocities ARE coupled with reference density
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem,tem1,r1,r2)
        do k=1,nk
          tem = dts*rdsf(k)
          do j=1,nj
          do i=1,ni
            qk(i,j,k) = tem*ppterm(i,j,k)*gz(i,j)
            sk(i,j,k) = tem*thterm(i,j,k)*gz(i,j)
            r2 = dts*gz(i,j)*rdsf(k)*rr0(i,j,k)*rf0(i,j,k+1)
            r1 = dts*gz(i,j)*rdsf(k)*rr0(i,j,k)*rf0(i,j,k)
            pk2(i,j,k) = r2*( -c2(i,j,k+1)*piadv(i,j,k+1)+(1.0-c1(i,j,k+1))*piadv(i,j,k) )
            pk1(i,j,k) = r1*( +c1(i,j,k  )*piadv(i,j,k-1)+(c2(i,j,k  )-1.0)*piadv(i,j,k) )
            tk2(i,j,k) = r2*( -c2(i,j,k+1)*thadv(i,j,k+1)+(1.0-c1(i,j,k+1))*thadv(i,j,k) )
            tk1(i,j,k) = r1*( +c1(i,j,k  )*thadv(i,j,k-1)+(c2(i,j,k  )-1.0)*thadv(i,j,k) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni+1
            us(i,j,k)=rru(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              vs(i,j,k)=rrv(i,j,k)
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              ws(i,j,k)=rrw(i,j,k)
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            tem = dts*g
            tem1 = dts*rds(k)*cp
            do j=1,nj
            do i=1,ni
              bk(i,j,k) = tem/(c2(i,j,k)*th0(i,j,k)+c1(i,j,k)*th0(i,j,k-1))
              mm(i,j,k) = tem1*(c2(i,j,k)*thv(i,j,k)+c1(i,j,k)*thv(i,j,k-1))*gz(i,j)
            enddo
            enddo
          ELSE
            do j=1,nj
            do i=1,ni
              dum3(i,j,1)=0.0
              dum3(i,j,nk+1)=0.0
            enddo
            enddo
          ENDIF
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        pk1(i,j,1) = 0.0
        tk1(i,j,1) = 0.0
        pk2(i,j,nk) = 0.0
        tk2(i,j,nk) = 0.0
      enddo
      enddo

!---------------------------------------------------------------------
!  Prepare for acoustic steps

      if( nrk.ge.2 )then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1,ni+1
            u3d(i,j,k)=ua(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              v3d(i,j,k)=va(i,j,k)
            enddo
            enddo
          ENDIF
          IF(k.ge.2)THEN
            do j=1,nj
            do i=1,ni
              w3d(i,j,k)=wa(i,j,k)
            enddo
            enddo
          ENDIF
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=tha(i,j,k)
          enddo
          enddo
        enddo

      endif

!---------------------------------------------------------------------

      IF( get_time_avg )THEN
        tavg = 1.0/float(nloop)
        IF(.not.terrain_flag)THEN
          ! without terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
          do k=1,nk
            do j=1,nj
            do i=1,ni+1
              rru(i,j,k)=0.0
            enddo
            enddo
            IF(axisymm.eq.0)THEN
              ! Cartesian grid:
              do j=1,nj+1
              do i=1,ni
                rrv(i,j,k)=0.0
              enddo
              enddo
            ENDIF
            IF(k.ge.2)THEN
              tem = rf0(1,1,k)*tavg*beta
              do j=1,nj
              do i=1,ni
                rrw(i,j,k)=wa(i,j,k)*tem
              enddo
              enddo
            ENDIF
          enddo
        ELSE
          ! with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
          do k=1,nk
            do j=1,nj
            do i=1,ni+1
              rru(i,j,k)=0.0
            enddo
            enddo
            IF(axisymm.eq.0)THEN
              ! Cartesian grid:
              do j=1,nj+1
              do i=1,ni
                rrv(i,j,k)=0.0
              enddo
              enddo
            ENDIF
            IF(k.ge.2)THEN
              tem = tavg*beta
              do j=1,nj
              do i=1,ni
                rrw(i,j,k)=wa(i,j,k)*rf0(i,j,k)*tem
              enddo
              enddo
            ENDIF
          enddo
      ENDIF    ! endif for terrain check
    ENDIF      ! endif for get_time_avg check



      tem = 1.0/dts


      IF(.not.terrain_flag)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k)=ppten(i,j,k)-tem*( ws(i,j,k  )*pk1(i,j,k) &
                                         +ws(i,j,k+1)*pk2(i,j,k) )
          thten(i,j,k)=thten(i,j,k)-tem*( ws(i,j,k  )*tk1(i,j,k) &
                                         +ws(i,j,k+1)*tk2(i,j,k) )
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k)=ppten(i,j,k)-tem*( ws(i,j,k  )*rrf0(i,j,k  )*pk1(i,j,k) &
                                         +ws(i,j,k+1)*rrf0(i,j,k+1)*pk2(i,j,k) )
          thten(i,j,k)=thten(i,j,k)-tem*( ws(i,j,k  )*rrf0(i,j,k  )*tk1(i,j,k) &
                                         +ws(i,j,k+1)*rrf0(i,j,k+1)*tk2(i,j,k) )
        enddo
        enddo
        enddo
      ENDIF


      if(timestats.ge.1) time_sound=time_sound+mytime()

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  Begin small steps:

      small_step_loop:  DO N=1,NLOOP

!-----

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,u3d)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,v3d)
 
        endif

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  Open boundary conditions:

        IF(wbc.eq.2.and.ibw.eq.1)THEN
          ! west open bc tendency:
          call   ssopenbcw(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbcw,dum1,u3d,uten,dts)
        ENDIF
        IF(ebc.eq.2.and.ibe.eq.1)THEN
          ! east open bc tendency:
          call   ssopenbce(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbce,dum1,u3d,uten,dts)
        ENDIF

        IF(roflux.eq.1)THEN
          call restrict_openbc_we(rvh,rmh,rho0,u3d)
        ENDIF

!-----

      IF(axisymm.eq.0)THEN
        IF(sbc.eq.2.and.ibs.eq.1)THEN
          ! south open bc tendency:
          call   ssopenbcs(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcs,dum1,v3d,vten,dts)
        ENDIF
        IF(nbc.eq.2.and.ibn.eq.1)THEN
          ! north open bc tendency:
          call   ssopenbcn(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcn,dum1,v3d,vten,dts)
        ENDIF

        IF(roflux.eq.1)THEN
          call restrict_openbc_sn(ruh,rmh,rho0,v3d)
        ENDIF
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  integrate u,v forward in time:

#ifdef MPI
          call comm_1s_end(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
#endif

!-----

    IF(.not.terrain_flag)THEN

      IF(axisymm.eq.0)THEN
        ! Cartesian grid without terrain:

        tem1 = rdx*cp*0.5
        tem2 = rdy*cp*0.5
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)         &
                   -tem1*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i)    &
                        *(thv(i,j,k)+thv(i-1,j,k)) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)         &
                   -tem2*(ppd(i,j,k)-ppd(i,j-1,k))*vf(j)    &
                        *(thv(i,j,k)+thv(i,j-1,k)) )
          enddo
          enddo
        enddo

      ELSE
        ! axisymmetric grid:

        tem1 = rdx*cp*0.5
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)         &
                   -tem1*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i)    &
                        *(thv(i,j,k)+thv(i-1,j,k)) )
          enddo
          enddo
        enddo

      ENDIF

    ELSE

        ! Cartesian grid with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+1
          ! dum1 stores ppd at w-pts:
          ! lowest model level:
          do i=0,ni+1
            dum1(i,j,1) = cgs1*ppd(i,j,1)+cgs2*ppd(i,j,2)+cgs3*ppd(i,j,3)
          enddo
          ! upper-most model level:
          do i=0,ni+1
            dum1(i,j,nk+1) = cgt1*ppd(i,j,nk)+cgt2*ppd(i,j,nk-1)+cgt3*ppd(i,j,nk-2)
          enddo
          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+1
            dum1(i,j,k) = r1*ppd(i,j,k-1)+r2*ppd(i,j,k)
          enddo
          enddo
        enddo

        tem1 = rdx*cp*0.5
        tem2 = rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          ! x-dir
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)               &
                   -cp*0.5*(thv(i,j,k)+thv(i-1,j,k))*(            &
                   ( ppd(i  ,j,k)*rgz(i  ,j)                      &
                    -ppd(i-1,j,k)*rgz(i-1,j)                      &
                   )*gzu(i,j)*rdx*uf(i)                           &
              +0.5*( gxu(i,j,k+1)*(dum1(i,j,k+1)+dum1(i-1,j,k+1)) &
                    -gxu(i,j,k  )*(dum1(i,j,k  )+dum1(i-1,j,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)               &
                   -cp*0.5*(thv(i,j,k)+thv(i,j-1,k))*(            &
                   ( ppd(i,j  ,k)*rgz(i,j  )                      &
                    -ppd(i,j-1,k)*rgz(i,j-1)                      &
                   )*gzv(i,j)*rdy*vf(j)                           &
              +0.5*( gyv(i,j,k+1)*(dum1(i,j,k+1)+dum1(i,j-1,k+1)) &
                    -gyv(i,j,k  )*(dum1(i,j,k  )+dum1(i,j-1,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
        enddo

    ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  get terms for horiz div (terrain only):

      IF(terrain_flag)THEN
        ! Cartesian grid with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,k)=u3d(i,j,k)*rgzu(i,j)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            dum2(i,j,k)=v3d(i,j,k)*rgzv(i,j)
          enddo
          enddo
        ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        DO k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do j=1,nj
          do i=1,ni
            dum3(i,j,k)=0.5*( ( r2*(dum1(i,j,k  )+dum1(i+1,j,k  ))               &
                               +r1*(dum1(i,j,k-1)+dum1(i+1,j,k-1)) )*dzdx(i,j)   &
                             +( r2*(dum2(i,j,k  )+dum2(i,j+1,k  ))               &
                               +r1*(dum2(i,j,k-1)+dum2(i,j+1,k-1)) )*dzdy(i,j)   &
                            )*(sigmaf(k)-zt)*gz(i,j)*rzt
          enddo
          enddo
        ENDDO
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  update arrays for vertically implicit solver

      temx = dts*0.5*rdx
      temy = dts*0.5*rdy

!$omp parallel do default(shared)   &
!$omp private(i,j,k,div,u1,u2,v1,v2,w1,w2)
    DO k=1,nk
    IF(axisymm.eq.0)THEN
      IF(.not.terrain_flag)THEN
        ! Cartesian grid without terrain:
        do j=1,nj
        do i=1,ni
          div = (u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)  &
               +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(u3d(i+1,j,k)-us(i+1,j,k))*uh(i)
          u1 = temx*(u3d(i  ,j,k)-us(i  ,j,k))*uh(i)
          v2 = temy*(v3d(i,j+1,k)-vs(i,j+1,k))*vh(j)
          v1 = temy*(v3d(i,j  ,k)-vs(i,j  ,k))*vh(j)
          fpk(i,j,k)=dts*( ppten(i,j,k)-ppterm(i,j,k)*div )     &
                 +( -( u2*(piadv(i+1,j,k)-piadv(i  ,j,k))       &
                      +u1*(piadv(i  ,j,k)-piadv(i-1,j,k)) )     &
                    -( v2*(piadv(i,j+1,k)-piadv(i,j  ,k))       &
                      +v1*(piadv(i,j  ,k)-piadv(i,j-1,k)) ) )   &
              +beta*( w3d(i,j,k  )*(pk1(i,j,k)+qk(i,j,k))       &
                     +w3d(i,j,k+1)*(pk2(i,j,k)-qk(i,j,k)) )
          ftk(i,j,k)=dts*( thten(i,j,k)-thterm(i,j,k)*div )     &
                 +( -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))       &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )     &
                    -( v2*(thadv(i,j+1,k)-thadv(i,j  ,k))       &
                      +v1*(thadv(i,j  ,k)-thadv(i,j-1,k)) ) )   &
              +beta*( w3d(i,j,k  )*(tk1(i,j,k)+sk(i,j,k))       &
                     +w3d(i,j,k+1)*(tk2(i,j,k)-sk(i,j,k)) )
        enddo
        enddo
      ELSE
        ! Cartesian grid with terrain:
        ! (note: see below for advection)
        do j=1,nj
        do i=1,ni
          div = gz(i,j)*( (dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)  &
                         +(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)  &
                         +(dum3(i,j,k+1)-dum3(i,j,k))*rdsf(k) )
          if(abs(div).lt.smeps) div=0.0
          w1 = w3d(i,j,k)
          w2 = w3d(i,j,k+1)
          if(k.eq. 1) w1 = 0.0
          if(k.eq.nk) w2 = 0.0
          fpk(i,j,k)=dts*( ppten(i,j,k)-ppterm(i,j,k)*div )  &
              +beta*( -qk(i,j,k)*(w2-w1) )
          ftk(i,j,k)=dts*( thten(i,j,k)-thterm(i,j,k)*div )  &
              +beta*( -sk(i,j,k)*(w2-w1) )
        enddo
        enddo
      ENDIF
    ELSE
        ! axisymmetric grid:
        do j=1,nj
        do i=1,ni
          div = (arh2(i)*u3d(i+1,j,k)-arh1(i)*u3d(i,j,k))*rdx*uh(i)
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(u3d(i+1,j,k)-us(i+1,j,k))*uh(i)*arh2(i)
          u1 = temx*(u3d(i  ,j,k)-us(i  ,j,k))*uh(i)*arh1(i)
          fpk(i,j,k)=dts*( ppten(i,j,k)-ppterm(i,j,k)*div )     &
                    -( u2*(piadv(i+1,j,k)-piadv(i  ,j,k))       &
                      +u1*(piadv(i  ,j,k)-piadv(i-1,j,k)) )     &
              +beta*( w3d(i,j,k  )*(pk1(i,j,k)+qk(i,j,k))       &
                     +w3d(i,j,k+1)*(pk2(i,j,k)-qk(i,j,k)) )
          ftk(i,j,k)=dts*( thten(i,j,k)-thterm(i,j,k)*div )     &
                    -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))       &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )     &
              +beta*( w3d(i,j,k  )*(tk1(i,j,k)+sk(i,j,k))       &
                     +w3d(i,j,k+1)*(tk2(i,j,k)-sk(i,j,k)) )
        enddo
        enddo
    ENDIF

      IF(k.ge.2)THEN
        do j=1,nj
        do i=1,ni
          fwk(i,j,k)=dts*wten(i,j,k)                           &
               +beta*( -mm(i,j,k)*(pp3d(i,j,k)-pp3d(i,j,k-1))  &
                       +bk(i,j,k)*(c2(i,j,k)*th3d(i,j,k)+c1(i,j,k)*th3d(i,j,k-1)) )
        enddo
        enddo
      ENDIF

    ENDDO
  
      if(timestats.ge.1) time_sound=time_sound+mytime()

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  advection for terrain:

      IF(terrain_flag)THEN
        ! Cartesian grid with terrain:
        call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)
        ! Cartesian grid with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,k)=0.5*(rho0(i-1,j,k)+rho0(i,j,k))*dum1(i,j,k)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            dum2(i,j,k)=0.5*(rho0(i,j-1,k)+rho0(i,j,k))*dum2(i,j,k)
          enddo
          enddo
        ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        DO k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do j=1,nj
          do i=1,ni
            ! NOTE:  dum3 is NOT coupled with density
            dum3(i,j,k)=0.5*( ( r2*(dum1(i,j,k  )+dum1(i+1,j,k  ))               &
                               +r1*(dum1(i,j,k-1)+dum1(i+1,j,k-1)) )*dzdx(i,j)   &
                             +( r2*(dum2(i,j,k  )+dum2(i,j+1,k  ))               &
                               +r1*(dum2(i,j,k-1)+dum2(i,j+1,k-1)) )*dzdy(i,j)   &
                            )*(sigmaf(k)-zt)*gz(i,j)*rzt * rrf0(i,j,k)
          enddo
          enddo
        ENDDO
        temx = dts*0.5*rdx
        temy = dts*0.5*rdy
!$omp parallel do default(shared)   &
!$omp private(i,j,k,u1,u2,v1,v2,w1,w2)
        DO k=1,nk
        do j=1,nj
        do i=1,ni
          u2 = temx*(dum1(i+1,j,k)-us(i+1,j,k))*uh(i)
          u1 = temx*(dum1(i  ,j,k)-us(i  ,j,k))*uh(i)
          v2 = temy*(dum2(i,j+1,k)-vs(i,j+1,k))*vh(j)
          v1 = temy*(dum2(i,j  ,k)-vs(i,j  ,k))*vh(j)
          w2 = dum3(i,j,k+1)+beta*w3d(i,j,k+1)
          w1 = dum3(i,j,k  )+beta*w3d(i,j,k  )
          fpk(i,j,k)=fpk(i,j,k)                                           &
                 +( -( u2*(piadv(i+1,j,k)-piadv(i  ,j,k))                 &
                      +u1*(piadv(i  ,j,k)-piadv(i-1,j,k)) )               &
                    -( v2*(piadv(i,j+1,k)-piadv(i,j  ,k))                 &
                      +v1*(piadv(i,j  ,k)-piadv(i,j-1,k)) ) )*rr0(i,j,k)*gz(i,j) &
                    +( w1*pk1(i,j,k)+w2*pk2(i,j,k) )
          ftk(i,j,k)=ftk(i,j,k)                                           &
                 +( -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    -( v2*(thadv(i,j+1,k)-thadv(i,j  ,k))                 &
                      +v1*(thadv(i,j  ,k)-thadv(i,j-1,k)) ) )*rr0(i,j,k)*gz(i,j) &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
        enddo
        enddo
        !-----
        IF( get_time_avg )THEN
          do j=1,nj
          do i=1,ni+1
            rru(i,j,k)=rru(i,j,k)+dum1(i,j,k)*tavg
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            rrv(i,j,k)=rrv(i,j,k)+dum2(i,j,k)*tavg
          enddo
          enddo
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              rrw(i,j,k)=rrw(i,j,k)+dum3(i,j,k)*rf0(i,j,k)*tavg
            enddo
            enddo
          ENDIF
        ENDIF
        !-----
        ENDDO
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  the vertcally implicit solver .... get new w

!$omp parallel do default(shared)   &
!$omp private(i,j,k,aa,bb,cc,dd,r1)
      DO j=1,nj

        k=2
        do i=1,ni
          cc =      -asq*( bk(i,j,k)*c2(i,j,k)*( tk2(i,j,k  )-sk(i,j,k  ) )   &
                                    -mm(i,j,k)*( pk2(i,j,k  )-qk(i,j,k  ) ) )
          bb = 1.0-asq*( bk(i,j,k)*( c2(i,j,k)*( tk1(i,j,k  )+sk(i,j,k  ) )   &
                                    +c1(i,j,k)*( tk2(i,j,k-1)-sk(i,j,k-1) ) ) &
                                    +mm(i,j,k)*(-(pk1(i,j,k  )+qk(i,j,k  ))   &
                                                +(pk2(i,j,k-1)-qk(i,j,k-1)) ) )
          dd = w3d(i,j,k)+fwk(i,j,k)+alph*(                             &
                  bk(i,j,k)*( c2(i,j,k)*(th3d(i,j,k  )+ftk(i,j,k  ))    &
                             +c1(i,j,k)*(th3d(i,j,k-1)+ftk(i,j,k-1)) )  &
                 -mm(i,j,k)*( (pp3d(i,j,k  )+fpk(i,j,k  ))              &
                             -(pp3d(i,j,k-1)+fpk(i,j,k-1)) ) )
          r1 = 1.0/bb
          dum1(i,j,k) = -cc*r1
          dum2(i,j,k) =  dd*r1
        enddo
        do k=3,(nk-1)
        do i=1,ni
          aa =      -asq*( bk(i,j,k)*c1(i,j,k)*( tk1(i,j,k-1)+sk(i,j,k-1) )   &
                                    +mm(i,j,k)*( pk1(i,j,k-1)+qk(i,j,k-1) ) )
          cc =      -asq*( bk(i,j,k)*c2(i,j,k)*( tk2(i,j,k  )-sk(i,j,k  ) )   &
                                    -mm(i,j,k)*( pk2(i,j,k  )-qk(i,j,k  ) ) )
          bb = 1.0-asq*( bk(i,j,k)*( c2(i,j,k)*( tk1(i,j,k  )+sk(i,j,k  ) )   &
                                    +c1(i,j,k)*( tk2(i,j,k-1)-sk(i,j,k-1) ) ) &
                                    +mm(i,j,k)*(-(pk1(i,j,k  )+qk(i,j,k  ))   &
                                                +(pk2(i,j,k-1)-qk(i,j,k-1)) ) )
          dd = w3d(i,j,k)+fwk(i,j,k)+alph*(                             &
                  bk(i,j,k)*( c2(i,j,k)*(th3d(i,j,k  )+ftk(i,j,k  ))    &
                             +c1(i,j,k)*(th3d(i,j,k-1)+ftk(i,j,k-1)) )  &
                 -mm(i,j,k)*( (pp3d(i,j,k  )+fpk(i,j,k  ))              &
                             -(pp3d(i,j,k-1)+fpk(i,j,k-1)) ) )
          r1 = 1.0/(aa*dum1(i,j,k-1)+bb)
          dum1(i,j,k) = -cc*r1
          dum2(i,j,k) = (dd-aa*dum2(i,j,k-1))*r1
        enddo
        enddo
        k = nk
        do i=1,ni
          aa =      -asq*( bk(i,j,k)*c1(i,j,k)*( tk1(i,j,k-1)+sk(i,j,k-1) )   &
                                    +mm(i,j,k)*( pk1(i,j,k-1)+qk(i,j,k-1) ) )
          bb = 1.0-asq*( bk(i,j,k)*( c2(i,j,k)*( tk1(i,j,k  )+sk(i,j,k  ) )   &
                                    +c1(i,j,k)*( tk2(i,j,k-1)-sk(i,j,k-1) ) ) &
                                    +mm(i,j,k)*(-(pk1(i,j,k  )+qk(i,j,k  ))   &
                                                +(pk2(i,j,k-1)-qk(i,j,k-1)) ) )
          dd = w3d(i,j,k)+fwk(i,j,k)+alph*(                             &
                  bk(i,j,k)*( c2(i,j,k)*(th3d(i,j,k  )+ftk(i,j,k  ))    &
                             +c1(i,j,k)*(th3d(i,j,k-1)+ftk(i,j,k-1)) )  &
                 -mm(i,j,k)*( (pp3d(i,j,k  )+fpk(i,j,k  ))              &
                             -(pp3d(i,j,k-1)+fpk(i,j,k-1)) ) )
          r1 = 1.0/(aa*dum1(i,j,k-1)+bb)
          dum2(i,j,k) = (dd-aa*dum2(i,j,k-1))*r1
          w3d(i,j,k)=dum2(i,j,k)
        enddo

        do k=(nk-1),2,-1
        do i=1,ni
          w3d(i,j,k)=dum1(i,j,k)*w3d(i,j,k+1)+dum2(i,j,k)
        enddo
        enddo

      ENDDO

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  get new pp,th

!$omp parallel do default(shared)   &
!$omp private(i,j,k,w1,w2)
      DO k=1,nk

      IF(.not.terrain_flag)THEN
        ! without terrain:
        do j=1,nj
        do i=1,ni
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+fpk(i,j,k)              &
              +alph*( w3d(i,j,k  )*(pk1(i,j,k)+qk(i,j,k)) &
                     +w3d(i,j,k+1)*(pk2(i,j,k)-qk(i,j,k)) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+ftk(i,j,k)              &
              +alph*( w3d(i,j,k  )*(tk1(i,j,k)+sk(i,j,k)) &
                     +w3d(i,j,k+1)*(tk2(i,j,k)-sk(i,j,k)) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
      ELSE
        ! with terrain:
        do j=1,nj
        do i=1,ni
          !-----
          w1 = w3d(i,j,k)
          w2 = w3d(i,j,k+1)
          if(k.eq. 1) w1 = 0.0
          if(k.eq.nk) w2 = 0.0
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+fpk(i,j,k)    &
              +alph*( w1*(pk1(i,j,k)+qk(i,j,k)) &
                     +w2*(pk2(i,j,k)-qk(i,j,k)) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+ftk(i,j,k)    &
              +alph*( w1*(tk1(i,j,k)+sk(i,j,k)) &
                     +w2*(tk2(i,j,k)-sk(i,j,k)) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
      ENDIF

      ENDDO
      if(timestats.ge.1) time_sound=time_sound+mytime()

        IF( n.lt.nloop )THEN
          call bcs(ppd)
#ifdef MPI
          call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                                 ps1,ps2,pn1,pn2,reqs_p)
#endif
        ENDIF

!--------------------------------------------------------------------
!  time-averaged velocities:

    IF( get_time_avg )THEN
      IF(.not.terrain_flag)THEN
        !-----
        ! without terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
        DO k=1,nk
          tem = rho0(1,1,k)*tavg
          do j=1,nj
          do i=1,ni+1
            rru(i,j,k)=rru(i,j,k)+u3d(i,j,k)*tem
          enddo
          enddo
          IF( axisymm.eq.0 )THEN
            do j=1,nj+1
            do i=1,ni
              rrv(i,j,k)=rrv(i,j,k)+v3d(i,j,k)*tem
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            if( n.eq.nloop )then
              tem = rf0(1,1,k)*tavg*alph
            else
              tem = rf0(1,1,k)*tavg
            endif
            do j=1,nj
            do i=1,ni
              rrw(i,j,k)=rrw(i,j,k)+w3d(i,j,k)*tem
            enddo
            enddo
          ENDIF
        ENDDO
        !-----
      ELSE
        !-----
        ! with terrain:
        if( n.eq.nloop )then
          tem = tavg*alph
        else
          tem = tavg
        endif
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=2,nk
          do j=1,nj
          do i=1,ni
            rrw(i,j,k)=rrw(i,j,k)+w3d(i,j,k)*rf0(i,j,k)*tem
          enddo
          enddo
        ENDDO
        !-----
      ENDIF    ! endif for terrain check
    ENDIF      ! endif for get_time_avg check
      if(timestats.ge.1) time_sound=time_sound+mytime()

!--------------------------------------------------------------------

      ENDDO  small_step_loop

!  end of small steps
!--------------------------------------------------------------------

      IF( nrk.eq.3 )THEN
        ! pressure tendency term: save for next timestep:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppx(i,j,k)=dum1(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
      if(timestats.ge.1) time_sound=time_sound+mytime()


      call bcu(u3d)
      IF(axisymm.eq.0)THEN
        call bcv(v3d)
      ENDIF
      call bcw(w3d,1)
      if(terrain_flag) call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)
      if(nrk.lt.3)then
        call bcs(th3d)
        call bcs(pp3d)
      endif


      end subroutine sound


soundns.F       1587424407  1602  20    100644  12867     `


      subroutine soundns(xh,rxh,arh1,arh2,uh,xf,uf,yh,vh,yf,vf,           &
                         zh,mh,c1,c2,mf,pi0,thv0,rr0,rf0,                 &
                         rds,sigma,rdsf,sigmaf,                           &
                         zs,gz,rgz,gzu,rgzu,gzv,rgzv,                     &
                         dzdx,dzdy,gx,gxu,gy,gyv,                         &
                         radbcw,radbce,radbcs,radbcn,                     &
                         dum1,dum2,dum3,div ,                             &
                         u0,ua,u3d,uten,                                  &
                         v0,va,v3d,vten,                                  &
                         wa,w3d,wten,                                     &
                         ppi,pp3d,ppten,thv,ppterm,dttmp,nrk,rtime,       &
                         th0,tha,th3d,thten,thterm)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,c1,c2
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rr0,rf0
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,div
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten
      real, dimension(ib:ie,jb:je,kb:ke) :: thv,ppterm
      real, intent(in) :: dttmp
      integer, intent(in) :: nrk
      real, intent(in) :: rtime
      real, dimension(ib:ie,jb:je,kb:ke) :: th0,tha,th3d,thten,thterm

!-----

      integer :: i,j,k
      real :: tem,tem1,tem2,r1,r2

!---------------------------------------------------------------------

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,ua)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,va)
 
        endif

!-----

        if(wbc.eq.2.and.ibw.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(1,j,k)=ua(1,j,k)
          enddo
          enddo
          call   ssopenbcw(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbcw,dum1,u3d,uten,dttmp)
        endif

        if(ebc.eq.2.and.ibe.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(ni+1,j,k)=ua(ni+1,j,k)
          enddo
          enddo
          call   ssopenbce(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbce,dum1,u3d,uten,dttmp)
        endif

!-----

      IF(axisymm.eq.0)THEN

        if(sbc.eq.2.and.ibs.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,1,k)=va(i,1,k)
          enddo
          enddo
          call   ssopenbcs(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcs,dum1,v3d,vten,dttmp)
        endif
 
        if(nbc.eq.2.and.ibn.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,nj+1,k)=va(i,nj+1,k)
          enddo
          enddo
          call   ssopenbcn(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcn,dum1,v3d,vten,dttmp)
        endif

      ENDIF

!-----

    IF(.not.terrain_flag)THEN

      IF(axisymm.eq.0)THEN

        tem1=dttmp*rdx*cp*0.5
        tem2=dttmp*rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)             &
                   -(tem1*(pp3d(i,j,k)-pp3d(i-1,j,k))*uf(i)    &
                         *(thv(i,j,k)+thv(i-1,j,k)))
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)             &
                   -(tem2*(pp3d(i,j,k)-pp3d(i,j-1,k))*vf(j)    &
                         *(thv(i,j,k)+thv(i,j-1,k)))
          enddo
          enddo
        enddo

      ELSE

        tem1=dttmp*rdx*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1+ibw,ni+1-ibe
          u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)             &
                 -(tem1*(pp3d(i,j,k)-pp3d(i-1,j,k))*uf(i)    &
                       *(thv(i,j,k)+thv(i-1,j,k)))
        enddo
        enddo
        enddo

      ENDIF

    ELSE

        ! Cartesian grid with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+1
          ! dum1 stores pp3d at w-pts:
          ! lowest model level:
          do i=0,ni+1
            dum1(i,j,1) = cgs1*pp3d(i,j,1)+cgs2*pp3d(i,j,2)+cgs3*pp3d(i,j,3)
          enddo
          ! upper-most model level:
          do i=0,ni+1
            dum1(i,j,nk+1) = cgt1*pp3d(i,j,nk)+cgt2*pp3d(i,j,nk-1)+cgt3*pp3d(i,j,nk-2)
          enddo
          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+1
            dum1(i,j,k) = r1*pp3d(i,j,k-1)+r2*pp3d(i,j,k)
          enddo
          enddo
        enddo

        tem1 = rdx*cp*0.5
        tem2 = rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          ! x-dir
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=ua(i,j,k)+dttmp*( uten(i,j,k)              &
                   -cp*0.5*(thv(i,j,k)+thv(i-1,j,k))*(            &
                   ( pp3d(i  ,j,k)*rgz(i  ,j)                     &
                    -pp3d(i-1,j,k)*rgz(i-1,j)                     &
                   )*gzu(i,j)*rdx*uf(i)                           &
              +0.5*( gxu(i,j,k+1)*(dum1(i,j,k+1)+dum1(i-1,j,k+1)) &
                    -gxu(i,j,k  )*(dum1(i,j,k  )+dum1(i-1,j,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=va(i,j,k)+dttmp*( vten(i,j,k)              &
                   -cp*0.5*(thv(i,j,k)+thv(i,j-1,k))*(            &
                   ( pp3d(i,j  ,k)*rgz(i,j  )                     &
                    -pp3d(i,j-1,k)*rgz(i,j-1)                     &
                   )*gzv(i,j)*rdy*vf(j)                           &
              +0.5*( gyv(i,j,k+1)*(dum1(i,j,k+1)+dum1(i,j-1,k+1)) &
                    -gyv(i,j,k  )*(dum1(i,j,k  )+dum1(i,j-1,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
        enddo

    ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcu(u3d)

!----------------------------------------------
!  convergence forcing:

      IF(axisymm.eq.0)THEN

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcv(v3d)

      ENDIF

!-----

    IF(.not.terrain_flag)THEN
        ! without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem1)
        do k=2,nk
        tem1 = rdz*cp*mf(1,1,k)
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=wa(i,j,k)+dttmp*( wten(i,j,k)                    &
                  -tem1*(pp3d(i,j,k)-pp3d(i,j,k-1))                   &
                       *(c2(1,1,k)*thv(i,j,k)+c1(1,1,k)*thv(i,j,k-1)) )
        enddo
        enddo
        enddo

      ELSE
        ! with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem1)
        do k=2,nk
        tem1 = rds(k)*cp
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=wa(i,j,k)+dttmp*( wten(i,j,k)                    &
                  -tem1*(pp3d(i,j,k)-pp3d(i,j,k-1))*gz(i,j)           &
                       *(c2(i,j,k)*thv(i,j,k)+c1(i,j,k)*thv(i,j,k-1)) )
        enddo
        enddo
        enddo

      ENDIF

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcw(w3d,1)
        if( terrain_flag ) call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)

!-----

  IF(.not.terrain_flag)THEN

    IF(axisymm.eq.0)THEN
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        div(i,j,k)=(u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)    &
                  +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)    &
                  +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(1,1,k)
      enddo
      enddo
      enddo

    ELSE
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        div(i,j,k)=(arh2(i)*u3d(i+1,j,k)-arh1(i)*u3d(i,j,k))*rdx*uh(i)   &
                  +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(1,1,k)
      enddo
      enddo
      enddo

    ENDIF

  ELSE

        ! Cartesian grid with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,k)=u3d(i,j,k)*rgzu(i,j)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            dum2(i,j,k)=v3d(i,j,k)*rgzv(i,j)
          enddo
          enddo
        ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        DO k=1,nk
          IF(k.eq.1)THEN
            do j=1,nj
            do i=1,ni
              dum3(i,j,1)=0.0
              dum3(i,j,nk+1)=0.0
            enddo
            enddo
          ELSE
            r2 = (sigmaf(k)-sigma(k-1))*rds(k)
            r1 = 1.0-r2
            do j=1,nj
            do i=1,ni
              dum3(i,j,k)=w3d(i,j,k)                                               &
                         +0.5*( ( r2*(dum1(i,j,k  )+dum1(i+1,j,k  ))               &
                                 +r1*(dum1(i,j,k-1)+dum1(i+1,j,k-1)) )*dzdx(i,j)   &
                               +( r2*(dum2(i,j,k  )+dum2(i,j+1,k  ))               &
                                 +r1*(dum2(i,j,k-1)+dum2(i,j+1,k-1)) )*dzdy(i,j)   &
                             )*(sigmaf(k)-zt)*gz(i,j)*rzt
            enddo
            enddo
          ENDIF
        ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1)
        do k=1,nk
          do j=1,nj
          do i=1,ni
            div(i,j,k) = gz(i,j)*( (dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)  &
                                  +(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)  &
                                  +(dum3(i,j,k+1)-dum3(i,j,k))*rdsf(k) )
            if(abs(div(i,j,k)).lt.smeps) div(i,j,k)=0.0
          enddo
          enddo
        enddo

  ENDIF

!-----

      IF( imoist.eq.1 .and. eqtset.eq.2 )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          pp3d(i,j,k)=ppi(i,j,k)+dttmp*( ppten(i,j,k)-ppterm(i,j,k)*div(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          th3d(i,j,k)=tha(i,j,k)+dttmp*( thten(i,j,k)-thterm(i,j,k)*div(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          pp3d(i,j,k)=ppi(i,j,k)+dttmp*( ppten(i,j,k)-ppterm(i,j,k)*div(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          th3d(i,j,k)=tha(i,j,k)+dttmp*thten(i,j,k)
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
        enddo
        enddo
        enddo

      ENDIF

        if(timestats.ge.1) time_sound=time_sound+mytime()
 
          if(nrk.lt.3)then
            call bcs(th3d)
            call bcs(pp3d)
          endif

!-------------------------------------------------------------------- 

      return
      end



soundcb.F       1587424407  1602  20    100644  25185     `


      subroutine soundcb(dt,xh,arh1,arh2,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,    &
                        rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,mf,         &
                        pi0,rho0,rr0,rf0,rrf0,th0,rth0,zs,                &
                        gz,rgz,gzu,rgzu,gzv,rgzv,                         &
                        dzdx,dzdy,gx,gxu,gy,gyv,                          &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,dum4,dum5,dum6,                    &
                        ppd ,fpk ,qk ,pk1,pk2,ftk,sk ,tk1,tk2,            &
                        u0,rru,us,ua,u3d,uten,                            &
                        v0,rrv,vs,va,v3d,vten,                            &
                        rrw,ws,wa,w3d,wten,                               &
                        ppi,pp3d,piadv,ppten,ppx,                         &
                        tha,th3d,thadv,thten,thterm,                      &
                        thv,ppterm,nrk,dttmp,rtime,get_time_avg,          &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_p)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,arh1,arh2,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,rr0,rf0,rrf0,th0,rth0
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv,dzdx,dzdy
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,dum5,dum6
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppd,fpk,qk,pk1,pk2,ftk,sk,tk1,tk2
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: rru,us,ua,u3d,uten
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: rrv,vs,va,v3d,vten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: rrw,ws,wa,w3d,wten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,piadv,ppten,ppx
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thadv,thten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: thterm,thv,ppterm
      integer, intent(in) :: nrk
      real, intent(in)  :: dttmp,rtime
      logical, intent(in) :: get_time_avg
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      integer, intent(inout), dimension(rmp) :: reqs_p

!-----

      integer :: i,j,k,n,nloop
      real :: tem,tem1,tem2,tem3,tem4,r1,r2,dts

      real :: temx,temy,u1,u2,v1,v2,w1,w2,ww,tavg,div

!---------------------------------------------------------------------

      if(nrk.eq.1)then
!!!        nloop=1
!!!        dts=dt/3.
        nloop=nint(float(nsound)/3.0)
        dts=dt/(nloop*3.0)
        if( dts.gt.(dt/nsound) )then
          nloop=nloop+1
          dts=dt/(nloop*3.0)
        endif
      elseif(nrk.eq.2)then
        nloop=0.5*nsound
        dts=dt/nsound
      elseif(nrk.eq.3)then
        nloop=nsound
        dts=dt/nsound
      endif

!!!      print *,'  nloop,dts,dttmp = ',nloop,dts,nloop*dts

!-----------------------------------------------------------------
!  define ppd first, then start comm:

      if( nrk.eq.1 )then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=ppi(i,j,k)+ppx(i,j,k)
        enddo
        enddo
        enddo

      else

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=ppi(i,j,k)+ppx(i,j,k)
          pp3d(i,j,k)=ppi(i,j,k)
        enddo
        enddo
        enddo

      endif
      if(timestats.ge.1) time_sound=time_sound+mytime()

      call bcs(ppd)
#ifdef MPI
      call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                             ps1,ps2,pn1,pn2,reqs_p)
#endif

!---------------------------------------------------------------------
!  Arrays for vadv:

      IF(.not.terrain_flag)THEN

        ! without terrain:
        ! "s" velocities ARE NOT coupled with reference density
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem,tem1,r1,r2)
        do k=1,nk
          r2 = dts*rdz*mh(1,1,k)*rr0(1,1,k)*rf0(1,1,k+1)
          r1 = dts*rdz*mh(1,1,k)*rr0(1,1,k)*rf0(1,1,k)
          do j=1,nj
          do i=1,ni
            tk2(i,j,k) = r2*( -c2(1,1,k+1)*thadv(i,j,k+1)+(1.0-c1(1,1,k+1))*thadv(i,j,k) )
            tk1(i,j,k) = r1*( +c1(1,1,k  )*thadv(i,j,k-1)+(c2(1,1,k  )-1.0)*thadv(i,j,k) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni+1
            us(i,j,k)=u3d(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              vs(i,j,k)=v3d(i,j,k)
            enddo
            enddo
          ENDIF
          IF(k.gt.1)THEN
            do j=1,nj
            do i=1,ni
              ws(i,j,k)=w3d(i,j,k)
            enddo
            enddo
          ENDIF
        enddo

      ELSE

        ! with terrain:
        ! "s" velocities ARE coupled with reference density
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem,tem1,r1,r2)
        do k=1,nk
          do j=1,nj
          do i=1,ni
            r2 = dts*gz(i,j)*rdsf(k)*rr0(i,j,k)*rf0(i,j,k+1)
            r1 = dts*gz(i,j)*rdsf(k)*rr0(i,j,k)*rf0(i,j,k)
            tk2(i,j,k) = r2*( -c2(i,j,k+1)*thadv(i,j,k+1)+(1.0-c1(i,j,k+1))*thadv(i,j,k) )
            tk1(i,j,k) = r1*( +c1(i,j,k  )*thadv(i,j,k-1)+(c2(i,j,k  )-1.0)*thadv(i,j,k) )
          enddo
          enddo
          do j=1,nj
          do i=1,ni+1
            us(i,j,k)=rru(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              vs(i,j,k)=rrv(i,j,k)
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              ws(i,j,k)=rrw(i,j,k)
            enddo
            enddo
          ELSE
            do j=1,nj
            do i=1,ni
              dum3(i,j,1)=0.0
              dum3(i,j,nk+1)=0.0
            enddo
            enddo
          ENDIF
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        tk1(i,j,1) = 0.0
        tk2(i,j,nk) = 0.0
      enddo
      enddo

!---------------------------------------------------------------------
!  Prepare for acoustic steps

      if( nrk.ge.2 )then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1,ni+1
            u3d(i,j,k)=ua(i,j,k)
          enddo
          enddo
          IF(axisymm.eq.0)THEN
            ! Cartesian grid:
            do j=1,nj+1
            do i=1,ni
              v3d(i,j,k)=va(i,j,k)
            enddo
            enddo
          ENDIF
          IF(k.ge.2)THEN
            do j=1,nj
            do i=1,ni
              w3d(i,j,k)=wa(i,j,k)
            enddo
            enddo
          ENDIF
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=tha(i,j,k)
          enddo
          enddo
        enddo

      endif

!---------------------------------------------------------------------

      IF( get_time_avg )THEN
        tavg = 1.0/float(nloop)
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
          do k=1,nk
            do j=1,nj
            do i=1,ni+1
              rru(i,j,k)=0.0
            enddo
            enddo
            IF(axisymm.eq.0)THEN
              ! Cartesian grid:
              do j=1,nj+1
              do i=1,ni
                rrv(i,j,k)=0.0
              enddo
              enddo
            ENDIF
            IF(k.ge.2)THEN
              do j=1,nj
              do i=1,ni
                rrw(i,j,k)=0.0
              enddo
              enddo
            ENDIF
          enddo
    ENDIF      ! endif for get_time_avg check


      if(timestats.ge.1) time_sound=time_sound+mytime()

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  Begin small steps:

      small_step_loop:  DO N=1,NLOOP

!-----

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,u3d)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,v3d)
 
        endif

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  Open boundary conditions:

        IF(wbc.eq.2.and.ibw.eq.1)THEN
          ! west open bc tendency:
          call   ssopenbcw(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbcw,dum1,u3d,uten,dts)
        ENDIF
        IF(ebc.eq.2.and.ibe.eq.1)THEN
          ! east open bc tendency:
          call   ssopenbce(uh,rds,sigma,rdsf,sigmaf,gz,rgzu,gx,radbce,dum1,u3d,uten,dts)
        ENDIF

        IF(roflux.eq.1)THEN
          call restrict_openbc_we(rvh,rmh,rho0,u3d)
        ENDIF

!-----

      IF(axisymm.eq.0)THEN
        IF(sbc.eq.2.and.ibs.eq.1)THEN
          ! south open bc tendency:
          call   ssopenbcs(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcs,dum1,v3d,vten,dts)
        ENDIF
        IF(nbc.eq.2.and.ibn.eq.1)THEN
          ! north open bc tendency:
          call   ssopenbcn(vh,rds,sigma,rdsf,sigmaf,gz,rgzv,gy,radbcn,dum1,v3d,vten,dts)
        ENDIF

        IF(roflux.eq.1)THEN
          call restrict_openbc_sn(ruh,rmh,rho0,v3d)
        ENDIF
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  integrate u,v forward in time:

#ifdef MPI
          call comm_1s_end(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
#endif

!-----

    IF(.not.terrain_flag)THEN

      IF(axisymm.eq.0)THEN
        ! Cartesian grid without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)      &
                    -rdx*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)      &
                    -rdy*(ppd(i,j,k)-ppd(i,j-1,k))*vf(j) )
          enddo
          enddo
        enddo

      ELSE
        ! axisymmetric grid:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)      &
                    -rdx*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i) )
          enddo
          enddo
        enddo

      ENDIF

    ELSE

        ! Cartesian grid with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        do j=0,nj+1
          ! dum1 stores ppd at w-pts:
          ! lowest model level:
          do i=0,ni+1
            dum1(i,j,1) = cgs1*ppd(i,j,1)+cgs2*ppd(i,j,2)+cgs3*ppd(i,j,3)
          enddo
          ! upper-most model level:
          do i=0,ni+1
            dum1(i,j,nk+1) = cgt1*ppd(i,j,nk)+cgt2*ppd(i,j,nk-1)+cgt3*ppd(i,j,nk-2)
          enddo
          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+1
            dum1(i,j,k) = r1*ppd(i,j,k-1)+r2*ppd(i,j,k)
          enddo
          enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
          ! x-dir
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k) -(            &
                   ( ppd(i  ,j,k)*rgz(i  ,j)                      &
                    -ppd(i-1,j,k)*rgz(i-1,j)                      &
                   )*gzu(i,j)*rdx*uf(i)                           &
              +0.5*( gxu(i,j,k+1)*(dum1(i,j,k+1)+dum1(i-1,j,k+1)) &
                    -gxu(i,j,k  )*(dum1(i,j,k  )+dum1(i-1,j,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k) -(            &
                   ( ppd(i,j  ,k)*rgz(i,j  )                      &
                    -ppd(i,j-1,k)*rgz(i,j-1)                      &
                   )*gzv(i,j)*rdy*vf(j)                           &
              +0.5*( gyv(i,j,k+1)*(dum1(i,j,k+1)+dum1(i,j-1,k+1)) &
                    -gyv(i,j,k  )*(dum1(i,j,k  )+dum1(i,j-1,k  )) &
                   )*rdsf(k) ) )
          enddo
          enddo
        enddo

    ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------
!  convergence forcing:

      IF(axisymm.eq.0)THEN
        ! Cartesian grid:
        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

      ENDIF

      if(timestats.ge.1) time_sound=time_sound+mytime()

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  integrate w forward in time:

      IF(.not.terrain_flag)THEN
        ! without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem1)
        do k=2,nk
        tem1 = rdz*mf(1,1,k)
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=w3d(i,j,k)+dts*( wten(i,j,k)            &
                  -tem1*(ppd(i,j,k)-ppd(i,j,k-1))            &
                +g*( c2(1,1,k)*th3d(i,j,k)*rth0(1,1,k)       &
                    +c1(1,1,k)*th3d(i,j,k-1)*rth0(1,1,k-1) ) )
        enddo
        enddo
        enddo

      ELSE
        ! with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=w3d(i,j,k)+dts*( wten(i,j,k)                     &
                -rds(k)*(ppd(i,j,k)-ppd(i,j,k-1))*gz(i,j)             &
                +g*( c2(i,j,k)*th3d(i,j,k)*rth0(i,j,k)                &
                    +c1(i,j,k)*th3d(i,j,k-1)*rth0(i,j,k-1) ) )
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)

      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  get terms for div,vadv (terrain only):

      IF(terrain_flag)THEN
        ! Cartesian grid with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,k)=u3d(i,j,k)*rgzu(i,j)
            dum4(i,j,k)=0.5*(rho0(i-1,j,k)+rho0(i,j,k))*dum1(i,j,k)
          enddo
          enddo
          do j=1,nj+1
          do i=1,ni
            dum2(i,j,k)=v3d(i,j,k)*rgzv(i,j)
            dum5(i,j,k)=0.5*(rho0(i,j-1,k)+rho0(i,j,k))*dum2(i,j,k)
          enddo
          enddo
        ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
        DO k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do j=1,nj
          do i=1,ni
            dum3(i,j,k)=w3d(i,j,k)                                               &
                       +0.5*( ( r2*(dum1(i,j,k  )+dum1(i+1,j,k  ))               &
                               +r1*(dum1(i,j,k-1)+dum1(i+1,j,k-1)) )*dzdx(i,j)   &
                             +( r2*(dum2(i,j,k  )+dum2(i,j+1,k  ))               &
                               +r1*(dum2(i,j,k-1)+dum2(i,j+1,k-1)) )*dzdy(i,j)   &
                            )*(sigmaf(k)-zt)*gz(i,j)*rzt
            ! NOTE:  dum6 is NOT coupled with density
            dum6(i,j,k)=w3d(i,j,k)                                               &
                       +0.5*( ( r2*(dum4(i,j,k  )+dum4(i+1,j,k  ))               &
                               +r1*(dum4(i,j,k-1)+dum4(i+1,j,k-1)) )*dzdx(i,j)   &
                             +( r2*(dum5(i,j,k  )+dum5(i,j+1,k  ))               &
                               +r1*(dum5(i,j,k-1)+dum5(i,j+1,k-1)) )*dzdy(i,j)   &
                            )*(sigmaf(k)-zt)*gz(i,j)*rzt * rrf0(i,j,k)
          enddo
          enddo
        ENDDO
      ENDIF

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!  get new pp,th

      temx = dts*0.5*rdx
      temy = dts*0.5*rdy

!$omp parallel do default(shared)   &
!$omp private(i,j,k,div,u1,u2,v1,v2,w1,w2,tem)
      DO k=1,nk

    IF( axisymm.eq.0 )THEN
      IF(.not.terrain_flag)THEN
        ! Cartesian grid, without terrain:
        do j=1,nj
        do i=1,ni
          div=(u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)    &
             +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)    &
             +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(1,1,k)
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(u3d(i+1,j,k)-us(i+1,j,k))*uh(i)
          u1 = temx*(u3d(i  ,j,k)-us(i  ,j,k))*uh(i)
          v2 = temy*(v3d(i,j+1,k)-vs(i,j+1,k))*vh(j)
          v1 = temy*(v3d(i,j  ,k)-vs(i,j  ,k))*vh(j)
          w2 = w3d(i,j,k+1)-ws(i,j,k+1)
          w1 = w3d(i,j,k  )-ws(i,j,k  )
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)-dts*csound*csound*div
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+dts*thten(i,j,k)                        &
                 +( -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    -( v2*(thadv(i,j+1,k)-thadv(i,j  ,k))                 &
                      +v1*(thadv(i,j  ,k)-thadv(i,j-1,k)) ) )             &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
      ELSE
        ! Cartesian grid, with terrain:
        do j=1,nj
        do i=1,ni
          div = gz(i,j)*( (dum1(i+1,j,k)-dum1(i,j,k))*rdx*uh(i)  &
                         +(dum2(i,j+1,k)-dum2(i,j,k))*rdy*vh(j)  &
                         +(dum3(i,j,k+1)-dum3(i,j,k))*rdsf(k) )
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(dum4(i+1,j,k)-us(i+1,j,k))*uh(i)
          u1 = temx*(dum4(i  ,j,k)-us(i  ,j,k))*uh(i)
          v2 = temy*(dum5(i,j+1,k)-vs(i,j+1,k))*vh(j)
          v1 = temy*(dum5(i,j  ,k)-vs(i,j  ,k))*vh(j)
          w2 = dum6(i,j,k+1)-ws(i,j,k+1)*rrf0(i,j,k+1)
          w1 = dum6(i,j,k  )-ws(i,j,k  )*rrf0(i,j,k  )
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)-dts*csound*csound*div
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+dts*thten(i,j,k)                        &
                 +( -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    -( v2*(thadv(i,j+1,k)-thadv(i,j  ,k))                 &
                      +v1*(thadv(i,j  ,k)-thadv(i,j-1,k)) ) )*rr0(i,j,k)*gz(i,j) &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
      ENDIF
    ELSE
        ! axisymmetric grid:
        do j=1,nj
        do i=1,ni
          div=(arh2(i)*u3d(i+1,j,k)-arh1(i)*u3d(i,j,k))*rdx*uh(i)   &
             +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(1,1,k)
          if(abs(div).lt.smeps) div=0.0
          u2 = temx*(u3d(i+1,j,k)-us(i+1,j,k))*uh(i)*arh2(i)
          u1 = temx*(u3d(i  ,j,k)-us(i  ,j,k))*uh(i)*arh1(i)
          w2 = w3d(i,j,k+1)-ws(i,j,k+1)
          w1 = w3d(i,j,k  )-ws(i,j,k  )
          !-----
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)-dts*csound*csound*div
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          dum1(i,j,k)=kdiv*( pp3d(i,j,k)-ppd(i,j,k) )
          ppd(i,j,k)=pp3d(i,j,k)+dum1(i,j,k)
          !-----
          th3d(i,j,k)=th3d(i,j,k)+dts*thten(i,j,k)                        &
                    -( u2*(thadv(i+1,j,k)-thadv(i  ,j,k))                 &
                      +u1*(thadv(i  ,j,k)-thadv(i-1,j,k)) )               &
                    +( w1*tk1(i,j,k)+w2*tk2(i,j,k) )
          if(abs(th3d(i,j,k)).lt.smeps) th3d(i,j,k)=0.0
          !-----
        enddo
        enddo
    ENDIF

      ENDDO
      if(timestats.ge.1) time_sound=time_sound+mytime()

        IF( n.lt.nloop )THEN
          call bcs(ppd)
#ifdef MPI
          call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                                 ps1,ps2,pn1,pn2,reqs_p)
#endif
        ENDIF

!--------------------------------------------------------------------
!  time-averaged velocities:

    IF( get_time_avg )THEN
      IF(.not.terrain_flag)THEN
        !-----
        ! without terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
        DO k=1,nk
          tem = rho0(1,1,k)*tavg
          do j=1,nj
          do i=1,ni+1
            rru(i,j,k)=rru(i,j,k)+u3d(i,j,k)*tem
          enddo
          enddo
          IF( axisymm.eq.0 )THEN
            do j=1,nj+1
            do i=1,ni
              rrv(i,j,k)=rrv(i,j,k)+v3d(i,j,k)*tem
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            tem = rf0(1,1,k)*tavg
            do j=1,nj
            do i=1,ni
              rrw(i,j,k)=rrw(i,j,k)+w3d(i,j,k)*tem
            enddo
            enddo
          ENDIF
        ENDDO
        !-----
      ELSE
        !-----
        ! with terrain:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
        DO k=1,nk
          do j=1,nj
          do i=1,ni+1
            rru(i,j,k)=rru(i,j,k)+dum4(i,j,k)*tavg
          enddo
          enddo
          IF( axisymm.eq.0 )THEN
            do j=1,nj+1
            do i=1,ni
              rrv(i,j,k)=rrv(i,j,k)+dum5(i,j,k)*tavg
            enddo
            enddo
          ENDIF
          IF( k.ge.2 )THEN
            do j=1,nj
            do i=1,ni
              rrw(i,j,k)=rrw(i,j,k)+dum6(i,j,k)*rf0(i,j,k)*tavg
            enddo
            enddo
          ENDIF
        ENDDO
        !-----
      ENDIF    ! endif for terrain check
    ENDIF      ! endif for get_time_avg check
      if(timestats.ge.1) time_sound=time_sound+mytime()

!--------------------------------------------------------------------

      ENDDO  small_step_loop

!  end of small steps
!--------------------------------------------------------------------

      IF( nrk.eq.3 )THEN
        ! pressure tendency term: save for next timestep:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppx(i,j,k)=dum1(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
      if(timestats.ge.1) time_sound=time_sound+mytime()


      call bcu(u3d)
      IF(axisymm.eq.0)THEN
        call bcv(v3d)
      ENDIF
      call bcw(w3d,1)
      if(terrain_flag) call bcwsfc(gz,dzdx,dzdy,u3d,v3d,w3d)
      if(nrk.lt.3)then
        call bcs(th3d)
        call bcs(pp3d)
      endif


      end subroutine soundcb



statpack.F      1587424407  1602  20    100644  15551     `

      subroutine statpack(nrec,ndt,dt,dtlast,rtime,adt,acfl,cloudvar,qname,budname,qbudget,asq,bsq, &
                          xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,vf,zh,mh,rmh,mf,    &
                          zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf,               &
                          rstat,pi0,rho0,thv0,th0,qv0,u0,v0,                &
                          dum1,dum2,dum3,dum4,dum5,rho  ,prs,               &
                          ua,va,wa,ppi,tha,qa,vq  ,kmh,kmv,khh,khv,tkea,pta,u10,v10,reset)
      use maxminmod
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer :: nrec,ndt
      real :: dt,dtlast,rtime
      double precision :: adt,acfl
      logical, dimension(maxq) :: cloudvar
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      double precision, dimension(nbudget) :: qbudget
      double precision, dimension(numq) :: asq,bsq
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: rgzu,rgzv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,thv0,th0,qv0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,dum5,rho,prs
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,vq
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, intent(in), dimension(ibl:iel,jbl:jel) :: u10,v10
      logical, intent(inout) :: reset

!-----------------------------------------------------------------------

      integer i,j,k,n,nstat
      character*6 :: text1,text2
      real qvs
      real rslf,rsif
#ifdef DP
      real*4 :: vout
#endif
#ifdef MPI
      double precision, dimension(nbudget) :: cfoo
      double precision, dimension(numq) :: afoo,bfoo
#endif

!-----------------------------------------------------------------------
#ifdef MPI
      cfoo = 0.0
      call MPI_REDUCE(qbudget(1),cfoo(1),nbudget,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      if( myid.eq.0 )then
        do n=1,nbudget
          qbudget(n)=cfoo(n)
        enddo
      else
        qbudget = 0.0
      endif
      if( imoist.eq.1 )then
        afoo = 0.0
        call MPI_REDUCE(asq(1),afoo(1),numq,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                        MPI_COMM_WORLD,ierr)
        if( myid.eq.0 )then
          do n=1,numq
            asq(n)=afoo(n)
          enddo
        else
          asq = 0.0
        endif
        bfoo = 0.0
        call MPI_REDUCE(bsq(1),bfoo(1),numq,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                        MPI_COMM_WORLD,ierr)
        if( myid.eq.0 )then
          do n=1,numq
            bsq(n)=bfoo(n)
          enddo
        else
          bsq = 0.0
        endif
      endif
#endif
!-----------------------------------------------------------------------

  IF( stat_out.gt.0 )THEN

      nstat = 0

    IF( adapt_dt.eq.1 )THEN
      nstat = 1
      rstat(nstat) = sngl(  adt/float(max(1,ndt)) )
      acfl         = sngl( acfl/float(max(1,ndt)) )
      reset = .true.
    ENDIF

      if(stat_w.eq.1) call maxmin(ni,nj,nk+1,wa,nstat,rstat,'WMAX  ','WMIN  ')
      if(stat_u.eq.1)then
        call maxmin(ni+1,nj,nk,ua,nstat,rstat,'UMAX  ','UMIN  ')
        call maxmin2d(ni+1,nj,ua(ib,jb,1),nstat,rstat,'SUMAX ','SUMIN ')
      endif
      if(stat_v.eq.1)then
        call maxmin(ni,nj+1,nk,va,nstat,rstat,'VMAX  ','VMIN  ')
!!!      if(myid.eq.0) print *,'  umax:',rstat(nstat)+rstat(nstat-1),rstat(nstat-4)+rstat(nstat-5),rstat(nstat-1)-rstat(nstat-5)
        call maxmin2d(ni,nj+1,va(ib,jb,1),nstat,rstat,'SVMAX ','SVMIN ')
      endif
      if(stat_rmw.eq.1)then
        call getrmw(nstat,rstat,xh,zh,ua,va)
      endif
 
      if(stat_pipert.eq.1) call maxmin(ni,nj,nk,ppi,nstat,rstat,'PPIMAX','PPIMIN')

      if(stat_prspert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum2(i,j,k)=prs(i,j,k)-p00*(pi0(i,j,k)**cpdrd)
        enddo
        enddo
        enddo
        call maxmin(ni,nj,nk,dum2,nstat,rstat,'PPMAX ','PPMIN ')
      endif

      if(stat_thpert.eq.1)then
        call maxmin(ni,nj,nk,tha,nstat,rstat,'THPMAX','THPMIN')
        call maxmin2d(ni,nj,tha(ib,jb,1),nstat,rstat,'STHPMX','STHPMN')
      endif

      if(imoist.eq.1.and.stat_q.eq.1)then
        do n=1,numq
          text1='MAX   '
          text2='MIN   '
          write(text1(4:6),121) qname(n)
          write(text2(4:6),121) qname(n)
121       format(a3)
          call maxmin(ni,nj,nk,qa(ib,jb,kb,n),nstat,rstat,text1,text2)
        enddo
      endif

      if(iturb.eq.1)then
        if(stat_tke.eq.1) call maxmin(ni,nj,nk+1,tkea,nstat,rstat,'TKEMAX','TKEMIN')
      endif

      if(iturb.ge.1)then
        if(stat_km.eq.1) call maxmin(ni,nj,nk+1,kmh,nstat,rstat,'KMHMAX','KMHMIN')
        if(stat_km.eq.1) call maxmin(ni,nj,nk+1,kmv,nstat,rstat,'KMVMAX','KMVMIN')
        if(stat_kh.eq.1) call maxmin(ni,nj,nk+1,khh,nstat,rstat,'KHHMAX','KHHMIN')
        if(stat_kh.eq.1) call maxmin(ni,nj,nk+1,khv,nstat,rstat,'KHVMAX','KHVMIN')
      endif

      if(stat_div.eq.1)then
      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum5(i,j,k)=                                                     &
              0.5*( (rho0(i,j,k)+rho0(i+1,j,k))*ua(i+1,j,k)                &
                   -(rho0(i,j,k)+rho0(i-1,j,k))*ua(i  ,j,k) )*rdx*uh(i)    &
             +0.5*( (rho0(i,j,k)+rho0(i,j+1,k))*va(i,j+1,k)                &
                   -(rho0(i,j,k)+rho0(i,j-1,k))*va(i,j  ,k) )*rdy*vh(j)    &
             +0.5*( (rho0(i,j,k)+rho0(i,j,k+1))*wa(i,j,k+1)                &
                   -(rho0(i,j,k)+rho0(i,j,k-1))*wa(i,j,k  ) )*rdz*mh(i,j,k)
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum5(i,j,k)=                                                     &
              rho0(1,1,k)*( xf(i+1)*ua(i+1,j,k)                            &
                           -xf(i  )*ua(i  ,j,k) )*rdx*uh(i)*rxh(i)         &
             +0.5*( (rho0(i,j,k)+rho0(i,j,k+1))*wa(i,j,k+1)                &
                   -(rho0(i,j,k)+rho0(i,j,k-1))*wa(i,j,k  ) )*rdz*mh(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
        call maxmin(ni,nj,nk,dum5,nstat,rstat,'DIVMAX','DIVMIN')
      endif

      IF(imoist.eq.1)THEN

        if(stat_rh.eq.1 .or. stat_the.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvs)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qvs=rslf( prs(i,j,k) , (th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k)) )
            dum2(i,j,k)=qa(i,j,k,nqv)*(1.0+qvs*reps)    &
                       /(qvs*(1.0+qa(i,j,k,nqv)*reps))
          enddo
          enddo
          enddo
        endif

        if(stat_rh.eq.1)then
          call maxmin(ni,nj,nk,dum2,nstat,rstat,'RHMAX ','RHMIN ')
        endif

        if(iice.eq.1 .and. stat_rhi.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvs)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qvs=rsif( prs(i,j,k) , (th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k)) )
            dum3(i,j,k)=qa(i,j,k,nqv)*(1.0+qvs*reps)    &
                       /(qvs*(1.0+qa(i,j,k,nqv)*reps))
          enddo
          enddo
          enddo
          call maxmin(ni,nj,nk,dum3,nstat,rstat,'RHIMAX','RHIMIN')
        endif

      ENDIF

        if(iptra.eq.1)then
          do n=1,npt
            text1='MXPT  '
            text2='MNPT  '
            if( n.le.9 )then
              write(text1(5:5),122) n
              write(text2(5:5),122) n
122           format(i1)
            else
              write(text1(5:6),123) n
              write(text2(5:6),123) n
123           format(i2)
            endif
            call maxmin(ni,nj,nk,pta(ib,jb,kb,n),nstat,rstat,text1,text2)
          enddo
        endif

      IF(imoist.eq.1)THEN

        if(stat_the.eq.1)then
          call calcthe(zh,pi0,th0,dum4,dum2,prs,ppi,tha,qa)
          call maxmin(ni,nj,nk,dum4,nstat,rstat,'THEMAX','THEMIN')
          call maxmin2d(ni,nj,dum4(ib,jb,1),nstat,rstat,'STHEMX','STHEMN')
        endif

        if(stat_cloud.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=0.0
          enddo
          enddo
          enddo
          do n=1,numq
            if(cloudvar(n))then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                dum1(i,j,k)=dum1(i,j,k)+qa(i,j,k,n)
              enddo
              enddo
              enddo
            endif
          enddo
          call cloud(nstat,rstat,zh,dum1)
        endif
      ENDIF

      if(stat_sfcprs.eq.1)then
        call maxmin2d(ni,nj,prs(ib,jb,1),nstat,rstat,'SFPMAX','SFPMIN')
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = cgs1*prs(i,j,1)+cgs2*prs(i,j,2)+cgs3*prs(i,j,3)
        enddo
        enddo
        call maxmin2d(ni,nj,dum1(ib,jb,1),nstat,rstat,'PSFCMX','PSFCMN')
      endif

      if(stat_wsp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=sqrt( (umove+0.5*(ua(i,j,k)+ua(i+1,j,k)))**2     &
                           +(vmove+0.5*(va(i,j,k)+va(i,j+1,k)))**2 )
        enddo
        enddo
        enddo
        call maxmin(ni,nj,nk,dum1,nstat,rstat,'WSPMAX','WSPMIN')
        call maxmin2d(ni,nj,dum1(ib,jb,1),nstat,rstat,'SWSPMX','SWSPMN')
      IF(bbc.eq.3)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1)=sqrt( u10(i,j)**2 + v10(i,j)**2 )
        enddo
        enddo
        call maxmin2d(ni,nj,dum1(ib,jb,1),nstat,rstat,'10MWMX','10MWMN')
      ENDIF
      endif

      if(stat_cfl.eq.1) call calccfl(nstat,rstat,dt,acfl,uh,vh,mh,ua,va,wa,1)

      if(stat_cfl.eq.1.and.iturb.ge.1) call calcksmax(nstat,rstat,dt,uh,vh,mf,kmh,kmv,khh,khv)

      if(stat_vort.eq.1) call vertvort(nstat,rstat,xh,xf,uf,vf,zh,zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf,dum1,dum2,ua,va)

      if(stat_tmass.eq.1) call calcmass(nstat,rstat,ruh,rvh,rmh,rho)

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum1(i,j,k)=0.0
        dum2(i,j,k)=0.0
        dum3(i,j,k)=0.0
      enddo
      enddo
      enddo
 
      IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=qa(i,j,k,nqv)
        enddo
        enddo
        enddo

        call getqli(qa,dum2,dum3)

        if(stat_tmois.eq.1)then
          call totmois(nstat,rstat,qbudget(budrain),ruh,rvh,rmh,dum1,dum2,dum3,rho)
        endif

        if(stat_qmass.eq.1)then
          do n=1,numq
            IF( (n.eq.nqv) .or.                                 &
                (n.ge.nql1.and.n.le.nql2) .or.                  &
                (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
              text1='   MAS'
              write(text1(1:3),121) qname(n)
              call totq(nstat,rstat,ruh,rvh,rmh,qa(ib,jb,kb,n),rho,text1)
            ENDIF
          enddo
        endif

      ENDIF

        if(imoist.eq.1)then
          if(ptype.eq.1.or.ptype.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=vq(i,j,k,3)
            enddo
            enddo
            enddo
          elseif(ptype.eq.6)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=vq(i,j,k,2)
            enddo
            enddo
            enddo
          else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=0.0
            enddo
            enddo
            enddo
          endif
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum4(i,j,k)=0.0
          enddo
          enddo
          enddo
        endif
 
      if(stat_tenerg.eq.1)then
        call calcener(nstat,rstat,ruh,rvh,zh,rmh,pi0,th0,rho,ua,va,wa,ppi,tha,    &
                      dum1,dum2,dum3,dum4)
      endif

      if(stat_mo.eq.1)then
        call calcmoe(nstat,rstat,ruh,rvh,rmh,rho,ua,va,wa,dum1,dum2,dum3,dum4)
      endif

      if(stat_tmf.eq.1) call tmf(nstat,rstat,ruh,rvh,rho,wa)

!----------

      IF(imoist.eq.1 .and. stat_pcn.eq.1)THEN
      if(myid.eq.0)then
100     format(2x,a6,':',1x,e13.6)
        do n=1,nbudget
          write(6,100) budname(n),qbudget(n)
          nstat = nstat + 1
          rstat(nstat) = qbudget(n)
        enddo
      endif
      ENDIF

      IF(imoist.eq.1 .and. stat_qsrc.eq.1)THEN
      if(myid.eq.0)then
        do n=1,numq
          text1='as    '
          write(text1(3:5),121) qname(n)
          write(6,100) text1,asq(n)
          nstat = nstat + 1
          rstat(nstat) = asq(n)
        enddo
        do n=1,numq
          text1='bs    '
          write(text1(3:5),121) qname(n)
          write(6,100) text1,bsq(n)
          nstat = nstat + 1
          rstat(nstat) = bsq(n)
        enddo
      endif
      ENDIF

  IF(myid.eq.0)THEN

!-----------------------------------------------------------------------
!  writeitout:  GrADS format

    IF(output_format.eq.1)THEN

      open(unit=60,file=statfile,form='unformatted',access='direct',   &
           recl=4,status='unknown')
      if( nstat.ne.stat_out )then
        print *,'  nstat,stat_out = ',nstat,stat_out
        stop 12998
      endif
      do n=1,nstat
#ifdef DP
        vout = rstat(n)
        write(60,rec=nrec) vout
#else
        write(60,rec=nrec) rstat(n)
#endif
        nrec = nrec + 1
      enddo
      close(unit=60)

!-----------------------------------------------------------------------
!  writeitout:  netcdf format

#ifdef NETCDF
    ELSEIF(output_format.eq.2)THEN

      call writestat_nc(nrec,rtime,nstat,rstat,qname,budname)

#endif

!-----------------------------------------------------------------------
!  writeout:  hdf5 format

#ifdef HDFOUT
    ELSEIF(output_format.ge.3)THEN

      call writestat_hdf5(nrec,rtime,nstat,rstat,qname,budname)

#endif

!-----------------------------------------------------------------------

    ENDIF

  ENDIF

      if(timestats.ge.1) time_stat=time_stat+mytime()

  ENDIF

      end subroutine statpack


thompson.F      1587424407  1602  20    100644  183130    `
!+---+-----------------------------------------------------------------+
!.. This subroutine computes the moisture tendencies of water vapor,
!.. cloud droplets, rain, cloud ice (pristine), snow, and graupel.
!.. Prior to WRFv2.2 this code was based on Reisner et al (1998), but
!.. few of those pieces remain.  A complete description is now found in
!.. Thompson, G., P. R. Field, R. M. Rasmussen, and W. D. Hall, 2008:
!.. Explicit Forecasts of winter precipitation using an improved bulk
!.. microphysics scheme. Part II: Implementation of a new snow
!.. parameterization.  Mon. Wea. Rev., 136, 5095-5115.
!.. Prior to WRFv3.1, this code was single-moment rain prediction as
!.. described in the reference above, but in v3.1 and higher, the
!.. scheme is two-moment rain (predicted rain number concentration).
!..
!.. Most importantly, users may wish to modify the prescribed number of
!.. cloud droplets (Nt_c; see guidelines mentioned below).  Otherwise,
!.. users may alter the rain and graupel size distribution parameters
!.. to use exponential (Marshal-Palmer) or generalized gamma shape.
!.. The snow field assumes a combination of two gamma functions (from
!.. Field et al. 2005) and would require significant modifications
!.. throughout the entire code to alter its shape as well as accretion
!.. rates.  Users may also alter the constants used for density of rain,
!.. graupel, ice, and snow, but the latter is not constant when using
!.. Paul Field's snow distribution and moments methods.  Other values
!.. users can modify include the constants for mass and/or velocity
!.. power law relations and assumed capacitances used in deposition/
!.. sublimation/evaporation/melting.
!.. Remaining values should probably be left alone.
!..
!..Author: Greg Thompson, NCAR-RAL, gthompsn@ucar.edu, 303-497-2805
!..Last modified: 06 Sep 2013
!..Adapted for CM1: 18 Sep 2013
!+---+-----------------------------------------------------------------+
!wrft:model_layer:physics
!+---+-----------------------------------------------------------------+
!
      MODULE module_mp_thompson

!!!      USE module_wrf_error
!!!      USE module_mp_radar
!!!      USE module_utility, ONLY: WRFU_Clock, WRFU_Alarm
!!!      USE module_domain, ONLY : HISTORY_ALARM, Is_alarm_tstep

      IMPLICIT NONE

      LOGICAL, PARAMETER, PRIVATE:: iiwarm = .false.
      INTEGER, PARAMETER, PRIVATE:: IFDRY = 0
      REAL, PARAMETER, PRIVATE:: T_0 = 273.15
      REAL, PARAMETER, PRIVATE:: PI = 3.1415926536

!..Densities of rain, snow, graupel, and cloud ice.
      REAL, PARAMETER, PRIVATE:: rho_w = 1000.0
      REAL, PARAMETER, PRIVATE:: rho_s = 100.0
      REAL, PARAMETER, PRIVATE:: rho_g = 500.0
      REAL, PARAMETER, PRIVATE:: rho_i = 890.0

!..Prescribed number of cloud droplets.  Set according to known data or
!.. roughly 100 per cc (100.E6 m^-3) for Maritime cases and
!.. 300 per cc (300.E6 m^-3) for Continental.  Gamma shape parameter,
!.. mu_c, calculated based on Nt_c is important in autoconversion
!.. scheme.
      ! setting to continental-type value by default:  GHB, 130918
!!!      REAL, PARAMETER, PRIVATE:: Nt_c = 100.E6
      REAL, PARAMETER, PRIVATE:: Nt_c = 250.E6

!..Generalized gamma distributions for rain, graupel and cloud ice.
!.. N(D) = N_0 * D**mu * exp(-lamda*D);  mu=0 is exponential.
      REAL, PARAMETER, PRIVATE:: mu_r = 0.0
      REAL, PARAMETER, PRIVATE:: mu_g = 0.0
      REAL, PARAMETER, PRIVATE:: mu_i = 0.0
      REAL, PRIVATE:: mu_c

!..Sum of two gamma distrib for snow (Field et al. 2005).
!.. N(D) = M2**4/M3**3 * [Kap0*exp(-M2*Lam0*D/M3)
!..    + Kap1*(M2/M3)**mu_s * D**mu_s * exp(-M2*Lam1*D/M3)]
!.. M2 and M3 are the (bm_s)th and (bm_s+1)th moments respectively
!.. calculated as function of ice water content and temperature.
      REAL, PARAMETER, PRIVATE:: mu_s = 0.6357
      REAL, PARAMETER, PRIVATE:: Kap0 = 490.6
      REAL, PARAMETER, PRIVATE:: Kap1 = 17.46
      REAL, PARAMETER, PRIVATE:: Lam0 = 20.78
      REAL, PARAMETER, PRIVATE:: Lam1 = 3.29

!..Y-intercept parameter for graupel is not constant and depends on
!.. mixing ratio.  Also, when mu_g is non-zero, these become equiv
!.. y-intercept for an exponential distrib and proper values are
!.. computed based on same mixing ratio and total number concentration.
      REAL, PARAMETER, PRIVATE:: gonv_min = 1.E4
      REAL, PARAMETER, PRIVATE:: gonv_max = 3.E6

!..Mass power law relations:  mass = am*D**bm
!.. Snow from Field et al. (2005), others assume spherical form.
      REAL, PARAMETER, PRIVATE:: am_r = PI*rho_w/6.0
      REAL, PARAMETER, PRIVATE:: bm_r = 3.0
      REAL, PARAMETER, PRIVATE:: am_s = 0.069
      REAL, PARAMETER, PRIVATE:: bm_s = 2.0
      REAL, PARAMETER, PRIVATE:: am_g = PI*rho_g/6.0
      REAL, PARAMETER, PRIVATE:: bm_g = 3.0
      REAL, PARAMETER, PRIVATE:: am_i = PI*rho_i/6.0
      REAL, PARAMETER, PRIVATE:: bm_i = 3.0

!..Fallspeed power laws relations:  v = (av*D**bv)*exp(-fv*D)
!.. Rain from Ferrier (1994), ice, snow, and graupel from
!.. Thompson et al (2008). Coefficient fv is zero for graupel/ice.
      REAL, PARAMETER, PRIVATE:: av_r = 4854.0
      REAL, PARAMETER, PRIVATE:: bv_r = 1.0
      REAL, PARAMETER, PRIVATE:: fv_r = 195.0
      REAL, PARAMETER, PRIVATE:: av_s = 40.0
      REAL, PARAMETER, PRIVATE:: bv_s = 0.55
      REAL, PARAMETER, PRIVATE:: fv_s = 100.0
      REAL, PARAMETER, PRIVATE:: av_g = 442.0
      REAL, PARAMETER, PRIVATE:: bv_g = 0.89
      REAL, PARAMETER, PRIVATE:: av_i = 1847.5
      REAL, PARAMETER, PRIVATE:: bv_i = 1.0

!..Capacitance of sphere and plates/aggregates: D**3, D**2
      REAL, PARAMETER, PRIVATE:: C_cube = 0.5
      REAL, PARAMETER, PRIVATE:: C_sqrd = 0.3

!..Collection efficiencies.  Rain/snow/graupel collection of cloud
!.. droplets use variables (Ef_rw, Ef_sw, Ef_gw respectively) and
!.. get computed elsewhere because they are dependent on stokes
!.. number.
      REAL, PARAMETER, PRIVATE:: Ef_si = 0.05
      REAL, PARAMETER, PRIVATE:: Ef_rs = 0.95
      REAL, PARAMETER, PRIVATE:: Ef_rg = 0.75
      REAL, PARAMETER, PRIVATE:: Ef_ri = 0.95

!..Minimum microphys values
!.. R1 value, 1.E-12, cannot be set lower because of numerical
!.. problems with Paul Field's moments and should not be set larger
!.. because of truncation problems in snow/ice growth.
      REAL, PARAMETER, PRIVATE:: R1 = 1.E-12
      REAL, PARAMETER, PRIVATE:: R2 = 1.E-6
      REAL, PARAMETER, PRIVATE:: eps = 1.E-15

!..Constants in Cooper curve relation for cloud ice number.
      REAL, PARAMETER, PRIVATE:: TNO = 5.0
      REAL, PARAMETER, PRIVATE:: ATO = 0.304

!..Rho_not used in fallspeed relations (rho_not/rho)**.5 adjustment.
      REAL, PARAMETER, PRIVATE:: rho_not = 101325.0/(287.05*298.0)

!..Schmidt number
      REAL, PARAMETER, PRIVATE:: Sc = 0.632
      REAL, PRIVATE:: Sc3

!..Homogeneous freezing temperature
      REAL, PARAMETER, PRIVATE:: HGFR = 235.16

!..Water vapor and air gas constants at constant pressure
      REAL, PARAMETER, PRIVATE:: Rv = 461.5
      REAL, PARAMETER, PRIVATE:: oRv = 1./Rv
      REAL, PARAMETER, PRIVATE:: R = 287.04
      REAL, PARAMETER, PRIVATE:: Cp = 1004.0
      ! for CM1:
      REAL, PARAMETER, PRIVATE:: cv = Cp - R
      REAL, PARAMETER, PRIVATE:: cvv = 1408.5
      REAL, PARAMETER, PRIVATE:: cpl = 4190.0
      REAL, PARAMETER, PRIVATE:: cpi = 2106.0
      REAL, PARAMETER, PRIVATE:: EP_2 = R/RV

!..Enthalpy of sublimation, vaporization, and fusion at 0C.
      REAL, PARAMETER, PRIVATE:: lsub = 2.834E6
      REAL, PARAMETER, PRIVATE:: lvap0 = 2.5E6
      REAL, PARAMETER, PRIVATE:: lfus = lsub - lvap0
      REAL, PARAMETER, PRIVATE:: olfus = 1./lfus

!..Ice initiates with this mass (kg), corresponding diameter calc.
!..Min diameters and mass of cloud, rain, snow, and graupel (m, kg).
      REAL, PARAMETER, PRIVATE:: xm0i = 1.E-12
      REAL, PARAMETER, PRIVATE:: D0c = 1.E-6
      REAL, PARAMETER, PRIVATE:: D0r = 50.E-6
      REAL, PARAMETER, PRIVATE:: D0s = 200.E-6
      REAL, PARAMETER, PRIVATE:: D0g = 250.E-6
      REAL, PRIVATE:: D0i, xm0s, xm0g

!..Lookup table dimensions
      INTEGER, PARAMETER, PRIVATE:: nbins = 100
      INTEGER, PARAMETER, PRIVATE:: nbc = nbins
      INTEGER, PARAMETER, PRIVATE:: nbi = nbins
      INTEGER, PARAMETER, PRIVATE:: nbr = nbins
      INTEGER, PARAMETER, PRIVATE:: nbs = nbins
      INTEGER, PARAMETER, PRIVATE:: nbg = nbins
      INTEGER, PARAMETER, PRIVATE:: ntb_c = 37
      INTEGER, PARAMETER, PRIVATE:: ntb_i = 64
      INTEGER, PARAMETER, PRIVATE:: ntb_r = 37
      INTEGER, PARAMETER, PRIVATE:: ntb_s = 28
      INTEGER, PARAMETER, PRIVATE:: ntb_g = 28
      INTEGER, PARAMETER, PRIVATE:: ntb_g1 = 28
      INTEGER, PARAMETER, PRIVATE:: ntb_r1 = 37
      INTEGER, PARAMETER, PRIVATE:: ntb_i1 = 55
      INTEGER, PARAMETER, PRIVATE:: ntb_t = 9
      INTEGER, PRIVATE:: nic2, nii2, nii3, nir2, nir3, nis2, nig2, nig3

      DOUBLE PRECISION, DIMENSION(nbins+1):: xDx
      DOUBLE PRECISION, DIMENSION(nbc):: Dc, dtc
      DOUBLE PRECISION, DIMENSION(nbi):: Di, dti
      DOUBLE PRECISION, DIMENSION(nbr):: Dr, dtr
      DOUBLE PRECISION, DIMENSION(nbs):: Ds, dts
      DOUBLE PRECISION, DIMENSION(nbg):: Dg, dtg

!..Lookup tables for cloud water content (kg/m**3).
      REAL, DIMENSION(ntb_c), PARAMETER, PRIVATE:: &
      r_c = (/1.e-6,2.e-6,3.e-6,4.e-6,5.e-6,6.e-6,7.e-6,8.e-6,9.e-6, &
              1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for cloud ice content (kg/m**3).
      REAL, DIMENSION(ntb_i), PARAMETER, PRIVATE:: &
      r_i = (/1.e-10,2.e-10,3.e-10,4.e-10, &
              5.e-10,6.e-10,7.e-10,8.e-10,9.e-10, &
              1.e-9,2.e-9,3.e-9,4.e-9,5.e-9,6.e-9,7.e-9,8.e-9,9.e-9, &
              1.e-8,2.e-8,3.e-8,4.e-8,5.e-8,6.e-8,7.e-8,8.e-8,9.e-8, &
              1.e-7,2.e-7,3.e-7,4.e-7,5.e-7,6.e-7,7.e-7,8.e-7,9.e-7, &
              1.e-6,2.e-6,3.e-6,4.e-6,5.e-6,6.e-6,7.e-6,8.e-6,9.e-6, &
              1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3/)

!..Lookup tables for rain content (kg/m**3).
      REAL, DIMENSION(ntb_r), PARAMETER, PRIVATE:: &
      r_r = (/1.e-6,2.e-6,3.e-6,4.e-6,5.e-6,6.e-6,7.e-6,8.e-6,9.e-6, &
              1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for graupel content (kg/m**3).
      REAL, DIMENSION(ntb_g), PARAMETER, PRIVATE:: &
      r_g = (/1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for snow content (kg/m**3).
      REAL, DIMENSION(ntb_s), PARAMETER, PRIVATE:: &
      r_s = (/1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for rain y-intercept parameter (/m**4).
      REAL, DIMENSION(ntb_r1), PARAMETER, PRIVATE:: &
      N0r_exp = (/1.e6,2.e6,3.e6,4.e6,5.e6,6.e6,7.e6,8.e6,9.e6, &
                  1.e7,2.e7,3.e7,4.e7,5.e7,6.e7,7.e7,8.e7,9.e7, &
                  1.e8,2.e8,3.e8,4.e8,5.e8,6.e8,7.e8,8.e8,9.e8, &
                  1.e9,2.e9,3.e9,4.e9,5.e9,6.e9,7.e9,8.e9,9.e9, &
                  1.e10/)

!..Lookup tables for graupel y-intercept parameter (/m**4).
      REAL, DIMENSION(ntb_g1), PARAMETER, PRIVATE:: &
      N0g_exp = (/1.e4,2.e4,3.e4,4.e4,5.e4,6.e4,7.e4,8.e4,9.e4, &
                  1.e5,2.e5,3.e5,4.e5,5.e5,6.e5,7.e5,8.e5,9.e5, &
                  1.e6,2.e6,3.e6,4.e6,5.e6,6.e6,7.e6,8.e6,9.e6, &
                  1.e7/)

!..Lookup tables for ice number concentration (/m**3).
      REAL, DIMENSION(ntb_i1), PARAMETER, PRIVATE:: &
      Nt_i = (/1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0, &
               1.e1,2.e1,3.e1,4.e1,5.e1,6.e1,7.e1,8.e1,9.e1, &
               1.e2,2.e2,3.e2,4.e2,5.e2,6.e2,7.e2,8.e2,9.e2, &
               1.e3,2.e3,3.e3,4.e3,5.e3,6.e3,7.e3,8.e3,9.e3, &
               1.e4,2.e4,3.e4,4.e4,5.e4,6.e4,7.e4,8.e4,9.e4, &
               1.e5,2.e5,3.e5,4.e5,5.e5,6.e5,7.e5,8.e5,9.e5, &
               1.e6/)

!..For snow moments conversions (from Field et al. 2005)
      REAL, DIMENSION(10), PARAMETER, PRIVATE:: &
      sa = (/ 5.065339, -0.062659, -3.032362, 0.029469, -0.000285, &
              0.31255,   0.000204,  0.003199, 0.0,      -0.015952/)
      REAL, DIMENSION(10), PARAMETER, PRIVATE:: &
      sb = (/ 0.476221, -0.015896,  0.165977, 0.007468, -0.000141, &
              0.060366,  0.000079,  0.000594, 0.0,      -0.003577/)

!..Temperatures (5 C interval 0 to -40) used in lookup tables.
      REAL, DIMENSION(ntb_t), PARAMETER, PRIVATE:: &
      Tc = (/-0.01, -5., -10., -15., -20., -25., -30., -35., -40./)

!..Lookup tables for various accretion/collection terms.
!.. ntb_x refers to the number of elements for rain, snow, graupel,
!.. and temperature array indices.  Variables beginning with t-p/c/m/n
!.. represent lookup tables.  Save compile-time memory by making
!.. allocatable (2009Jun12, J. Michalakes).
      INTEGER, PARAMETER, PRIVATE:: R8SIZE = 8
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:,:)::             &
                tcg_racg, tmr_racg, tcr_gacr, tmg_gacr,                 &
                tnr_racg, tnr_gacr
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:,:)::             &
                tcs_racs1, tmr_racs1, tcs_racs2, tmr_racs2,             &
                tcr_sacr1, tms_sacr1, tcr_sacr2, tms_sacr2,             &
                tnr_racs1, tnr_racs2, tnr_sacr1, tnr_sacr2
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:)::                 &
                tpi_qcfz, tni_qcfz
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:)::               &
                tpi_qrfz, tpg_qrfz, tni_qrfz, tnr_qrfz
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:)::                 &
                tps_iaus, tni_iaus, tpi_ide
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:):: t_Efrw
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:):: t_Efsw
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:):: tnr_rev

!..Variables holding a bunch of exponents and gamma values (cloud water,
!.. cloud ice, rain, snow, then graupel).
      REAL, DIMENSION(3), PRIVATE:: cce, ccg
      REAL, PRIVATE::  ocg1, ocg2
      REAL, DIMENSION(7), PRIVATE:: cie, cig
      REAL, PRIVATE:: oig1, oig2, obmi
      REAL, DIMENSION(13), PRIVATE:: cre, crg
      REAL, PRIVATE:: ore1, org1, org2, org3, obmr
      REAL, DIMENSION(18), PRIVATE:: cse, csg
      REAL, PRIVATE:: oams, obms, ocms
      REAL, DIMENSION(12), PRIVATE:: cge, cgg
      REAL, PRIVATE:: oge1, ogg1, ogg2, ogg3, oamg, obmg, ocmg

!..Declaration of precomputed constants in various rate eqns.
      REAL:: t1_qr_qc, t1_qr_qi, t2_qr_qi, t1_qg_qc, t1_qs_qc, t1_qs_qi
      REAL:: t1_qr_ev, t2_qr_ev
      REAL:: t1_qs_sd, t2_qs_sd, t1_qg_sd, t2_qg_sd
      REAL:: t1_qs_me, t2_qs_me, t1_qg_me, t2_qg_me

      CHARACTER*256:: mp_debug

!..Various radar related variables
      PUBLIC :: rayleigh_soak_wetgraupel
      PUBLIC :: radar_init
      PRIVATE :: m_complex_water_ray
      PRIVATE :: m_complex_ice_maetzler
      PRIVATE :: m_complex_maxwellgarnett
      PRIVATE :: get_m_mix_nested
      PRIVATE :: get_m_mix
      PRIVATE :: WGAMMA
      PRIVATE :: GAMMLN


      INTEGER, PARAMETER, PUBLIC:: nrbins = 50
      DOUBLE PRECISION, DIMENSION(nrbins+1), PUBLIC:: xxDx
      DOUBLE PRECISION, DIMENSION(nrbins), PUBLIC:: xxDs,xdts,xxDg,xdtg
      DOUBLE PRECISION, PARAMETER, PUBLIC:: lamda_radar = 0.10           ! in meters
      DOUBLE PRECISION, PUBLIC:: K_w, PI5, lamda4
      COMPLEX*16, PUBLIC:: m_w_0, m_i_0
      DOUBLE PRECISION, DIMENSION(nrbins+1), PUBLIC:: simpson
      DOUBLE PRECISION, DIMENSION(3), PARAMETER, PUBLIC:: basis =       &
                           (/1.d0/3.d0, 4.d0/3.d0, 1.d0/3.d0/)
      REAL, DIMENSION(4), PUBLIC:: xcre, xcse, xcge, xcrg, xcsg, xcgg
      REAL, PUBLIC:: xam_r, xbm_r, xmu_r, xobmr
      REAL, PUBLIC:: xam_s, xbm_s, xmu_s, xoams, xobms, xocms
      REAL, PUBLIC:: xam_g, xbm_g, xmu_g, xoamg, xobmg, xocmg
      REAL, PUBLIC:: xorg2, xosg2, xogg2

      INTEGER, PARAMETER, PUBLIC:: slen = 20
      CHARACTER(len=slen), PUBLIC::                                     &
              mixingrulestring_s, matrixstring_s, inclusionstring_s,    &
              hoststring_s, hostmatrixstring_s, hostinclusionstring_s,  &
              mixingrulestring_g, matrixstring_g, inclusionstring_g,    &
              hoststring_g, hostmatrixstring_g, hostinclusionstring_g

!..Single melting snow/graupel particle 90% meltwater on external sfc
      DOUBLE PRECISION, PARAMETER:: melt_outside_s = 0.9d0
      DOUBLE PRECISION, PARAMETER:: melt_outside_g = 0.9d0

      CHARACTER*256:: radar_debug

!+---+
!+---+-----------------------------------------------------------------+
!..END DECLARATIONS
!+---+-----------------------------------------------------------------+
!+---+
!ctrlL

      CONTAINS

      SUBROUTINE thompson_init

      IMPLICIT NONE

      INTEGER:: i, j, k, m, n
      LOGICAL:: micro_init

!..Allocate space for lookup tables (J. Michalakes 2009Jun08).
      micro_init = .FALSE.

      if (.NOT. ALLOCATED(tcg_racg) ) then
         ALLOCATE(tcg_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))
         micro_init = .TRUE.
      endif

      if (.NOT. ALLOCATED(tmr_racg)) ALLOCATE(tmr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcr_gacr)) ALLOCATE(tcr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tmg_gacr)) ALLOCATE(tmg_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_racg)) ALLOCATE(tnr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_gacr)) ALLOCATE(tnr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))

      if (.NOT. ALLOCATED(tcs_racs1)) ALLOCATE(tcs_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tmr_racs1)) ALLOCATE(tmr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcs_racs2)) ALLOCATE(tcs_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tmr_racs2)) ALLOCATE(tmr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcr_sacr1)) ALLOCATE(tcr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tms_sacr1)) ALLOCATE(tms_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcr_sacr2)) ALLOCATE(tcr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tms_sacr2)) ALLOCATE(tms_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_racs1)) ALLOCATE(tnr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_racs2)) ALLOCATE(tnr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_sacr1)) ALLOCATE(tnr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_sacr2)) ALLOCATE(tnr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))

      if (.NOT. ALLOCATED(tpi_qcfz)) ALLOCATE(tpi_qcfz(ntb_c,45))
      if (.NOT. ALLOCATED(tni_qcfz)) ALLOCATE(tni_qcfz(ntb_c,45))

      if (.NOT. ALLOCATED(tpi_qrfz)) ALLOCATE(tpi_qrfz(ntb_r,ntb_r1,45))
      if (.NOT. ALLOCATED(tpg_qrfz)) ALLOCATE(tpg_qrfz(ntb_r,ntb_r1,45))
      if (.NOT. ALLOCATED(tni_qrfz)) ALLOCATE(tni_qrfz(ntb_r,ntb_r1,45))
      if (.NOT. ALLOCATED(tnr_qrfz)) ALLOCATE(tnr_qrfz(ntb_r,ntb_r1,45))

      if (.NOT. ALLOCATED(tps_iaus)) ALLOCATE(tps_iaus(ntb_i,ntb_i1))
      if (.NOT. ALLOCATED(tni_iaus)) ALLOCATE(tni_iaus(ntb_i,ntb_i1))
      if (.NOT. ALLOCATED(tpi_ide)) ALLOCATE(tpi_ide(ntb_i,ntb_i1))

      if (.NOT. ALLOCATED(t_Efrw)) ALLOCATE(t_Efrw(nbr,nbc))
      if (.NOT. ALLOCATED(t_Efsw)) ALLOCATE(t_Efsw(nbs,nbc))

      if (.NOT. ALLOCATED(tnr_rev)) ALLOCATE(tnr_rev(nbr, ntb_r1, ntb_r))

      if (micro_init) then

!..From Martin et al. (1994), assign gamma shape parameter mu for cloud
!.. drops according to general dispersion characteristics (disp=~0.25
!.. for Maritime and 0.45 for Continental).
!.. disp=SQRT((mu+2)/(mu+1) - 1) so mu varies from 15 for Maritime
!.. to 2 for really dirty air.
      mu_c = MIN(15., (1000.E6/Nt_c + 2.))

!..Schmidt number to one-third used numerous times.
      Sc3 = Sc**(1./3.)

!..Compute min ice diam from mass, min snow/graupel mass from diam.
      D0i = (xm0i/am_i)**(1./bm_i)
      xm0s = am_s * D0s**bm_s
      xm0g = am_g * D0g**bm_g

!..These constants various exponents and gamma() assoc with cloud,
!.. rain, snow, and graupel.
      cce(1) = mu_c + 1.
      cce(2) = bm_r + mu_c + 1.
      cce(3) = bm_r + mu_c + 4.
      ccg(1) = WGAMMA(cce(1))
      ccg(2) = WGAMMA(cce(2))
      ccg(3) = WGAMMA(cce(3))
      ocg1 = 1./ccg(1)
      ocg2 = 1./ccg(2)

      cie(1) = mu_i + 1.
      cie(2) = bm_i + mu_i + 1.
      cie(3) = bm_i + mu_i + bv_i + 1.
      cie(4) = mu_i + bv_i + 1.
      cie(5) = mu_i + 2.
      cie(6) = bm_i*0.5 + mu_i + bv_i + 1.
      cie(7) = bm_i*0.5 + mu_i + 1.
      cig(1) = WGAMMA(cie(1))
      cig(2) = WGAMMA(cie(2))
      cig(3) = WGAMMA(cie(3))
      cig(4) = WGAMMA(cie(4))
      cig(5) = WGAMMA(cie(5))
      cig(6) = WGAMMA(cie(6))
      cig(7) = WGAMMA(cie(7))
      oig1 = 1./cig(1)
      oig2 = 1./cig(2)
      obmi = 1./bm_i

      cre(1) = bm_r + 1.
      cre(2) = mu_r + 1.
      cre(3) = bm_r + mu_r + 1.
      cre(4) = bm_r*2. + mu_r + 1.
      cre(5) = mu_r + bv_r + 1.
      cre(6) = bm_r + mu_r + bv_r + 1.
      cre(7) = bm_r*0.5 + mu_r + bv_r + 1.
      cre(8) = bm_r + mu_r + bv_r + 3.
      cre(9) = mu_r + bv_r + 3.
      cre(10) = mu_r + 2.
      cre(11) = 0.5*(bv_r + 5. + 2.*mu_r)
      cre(12) = bm_r*0.5 + mu_r + 1.
      cre(13) = bm_r*2. + mu_r + bv_r + 1.
      do n = 1, 13
         crg(n) = WGAMMA(cre(n))
      enddo
      obmr = 1./bm_r
      ore1 = 1./cre(1)
      org1 = 1./crg(1)
      org2 = 1./crg(2)
      org3 = 1./crg(3)

      cse(1) = bm_s + 1.
      cse(2) = bm_s + 2.
      cse(3) = bm_s*2.
      cse(4) = bm_s + bv_s + 1.
      cse(5) = bm_s*2. + bv_s + 1.
      cse(6) = bm_s*2. + 1.
      cse(7) = bm_s + mu_s + 1.
      cse(8) = bm_s + mu_s + 2.
      cse(9) = bm_s + mu_s + 3.
      cse(10) = bm_s + mu_s + bv_s + 1.
      cse(11) = bm_s*2. + mu_s + bv_s + 1.
      cse(12) = bm_s*2. + mu_s + 1.
      cse(13) = bv_s + 2.
      cse(14) = bm_s + bv_s
      cse(15) = mu_s + 1.
      cse(16) = 1.0 + (1.0 + bv_s)/2.
      cse(17) = cse(16) + mu_s + 1.
      cse(18) = bv_s + mu_s + 3.
      do n = 1, 18
         csg(n) = WGAMMA(cse(n))
      enddo
      oams = 1./am_s
      obms = 1./bm_s
      ocms = oams**obms

      cge(1) = bm_g + 1.
      cge(2) = mu_g + 1.
      cge(3) = bm_g + mu_g + 1.
      cge(4) = bm_g*2. + mu_g + 1.
      cge(5) = bm_g*2. + mu_g + bv_g + 1.
      cge(6) = bm_g + mu_g + bv_g + 1.
      cge(7) = bm_g + mu_g + bv_g + 2.
      cge(8) = bm_g + mu_g + bv_g + 3.
      cge(9) = mu_g + bv_g + 3.
      cge(10) = mu_g + 2.
      cge(11) = 0.5*(bv_g + 5. + 2.*mu_g)
      cge(12) = 0.5*(bv_g + 5.) + mu_g
      do n = 1, 12
         cgg(n) = WGAMMA(cge(n))
      enddo
      oamg = 1./am_g
      obmg = 1./bm_g
      ocmg = oamg**obmg
      oge1 = 1./cge(1)
      ogg1 = 1./cgg(1)
      ogg2 = 1./cgg(2)
      ogg3 = 1./cgg(3)

!+---+-----------------------------------------------------------------+
!..Simplify various rate eqns the best we can now.
!+---+-----------------------------------------------------------------+

!..Rain collecting cloud water and cloud ice
      t1_qr_qc = PI*.25*av_r * crg(9)
      t1_qr_qi = PI*.25*av_r * crg(9)
      t2_qr_qi = PI*.25*am_r*av_r * crg(8)

!..Graupel collecting cloud water
      t1_qg_qc = PI*.25*av_g * cgg(9)

!..Snow collecting cloud water
      t1_qs_qc = PI*.25*av_s

!..Snow collecting cloud ice
      t1_qs_qi = PI*.25*av_s

!..Evaporation of rain; ignore depositional growth of rain.
      t1_qr_ev = 0.78 * crg(10)
      t2_qr_ev = 0.308*Sc3*SQRT(av_r) * crg(11)

!..Sublimation/depositional growth of snow
      t1_qs_sd = 0.86
      t2_qs_sd = 0.28*Sc3*SQRT(av_s)

!..Melting of snow
      t1_qs_me = PI*4.*C_sqrd*olfus * 0.86
      t2_qs_me = PI*4.*C_sqrd*olfus * 0.28*Sc3*SQRT(av_s)

!..Sublimation/depositional growth of graupel
      t1_qg_sd = 0.86 * cgg(10)
      t2_qg_sd = 0.28*Sc3*SQRT(av_g) * cgg(11)

!..Melting of graupel
      t1_qg_me = PI*4.*C_cube*olfus * 0.86 * cgg(10)
      t2_qg_me = PI*4.*C_cube*olfus * 0.28*Sc3*SQRT(av_g) * cgg(11)

!..Constants for helping find lookup table indexes.
      nic2 = NINT(ALOG10(r_c(1)))
      nii2 = NINT(ALOG10(r_i(1)))
      nii3 = NINT(ALOG10(Nt_i(1)))
      nir2 = NINT(ALOG10(r_r(1)))
      nir3 = NINT(ALOG10(N0r_exp(1)))
      nis2 = NINT(ALOG10(r_s(1)))
      nig2 = NINT(ALOG10(r_g(1)))
      nig3 = NINT(ALOG10(N0g_exp(1)))

!..Create bins of cloud water (from min diameter up to 100 microns).
      Dc(1) = D0c*1.0d0
      dtc(1) = D0c*1.0d0
      do n = 2, nbc
         Dc(n) = Dc(n-1) + 1.0D-6
         dtc(n) = (Dc(n) - Dc(n-1))
      enddo

!..Create bins of cloud ice (from min diameter up to 5x min snow size).
      xDx(1) = D0i*1.0d0
      xDx(nbi+1) = 5.0d0*D0s
      do n = 2, nbi
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbi) &
                  *DLOG(xDx(nbi+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbi
         Di(n) = DSQRT(xDx(n)*xDx(n+1))
         dti(n) = xDx(n+1) - xDx(n)
      enddo

!..Create bins of rain (from min diameter up to 5 mm).
      xDx(1) = D0r*1.0d0
      xDx(nbr+1) = 0.005d0
      do n = 2, nbr
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbr) &
                  *DLOG(xDx(nbr+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbr
         Dr(n) = DSQRT(xDx(n)*xDx(n+1))
         dtr(n) = xDx(n+1) - xDx(n)
      enddo

!..Create bins of snow (from min diameter up to 2 cm).
      xDx(1) = D0s*1.0d0
      xDx(nbs+1) = 0.02d0
      do n = 2, nbs
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbs) &
                  *DLOG(xDx(nbs+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbs
         Ds(n) = DSQRT(xDx(n)*xDx(n+1))
         dts(n) = xDx(n+1) - xDx(n)
      enddo

!..Create bins of graupel (from min diameter up to 5 cm).
      xDx(1) = D0g*1.0d0
      xDx(nbg+1) = 0.05d0
      do n = 2, nbg
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbg) &
                  *DLOG(xDx(nbg+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbg
         Dg(n) = DSQRT(xDx(n)*xDx(n+1))
         dtg(n) = xDx(n+1) - xDx(n)
      enddo

!+---+-----------------------------------------------------------------+
!..Create lookup tables for most costly calculations.
!+---+-----------------------------------------------------------------+

      do m = 1, ntb_r
         do k = 1, ntb_r1
            do j = 1, ntb_g
               do i = 1, ntb_g1
                  tcg_racg(i,j,k,m) = 0.0d0
                  tmr_racg(i,j,k,m) = 0.0d0
                  tcr_gacr(i,j,k,m) = 0.0d0
                  tmg_gacr(i,j,k,m) = 0.0d0
                  tnr_racg(i,j,k,m) = 0.0d0
                  tnr_gacr(i,j,k,m) = 0.0d0
               enddo
            enddo
         enddo
      enddo

      do m = 1, ntb_r
         do k = 1, ntb_r1
            do j = 1, ntb_t
               do i = 1, ntb_s
                  tcs_racs1(i,j,k,m) = 0.0d0
                  tmr_racs1(i,j,k,m) = 0.0d0
                  tcs_racs2(i,j,k,m) = 0.0d0
                  tmr_racs2(i,j,k,m) = 0.0d0
                  tcr_sacr1(i,j,k,m) = 0.0d0
                  tms_sacr1(i,j,k,m) = 0.0d0
                  tcr_sacr2(i,j,k,m) = 0.0d0
                  tms_sacr2(i,j,k,m) = 0.0d0
                  tnr_racs1(i,j,k,m) = 0.0d0
                  tnr_racs2(i,j,k,m) = 0.0d0
                  tnr_sacr1(i,j,k,m) = 0.0d0
                  tnr_sacr2(i,j,k,m) = 0.0d0
               enddo
            enddo
         enddo
      enddo

      do k = 1, 45
         do j = 1, ntb_r1
            do i = 1, ntb_r
               tpi_qrfz(i,j,k) = 0.0d0
               tni_qrfz(i,j,k) = 0.0d0
               tpg_qrfz(i,j,k) = 0.0d0
               tnr_qrfz(i,j,k) = 0.0d0
            enddo
         enddo
         do i = 1, ntb_c
            tpi_qcfz(i,k) = 0.0d0
            tni_qcfz(i,k) = 0.0d0
         enddo
      enddo

      do j = 1, ntb_i1
         do i = 1, ntb_i
            tps_iaus(i,j) = 0.0d0
            tni_iaus(i,j) = 0.0d0
            tpi_ide(i,j) = 0.0d0
         enddo
      enddo

      do j = 1, nbc
         do i = 1, nbr
            t_Efrw(i,j) = 0.0
         enddo
         do i = 1, nbs
            t_Efsw(i,j) = 0.0
         enddo
      enddo

      do k = 1, ntb_r
         do j = 1, ntb_r1
            do i = 1, nbr
               tnr_rev(i,j,k) = 0.0d0
            enddo
         enddo
      enddo

!!!      CALL wrf_debug(150, 'CREATING MICROPHYSICS LOOKUP TABLES ... ')
!!!      WRITE (wrf_err_message, '(a, f5.2, a, f5.2, a, f5.2, a, f5.2)') &
!!!          ' using: mu_c=',mu_c,' mu_i=',mu_i,' mu_r=',mu_r,' mu_g=',mu_g
!!!      CALL wrf_debug(150, wrf_err_message)

!..Collision efficiency between rain/snow and cloud water.
!!!      CALL wrf_debug(200, '  creating qc collision eff tables')
      call table_Efrw
      call table_Efsw

!..Drop evaporation.
!     CALL wrf_debug(200, '  creating rain evap table')
!     call table_dropEvap

!..Initialize various constants for computing radar reflectivity.
      xam_r = am_r
      xbm_r = bm_r
      xmu_r = mu_r
      xam_s = am_s
      xbm_s = bm_s
      xmu_s = mu_s
      xam_g = am_g
      xbm_g = bm_g
      xmu_g = mu_g
      call radar_init

      if (.not. iiwarm) then

!..Rain collecting graupel & graupel collecting rain.
!!!      CALL wrf_debug(200, '  creating rain collecting graupel table')
      call qr_acr_qg

!..Rain collecting snow & snow collecting rain.
!!!      CALL wrf_debug(200, '  creating rain collecting snow table')
      call qr_acr_qs

!..Cloud water and rain freezing (Bigg, 1953).
!!!      CALL wrf_debug(200, '  creating freezing of water drops table')
      call freezeH2O

!..Conversion of some ice mass into snow category.
!!!      CALL wrf_debug(200, '  creating ice converting to snow table')
      call qi_aut_qs

      endif

!!!      CALL wrf_debug(150, ' ... DONE microphysical lookup tables')

      endif

      END SUBROUTINE thompson_init
!+---+-----------------------------------------------------------------+
!
!+---+-----------------------------------------------------------------+
!..This is a wrapper routine designed to transfer values from 3D to 1D.
!+---+-----------------------------------------------------------------+
      SUBROUTINE mp_gt_driver(qv, qc, qr, qi, qs, qg, nci, ncr,    &
                              th0, t3d, pii, p, dzz, dt_in, RAIN,  &
                              tcond,tevac,tevar,train,             &
                              ruh,rvh,rmh,rho,rr,dbz3d,getdbz)

      implicit none

      include 'input.incl'
      include 'timestat.incl'

!..Subroutine arguments
!      INTEGER, INTENT(IN):: ids,ide, jds,jde, kds,kde, &
!                            ims,ime, jms,jme, kms,kme, &
!                            its,ite, jts,jte, kts,kte
      REAL, DIMENSION(ib:ie, jb:je, kb:ke), INTENT(INOUT):: &
                          qv, qc, qr, qi, qs, qg, nci, ncr, t3d, dbz3d
!!!#ifdef WRF_CHEM
!!!      REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT):: &
!!!                          rainprod, evapprod
!!!#endif
      REAL, DIMENSION(ib:ie, jb:je, kb:ke), INTENT(IN):: &
                          th0, pii, p, dzz, rmh, rho, rr
      REAL, DIMENSION(ib:ie, jb:je, nrain), INTENT(INOUT):: &
                          RAIN
!!!      REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT)::      &
!!!                          SNOWNC, SNOWNCV, GRAUPELNC, GRAUPELNCV
!!!      REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT)::       &
!!!                          refl_10cm
      REAL, INTENT(IN):: dt_in
      double precision, intent(inout) :: tcond,tevac,tevar,train
      real, intent(in), dimension(ib:ie) :: ruh
      real, intent(in), dimension(jb:je) :: rvh
      logical, INTENT(IN):: getdbz
!!!      INTEGER, INTENT(IN):: itimestep

!..Local variables
      REAL, DIMENSION(nk):: &
                          qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                          nr1d, t1d, p1d, dz1d, dBZ, rho1d
!!!#ifdef WRF_CHEM
!!!      REAL, DIMENSION(kts:kte):: &
!!!                          rainprod1d, evapprod1d
!!!#endif
!!!      REAL, DIMENSION(its:ite, jts:jte):: pcp_ra, pcp_sn, pcp_gr, pcp_ic
      REAL:: dt, pptrain, pptsnow, pptgraul, pptice
      REAL:: qc_max, qr_max, qs_max, qi_max, qg_max, ni_max, nr_max
      INTEGER:: i, j, k
      INTEGER:: imax_qc,imax_qr,imax_qi,imax_qs,imax_qg,imax_ni,imax_nr
      INTEGER:: jmax_qc,jmax_qr,jmax_qi,jmax_qs,jmax_qg,jmax_ni,jmax_nr
      INTEGER:: kmax_qc,kmax_qr,kmax_qi,kmax_qs,kmax_qg,kmax_ni,kmax_nr
      INTEGER:: i_start, j_start, i_end, j_end
!!!      LOGICAL, OPTIONAL, INTENT(IN) :: diagflag
!!!      INTEGER, OPTIONAL, INTENT(IN) :: do_radar_ref

      integer :: n
      DOUBLE PRECISION, DIMENSION(1:nk):: prv_rev,prw_vcd
      real :: tem1,tem2
      double precision, dimension(nj) :: bud1,bud2,bud3,bud4

!+---+

      tem1 = dx*dy*dz

!      i_start = its
!      j_start = jts
!      i_end   = MIN(ite, ide-1)
!      j_end   = MIN(jte, jde-1)

!..For idealized testing by developer.
!     if ( (ide-ids+1).gt.4 .and. (jde-jds+1).lt.4 .and.                &
!          ids.eq.its.and.ide.eq.ite.and.jds.eq.jts.and.jde.eq.jte) then
!        i_start = its + 2
!        i_end   = ite
!        j_start = jts
!        j_end   = jte
!     endif

      dt = dt_in
   
!      qc_max = 0.
!      qr_max = 0.
!      qs_max = 0.
!      qi_max = 0.
!      qg_max = 0
!      ni_max = 0.
!      nr_max = 0.
!      imax_qc = 0
!      imax_qr = 0
!      imax_qi = 0
!      imax_qs = 0
!      imax_qg = 0
!      imax_ni = 0
!      imax_nr = 0
!      jmax_qc = 0
!      jmax_qr = 0
!      jmax_qi = 0
!      jmax_qs = 0
!      jmax_qg = 0
!      jmax_ni = 0
!      jmax_nr = 0
!      kmax_qc = 0
!      kmax_qr = 0
!      kmax_qi = 0
!      kmax_qs = 0
!      kmax_qg = 0
!      kmax_ni = 0
!      kmax_nr = 0
!      do i = 1, 256
!         mp_debug(i:i) = char(0)
!      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,n,pptrain,pptsnow,pptgraul,pptice,   &
!$omp t1d,p1d,dz1d,qv1d,qc1d,qi1d,qr1d,qs1d,qg1d,ni1d,nr1d,   &
!$omp rho1d,prv_rev,prw_vcd,tem2,dbz)
      j_loop:  do j = 1,nj
      bud1(j)=0.0d0
      bud2(j)=0.0d0
      bud3(j)=0.0d0
      bud4(j)=0.0d0
      i_loop:  do i = 1,ni

         pptrain = 0.
         pptsnow = 0.
         pptgraul = 0.
         pptice = 0.
!         RAINNCV(i,j) = 0.
!         IF ( PRESENT (snowncv) ) THEN
!            SNOWNCV(i,j) = 0.
!         ENDIF
!         IF ( PRESENT (graupelncv) ) THEN
!            GRAUPELNCV(i,j) = 0.
!         ENDIF
!         SR(i,j) = 0.

         do k = 1, nk
!!!            t1d(k) = th(i,k,j)*pii(i,k,j)
            t1d(k) = t3d(i,j,k)
            p1d(k) = p(i,j,k)
            dz1d(k) = dzz(i,j,k)
            qv1d(k) = qv(i,j,k)
            qc1d(k) = qc(i,j,k)
            qi1d(k) = qi(i,j,k)
            qr1d(k) = qr(i,j,k)
            qs1d(k) = qs(i,j,k)
            qg1d(k) = qg(i,j,k)
            ni1d(k) = nci(i,j,k)
            nr1d(k) = ncr(i,j,k)
            rho1d(k) = rho(i,j,k)
         enddo

         prv_rev = 0.0
         prw_vcd = 0.0

         call mp_thompson(qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                      nr1d, t1d, p1d, dz1d, &
                      pptrain, pptsnow, pptgraul, pptice, &
!!!#ifdef WRF_CHEM
!!!                      rainprod1d, evapprod1d, &
!!!#endif
                      1, nk, dt, i, j, rho1d, prv_rev, prw_vcd, eqtset )

         do n = 1,nrain
            RAIN(i,j,n) = RAIN(i,j,n) + 0.1*( pptrain + pptsnow + pptgraul + pptice )
         enddo
         bud1(j) = bud1(j) + ( pptrain + pptsnow + pptgraul + pptice )*ruh(i)*rvh(j)*dx*dy

         do k=1,nk
           tem2 = dt*rr(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*tem1
           bud2(j) = bud2(j) + tem2*prv_rev(k)
           bud3(j) = bud3(j) + tem2*max(prw_vcd(k),0.0d0)
           bud4(j) = bud4(j) - tem2*min(prw_vcd(k),0.0d0)
         enddo

!         pcp_ra(i,j) = pptrain
!         pcp_sn(i,j) = pptsnow
!         pcp_gr(i,j) = pptgraul
!         pcp_ic(i,j) = pptice
!         RAINNCV(i,j) = pptrain + pptsnow + pptgraul + pptice
!         RAINNC(i,j) = RAINNC(i,j) + pptrain + pptsnow + pptgraul + pptice
!         IF ( PRESENT(snowncv) .AND. PRESENT(snownc) ) THEN
!            SNOWNCV(i,j) = pptsnow + pptice
!            SNOWNC(i,j) = SNOWNC(i,j) + pptsnow + pptice
!         ENDIF
!         IF ( PRESENT(graupelncv) .AND. PRESENT(graupelnc) ) THEN
!            GRAUPELNCV(i,j) = pptgraul
!            GRAUPELNC(i,j) = GRAUPELNC(i,j) + pptgraul
!         ENDIF
!         SR(i,j) = (pptsnow + pptgraul + pptice)/(RAINNCV(i,j)+1.e-12)

         do k = 1, nk
            qv(i,j,k) = qv1d(k)
            qc(i,j,k) = qc1d(k)
            qi(i,j,k) = qi1d(k)
            qr(i,j,k) = qr1d(k)
            qs(i,j,k) = qs1d(k)
            qg(i,j,k) = qg1d(k)
            nci(i,j,k) = ni1d(k)
            ncr(i,j,k) = nr1d(k)
!!!#ifdef WRF_CHEM
!!!            rainprod(i,k,j) = rainprod1d(k)
!!!            evapprod(i,k,j) = evapprod1d(k)
!!!#endif
!!!            th(i,k,j) = t1d(k)/pii(i,k,j)
            t3d(i,j,k) = t1d(k)
!            if (qc1d(k) .gt. qc_max) then
!             imax_qc = i
!             jmax_qc = j
!             kmax_qc = k
!             qc_max = qc1d(k)
!            elseif (qc1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative qc ', qc1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qr1d(k) .gt. qr_max) then
!             imax_qr = i
!             jmax_qr = j
!             kmax_qr = k
!             qr_max = qr1d(k)
!            elseif (qr1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative qr ', qr1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (nr1d(k) .gt. nr_max) then
!             imax_nr = i
!             jmax_nr = j
!             kmax_nr = k
!             nr_max = nr1d(k)
!            elseif (nr1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative nr ', nr1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qs1d(k) .gt. qs_max) then
!             imax_qs = i
!             jmax_qs = j
!             kmax_qs = k
!             qs_max = qs1d(k)
!            elseif (qs1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative qs ', qs1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qi1d(k) .gt. qi_max) then
!             imax_qi = i
!             jmax_qi = j
!             kmax_qi = k
!             qi_max = qi1d(k)
!            elseif (qi1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative qi ', qi1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qg1d(k) .gt. qg_max) then
!             imax_qg = i
!             jmax_qg = j
!             kmax_qg = k
!             qg_max = qg1d(k)
!            elseif (qg1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative qg ', qg1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (ni1d(k) .gt. ni_max) then
!             imax_ni = i
!             jmax_ni = j
!             kmax_ni = k
!             ni_max = ni1d(k)
!            elseif (ni1d(k) .lt. 0.0) then
!!!             write(mp_debug,*) 'WARNING, negative ni ', ni1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qv1d(k) .lt. 0.0) then
!             if (k.lt.kte-2 .and. k.gt.kts+1) then
!                qv(i,k,j) = 0.5*(qv(i,k-1,j) + qv(i,k+1,j))
!             else
!                qv(i,k,j) = 1.E-7
!             endif
!!!             write(mp_debug,*) 'WARNING, negative qv ', qv1d(k),        &
!!!                        ' at i,j,k=', i,j,k
!!!             CALL wrf_debug(150, mp_debug)
!            endif
         enddo

!         IF ( PRESENT (diagflag) ) THEN
!         if (diagflag .and. do_radar_ref == 1) then
         if(getdbz)then
          call calc_refl10cm (qv1d, qc1d, qr1d, nr1d, qs1d, qg1d,       &
                      t1d, p1d, rho1d, dBZ, 1, nk, i, j)
          do k = 1, nk
             dbz3d(i,j,k) = MAX(-35., dBZ(k))
          enddo
         endif
!         ENDIF

      enddo i_loop
      enddo j_loop

      do j=1,nj
        train=train+bud1(j)
        tevar=tevar+bud2(j)
        tcond=tcond+bud3(j)
        tevac=tevac+bud4(j)
      enddo

      time_microphy=time_microphy+mytime()

! DEBUG - GT
!!!      write(mp_debug,'(a,7(a,e13.6,1x,a,i3,a,i3,a,i3,a,1x))') 'MP-GT:', &
!!!         'qc: ', qc_max, '(', imax_qc, ',', jmax_qc, ',', kmax_qc, ')', &
!!!         'qr: ', qr_max, '(', imax_qr, ',', jmax_qr, ',', kmax_qr, ')', &
!!!         'qi: ', qi_max, '(', imax_qi, ',', jmax_qi, ',', kmax_qi, ')', &
!!!         'qs: ', qs_max, '(', imax_qs, ',', jmax_qs, ',', kmax_qs, ')', &
!!!         'qg: ', qg_max, '(', imax_qg, ',', jmax_qg, ',', kmax_qg, ')', &
!!!         'ni: ', ni_max, '(', imax_ni, ',', jmax_ni, ',', kmax_ni, ')', &
!!!         'nr: ', nr_max, '(', imax_nr, ',', jmax_nr, ',', kmax_nr, ')'
!!!      CALL wrf_debug(150, mp_debug)
! END DEBUG - GT

!      do i = 1, 256
!         mp_debug(i:i) = char(0)
!      enddo

      END SUBROUTINE mp_gt_driver

!+---+-----------------------------------------------------------------+
!
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!.. This subroutine computes the moisture tendencies of water vapor,
!.. cloud droplets, rain, cloud ice (pristine), snow, and graupel.
!.. Previously this code was based on Reisner et al (1998), but few of
!.. those pieces remain.  A complete description is now found in
!.. Thompson et al. (2004, 2008).
!+---+-----------------------------------------------------------------+
!
      subroutine mp_thompson (qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                          nr1d, t1d, p1d, dzq, &
                          pptrain, pptsnow, pptgraul, pptice, &
!!!#ifdef WRF_CHEM
!!!                          rainprod, evapprod, &
!!!#endif
                          kts, kte, dt, ii, jj, rho1d, prv_rev, prw_vcd, eqtset )

      implicit none

!..Sub arguments
      INTEGER, INTENT(IN):: kts, kte, ii, jj
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: &
                          qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                          nr1d, t1d, p1d
#ifdef WRF_CHEM
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: &
                          rainprod, evapprod
#endif
      REAL, DIMENSION(kts:kte), INTENT(IN):: dzq
      REAL, INTENT(INOUT):: pptrain, pptsnow, pptgraul, pptice
      REAL, INTENT(IN):: dt
      integer, intent(in) :: eqtset

!..Local variables
      REAL, DIMENSION(kts:kte):: tten, qvten, qcten, qiten, &
           qrten, qsten, qgten, niten, nrten

      DOUBLE PRECISION, DIMENSION(kts:kte), INTENT(INOUT) :: prv_rev,prw_vcd
      REAL, DIMENSION(kts:kte), INTENT(IN) :: rho1d

      DOUBLE PRECISION, DIMENSION(kts:kte):: prr_wau, prr_rcw, prr_rcs, &
           prr_rcg, prr_sml, prr_gml, &
           prr_rci,                   &
           pnr_wau, pnr_rcs, pnr_rcg, &
           pnr_rci, pnr_sml, pnr_gml, &
           pnr_rev, pnr_rcr, pnr_rfz

      DOUBLE PRECISION, DIMENSION(kts:kte):: pri_inu, pni_inu, pri_ihm, &
           pni_ihm, pri_wfz, pni_wfz, &
           pri_rfz, pni_rfz, pri_ide, &
           pni_ide, pri_rci, pni_rci, &
           pni_sci, pni_iau

      DOUBLE PRECISION, DIMENSION(kts:kte):: prs_iau, prs_sci, prs_rcs, &
           prs_scw, prs_sde, prs_ihm, &
           prs_ide

      DOUBLE PRECISION, DIMENSION(kts:kte):: prg_scw, prg_rfz, prg_gde, &
           prg_gcw, prg_rci, prg_rcs, &
           prg_rcg, prg_ihm

      DOUBLE PRECISION, PARAMETER:: zeroD0 = 0.0d0

      REAL, DIMENSION(kts:kte):: temp, pres, qv
      REAL, DIMENSION(kts:kte):: rc, ri, rr, rs, rg, ni, nr
      REAL, DIMENSION(kts:kte):: rho, rhof, rhof2
      REAL, DIMENSION(kts:kte):: qvs, qvsi, delQvs
      REAL, DIMENSION(kts:kte):: satw, sati, ssatw, ssati
      REAL, DIMENSION(kts:kte):: diffu, visco, vsc2, &
           tcond, lvap, ocp, lvt2
      REAL, DIMENSION(kts:kte):: cvm
      real :: econd,edep,efrz

      DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilamg, N0_r, N0_g
      REAL, DIMENSION(kts:kte):: mvd_r, mvd_c
      REAL, DIMENSION(kts:kte):: smob, smo2, smo1, smo0, &
           smoc, smod, smoe, smof

      REAL, DIMENSION(kts:kte):: sed_r, sed_s, sed_g, sed_i, sed_n

      REAL:: rgvm, delta_tp, orho, lfus2
      REAL, DIMENSION(4):: onstep
      DOUBLE PRECISION:: N0_exp, N0_min, lam_exp, lamc, lamr, lamg
      DOUBLE PRECISION:: lami, ilami
      REAL:: xDc, Dc_b, Dc_g, xDi, xDr, xDs, xDg, Ds_m, Dg_m
      DOUBLE PRECISION:: Dr_star
      REAL:: zeta1, zeta, taud, tau
      REAL:: stoke_r, stoke_s, stoke_g, stoke_i
      REAL:: vti, vtr, vts, vtg
      REAL, DIMENSION(kts:kte+1):: vtik, vtnik, vtrk, vtnrk, vtsk, vtgk
      REAL, DIMENSION(kts:kte):: vts_boost
      REAL:: Mrat, ils1, ils2, t1_vts, t2_vts, t3_vts, t4_vts, C_snow
      REAL:: a_, b_, loga_, A1, A2, tf
      REAL:: tempc, tc0, r_mvd1, r_mvd2, xkrat
      REAL:: xnc, xri, xni, xmi, oxmi, xrc, xrr, xnr
      REAL:: xsat, rate_max, sump, ratio
      REAL:: clap, fcd, dfcd
      REAL:: otemp, rvs, rvs_p, rvs_pp, gamsc, alphsc, t1_evap, t1_subl
      REAL:: r_frac, g_frac
      REAL:: Ef_rw, Ef_sw, Ef_gw, Ef_rr
      REAL:: dtsave, odts, odt, odzq
      REAL:: xslw1, ygra1, zans1, eva_factor
      INTEGER:: i, k, k2, n, nn, nstep, k_0, kbot, IT, iexfrq
      INTEGER, DIMENSION(4):: ksed1
      INTEGER:: nir, nis, nig, nii, nic
      INTEGER:: idx_tc, idx_t, idx_s, idx_g1, idx_g, idx_r1, idx_r,     &
                idx_i1, idx_i, idx_c, idx, idx_d
      LOGICAL:: melti, no_micro
      LOGICAL, DIMENSION(kts:kte):: L_qc, L_qi, L_qr, L_qs, L_qg
      LOGICAL:: debug_flag
      ! for CM1 saturation adjustment:
      real :: dumt,dumqv,dumqc,dumqr,dumqi,dumqs,dumqg,SAVEQC,SAVET,RDT

!+---+

      debug_flag = .false.
!     if (ii.eq.315 .and. jj.eq.2) debug_flag = .true.

      no_micro = .true.
      dtsave = dt
      odt = 1./dt
      odts = 1./dtsave
      iexfrq = 1

!+---+-----------------------------------------------------------------+
!.. Source/sink terms.  First 2 chars: "pr" represents source/sink of
!.. mass while "pn" represents source/sink of number.  Next char is one
!.. of "v" for water vapor, "r" for rain, "i" for cloud ice, "w" for
!.. cloud water, "s" for snow, and "g" for graupel.  Next chars
!.. represent processes: "de" for sublimation/deposition, "ev" for
!.. evaporation, "fz" for freezing, "ml" for melting, "au" for
!.. autoconversion, "nu" for ice nucleation, "hm" for Hallet/Mossop
!.. secondary ice production, and "c" for collection followed by the
!.. character for the species being collected.  ALL of these terms are
!.. positive (except for deposition/sublimation terms which can switch
!.. signs based on super/subsaturation) and are treated as negatives
!.. where necessary in the tendency equations.
!+---+-----------------------------------------------------------------+

      do k = kts, kte
         tten(k) = 0.
         qvten(k) = 0.
         qcten(k) = 0.
         qiten(k) = 0.
         qrten(k) = 0.
         qsten(k) = 0.
         qgten(k) = 0.
         niten(k) = 0.
         nrten(k) = 0.

         prw_vcd(k) = 0.

         prv_rev(k) = 0.
         prr_wau(k) = 0.
         prr_rcw(k) = 0.
         prr_rcs(k) = 0.
         prr_rcg(k) = 0.
         prr_sml(k) = 0.
         prr_gml(k) = 0.
         prr_rci(k) = 0.
         pnr_wau(k) = 0.
         pnr_rcs(k) = 0.
         pnr_rcg(k) = 0.
         pnr_rci(k) = 0.
         pnr_sml(k) = 0.
         pnr_gml(k) = 0.
         pnr_rev(k) = 0.
         pnr_rcr(k) = 0.
         pnr_rfz(k) = 0.

         pri_inu(k) = 0.
         pni_inu(k) = 0.
         pri_ihm(k) = 0.
         pni_ihm(k) = 0.
         pri_wfz(k) = 0.
         pni_wfz(k) = 0.
         pri_rfz(k) = 0.
         pni_rfz(k) = 0.
         pri_ide(k) = 0.
         pni_ide(k) = 0.
         pri_rci(k) = 0.
         pni_rci(k) = 0.
         pni_sci(k) = 0.
         pni_iau(k) = 0.

         prs_iau(k) = 0.
         prs_sci(k) = 0.
         prs_rcs(k) = 0.
         prs_scw(k) = 0.
         prs_sde(k) = 0.
         prs_ihm(k) = 0.
         prs_ide(k) = 0.

         prg_scw(k) = 0.
         prg_rfz(k) = 0.
         prg_gde(k) = 0.
         prg_gcw(k) = 0.
         prg_rci(k) = 0.
         prg_rcs(k) = 0.
         prg_rcg(k) = 0.
         prg_ihm(k) = 0.
      enddo
#ifdef WRF_CHEM
      do k = kts, kte
         rainprod(k) = 0.
         evapprod(k) = 0.
      enddo
#endif

!+---+-----------------------------------------------------------------+
!..Put column of data into local arrays.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k)
         qv(k) = MAX(1.E-10, qv1d(k))
         pres(k) = p1d(k)
!!!         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         rho(k) = rho1d(k)
         if (qc1d(k) .gt. R1) then
            no_micro = .false.
            rc(k) = qc1d(k)*rho(k)
            L_qc(k) = .true.
         else
            qc1d(k) = 0.0
            rc(k) = R1
            L_qc(k) = .false.
         endif
         if (qi1d(k) .gt. R1) then
            no_micro = .false.
            ri(k) = qi1d(k)*rho(k)
            ni(k) = MAX(R2, ni1d(k)*rho(k))
            L_qi(k) = .true.
            lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
            ilami = 1./lami
            xDi = (bm_i + mu_i + 1.) * ilami
            if (xDi.lt. 20.E-6) then
             lami = cie(2)/20.E-6
             ni(k) = MIN(250.D3, cig(1)*oig2*ri(k)/am_i*lami**bm_i)
            elseif (xDi.gt. 300.E-6) then
             lami = cie(2)/300.E-6
             ni(k) = cig(1)*oig2*ri(k)/am_i*lami**bm_i
            endif
         else
            qi1d(k) = 0.0
            ni1d(k) = 0.0
            ri(k) = R1
            ni(k) = R2
            L_qi(k) = .false.
         endif

         if (qr1d(k) .gt. R1) then
            no_micro = .false.
            rr(k) = qr1d(k)*rho(k)
            nr(k) = MAX(R2, nr1d(k)*rho(k))
            L_qr(k) = .true.
            lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
            mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
            if (mvd_r(k) .gt. 2.5E-3) then
               mvd_r(k) = 2.5E-3
               lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
               nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
            elseif (mvd_r(k) .lt. D0r*0.75) then
               mvd_r(k) = D0r*0.75
               lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
               nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
            endif
         else
            qr1d(k) = 0.0
            nr1d(k) = 0.0
            rr(k) = R1
            nr(k) = R2
            L_qr(k) = .false.
         endif
         if (qs1d(k) .gt. R1) then
            no_micro = .false.
            rs(k) = qs1d(k)*rho(k)
            L_qs(k) = .true.
         else
            qs1d(k) = 0.0
            rs(k) = R1
            L_qs(k) = .false.
         endif
         if (qg1d(k) .gt. R1) then
            no_micro = .false.
            rg(k) = qg1d(k)*rho(k)
            L_qg(k) = .true.
         else
            qg1d(k) = 0.0
            rg(k) = R1
            L_qg(k) = .false.
         endif
      enddo


!+---+-----------------------------------------------------------------+
!..Derive various thermodynamic variables frequently used.
!.. Saturation vapor pressure (mixing ratio) over liquid/ice comes from
!.. Flatau et al. 1992; enthalpy (latent heat) of vaporization from
!.. Bohren & Albrecht 1998; others from Pruppacher & Klett 1978.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         tempc = temp(k) - 273.15
         rhof(k) = SQRT(RHO_NOT/rho(k))
         rhof2(k) = SQRT(rhof(k))
         qvs(k) = rslf(pres(k), temp(k))
         delQvs(k) = MAX(0.0, rslf(pres(k), 273.15)-qv(k))
         if (tempc .le. 0.0) then
          qvsi(k) = rsif(pres(k), temp(k))
         else
          qvsi(k) = qvs(k)
         endif
         satw(k) = qv(k)/qvs(k)
         sati(k) = qv(k)/qvsi(k)
         ssatw(k) = satw(k) - 1.
         ssati(k) = sati(k) - 1.
         if (abs(ssatw(k)).lt. eps) ssatw(k) = 0.0
         if (abs(ssati(k)).lt. eps) ssati(k) = 0.0
         if (no_micro .and. ssati(k).gt. 0.0) no_micro = .false.
         diffu(k) = 2.11E-5*(temp(k)/273.15)**1.94 * (101325./pres(k))
         if (tempc .ge. 0.0) then
            visco(k) = (1.718+0.0049*tempc)*1.0E-5
         else
            visco(k) = (1.718+0.0049*tempc-1.2E-5*tempc*tempc)*1.0E-5
         endif
         ocp(k) = 1./(Cp*(1.+0.887*qv(k)))
         vsc2(k) = SQRT(rho(k)/visco(k))
         lvap(k) = lvap0 + (2106.0 - 4218.0)*tempc
         tcond(k) = (5.69 + 0.0168*tempc)*1.0E-5 * 418.936
         if(eqtset.eq.2)then
           cvm(k) = cv+cvv*qv1d(k)+cpl*(qc1d(k)+qr1d(k))   &
                                  +cpi*(qi1d(k)+qs1d(k)+qg1d(k))
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..If no existing hydrometeor species and no chance to initiate ice or
!.. condense cloud water, just exit quickly!
!+---+-----------------------------------------------------------------+

      if (no_micro) return

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope, and useful moments for snow.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         if (.not. L_qs(k)) CYCLE
         tc0 = MIN(-0.1, temp(k)-273.15)
         smob(k) = rs(k)*oams

!..All other moments based on reference, 2nd moment.  If bm_s.ne.2,
!.. then we must compute actual 2nd moment and use as reference.
         if (bm_s.gt.(2.0-1.e-3) .and. bm_s.lt.(2.0+1.e-3)) then
            smo2(k) = smob(k)
         else
            loga_ = sa(1) + sa(2)*tc0 + sa(3)*bm_s &
               + sa(4)*tc0*bm_s + sa(5)*tc0*tc0 &
               + sa(6)*bm_s*bm_s + sa(7)*tc0*tc0*bm_s &
               + sa(8)*tc0*bm_s*bm_s + sa(9)*tc0*tc0*tc0 &
               + sa(10)*bm_s*bm_s*bm_s
            a_ = 10.0**loga_
            b_ = sb(1) + sb(2)*tc0 + sb(3)*bm_s &
               + sb(4)*tc0*bm_s + sb(5)*tc0*tc0 &
               + sb(6)*bm_s*bm_s + sb(7)*tc0*tc0*bm_s &
               + sb(8)*tc0*bm_s*bm_s + sb(9)*tc0*tc0*tc0 &
               + sb(10)*bm_s*bm_s*bm_s
            smo2(k) = (smob(k)/a_)**(1./b_)
         endif

!..Calculate 0th moment.  Represents snow number concentration.
         loga_ = sa(1) + sa(2)*tc0 + sa(5)*tc0*tc0 + sa(9)*tc0*tc0*tc0
         a_ = 10.0**loga_
         b_ = sb(1) + sb(2)*tc0 + sb(5)*tc0*tc0 + sb(9)*tc0*tc0*tc0
         smo0(k) = a_ * smo2(k)**b_

!..Calculate 1st moment.  Useful for depositional growth and melting.
         loga_ = sa(1) + sa(2)*tc0 + sa(3) &
               + sa(4)*tc0 + sa(5)*tc0*tc0 &
               + sa(6) + sa(7)*tc0*tc0 &
               + sa(8)*tc0 + sa(9)*tc0*tc0*tc0 &
               + sa(10)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3) + sb(4)*tc0 &
              + sb(5)*tc0*tc0 + sb(6) &
              + sb(7)*tc0*tc0 + sb(8)*tc0 &
              + sb(9)*tc0*tc0*tc0 + sb(10)
         smo1(k) = a_ * smo2(k)**b_

!..Calculate bm_s+1 (th) moment.  Useful for diameter calcs.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(1) &
               + sa(4)*tc0*cse(1) + sa(5)*tc0*tc0 &
               + sa(6)*cse(1)*cse(1) + sa(7)*tc0*tc0*cse(1) &
               + sa(8)*tc0*cse(1)*cse(1) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(1)*cse(1)*cse(1)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(1) + sb(4)*tc0*cse(1) &
              + sb(5)*tc0*tc0 + sb(6)*cse(1)*cse(1) &
              + sb(7)*tc0*tc0*cse(1) + sb(8)*tc0*cse(1)*cse(1) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(1)*cse(1)*cse(1)
         smoc(k) = a_ * smo2(k)**b_

!..Calculate bv_s+2 (th) moment.  Useful for riming.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(13) &
               + sa(4)*tc0*cse(13) + sa(5)*tc0*tc0 &
               + sa(6)*cse(13)*cse(13) + sa(7)*tc0*tc0*cse(13) &
               + sa(8)*tc0*cse(13)*cse(13) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(13)*cse(13)*cse(13)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(13) + sb(4)*tc0*cse(13) &
              + sb(5)*tc0*tc0 + sb(6)*cse(13)*cse(13) &
              + sb(7)*tc0*tc0*cse(13) + sb(8)*tc0*cse(13)*cse(13) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(13)*cse(13)*cse(13)
         smoe(k) = a_ * smo2(k)**b_

!..Calculate 1+(bv_s+1)/2 (th) moment.  Useful for depositional growth.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(16) &
               + sa(4)*tc0*cse(16) + sa(5)*tc0*tc0 &
               + sa(6)*cse(16)*cse(16) + sa(7)*tc0*tc0*cse(16) &
               + sa(8)*tc0*cse(16)*cse(16) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(16)*cse(16)*cse(16)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(16) + sb(4)*tc0*cse(16) &
              + sb(5)*tc0*tc0 + sb(6)*cse(16)*cse(16) &
              + sb(7)*tc0*tc0*cse(16) + sb(8)*tc0*cse(16)*cse(16) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(16)*cse(16)*cse(16)
         smof(k) = a_ * smo2(k)**b_

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+
      N0_min = gonv_max
      do k = kte, kts, -1
         if (temp(k).lt.270.65 .and. L_qr(k) .and. mvd_r(k).gt.100.E-6) then
            xslw1 = 4.01 + alog10(mvd_r(k))
         else
            xslw1 = 0.01
         endif
         ygra1 = 4.31 + alog10(max(5.E-5, rg(k)))
         zans1 = 3.1 + (100./(300.*xslw1*ygra1/(10./xslw1+1.+0.25*ygra1)+30.+10.*ygra1))
         N0_exp = 10.**(zans1)
         N0_exp = MAX(DBLE(gonv_min), MIN(N0_exp, DBLE(gonv_max)))
         N0_min = MIN(N0_exp, N0_min)
         N0_exp = N0_min
         lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1
         lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
         ilamg(k) = 1./lamg
         N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2)
!+---+-----------------------------------------------------------------+
!     if( debug_flag .and. k.lt.42) then
!        if (k.eq.41) write(mp_debug,*) 'DEBUG-GT:   K,   zans1,      rc,        rr,         rg,        N0_g'
!        if (k.eq.41) CALL wrf_debug(0, mp_debug)
!        write(mp_debug, 'a, i2, 1x, f6.3, 1x, 4(1x,e13.6,1x)')         &
!                   '  GT ', k, zans1, rc(k), rr(k), rg(k), N0_g(k)
!        CALL wrf_debug(0, mp_debug)
!     endif
!+---+-----------------------------------------------------------------+
      enddo

      endif

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for rain.
!+---+-----------------------------------------------------------------+
      do k = kte, kts, -1
         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
         ilamr(k) = 1./lamr
         mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
         N0_r(k) = nr(k)*org2*lamr**cre(2)
      enddo

!+---+-----------------------------------------------------------------+
!..Compute warm-rain process terms (except evap done later).
!+---+-----------------------------------------------------------------+

      do k = kts, kte

!..Rain self-collection follows Seifert, 1994 and drop break-up
!.. follows Verlinde and Cotton, 1993.                                        RAIN2M
!.. Reduced leading coeff because higher values overly force to singular
!.. mean size of rain.
         if (L_qr(k) .and. mvd_r(k).gt. D0r) then
!-GT      Ef_rr = 1.0
!-GT      if (mvd_r(k) .gt. 1500.0E-6) then
             Ef_rr = 2.0 - EXP(2300.0*(mvd_r(k)-1600.0E-6))
!-GT      endif
          pnr_rcr(k) = Ef_rr * 0.5*nr(k)*rr(k)
         endif

         mvd_c(k) = D0c
         if (.not. L_qc(k)) CYCLE
         xDc = MAX(D0c*1.E6, ((rc(k)/(am_r*Nt_c))**obmr) * 1.E6)
         lamc = (Nt_c*am_r* ccg(2) * ocg1 / rc(k))**obmr
         mvd_c(k) = (3.0+mu_c+0.672) / lamc

!..Autoconversion follows Berry & Reinhardt (1974) with characteristic
!.. diameters correctly computed from gamma distrib of cloud droplets.
         if (rc(k).gt. 0.01e-3) then
          Dc_g = ((ccg(3)*ocg2)**obmr / lamc) * 1.E6
          Dc_b = (xDc*xDc*xDc*Dc_g*Dc_g*Dc_g - xDc*xDc*xDc*xDc*xDc*xDc) &
                 **(1./6.)
          zeta1 = 0.5*((6.25E-6*xDc*Dc_b*Dc_b*Dc_b - 0.4) &
                     + abs(6.25E-6*xDc*Dc_b*Dc_b*Dc_b - 0.4))
          zeta = 0.027*rc(k)*zeta1
          taud = 0.5*((0.5*Dc_b - 7.5) + abs(0.5*Dc_b - 7.5)) + R1
          tau  = 3.72/(rc(k)*taud)
          prr_wau(k) = zeta/tau
          prr_wau(k) = MIN(DBLE(rc(k)*odts), prr_wau(k))
          pnr_wau(k) = prr_wau(k) / (am_r*mu_c*D0r*D0r*D0r)              ! RAIN2M
         endif

!..Rain collecting cloud water.  In CE, assume Dc<<Dr and vtc=~0.
         if (L_qr(k) .and. mvd_r(k).gt. D0r .and. mvd_c(k).gt. D0c) then
          lamr = 1./ilamr(k)
          idx = 1 + INT(nbr*DLOG(mvd_r(k)/Dr(1))/DLOG(Dr(nbr)/Dr(1)))
          idx = MIN(idx, nbr)
          Ef_rw = t_Efrw(idx, INT(mvd_c(k)*1.E6))
          prr_rcw(k) = rhof(k)*t1_qr_qc*Ef_rw*rc(k)*N0_r(k) &
                         *((lamr+fv_r)**(-cre(9)))
          prr_rcw(k) = MIN(DBLE(rc(k)*odts), prr_rcw(k))
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..Compute all frozen hydrometeor species' process terms.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         vts_boost(k) = 1.5

!..Temperature lookup table indexes.
         tempc = temp(k) - 273.15
         idx_tc = MAX(1, MIN(NINT(-tempc), 45) )
         idx_t = INT( (tempc-2.5)/5. ) - 1
         idx_t = MAX(1, -idx_t)
         idx_t = MIN(idx_t, ntb_t)
         IT = MAX(1, MIN(NINT(-tempc), 31) )

!..Cloud water lookup table index.
         if (rc(k).gt. r_c(1)) then
          nic = NINT(ALOG10(rc(k)))
          do nn = nic-1, nic+1
             n = nn
             if ( (rc(k)/10.**nn).ge.1.0 .and. &
                  (rc(k)/10.**nn).lt.10.0) goto 141
          enddo
 141      continue
          idx_c = INT(rc(k)/10.**n) + 10*(n-nic2) - (n-nic2)
          idx_c = MAX(1, MIN(idx_c, ntb_c))
         else
          idx_c = 1
         endif

!..Cloud ice lookup table indexes.
         if (ri(k).gt. r_i(1)) then
          nii = NINT(ALOG10(ri(k)))
          do nn = nii-1, nii+1
             n = nn
             if ( (ri(k)/10.**nn).ge.1.0 .and. &
                  (ri(k)/10.**nn).lt.10.0) goto 142
          enddo
 142      continue
          idx_i = INT(ri(k)/10.**n) + 10*(n-nii2) - (n-nii2)
          idx_i = MAX(1, MIN(idx_i, ntb_i))
         else
          idx_i = 1
         endif

         if (ni(k).gt. Nt_i(1)) then
          nii = NINT(ALOG10(ni(k)))
          do nn = nii-1, nii+1
             n = nn
             if ( (ni(k)/10.**nn).ge.1.0 .and. &
                  (ni(k)/10.**nn).lt.10.0) goto 143
          enddo
 143      continue
          idx_i1 = INT(ni(k)/10.**n) + 10*(n-nii3) - (n-nii3)
          idx_i1 = MAX(1, MIN(idx_i1, ntb_i1))
         else
          idx_i1 = 1
         endif

!..Rain lookup table indexes.
         if (rr(k).gt. r_r(1)) then
          nir = NINT(ALOG10(rr(k)))
          do nn = nir-1, nir+1
             n = nn
             if ( (rr(k)/10.**nn).ge.1.0 .and. &
                  (rr(k)/10.**nn).lt.10.0) goto 144
          enddo
 144      continue
          idx_r = INT(rr(k)/10.**n) + 10*(n-nir2) - (n-nir2)
          idx_r = MAX(1, MIN(idx_r, ntb_r))

          lamr = 1./ilamr(k)
          lam_exp = lamr * (crg(3)*org2*org1)**bm_r
          N0_exp = org1*rr(k)/am_r * lam_exp**cre(1)
          nir = NINT(DLOG10(N0_exp))
          do nn = nir-1, nir+1
             n = nn
             if ( (N0_exp/10.**nn).ge.1.0 .and. &
                  (N0_exp/10.**nn).lt.10.0) goto 145
          enddo
 145      continue
          idx_r1 = INT(N0_exp/10.**n) + 10*(n-nir3) - (n-nir3)
          idx_r1 = MAX(1, MIN(idx_r1, ntb_r1))
         else
          idx_r = 1
          idx_r1 = ntb_r1
         endif

!..Snow lookup table index.
         if (rs(k).gt. r_s(1)) then
          nis = NINT(ALOG10(rs(k)))
          do nn = nis-1, nis+1
             n = nn
             if ( (rs(k)/10.**nn).ge.1.0 .and. &
                  (rs(k)/10.**nn).lt.10.0) goto 146
          enddo
 146      continue
          idx_s = INT(rs(k)/10.**n) + 10*(n-nis2) - (n-nis2)
          idx_s = MAX(1, MIN(idx_s, ntb_s))
         else
          idx_s = 1
         endif

!..Graupel lookup table index.
         if (rg(k).gt. r_g(1)) then
          nig = NINT(ALOG10(rg(k)))
          do nn = nig-1, nig+1
             n = nn
             if ( (rg(k)/10.**nn).ge.1.0 .and. &
                  (rg(k)/10.**nn).lt.10.0) goto 147
          enddo
 147      continue
          idx_g = INT(rg(k)/10.**n) + 10*(n-nig2) - (n-nig2)
          idx_g = MAX(1, MIN(idx_g, ntb_g))

          lamg = 1./ilamg(k)
          lam_exp = lamg * (cgg(3)*ogg2*ogg1)**bm_g
          N0_exp = ogg1*rg(k)/am_g * lam_exp**cge(1)
          nig = NINT(DLOG10(N0_exp))
          do nn = nig-1, nig+1
             n = nn
             if ( (N0_exp/10.**nn).ge.1.0 .and. &
                  (N0_exp/10.**nn).lt.10.0) goto 148
          enddo
 148      continue
          idx_g1 = INT(N0_exp/10.**n) + 10*(n-nig3) - (n-nig3)
          idx_g1 = MAX(1, MIN(idx_g1, ntb_g1))
         else
          idx_g = 1
          idx_g1 = ntb_g1
         endif

!..Deposition/sublimation prefactor (from Srivastava & Coen 1992).
         otemp = 1./temp(k)
         rvs = rho(k)*qvsi(k)
         rvs_p = rvs*otemp*(lsub*otemp*oRv - 1.)
         rvs_pp = rvs * ( otemp*(lsub*otemp*oRv - 1.) &
                         *otemp*(lsub*otemp*oRv - 1.) &
                         + (-2.*lsub*otemp*otemp*otemp*oRv) &
                         + otemp*otemp)
         gamsc = lsub*diffu(k)/tcond(k) * rvs_p
         alphsc = 0.5*(gamsc/(1.+gamsc))*(gamsc/(1.+gamsc)) &
                    * rvs_pp/rvs_p * rvs/rvs_p
         alphsc = MAX(1.E-9, alphsc)
         xsat = ssati(k)
         if (abs(xsat).lt. 1.E-9) xsat=0.
         t1_subl = 4.*PI*( 1.0 - alphsc*xsat &
                + 2.*alphsc*alphsc*xsat*xsat &
                - 5.*alphsc*alphsc*alphsc*xsat*xsat*xsat ) &
                / (1.+gamsc)

!..Snow collecting cloud water.  In CE, assume Dc<<Ds and vtc=~0.
         if (L_qc(k) .and. mvd_c(k).gt. D0c) then
          xDs = 0.0
          if (L_qs(k)) xDs = smoc(k) / smob(k)
          if (xDs .gt. D0s) then
           idx = 1 + INT(nbs*DLOG(xDs/Ds(1))/DLOG(Ds(nbs)/Ds(1)))
           idx = MIN(idx, nbs)
           Ef_sw = t_Efsw(idx, INT(mvd_c(k)*1.E6))
           prs_scw(k) = rhof(k)*t1_qs_qc*Ef_sw*rc(k)*smoe(k)
          endif

!..Graupel collecting cloud water.  In CE, assume Dc<<Dg and vtc=~0.
          if (rg(k).ge. r_g(1) .and. mvd_c(k).gt. D0c) then
           xDg = (bm_g + mu_g + 1.) * ilamg(k)
           vtg = rhof(k)*av_g*cgg(6)*ogg3 * ilamg(k)**bv_g
           stoke_g = mvd_c(k)*mvd_c(k)*vtg*rho_w/(9.*visco(k)*xDg)
           if (xDg.gt. D0g) then
            if (stoke_g.ge.0.4 .and. stoke_g.le.10.) then
             Ef_gw = 0.55*ALOG10(2.51*stoke_g)
            elseif (stoke_g.lt.0.4) then
             Ef_gw = 0.0
            elseif (stoke_g.gt.10) then
             Ef_gw = 0.77
            endif
            prg_gcw(k) = rhof(k)*t1_qg_qc*Ef_gw*rc(k)*N0_g(k) &
                          *ilamg(k)**cge(9)
           endif
          endif
         endif

!..Rain collecting snow.  Cannot assume Wisner (1972) approximation
!.. or Mizuno (1990) approach so we solve the CE explicitly and store
!.. results in lookup table.
         if (rr(k).ge. r_r(1)) then
          if (rs(k).ge. r_s(1)) then
           if (temp(k).lt.T_0) then
            prr_rcs(k) = -(tmr_racs2(idx_s,idx_t,idx_r1,idx_r) &
                           + tcr_sacr2(idx_s,idx_t,idx_r1,idx_r) &
                           + tmr_racs1(idx_s,idx_t,idx_r1,idx_r) &
                           + tcr_sacr1(idx_s,idx_t,idx_r1,idx_r))
            prs_rcs(k) = tmr_racs2(idx_s,idx_t,idx_r1,idx_r) &
                         + tcr_sacr2(idx_s,idx_t,idx_r1,idx_r) &
                         - tcs_racs1(idx_s,idx_t,idx_r1,idx_r) &
                         - tms_sacr1(idx_s,idx_t,idx_r1,idx_r)
            prg_rcs(k) = tmr_racs1(idx_s,idx_t,idx_r1,idx_r) &
                         + tcr_sacr1(idx_s,idx_t,idx_r1,idx_r) &
                         + tcs_racs1(idx_s,idx_t,idx_r1,idx_r) &
                         + tms_sacr1(idx_s,idx_t,idx_r1,idx_r)
            prr_rcs(k) = MAX(DBLE(-rr(k)*odts), prr_rcs(k))
            prs_rcs(k) = MAX(DBLE(-rs(k)*odts), prs_rcs(k))
            prg_rcs(k) = MIN(DBLE((rr(k)+rs(k))*odts), prg_rcs(k))
            pnr_rcs(k) = tnr_racs1(idx_s,idx_t,idx_r1,idx_r)            &   ! RAIN2M
                         + tnr_racs2(idx_s,idx_t,idx_r1,idx_r)          &
                         + tnr_sacr1(idx_s,idx_t,idx_r1,idx_r)          &
                         + tnr_sacr2(idx_s,idx_t,idx_r1,idx_r)
           else
            prs_rcs(k) = -tcs_racs1(idx_s,idx_t,idx_r1,idx_r)           &
                         - tms_sacr1(idx_s,idx_t,idx_r1,idx_r)          &
                         + tmr_racs2(idx_s,idx_t,idx_r1,idx_r)          &
                         + tcr_sacr2(idx_s,idx_t,idx_r1,idx_r)
            prs_rcs(k) = MAX(DBLE(-rs(k)*odts), prs_rcs(k))
            prr_rcs(k) = -prs_rcs(k)
            pnr_rcs(k) = tnr_racs2(idx_s,idx_t,idx_r1,idx_r)            &   ! RAIN2M
                         + tnr_sacr2(idx_s,idx_t,idx_r1,idx_r)
           endif
           pnr_rcs(k) = MIN(DBLE(nr(k)*odts), pnr_rcs(k))
          endif

!..Rain collecting graupel.  Cannot assume Wisner (1972) approximation
!.. or Mizuno (1990) approach so we solve the CE explicitly and store
!.. results in lookup table.
          if (rg(k).ge. r_g(1)) then
           if (temp(k).lt.T_0) then
            prg_rcg(k) = tmr_racg(idx_g1,idx_g,idx_r1,idx_r) &
                         + tcr_gacr(idx_g1,idx_g,idx_r1,idx_r)
            prg_rcg(k) = MIN(DBLE(rr(k)*odts), prg_rcg(k))
            prr_rcg(k) = -prg_rcg(k)
            pnr_rcg(k) = tnr_racg(idx_g1,idx_g,idx_r1,idx_r)            &   ! RAIN2M
                         + tnr_gacr(idx_g1,idx_g,idx_r1,idx_r)
            pnr_rcg(k) = MIN(DBLE(nr(k)*odts), pnr_rcg(k))
           else
            prr_rcg(k) = tcg_racg(idx_g1,idx_g,idx_r1,idx_r)
            prr_rcg(k) = MIN(DBLE(rg(k)*odts), prr_rcg(k))
            prg_rcg(k) = -prr_rcg(k)
           endif
          endif
         endif

!+---+-----------------------------------------------------------------+
!..Next IF block handles only those processes below 0C.
!+---+-----------------------------------------------------------------+

         if (temp(k).lt.T_0) then

          vts_boost(k) = 1.0
          rate_max = (qv(k)-qvsi(k))*rho(k)*odts*0.999

!..Freezing of water drops into graupel/cloud ice (Bigg 1953).
          if (rr(k).gt. r_r(1)) then
           prg_rfz(k) = tpg_qrfz(idx_r,idx_r1,idx_tc)*odts
           pri_rfz(k) = tpi_qrfz(idx_r,idx_r1,idx_tc)*odts
           pni_rfz(k) = tni_qrfz(idx_r,idx_r1,idx_tc)*odts
           pnr_rfz(k) = tnr_qrfz(idx_r,idx_r1,idx_tc)*odts                 ! RAIN2M
           pnr_rfz(k) = MIN(DBLE(nr(k)*odts), pnr_rfz(k))
          elseif (rr(k).gt. R1 .and. temp(k).lt.HGFR) then
           pri_rfz(k) = rr(k)*odts
           pnr_rfz(k) = nr(k)*odts                                         ! RAIN2M
           pni_rfz(k) = pnr_rfz(k)
          endif
          if (rc(k).gt. r_c(1)) then
           pri_wfz(k) = tpi_qcfz(idx_c,idx_tc)*odts
           pri_wfz(k) = MIN(DBLE(rc(k)*odts), pri_wfz(k))
           pni_wfz(k) = tni_qcfz(idx_c,idx_tc)*odts
           pni_wfz(k) = MIN(DBLE(Nt_c*odts), pri_wfz(k)/(2.*xm0i), &
                                pni_wfz(k))
          elseif (rc(k).gt. R1 .and. temp(k).lt.HGFR) then
           pri_wfz(k) = rc(k)*odts
           pni_wfz(k) = MIN(DBLE(Nt_c*odts), pri_wfz(k)/(2.*xm0i), &
                                pni_wfz(k))
          endif

!..Nucleate ice from deposition & condensation freezing (Cooper 1986)
!.. but only if water sat and T<-12C or 25%+ ice supersaturated.
          if ( (ssati(k).ge. 0.25) .or. (ssatw(k).gt. eps &
                                .and. temp(k).lt.261.15) ) then
           xnc = MIN(250.E3, TNO*EXP(ATO*(T_0-temp(k))))
           xni = ni(k) + (pni_rfz(k)+pni_wfz(k))*dtsave
           pni_inu(k) = 0.5*(xnc-xni + abs(xnc-xni))*odts
           pri_inu(k) = MIN(DBLE(rate_max), xm0i*pni_inu(k))
           pni_inu(k) = pri_inu(k)/xm0i
          endif

!..Deposition/sublimation of cloud ice (Srivastava & Coen 1992).
          if (L_qi(k)) then
           lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
           ilami = 1./lami
           xDi = MAX(DBLE(D0i), (bm_i + mu_i + 1.) * ilami)
           xmi = am_i*xDi**bm_i
           oxmi = 1./xmi
           pri_ide(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
                  *oig1*cig(5)*ni(k)*ilami

           if (pri_ide(k) .lt. 0.0) then
            pri_ide(k) = MAX(DBLE(-ri(k)*odts), pri_ide(k), DBLE(rate_max))
            pni_ide(k) = pri_ide(k)*oxmi
            pni_ide(k) = MAX(DBLE(-ni(k)*odts), pni_ide(k))
           else
            pri_ide(k) = MIN(pri_ide(k), DBLE(rate_max))
            prs_ide(k) = (1.0D0-tpi_ide(idx_i,idx_i1))*pri_ide(k)
            pri_ide(k) = tpi_ide(idx_i,idx_i1)*pri_ide(k)
           endif

!..Some cloud ice needs to move into the snow category.  Use lookup
!.. table that resulted from explicit bin representation of distrib.
           if ( (idx_i.eq. ntb_i) .or. (xDi.gt. 5.0*D0s) ) then
            prs_iau(k) = ri(k)*.99*odts
            pni_iau(k) = ni(k)*.95*odts
           elseif (xDi.lt. 0.1*D0s) then
            prs_iau(k) = 0.
            pni_iau(k) = 0.
           else
            prs_iau(k) = tps_iaus(idx_i,idx_i1)*odts
            prs_iau(k) = MIN(DBLE(ri(k)*.99*odts), prs_iau(k))
            pni_iau(k) = tni_iaus(idx_i,idx_i1)*odts
            pni_iau(k) = MIN(DBLE(ni(k)*.95*odts), pni_iau(k))
           endif
          endif

!..Deposition/sublimation of snow/graupel follows Srivastava & Coen
!.. (1992).
          if (L_qs(k)) then
           C_snow = C_sqrd + (tempc+15.)*(C_cube-C_sqrd)/(-30.+15.)
           C_snow = MAX(C_sqrd, MIN(C_snow, C_cube))
           prs_sde(k) = C_snow*t1_subl*diffu(k)*ssati(k)*rvs &
                        * (t1_qs_sd*smo1(k) &
                         + t2_qs_sd*rhof2(k)*vsc2(k)*smof(k))
           if (prs_sde(k).lt. 0.) then
            prs_sde(k) = MAX(DBLE(-rs(k)*odts), prs_sde(k), DBLE(rate_max))
           else
            prs_sde(k) = MIN(prs_sde(k), DBLE(rate_max))
           endif
          endif

          if (L_qg(k) .and. ssati(k).lt. -eps) then
           prg_gde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
               * N0_g(k) * (t1_qg_sd*ilamg(k)**cge(10) &
               + t2_qg_sd*vsc2(k)*rhof2(k)*ilamg(k)**cge(11))
           if (prg_gde(k).lt. 0.) then
            prg_gde(k) = MAX(DBLE(-rg(k)*odts), prg_gde(k), DBLE(rate_max))
           else
            prg_gde(k) = MIN(prg_gde(k), DBLE(rate_max))
           endif
          endif

!..Snow collecting cloud ice.  In CE, assume Di<<Ds and vti=~0.
          if (L_qi(k)) then
           lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
           ilami = 1./lami
           xDi = MAX(DBLE(D0i), (bm_i + mu_i + 1.) * ilami)
           xmi = am_i*xDi**bm_i
           oxmi = 1./xmi
           if (rs(k).ge. r_s(1)) then
            prs_sci(k) = t1_qs_qi*rhof(k)*Ef_si*ri(k)*smoe(k)
            pni_sci(k) = prs_sci(k) * oxmi
           endif

!..Rain collecting cloud ice.  In CE, assume Di<<Dr and vti=~0.
           if (rr(k).ge. r_r(1) .and. mvd_r(k).gt. 4.*xDi) then
            lamr = 1./ilamr(k)
            pri_rci(k) = rhof(k)*t1_qr_qi*Ef_ri*ri(k)*N0_r(k) &
                           *((lamr+fv_r)**(-cre(9)))
            pnr_rci(k) = rhof(k)*t1_qr_qi*Ef_ri*ni(k)*N0_r(k)           &   ! RAIN2M
                           *((lamr+fv_r)**(-cre(9)))
            pni_rci(k) = pri_rci(k) * oxmi
            prr_rci(k) = rhof(k)*t2_qr_qi*Ef_ri*ni(k)*N0_r(k) &
                           *((lamr+fv_r)**(-cre(8)))
            prr_rci(k) = MIN(DBLE(rr(k)*odts), prr_rci(k))
            prg_rci(k) = pri_rci(k) + prr_rci(k)
           endif
          endif

!..Ice multiplication from rime-splinters (Hallet & Mossop 1974).
          if (prg_gcw(k).gt. eps .and. tempc.gt.-8.0) then
           tf = 0.
           if (tempc.ge.-5.0 .and. tempc.lt.-3.0) then
            tf = 0.5*(-3.0 - tempc)
           elseif (tempc.gt.-8.0 .and. tempc.lt.-5.0) then
            tf = 0.33333333*(8.0 + tempc)
           endif
           pni_ihm(k) = 3.5E8*tf*prg_gcw(k)
           pri_ihm(k) = xm0i*pni_ihm(k)
           prs_ihm(k) = prs_scw(k)/(prs_scw(k)+prg_gcw(k)) &
                          * pri_ihm(k)
           prg_ihm(k) = prg_gcw(k)/(prs_scw(k)+prg_gcw(k)) &
                          * pri_ihm(k)
          endif

!..A portion of rimed snow converts to graupel but some remains snow.
!.. Interp from 5 to 75% as riming factor increases from 5.0 to 30.0
!.. 0.028 came from (.75-.05)/(30.-5.).  This remains ad-hoc and should
!.. be revisited.
          if (prs_scw(k).gt.5.0*prs_sde(k) .and. &
                         prs_sde(k).gt.eps) then
           r_frac = MIN(30.0D0, prs_scw(k)/prs_sde(k))
           g_frac = MIN(0.75, 0.05 + (r_frac-5.)*.028)
           vts_boost(k) = MIN(1.5, 1.1 + (r_frac-5.)*.016)
           prg_scw(k) = g_frac*prs_scw(k)
           prs_scw(k) = (1. - g_frac)*prs_scw(k)
          endif

         else

!..Melt snow and graupel and enhance from collisions with liquid.
!.. We also need to sublimate snow and graupel if subsaturated.
          if (L_qs(k)) then
           prr_sml(k) = (tempc*tcond(k)-lvap0*diffu(k)*delQvs(k))       &
                      * (t1_qs_me*smo1(k) + t2_qs_me*rhof2(k)*vsc2(k)*smof(k))
           prr_sml(k) = prr_sml(k) + 4218.*olfus*tempc &
                                   * (prr_rcs(k)+prs_scw(k))
           prr_sml(k) = MIN(DBLE(rs(k)*odts), MAX(0.D0, prr_sml(k)))
           pnr_sml(k) = smo0(k)/rs(k)*prr_sml(k) * 10.0**(-0.75*tempc)      ! RAIN2M
           pnr_sml(k) = MIN(DBLE(smo0(k)*odts), pnr_sml(k))
           if (tempc.gt.3.5 .or. rs(k).lt.0.005E-3) pnr_sml(k)=0.0

           if (ssati(k).lt. 0.) then
            prs_sde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
                         * (t1_qs_sd*smo1(k) &
                          + t2_qs_sd*rhof2(k)*vsc2(k)*smof(k))
            prs_sde(k) = MAX(DBLE(-rs(k)*odts), prs_sde(k))
           endif
          endif

          if (L_qg(k)) then
           prr_gml(k) = (tempc*tcond(k)-lvap0*diffu(k)*delQvs(k))       &
                      * N0_g(k)*(t1_qg_me*ilamg(k)**cge(10)             &
                      + t2_qg_me*rhof2(k)*vsc2(k)*ilamg(k)**cge(11))
!-GT       prr_gml(k) = prr_gml(k) + 4218.*olfus*tempc &
!-GT                               * (prr_rcg(k)+prg_gcw(k))
           prr_gml(k) = MIN(DBLE(rg(k)*odts), MAX(0.D0, prr_gml(k)))
           pnr_gml(k) = N0_g(k)*cgg(2)*ilamg(k)**cge(2) / rg(k)         &   ! RAIN2M
                      * prr_gml(k) * 10.0**(-.25*tempc)
           if (tempc.gt.7.5 .or. rg(k).lt.0.005E-3) pnr_gml(k)=0.0

           if (ssati(k).lt. 0.) then
            prg_gde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
                * N0_g(k) * (t1_qg_sd*ilamg(k)**cge(10) &
                + t2_qg_sd*vsc2(k)*rhof2(k)*ilamg(k)**cge(11))
            prg_gde(k) = MAX(DBLE(-rg(k)*odts), prg_gde(k))
           endif
          endif

!.. This change will be required if users run adaptive time step that
!.. results in delta-t that is generally too long to allow cloud water
!.. collection by snow/graupel above melting temperature.
!.. Credit to Bjorn-Egil Nygaard for discovering.
          if (dt .gt. 120.) then
             prr_rcw(k)=prr_rcw(k)+prs_scw(k)+prg_gcw(k)
             prs_scw(k)=0.
             prg_gcw(k)=0.
          endif

         endif

      enddo
      endif

!+---+-----------------------------------------------------------------+
!..Ensure we do not deplete more hydrometeor species than exists.
!+---+-----------------------------------------------------------------+
      do k = kts, kte

!..If ice supersaturated, ensure sum of depos growth terms does not
!.. deplete more vapor than possibly exists.  If subsaturated, limit
!.. sum of sublimation terms such that vapor does not reproduce ice
!.. supersat again.
         sump = pri_inu(k) + pri_ide(k) + prs_ide(k) &
              + prs_sde(k) + prg_gde(k)
         rate_max = (qv(k)-qvsi(k))*odts*0.999
         if ( (sump.gt. eps .and. sump.gt. rate_max) .or. &
              (sump.lt. -eps .and. sump.lt. rate_max) ) then
          ratio = rate_max/sump
          pri_inu(k) = pri_inu(k) * ratio
          pri_ide(k) = pri_ide(k) * ratio
          pni_ide(k) = pni_ide(k) * ratio
          prs_ide(k) = prs_ide(k) * ratio
          prs_sde(k) = prs_sde(k) * ratio
          prg_gde(k) = prg_gde(k) * ratio
         endif

!..Cloud water conservation.
         sump = -prr_wau(k) - pri_wfz(k) - prr_rcw(k) &
                - prs_scw(k) - prg_scw(k) - prg_gcw(k)
         rate_max = -rc(k)*odts
         if (sump.lt. rate_max .and. L_qc(k)) then
          ratio = rate_max/sump
          prr_wau(k) = prr_wau(k) * ratio
          pri_wfz(k) = pri_wfz(k) * ratio
          prr_rcw(k) = prr_rcw(k) * ratio
          prs_scw(k) = prs_scw(k) * ratio
          prg_scw(k) = prg_scw(k) * ratio
          prg_gcw(k) = prg_gcw(k) * ratio
         endif

!..Cloud ice conservation.
         sump = pri_ide(k) - prs_iau(k) - prs_sci(k) &
                - pri_rci(k)
         rate_max = -ri(k)*odts
         if (sump.lt. rate_max .and. L_qi(k)) then
          ratio = rate_max/sump
          pri_ide(k) = pri_ide(k) * ratio
          prs_iau(k) = prs_iau(k) * ratio
          prs_sci(k) = prs_sci(k) * ratio
          pri_rci(k) = pri_rci(k) * ratio
         endif

!..Rain conservation.
         sump = -prg_rfz(k) - pri_rfz(k) - prr_rci(k) &
                + prr_rcs(k) + prr_rcg(k)
         rate_max = -rr(k)*odts
         if (sump.lt. rate_max .and. L_qr(k)) then
          ratio = rate_max/sump
          prg_rfz(k) = prg_rfz(k) * ratio
          pri_rfz(k) = pri_rfz(k) * ratio
          prr_rci(k) = prr_rci(k) * ratio
          prr_rcs(k) = prr_rcs(k) * ratio
          prr_rcg(k) = prr_rcg(k) * ratio
         endif

!..Snow conservation.
         sump = prs_sde(k) - prs_ihm(k) - prr_sml(k) &
                + prs_rcs(k)
         rate_max = -rs(k)*odts
         if (sump.lt. rate_max .and. L_qs(k)) then
          ratio = rate_max/sump
          prs_sde(k) = prs_sde(k) * ratio
          prs_ihm(k) = prs_ihm(k) * ratio
          prr_sml(k) = prr_sml(k) * ratio
          prs_rcs(k) = prs_rcs(k) * ratio
         endif

!..Graupel conservation.
         sump = prg_gde(k) - prg_ihm(k) - prr_gml(k) &
              + prg_rcg(k)
         rate_max = -rg(k)*odts
         if (sump.lt. rate_max .and. L_qg(k)) then
          ratio = rate_max/sump
          prg_gde(k) = prg_gde(k) * ratio
          prg_ihm(k) = prg_ihm(k) * ratio
          prr_gml(k) = prr_gml(k) * ratio
          prg_rcg(k) = prg_rcg(k) * ratio
         endif

!..Re-enforce proper mass conservation for subsequent elements in case
!.. any of the above terms were altered.  Thanks P. Blossey. 2009Sep28
         pri_ihm(k) = prs_ihm(k) + prg_ihm(k)
         ratio = MIN( ABS(prr_rcg(k)), ABS(prg_rcg(k)) )
         prr_rcg(k) = ratio * SIGN(1.0, SNGL(prr_rcg(k)))
         prg_rcg(k) = -prr_rcg(k)
         if (temp(k).gt.T_0) then
            ratio = MIN( ABS(prr_rcs(k)), ABS(prs_rcs(k)) )
            prr_rcs(k) = ratio * SIGN(1.0, SNGL(prr_rcs(k)))
            prs_rcs(k) = -prr_rcs(k)
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate tendencies of all species but constrain the number of ice
!.. to reasonable values.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         orho = 1./rho(k)
         lfus2 = lsub - lvap(k)

!..Water vapor tendency
         qvten(k) = qvten(k) + (-pri_inu(k) - pri_ide(k) &
                      - prs_ide(k) - prs_sde(k) - prg_gde(k)) &
                      * orho

!..Cloud water tendency
         qcten(k) = qcten(k) + (-prr_wau(k) - pri_wfz(k) &
                      - prr_rcw(k) - prs_scw(k) - prg_scw(k) &
                      - prg_gcw(k)) &
                      * orho

!..Cloud ice mixing ratio tendency
         qiten(k) = qiten(k) + (pri_inu(k) + pri_ihm(k) &
                      + pri_wfz(k) + pri_rfz(k) + pri_ide(k) &
                      - prs_iau(k) - prs_sci(k) - pri_rci(k)) &
                      * orho

!..Cloud ice number tendency.
         niten(k) = niten(k) + (pni_inu(k) + pni_ihm(k) &
                      + pni_wfz(k) + pni_rfz(k) + pni_ide(k) &
                      - pni_iau(k) - pni_sci(k) - pni_rci(k)) &
                      * orho

!..Cloud ice mass/number balance; keep mass-wt mean size between
!.. 20 and 300 microns.  Also no more than 250 xtals per liter.
         xri=MAX(R1,(qi1d(k) + qiten(k)*dtsave)*rho(k))
         xni=MAX(R2,(ni1d(k) + niten(k)*dtsave)*rho(k))
         if (xri.gt. R1) then
           lami = (am_i*cig(2)*oig1*xni/xri)**obmi
           ilami = 1./lami
           xDi = (bm_i + mu_i + 1.) * ilami
           if (xDi.lt. 20.E-6) then
            lami = cie(2)/20.E-6
            xni = MIN(250.D3, cig(1)*oig2*xri/am_i*lami**bm_i)
            niten(k) = (xni-ni1d(k)*rho(k))*odts*orho
           elseif (xDi.gt. 300.E-6) then
            lami = cie(2)/300.E-6
            xni = cig(1)*oig2*xri/am_i*lami**bm_i
            niten(k) = (xni-ni1d(k)*rho(k))*odts*orho
           endif
         else
          niten(k) = -ni1d(k)*odts
         endif
         xni=MAX(0.,(ni1d(k) + niten(k)*dtsave)*rho(k))
         if (xni.gt.250.E3) &
                niten(k) = (250.E3-ni1d(k)*rho(k))*odts*orho

!..Rain tendency
         qrten(k) = qrten(k) + (prr_wau(k) + prr_rcw(k) &
                      + prr_sml(k) + prr_gml(k) + prr_rcs(k) &
                      + prr_rcg(k) - prg_rfz(k) &
                      - pri_rfz(k) - prr_rci(k)) &
                      * orho

!..Rain number tendency
         nrten(k) = nrten(k) + (pnr_wau(k) + pnr_sml(k) + pnr_gml(k)    &
                      - (pnr_rfz(k) + pnr_rcr(k) + pnr_rcg(k)           &
                      + pnr_rcs(k) + pnr_rci(k)) )                      &
                      * orho

!..Rain mass/number balance; keep median volume diameter between
!.. 37 microns (D0r*0.75) and 2.5 mm.
         xrr=MAX(R1,(qr1d(k) + qrten(k)*dtsave)*rho(k))
         xnr=MAX(R2,(nr1d(k) + nrten(k)*dtsave)*rho(k))
         if (xrr.gt. R1) then
           lamr = (am_r*crg(3)*org2*xnr/xrr)**obmr
           mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
           if (mvd_r(k) .gt. 2.5E-3) then
              mvd_r(k) = 2.5E-3
              lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
              xnr = crg(2)*org3*xrr*lamr**bm_r / am_r
              nrten(k) = (xnr-nr1d(k)*rho(k))*odts*orho
           elseif (mvd_r(k) .lt. D0r*0.75) then
              mvd_r(k) = D0r*0.75
              lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
              xnr = crg(2)*org3*xrr*lamr**bm_r / am_r
              nrten(k) = (xnr-nr1d(k)*rho(k))*odts*orho
           endif
         else
           qrten(k) = -qr1d(k)*odts
           nrten(k) = -nr1d(k)*odts
         endif

!..Snow tendency
         qsten(k) = qsten(k) + (prs_iau(k) + prs_sde(k) &
                      + prs_sci(k) + prs_scw(k) + prs_rcs(k) &
                      + prs_ide(k) - prs_ihm(k) - prr_sml(k)) &
                      * orho

!..Graupel tendency
         qgten(k) = qgten(k) + (prg_scw(k) + prg_rfz(k) &
                      + prg_gde(k) + prg_rcg(k) + prg_gcw(k) &
                      + prg_rci(k) + prg_rcs(k) - prg_ihm(k) &
                      - prr_gml(k)) &
                      * orho

!..Temperature tendency
         if (temp(k).lt.T_0) then
          if(eqtset.eq.1)then
          tten(k) = tten(k) &
                    + ( lsub*ocp(k)*(pri_inu(k) + pri_ide(k) &
                                     + prs_ide(k) + prs_sde(k) &
                                     + prg_gde(k)) &
                     + lfus2*ocp(k)*(pri_wfz(k) + pri_rfz(k) &
                                     + prg_rfz(k) + prs_scw(k) &
                                     + prg_scw(k) + prg_gcw(k) &
                                     + prg_rcs(k) + prs_rcs(k) &
                                     + prr_rci(k) + prg_rcg(k)) &
                       )*orho * (1-IFDRY)
          else
          edep = (lsub-Rv*temp(k))/cvm(k)
          efrz = lfus2/cvm(k)
          tten(k) = tten(k) &
                    + (        edep*(pri_inu(k) + pri_ide(k) &
                                     + prs_ide(k) + prs_sde(k) &
                                     + prg_gde(k)) &
                     +         efrz*(pri_wfz(k) + pri_rfz(k) &
                                     + prg_rfz(k) + prs_scw(k) &
                                     + prg_scw(k) + prg_gcw(k) &
                                     + prg_rcs(k) + prs_rcs(k) &
                                     + prr_rci(k) + prg_rcg(k)) &
                       )*orho * (1-IFDRY)
          endif
         else
          if(eqtset.eq.1)then
          tten(k) = tten(k) &
                    + ( lfus*ocp(k)*(-prr_sml(k) - prr_gml(k) &
                                     - prr_rcg(k) - prr_rcs(k)) &
                      + lsub*ocp(k)*(prs_sde(k) + prg_gde(k)) &
                       )*orho * (1-IFDRY)
          else
          efrz = lfus/cvm(k)
          edep = (lsub-Rv*temp(k))/cvm(k)
          tten(k) = tten(k) &
                    + (        efrz*(-prr_sml(k) - prr_gml(k) &
                                     - prr_rcg(k) - prr_rcs(k)) &
                      +        edep*(prs_sde(k) + prg_gde(k)) &
                       )*orho * (1-IFDRY)
          endif
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Update variables for TAU+1 before condensation & sedimention.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k) + DT*tten(k)
         otemp = 1./temp(k)
         tempc = temp(k) - 273.15
         qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
         if(eqtset.eq.1)then
         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         else
         pres(k) = rho(k)*(R+Rv*qv(k))*temp(k)
         endif
         rhof(k) = SQRT(RHO_NOT/rho(k))
         rhof2(k) = SQRT(rhof(k))
         qvs(k) = rslf(pres(k), temp(k))
         ssatw(k) = qv(k)/qvs(k) - 1.
         if (abs(ssatw(k)).lt. eps) ssatw(k) = 0.0
         diffu(k) = 2.11E-5*(temp(k)/273.15)**1.94 * (101325./pres(k))
         if (tempc .ge. 0.0) then
            visco(k) = (1.718+0.0049*tempc)*1.0E-5
         else
            visco(k) = (1.718+0.0049*tempc-1.2E-5*tempc*tempc)*1.0E-5
         endif
         vsc2(k) = SQRT(rho(k)/visco(k))
         lvap(k) = lvap0 + (2106.0 - 4218.0)*tempc
         tcond(k) = (5.69 + 0.0168*tempc)*1.0E-5 * 418.936
         ocp(k) = 1./(Cp*(1.+0.887*qv(k)))
         lvt2(k)=lvap(k)*lvap(k)*ocp(k)*oRv*otemp*otemp

         if ((qc1d(k) + qcten(k)*DT) .gt. R1) then
            rc(k) = (qc1d(k) + qcten(k)*DT)*rho(k)
            L_qc(k) = .true.
         else
            rc(k) = R1
            L_qc(k) = .false.
         endif

         if ((qi1d(k) + qiten(k)*DT) .gt. R1) then
            ri(k) = (qi1d(k) + qiten(k)*DT)*rho(k)
            ni(k) = MAX(R2, (ni1d(k) + niten(k)*DT)*rho(k))
            L_qi(k) = .true. 
         else
            ri(k) = R1
            ni(k) = R2
            L_qi(k) = .false.
         endif

         if ((qr1d(k) + qrten(k)*DT) .gt. R1) then
            rr(k) = (qr1d(k) + qrten(k)*DT)*rho(k)
            nr(k) = MAX(R2, (nr1d(k) + nrten(k)*DT)*rho(k))
            L_qr(k) = .true.
            lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
            mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
            if (mvd_r(k) .gt. 2.5E-3) then
               mvd_r(k) = 2.5E-3
               lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
               nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
            elseif (mvd_r(k) .lt. D0r*0.75) then
               mvd_r(k) = D0r*0.75
               lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
               nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
            endif
         else
            rr(k) = R1
            nr(k) = R2
            L_qr(k) = .false.
         endif
               
         if ((qs1d(k) + qsten(k)*DT) .gt. R1) then
            rs(k) = (qs1d(k) + qsten(k)*DT)*rho(k)
            L_qs(k) = .true.
         else
            rs(k) = R1
            L_qs(k) = .false.
         endif

         if ((qg1d(k) + qgten(k)*DT) .gt. R1) then
            rg(k) = (qg1d(k) + qgten(k)*DT)*rho(k)
            L_qg(k) = .true.
         else
            rg(k) = R1
            L_qg(k) = .false.
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..With tendency-updated mixing ratios, recalculate snow moments and
!.. intercepts/slopes of graupel and rain.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         if (.not. L_qs(k)) CYCLE
         tc0 = MIN(-0.1, temp(k)-273.15)
         smob(k) = rs(k)*oams

!..All other moments based on reference, 2nd moment.  If bm_s.ne.2,
!.. then we must compute actual 2nd moment and use as reference.
         if (bm_s.gt.(2.0-1.e-3) .and. bm_s.lt.(2.0+1.e-3)) then
            smo2(k) = smob(k)
         else
            loga_ = sa(1) + sa(2)*tc0 + sa(3)*bm_s &
               + sa(4)*tc0*bm_s + sa(5)*tc0*tc0 &
               + sa(6)*bm_s*bm_s + sa(7)*tc0*tc0*bm_s &
               + sa(8)*tc0*bm_s*bm_s + sa(9)*tc0*tc0*tc0 &
               + sa(10)*bm_s*bm_s*bm_s
            a_ = 10.0**loga_
            b_ = sb(1) + sb(2)*tc0 + sb(3)*bm_s &
               + sb(4)*tc0*bm_s + sb(5)*tc0*tc0 &
               + sb(6)*bm_s*bm_s + sb(7)*tc0*tc0*bm_s &
               + sb(8)*tc0*bm_s*bm_s + sb(9)*tc0*tc0*tc0 &
               + sb(10)*bm_s*bm_s*bm_s
            smo2(k) = (smob(k)/a_)**(1./b_)
         endif

!..Calculate bm_s+1 (th) moment.  Useful for diameter calcs.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(1) &
               + sa(4)*tc0*cse(1) + sa(5)*tc0*tc0 &
               + sa(6)*cse(1)*cse(1) + sa(7)*tc0*tc0*cse(1) &
               + sa(8)*tc0*cse(1)*cse(1) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(1)*cse(1)*cse(1)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(1) + sb(4)*tc0*cse(1) &
              + sb(5)*tc0*tc0 + sb(6)*cse(1)*cse(1) &
              + sb(7)*tc0*tc0*cse(1) + sb(8)*tc0*cse(1)*cse(1) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(1)*cse(1)*cse(1)
         smoc(k) = a_ * smo2(k)**b_

!..Calculate bm_s+bv_s (th) moment.  Useful for sedimentation.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(14) &
               + sa(4)*tc0*cse(14) + sa(5)*tc0*tc0 &
               + sa(6)*cse(14)*cse(14) + sa(7)*tc0*tc0*cse(14) &
               + sa(8)*tc0*cse(14)*cse(14) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(14)*cse(14)*cse(14)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(14) + sb(4)*tc0*cse(14) &
              + sb(5)*tc0*tc0 + sb(6)*cse(14)*cse(14) &
              + sb(7)*tc0*tc0*cse(14) + sb(8)*tc0*cse(14)*cse(14) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(14)*cse(14)*cse(14)
         smod(k) = a_ * smo2(k)**b_
      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+
      N0_min = gonv_max
      do k = kte, kts, -1
         if (temp(k).lt.270.65 .and. L_qr(k) .and. mvd_r(k).gt.100.E-6) then
            xslw1 = 4.01 + alog10(mvd_r(k))
         else
            xslw1 = 0.01
         endif
         ygra1 = 4.31 + alog10(max(5.E-5, rg(k)))
         zans1 = 3.1 + (100./(300.*xslw1*ygra1/(10./xslw1+1.+0.25*ygra1)+30.+10.*ygra1))
         N0_exp = 10.**(zans1)
         N0_exp = MAX(DBLE(gonv_min), MIN(N0_exp, DBLE(gonv_max)))
         N0_min = MIN(N0_exp, N0_min)
         N0_exp = N0_min
         lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1
         lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
         ilamg(k) = 1./lamg
         N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2)
      enddo

      endif

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for rain.
!+---+-----------------------------------------------------------------+
      do k = kte, kts, -1
         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
         ilamr(k) = 1./lamr
         mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
         N0_r(k) = nr(k)*org2*lamr**cre(2)
      enddo

!+---+-----------------------------------------------------------------+
!..Cloud water condensation and evaporation.  Newly formulated using
!.. Newton-Raphson iterations (3 should suffice) as provided by B. Hall.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
        IF(eqtset.eq.1)THEN
         ! Thompson saturation adjustment scheme:
         if ( (ssatw(k).gt. eps) .or. (ssatw(k).lt. -eps .and. &
                   L_qc(k)) ) then
          clap = (qv(k)-qvs(k))/(1. + lvt2(k)*qvs(k))
          do n = 1, 3
             fcd = qvs(k)* EXP(lvt2(k)*clap) - qv(k) + clap
             dfcd = qvs(k)*lvt2(k)* EXP(lvt2(k)*clap) + 1.
             clap = clap - fcd/dfcd
          enddo
          xrc = rc(k) + clap
          if (xrc.gt. 0.0) then
             prw_vcd(k) = clap*odt
          else
             prw_vcd(k) = -rc(k)/rho(k)*odts
          endif

          qcten(k) = qcten(k) + prw_vcd(k)
          qvten(k) = qvten(k) - prw_vcd(k)
          tten(k) = tten(k) + lvap(k)*ocp(k)*prw_vcd(k)*(1-IFDRY)
          rc(k) = MAX(R1, (qc1d(k) + DT*qcten(k))*rho(k))
          qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
          temp(k) = t1d(k) + DT*tten(k)
          rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
          qvs(k) = rslf(pres(k), temp(k))
          ssatw(k) = qv(k)/qvs(k) - 1.
         endif
        ELSE
         ! CM1 saturation adjustment scheme:
          dumt = t1d(k) + DT*tten(k)
          dumqv = qv1d(k) + qvten(k)*DT
          dumqc = qc1d(k) + qcten(k)*DT
          dumqr = qr1d(k) + qrten(k)*DT
          dumqi = qi1d(k) + qiten(k)*DT
          dumqs = qs1d(k) + qsten(k)*DT
          dumqg = qg1d(k) + qgten(k)*DT
          SAVEQC = DUMQC
          SAVET = DUMT
          pres(k) = rho(k)*(R+Rv*dumqv)*dumt
          call satadj3(DUMT,PRES(K),DUMQV,DUMQC,DUMQR,DUMQI,DUMQS,DUMQG,RHO(K))
          IF( abs(DUMT-SAVET).ge.0.0001 )THEN
            RDT = 1.0/DT
            prw_vcd(k) = (DUMQC-SAVEQC)*RDT
            qcten(k) = qcten(k) + prw_vcd(k)
            qvten(k) = qvten(k) - prw_vcd(k)
            tten(k) = tten(k) + (DUMT-SAVET)*RDT
          ELSE
            prw_vcd(k) = 0.0
          ENDIF
          rc(k) = MAX(R1, (qc1d(k) + DT*qcten(k))*rho(k))
          qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
          temp(k) = t1d(k) + DT*tten(k)
          qvs(k) = rslf(pres(k), temp(k))
          ssatw(k) = qv(k)/qvs(k) - 1.
        ENDIF
      enddo

!+---+-----------------------------------------------------------------+
!.. If still subsaturated, allow rain to evaporate, following
!.. Srivastava & Coen (1992).
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         if ( (ssatw(k).lt. -eps) .and. L_qr(k) &
                     .and. (.not.(prw_vcd(k).gt. 0.)) ) then
          tempc = temp(k) - 273.15
          otemp = 1./temp(k)
          rhof(k) = SQRT(RHO_NOT/rho(k))
          rhof2(k) = SQRT(rhof(k))
          diffu(k) = 2.11E-5*(temp(k)/273.15)**1.94 * (101325./pres(k))
          if (tempc .ge. 0.0) then
             visco(k) = (1.718+0.0049*tempc)*1.0E-5
          else
             visco(k) = (1.718+0.0049*tempc-1.2E-5*tempc*tempc)*1.0E-5
          endif
          vsc2(k) = SQRT(rho(k)/visco(k))
          lvap(k) = lvap0 + (2106.0 - 4218.0)*tempc
          tcond(k) = (5.69 + 0.0168*tempc)*1.0E-5 * 418.936
          ocp(k) = 1./(Cp*(1.+0.887*qv(k)))

          rvs = rho(k)*qvs(k)
          rvs_p = rvs*otemp*(lvap(k)*otemp*oRv - 1.)
          rvs_pp = rvs * ( otemp*(lvap(k)*otemp*oRv - 1.) &
                          *otemp*(lvap(k)*otemp*oRv - 1.) &
                          + (-2.*lvap(k)*otemp*otemp*otemp*oRv) &
                          + otemp*otemp)
          gamsc = lvap(k)*diffu(k)/tcond(k) * rvs_p
          alphsc = 0.5*(gamsc/(1.+gamsc))*(gamsc/(1.+gamsc)) &
                     * rvs_pp/rvs_p * rvs/rvs_p
          alphsc = MAX(1.E-9, alphsc)
          xsat   = MIN(-1.E-9, ssatw(k))
          t1_evap = 2.*PI*( 1.0 - alphsc*xsat  &
                 + 2.*alphsc*alphsc*xsat*xsat  &
                 - 5.*alphsc*alphsc*alphsc*xsat*xsat*xsat ) &
                 / (1.+gamsc)

          lamr = 1./ilamr(k)
!..Rapidly eliminate near zero values when low humidity (<95%)
          if (qv(k)/qvs(k) .lt. 0.95 .AND. rr(k)/rho(k).le.1.E-8) then
          prv_rev(k) = rr(k)/rho(k)*odts
          else
          prv_rev(k) = t1_evap*diffu(k)*(-ssatw(k))*N0_r(k)*rvs &
              * (t1_qr_ev*ilamr(k)**cre(10) &
              + t2_qr_ev*vsc2(k)*rhof2(k)*((lamr+0.5*fv_r)**(-cre(11))))
          rate_max = MIN((rr(k)/rho(k)*odts), (qvs(k)-qv(k))*odts)
          prv_rev(k) = MIN(DBLE(rate_max), prv_rev(k)/rho(k))
!..REDUCE the rain evaporation in same places as melting graupel occurs. 
!..Rationale: not much shedding of the water from the graupel so
!..likely that the water-coated graupel evaporating much slower than
!..if the water was immediately shed off.
          IF (prr_gml(k).gt.0.0) THEN
             eva_factor = MIN(1.0, 0.01+(0.99-0.01)*(tempc/20.0))
             prv_rev(k) = prv_rev(k)*eva_factor
          ENDIF
          endif
          pnr_rev(k) = MIN(DBLE(nr(k)*0.99/rho(k)*odts),                &   ! RAIN2M
                       prv_rev(k) * nr(k)/rr(k))

          qrten(k) = qrten(k) - prv_rev(k)
          qvten(k) = qvten(k) + prv_rev(k)
          nrten(k) = nrten(k) - pnr_rev(k)
          if(eqtset.eq.1)then
          tten(k) = tten(k) - lvap(k)*ocp(k)*prv_rev(k)*(1-IFDRY)
          else
          econd = (lvap(k)-Rv*temp(k))/cvm(k)
          tten(k) = tten(k) - econd*prv_rev(k)*(1-IFDRY)
          endif

          rr(k) = MAX(R1, (qr1d(k) + DT*qrten(k))*rho(k))
          qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
          nr(k) = MAX(R2, (nr1d(k) + DT*nrten(k))*rho(k))
          temp(k) = t1d(k) + DT*tten(k)
          if(eqtset.eq.1)then
          rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
          else
          pres(k) = rho(k)*(R+Rv*qv(k))*temp(k)
          endif
         endif
      enddo
#ifdef WRF_CHEM
      do k = kts, kte
         evapprod(k) = prv_rev(k) - (min(zeroD0,prs_sde(k)) + &
                                     min(zeroD0,prg_gde(k)))
         rainprod(k) = prr_wau(k) + prr_rcw(k) + prs_scw(k) + &
                                    prg_scw(k) + prs_iau(k) + &
                                    prg_gcw(k) + prs_sci(k) + &
                                    pri_rci(k)
      enddo
#endif

!+---+-----------------------------------------------------------------+
!..Find max terminal fallspeed (distribution mass-weighted mean
!.. velocity) and use it to determine if we need to split the timestep
!.. (var nstep>1).  Either way, only bother to do sedimentation below
!.. 1st level that contains any sedimenting particles (k=ksed1 on down).
!.. New in v3.0+ is computing separate for rain, ice, snow, and
!.. graupel species thus making code faster with credit to J. Schmidt.
!+---+-----------------------------------------------------------------+
      nstep = 0
      onstep(:) = 1.0
      ksed1(:) = 1
      do k = kte+1, kts, -1
         vtrk(k) = 0.
         vtnrk(k) = 0.
         vtik(k) = 0.
         vtnik(k) = 0.
         vtsk(k) = 0.
         vtgk(k) = 0.
      enddo
      do k = kte, kts, -1
         vtr = 0.
         rhof(k) = SQRT(RHO_NOT/rho(k))

         if (rr(k).gt. R1) then
          lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
          vtr = rhof(k)*av_r*crg(6)*org3 * lamr**cre(3)                 &
                      *((lamr+fv_r)**(-cre(6)))
          vtrk(k) = vtr
! First below is technically correct:
!         vtr = rhof(k)*av_r*crg(5)*org2 * lamr**cre(2)                 &
!                     *((lamr+fv_r)**(-cre(5)))
! Test: make number fall faster (but still slower than mass)
! Goal: less prominent size sorting
          vtr = rhof(k)*av_r*crg(7)/crg(12) * lamr**cre(12)             &
                      *((lamr+fv_r)**(-cre(7)))
          vtnrk(k) = vtr
         else
          vtrk(k) = vtrk(k+1)
          vtnrk(k) = vtnrk(k+1)
         endif

         if (MAX(vtrk(k),vtnrk(k)) .gt. 1.E-3) then
            ksed1(1) = MAX(ksed1(1), k)
            delta_tp = dzq(k)/(MAX(vtrk(k),vtnrk(k)))
            nstep = MAX(nstep, INT(DT/delta_tp + 1.))
         endif
      enddo
      if (ksed1(1) .eq. kte) ksed1(1) = kte-1
      if (nstep .gt. 0) onstep(1) = 1./REAL(nstep)

!+---+-----------------------------------------------------------------+

      if (.not. iiwarm) then

       nstep = 0
       do k = kte, kts, -1
          vti = 0.

          if (ri(k).gt. R1) then
           lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
           ilami = 1./lami
           vti = rhof(k)*av_i*cig(3)*oig2 * ilami**bv_i
           vtik(k) = vti
! First below is technically correct:
!          vti = rhof(k)*av_i*cig(4)*oig1 * ilami**bv_i
! Goal: less prominent size sorting
           vti = rhof(k)*av_i*cig(6)/cig(7) * ilami**bv_i
           vtnik(k) = vti
          else
           vtik(k) = vtik(k+1)
           vtnik(k) = vtnik(k+1)
          endif

          if (vtik(k) .gt. 1.E-3) then
             ksed1(2) = MAX(ksed1(2), k)
             delta_tp = dzq(k)/vtik(k)
             nstep = MAX(nstep, INT(DT/delta_tp + 1.))
          endif
       enddo
       if (ksed1(2) .eq. kte) ksed1(2) = kte-1
       if (nstep .gt. 0) onstep(2) = 1./REAL(nstep)

!+---+-----------------------------------------------------------------+

       nstep = 0
       do k = kte, kts, -1
          vts = 0.

          if (rs(k).gt. R1) then
           xDs = smoc(k) / smob(k)
           Mrat = 1./xDs
           ils1 = 1./(Mrat*Lam0 + fv_s)
           ils2 = 1./(Mrat*Lam1 + fv_s)
           t1_vts = Kap0*csg(4)*ils1**cse(4)
           t2_vts = Kap1*Mrat**mu_s*csg(10)*ils2**cse(10)
           ils1 = 1./(Mrat*Lam0)
           ils2 = 1./(Mrat*Lam1)
           t3_vts = Kap0*csg(1)*ils1**cse(1)
           t4_vts = Kap1*Mrat**mu_s*csg(7)*ils2**cse(7)
           vts = rhof(k)*av_s * (t1_vts+t2_vts)/(t3_vts+t4_vts)
           if (temp(k).gt. T_0) then
            vtsk(k) = MAX(vts*vts_boost(k), vtrk(k))
           else
            vtsk(k) = vts*vts_boost(k)
           endif
          else
            vtsk(k) = vtsk(k+1)
          endif

          if (vtsk(k) .gt. 1.E-3) then
             ksed1(3) = MAX(ksed1(3), k)
             delta_tp = dzq(k)/vtsk(k)
             nstep = MAX(nstep, INT(DT/delta_tp + 1.))
          endif
       enddo
       if (ksed1(3) .eq. kte) ksed1(3) = kte-1
       if (nstep .gt. 0) onstep(3) = 1./REAL(nstep)

!+---+-----------------------------------------------------------------+

       nstep = 0
       do k = kte, kts, -1
          vtg = 0.

          if (rg(k).gt. R1) then
           vtg = rhof(k)*av_g*cgg(6)*ogg3 * ilamg(k)**bv_g
           if (temp(k).gt. T_0) then
            vtgk(k) = MAX(vtg, vtrk(k))
           else
            vtgk(k) = vtg
           endif
          else
            vtgk(k) = vtgk(k+1)
          endif

          if (vtgk(k) .gt. 1.E-3) then
             ksed1(4) = MAX(ksed1(4), k)
             delta_tp = dzq(k)/vtgk(k)
             nstep = MAX(nstep, INT(DT/delta_tp + 1.))
          endif
       enddo
       if (ksed1(4) .eq. kte) ksed1(4) = kte-1
       if (nstep .gt. 0) onstep(4) = 1./REAL(nstep)
      endif

!+---+-----------------------------------------------------------------+
!..Sedimentation of mixing ratio is the integral of v(D)*m(D)*N(D)*dD,
!.. whereas neglect m(D) term for number concentration.  Therefore,
!.. cloud ice has proper differential sedimentation.
!.. New in v3.0+ is computing separate for rain, ice, snow, and
!.. graupel species thus making code faster with credit to J. Schmidt.
!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(1))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_r(k) = vtrk(k)*rr(k)
            sed_n(k) = vtnrk(k)*nr(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qrten(k) = qrten(k) - sed_r(k)*odzq*onstep(1)*orho
         nrten(k) = nrten(k) - sed_n(k)*odzq*onstep(1)*orho
         rr(k) = MAX(R1, rr(k) - sed_r(k)*odzq*DT*onstep(1))
         nr(k) = MAX(R2, nr(k) - sed_n(k)*odzq*DT*onstep(1))
         do k = ksed1(1), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qrten(k) = qrten(k) + (sed_r(k+1)-sed_r(k)) &
                                               *odzq*onstep(1)*orho
            nrten(k) = nrten(k) + (sed_n(k+1)-sed_n(k)) &
                                               *odzq*onstep(1)*orho
            rr(k) = MAX(R1, rr(k) + (sed_r(k+1)-sed_r(k)) &
                                           *odzq*DT*onstep(1))
            nr(k) = MAX(R2, nr(k) + (sed_n(k+1)-sed_n(k)) &
                                           *odzq*DT*onstep(1))
         enddo

         if (rr(kts).gt.R1*10.) &
         pptrain = pptrain + sed_r(kts)*DT*onstep(1)
      enddo

!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(2))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_i(k) = vtik(k)*ri(k)
            sed_n(k) = vtnik(k)*ni(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qiten(k) = qiten(k) - sed_i(k)*odzq*onstep(2)*orho
         niten(k) = niten(k) - sed_n(k)*odzq*onstep(2)*orho
         ri(k) = MAX(R1, ri(k) - sed_i(k)*odzq*DT*onstep(2))
         ni(k) = MAX(R2, ni(k) - sed_n(k)*odzq*DT*onstep(2))
         do k = ksed1(2), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qiten(k) = qiten(k) + (sed_i(k+1)-sed_i(k)) &
                                               *odzq*onstep(2)*orho
            niten(k) = niten(k) + (sed_n(k+1)-sed_n(k)) &
                                               *odzq*onstep(2)*orho
            ri(k) = MAX(R1, ri(k) + (sed_i(k+1)-sed_i(k)) &
                                           *odzq*DT*onstep(2))
            ni(k) = MAX(R2, ni(k) + (sed_n(k+1)-sed_n(k)) &
                                           *odzq*DT*onstep(2))
         enddo

         if (ri(kts).gt.R1*10.) &
         pptice = pptice + sed_i(kts)*DT*onstep(2)
      enddo

!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(3))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_s(k) = vtsk(k)*rs(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qsten(k) = qsten(k) - sed_s(k)*odzq*onstep(3)*orho
         rs(k) = MAX(R1, rs(k) - sed_s(k)*odzq*DT*onstep(3))
         do k = ksed1(3), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qsten(k) = qsten(k) + (sed_s(k+1)-sed_s(k)) &
                                               *odzq*onstep(3)*orho
            rs(k) = MAX(R1, rs(k) + (sed_s(k+1)-sed_s(k)) &
                                           *odzq*DT*onstep(3))
         enddo

         if (rs(kts).gt.R1*10.) &
         pptsnow = pptsnow + sed_s(kts)*DT*onstep(3)
      enddo

!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(4))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_g(k) = vtgk(k)*rg(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qgten(k) = qgten(k) - sed_g(k)*odzq*onstep(4)*orho
         rg(k) = MAX(R1, rg(k) - sed_g(k)*odzq*DT*onstep(4))
         do k = ksed1(4), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qgten(k) = qgten(k) + (sed_g(k+1)-sed_g(k)) &
                                               *odzq*onstep(4)*orho
            rg(k) = MAX(R1, rg(k) + (sed_g(k+1)-sed_g(k)) &
                                           *odzq*DT*onstep(4))
         enddo

         if (rg(kts).gt.R1*10.) &
         pptgraul = pptgraul + sed_g(kts)*DT*onstep(4)
      enddo

!+---+-----------------------------------------------------------------+
!.. Instantly melt any cloud ice into cloud water if above 0C and
!.. instantly freeze any cloud water found below HGFR.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         xri = MAX(0.0, qi1d(k) + qiten(k)*DT)
         if ( (temp(k).gt. T_0) .and. (xri.gt. 0.0) ) then
          qcten(k) = qcten(k) + xri*odt
          qiten(k) = qiten(k) - xri*odt
          niten(k) = -ni1d(k)*odt
          if(eqtset.eq.1)then
          tten(k) = tten(k) - lfus*ocp(k)*xri*odt*(1-IFDRY)
          else
          efrz = lfus/cvm(k)
          tten(k) = tten(k) - efrz*xri*odt*(1-IFDRY)
          endif
         endif

         xrc = MAX(0.0, qc1d(k) + qcten(k)*DT)
         if ( (temp(k).lt. HGFR) .and. (xrc.gt. 0.0) ) then
          lfus2 = lsub - lvap(k)
          qiten(k) = qiten(k) + xrc*odt
          niten(k) = niten(k) + xrc/xm0i * odt
          qcten(k) = qcten(k) - xrc*odt
          if(eqtset.eq.1)then
          tten(k) = tten(k) + lfus2*ocp(k)*xrc*odt*(1-IFDRY)
          else
          efrz = lfus2/cvm(k)
          tten(k) = tten(k) + efrz*xrc*odt*(1-IFDRY)
          endif
         endif
      enddo
      endif

!+---+-----------------------------------------------------------------+
!.. All tendencies computed, apply and pass back final values to parent.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         t1d(k)  = t1d(k) + tten(k)*DT
         qv1d(k) = MAX(1.E-10, qv1d(k) + qvten(k)*DT)
         qc1d(k) = qc1d(k) + qcten(k)*DT
         if (qc1d(k) .le. R1) qc1d(k) = 0.0
         qi1d(k) = qi1d(k) + qiten(k)*DT
         ni1d(k) = MAX(R2/rho(k), ni1d(k) + niten(k)*DT)
         if (qi1d(k) .le. R1) then
           qi1d(k) = 0.0
           ni1d(k) = 0.0
         else
           lami = (am_i*cig(2)*oig1*ni1d(k)/qi1d(k))**obmi
           ilami = 1./lami
           xDi = (bm_i + mu_i + 1.) * ilami
           if (xDi.lt. 20.E-6) then
            lami = cie(2)/20.E-6
           elseif (xDi.gt. 300.E-6) then
            lami = cie(2)/300.E-6
           endif
           ni1d(k) = MIN(cig(1)*oig2*qi1d(k)/am_i*lami**bm_i,           &
                         250.D3/rho(k))
         endif
         qr1d(k) = qr1d(k) + qrten(k)*DT
         nr1d(k) = MAX(R2/rho(k), nr1d(k) + nrten(k)*DT)
         if (qr1d(k) .le. R1) then
           qr1d(k) = 0.0
           nr1d(k) = 0.0
         else
           lamr = (am_r*crg(3)*org2*nr1d(k)/qr1d(k))**obmr
           mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
           if (mvd_r(k) .gt. 2.5E-3) then
              mvd_r(k) = 2.5E-3
           elseif (mvd_r(k) .lt. D0r*0.75) then
              mvd_r(k) = D0r*0.75
           endif
           lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
           nr1d(k) = crg(2)*org3*qr1d(k)*lamr**bm_r / am_r
         endif
         qs1d(k) = qs1d(k) + qsten(k)*DT
         if (qs1d(k) .le. R1) qs1d(k) = 0.0
         qg1d(k) = qg1d(k) + qgten(k)*DT
         if (qg1d(k) .le. R1) qg1d(k) = 0.0
      enddo

      end subroutine mp_thompson
!+---+-----------------------------------------------------------------+
!
!+---+-----------------------------------------------------------------+
!..Creation of the lookup tables and support functions found below here.
!+---+-----------------------------------------------------------------+
!..Rain collecting graupel (and inverse).  Explicit CE integration.
!+---+-----------------------------------------------------------------+

      subroutine qr_acr_qg

      implicit none

!..Local variables
      INTEGER:: i, j, k, m, n, n2
      INTEGER:: km, km_s, km_e
      DOUBLE PRECISION, DIMENSION(nbg):: vg, N_g
      DOUBLE PRECISION, DIMENSION(nbr):: vr, N_r
      DOUBLE PRECISION:: N0_r, N0_g, lam_exp, lamg, lamr
      DOUBLE PRECISION:: massg, massr, dvg, dvr, t1, t2, z1, z2, y1, y2

!+---+

      do n2 = 1, nbr
!        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2))
         vr(n2) = -0.1021 + 4.932E3*Dr(n2) - 0.9551E6*Dr(n2)*Dr(n2)     &
              + 0.07934E9*Dr(n2)*Dr(n2)*Dr(n2)                          &
              - 0.002362E12*Dr(n2)*Dr(n2)*Dr(n2)*Dr(n2)
      enddo
      do n = 1, nbg
         vg(n) = av_g*Dg(n)**bv_g
      enddo

!..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for
!.. fortran indices.  J. Michalakes, 2009Oct30.

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e )
#else
      km_s = 0
      km_e = ntb_r*ntb_r1 - 1
#endif

      do km = km_s, km_e
         m = km / ntb_r1 + 1
         k = mod( km , ntb_r1 ) + 1

         lam_exp = (N0r_exp(k)*am_r*crg(1)/r_r(m))**ore1
         lamr = lam_exp * (crg(3)*org2*org1)**obmr
         N0_r = N0r_exp(k)/(crg(2)*lam_exp) * lamr**cre(2)
         do n2 = 1, nbr
            N_r(n2) = N0_r*Dr(n2)**mu_r *DEXP(-lamr*Dr(n2))*dtr(n2)
         enddo

         do j = 1, ntb_g
         do i = 1, ntb_g1
            lam_exp = (N0g_exp(i)*am_g*cgg(1)/r_g(j))**oge1
            lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
            N0_g = N0g_exp(i)/(cgg(2)*lam_exp) * lamg**cge(2)
            do n = 1, nbg
               N_g(n) = N0_g*Dg(n)**mu_g * DEXP(-lamg*Dg(n))*dtg(n)
            enddo

            t1 = 0.0d0
            t2 = 0.0d0
            z1 = 0.0d0
            z2 = 0.0d0
            y1 = 0.0d0
            y2 = 0.0d0
            do n2 = 1, nbr
               massr = am_r * Dr(n2)**bm_r
               do n = 1, nbg
                  massg = am_g * Dg(n)**bm_g

                  dvg = 0.5d0*((vr(n2) - vg(n)) + DABS(vr(n2)-vg(n)))
                  dvr = 0.5d0*((vg(n) - vr(n2)) + DABS(vg(n)-vr(n2)))

                  t1 = t1+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvg*massg * N_g(n)* N_r(n2)
                  z1 = z1+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvg*massr * N_g(n)* N_r(n2)
                  y1 = y1+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvg       * N_g(n)* N_r(n2)

                  t2 = t2+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvr*massr * N_g(n)* N_r(n2)
                  y2 = y2+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvr       * N_g(n)* N_r(n2)
                  z2 = z2+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvr*massg * N_g(n)* N_r(n2)
               enddo
 97            continue
            enddo
            tcg_racg(i,j,k,m) = t1
            tmr_racg(i,j,k,m) = DMIN1(z1, r_r(m)*1.0d0)
            tcr_gacr(i,j,k,m) = t2
            tmg_gacr(i,j,k,m) = z2
            tnr_racg(i,j,k,m) = y1
            tnr_gacr(i,j,k,m) = y2
         enddo
         enddo
      enddo

!..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30).

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_gatherv(tcg_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmg_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
#endif


      end subroutine qr_acr_qg
!+---+-----------------------------------------------------------------+
!
!+---+-----------------------------------------------------------------+
!..Rain collecting snow (and inverse).  Explicit CE integration.
!+---+-----------------------------------------------------------------+

      subroutine qr_acr_qs

      implicit none

!..Local variables
      INTEGER:: i, j, k, m, n, n2
      INTEGER:: km, km_s, km_e
      DOUBLE PRECISION, DIMENSION(nbr):: vr, D1, N_r
      DOUBLE PRECISION, DIMENSION(nbs):: vs, N_s
      DOUBLE PRECISION:: loga_, a_, b_, second, M0, M2, M3, Mrat, oM3
      DOUBLE PRECISION:: N0_r, lam_exp, lamr, slam1, slam2
      DOUBLE PRECISION:: dvs, dvr, masss, massr
      DOUBLE PRECISION:: t1, t2, t3, t4, z1, z2, z3, z4
      DOUBLE PRECISION:: y1, y2, y3, y4

!+---+

      do n2 = 1, nbr
!        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2))
         vr(n2) = -0.1021 + 4.932E3*Dr(n2) - 0.9551E6*Dr(n2)*Dr(n2)     &
              + 0.07934E9*Dr(n2)*Dr(n2)*Dr(n2)                          &
              - 0.002362E12*Dr(n2)*Dr(n2)*Dr(n2)*Dr(n2)
         D1(n2) = (vr(n2)/av_s)**(1./bv_s)
      enddo
      do n = 1, nbs
         vs(n) = 1.5*av_s*Ds(n)**bv_s * DEXP(-fv_s*Ds(n))
      enddo

!..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for
!.. fortran indices.  J. Michalakes, 2009Oct30.

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e )
#else
      km_s = 0
      km_e = ntb_r*ntb_r1 - 1
#endif

      do km = km_s, km_e
         m = km / ntb_r1 + 1
         k = mod( km , ntb_r1 ) + 1

         lam_exp = (N0r_exp(k)*am_r*crg(1)/r_r(m))**ore1
         lamr = lam_exp * (crg(3)*org2*org1)**obmr
         N0_r = N0r_exp(k)/(crg(2)*lam_exp) * lamr**cre(2)
         do n2 = 1, nbr
            N_r(n2) = N0_r*Dr(n2)**mu_r * DEXP(-lamr*Dr(n2))*dtr(n2)
         enddo

         do j = 1, ntb_t
            do i = 1, ntb_s

!..From the bm_s moment, compute plus one moment.  If we are not
!.. using bm_s=2, then we must transform to the pure 2nd moment
!.. (variable called "second") and then to the bm_s+1 moment.

               M2 = r_s(i)*oams *1.0d0
               if (bm_s.gt.2.0-1.E-3 .and. bm_s.lt.2.0+1.E-3) then
                  loga_ = sa(1) + sa(2)*Tc(j) + sa(3)*bm_s &
                     + sa(4)*Tc(j)*bm_s + sa(5)*Tc(j)*Tc(j) &
                     + sa(6)*bm_s*bm_s + sa(7)*Tc(j)*Tc(j)*bm_s &
                     + sa(8)*Tc(j)*bm_s*bm_s + sa(9)*Tc(j)*Tc(j)*Tc(j) &
                     + sa(10)*bm_s*bm_s*bm_s
                  a_ = 10.0**loga_
                  b_ = sb(1) + sb(2)*Tc(j) + sb(3)*bm_s &
                     + sb(4)*Tc(j)*bm_s + sb(5)*Tc(j)*Tc(j) &
                     + sb(6)*bm_s*bm_s + sb(7)*Tc(j)*Tc(j)*bm_s &
                     + sb(8)*Tc(j)*bm_s*bm_s + sb(9)*Tc(j)*Tc(j)*Tc(j) &
                     + sb(10)*bm_s*bm_s*bm_s
                  second = (M2/a_)**(1./b_)
               else
                  second = M2
               endif

               loga_ = sa(1) + sa(2)*Tc(j) + sa(3)*cse(1) &
                  + sa(4)*Tc(j)*cse(1) + sa(5)*Tc(j)*Tc(j) &
                  + sa(6)*cse(1)*cse(1) + sa(7)*Tc(j)*Tc(j)*cse(1) &
                  + sa(8)*Tc(j)*cse(1)*cse(1) + sa(9)*Tc(j)*Tc(j)*Tc(j) &
                  + sa(10)*cse(1)*cse(1)*cse(1)
               a_ = 10.0**loga_
               b_ = sb(1)+sb(2)*Tc(j)+sb(3)*cse(1) + sb(4)*Tc(j)*cse(1) &
                  + sb(5)*Tc(j)*Tc(j) + sb(6)*cse(1)*cse(1) &
                  + sb(7)*Tc(j)*Tc(j)*cse(1) + sb(8)*Tc(j)*cse(1)*cse(1) &
                  + sb(9)*Tc(j)*Tc(j)*Tc(j)+sb(10)*cse(1)*cse(1)*cse(1)
               M3 = a_ * second**b_

               oM3 = 1./M3
               Mrat = M2*(M2*oM3)*(M2*oM3)*(M2*oM3)
               M0   = (M2*oM3)**mu_s
               slam1 = M2 * oM3 * Lam0
               slam2 = M2 * oM3 * Lam1

               do n = 1, nbs
                  N_s(n) = Mrat*(Kap0*DEXP(-slam1*Ds(n)) &
                      + Kap1*M0*Ds(n)**mu_s * DEXP(-slam2*Ds(n)))*dts(n)
               enddo

               t1 = 0.0d0
               t2 = 0.0d0
               t3 = 0.0d0
               t4 = 0.0d0
               z1 = 0.0d0
               z2 = 0.0d0
               z3 = 0.0d0
               z4 = 0.0d0
               y1 = 0.0d0
               y2 = 0.0d0
               y3 = 0.0d0
               y4 = 0.0d0
               do n2 = 1, nbr
                  massr = am_r * Dr(n2)**bm_r
                  do n = 1, nbs
                     masss = am_s * Ds(n)**bm_s
      
                     dvs = 0.5d0*((vr(n2) - vs(n)) + DABS(vr(n2)-vs(n)))
                     dvr = 0.5d0*((vs(n) - vr(n2)) + DABS(vs(n)-vr(n2)))

                     if (massr .gt. 1.5*masss) then
                     t1 = t1+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*masss * N_s(n)* N_r(n2)
                     z1 = z1+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*massr * N_s(n)* N_r(n2)
                     y1 = y1+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs       * N_s(n)* N_r(n2)
                     else
                     t3 = t3+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*masss * N_s(n)* N_r(n2)
                     z3 = z3+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*massr * N_s(n)* N_r(n2)
                     y3 = y3+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs       * N_s(n)* N_r(n2)
                     endif

                     if (massr .gt. 1.5*masss) then
                     t2 = t2+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*massr * N_s(n)* N_r(n2)
                     y2 = y2+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr       * N_s(n)* N_r(n2)
                     z2 = z2+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*masss * N_s(n)* N_r(n2)
                     else
                     t4 = t4+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*massr * N_s(n)* N_r(n2)
                     y4 = y4+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr       * N_s(n)* N_r(n2)
                     z4 = z4+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*masss * N_s(n)* N_r(n2)
                     endif

                  enddo
               enddo
               tcs_racs1(i,j,k,m) = t1
               tmr_racs1(i,j,k,m) = DMIN1(z1, r_r(m)*1.0d0)
               tcs_racs2(i,j,k,m) = t3
               tmr_racs2(i,j,k,m) = z3
               tcr_sacr1(i,j,k,m) = t2
               tms_sacr1(i,j,k,m) = z2
               tcr_sacr2(i,j,k,m) = t4
               tms_sacr2(i,j,k,m) = z4
               tnr_racs1(i,j,k,m) = y1
               tnr_racs2(i,j,k,m) = y3
               tnr_sacr1(i,j,k,m) = y2
               tnr_sacr2(i,j,k,m) = y4
            enddo
         enddo
      enddo

!..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30).

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_gatherv(tcs_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcs_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tms_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tms_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
#endif


      end subroutine qr_acr_qs
!+---+-----------------------------------------------------------------+
!
!+---+-----------------------------------------------------------------+
!..This is a literal adaptation of Bigg (1954) probability of drops of
!..a particular volume freezing.  Given this probability, simply freeze
!..the proportion of drops summing their masses.
!+---+-----------------------------------------------------------------+

      subroutine freezeH2O

      implicit none

!..Local variables
      INTEGER:: i, j, k, n, n2
      DOUBLE PRECISION, DIMENSION(nbr):: N_r, massr
      DOUBLE PRECISION, DIMENSION(nbc):: N_c, massc
      DOUBLE PRECISION:: sum1, sum2, sumn1, sumn2, &
                         prob, vol, Texp, orho_w, &
                         lam_exp, lamr, N0_r, lamc, N0_c, y

!+---+

      orho_w = 1./rho_w

      do n2 = 1, nbr
         massr(n2) = am_r*Dr(n2)**bm_r
      enddo
      do n = 1, nbc
         massc(n) = am_r*Dc(n)**bm_r
      enddo

!..Freeze water (smallest drops become cloud ice, otherwise graupel).
      do k = 1, 45
!         print*, ' Freezing water for temp = ', -k
         Texp = DEXP( DFLOAT(k) ) - 1.0D0
         do j = 1, ntb_r1
            do i = 1, ntb_r
               lam_exp = (N0r_exp(j)*am_r*crg(1)/r_r(i))**ore1
               lamr = lam_exp * (crg(3)*org2*org1)**obmr
               N0_r = N0r_exp(j)/(crg(2)*lam_exp) * lamr**cre(2)
               sum1 = 0.0d0
               sum2 = 0.0d0
               sumn1 = 0.0d0
               sumn2 = 0.0d0
               do n2 = nbr, 1, -1
                  N_r(n2) = N0_r*Dr(n2)**mu_r*DEXP(-lamr*Dr(n2))*dtr(n2)
                  vol = massr(n2)*orho_w
                  prob = 1.0D0 - DEXP(-120.0D0*vol*5.2D-4 * Texp)
                  if (massr(n2) .lt. xm0g) then
                     sumn1 = sumn1 + prob*N_r(n2)
                     sum1 = sum1 + prob*N_r(n2)*massr(n2)
                  else
                     sumn2 = sumn2 + prob*N_r(n2)
                     sum2 = sum2 + prob*N_r(n2)*massr(n2)
                  endif
                  if ((sum1+sum2) .ge. r_r(i)) EXIT
               enddo
               tpi_qrfz(i,j,k) = sum1
               tni_qrfz(i,j,k) = sumn1
               tpg_qrfz(i,j,k) = sum2
               tnr_qrfz(i,j,k) = sumn2
            enddo
         enddo
         do i = 1, ntb_c
            lamc = 1.0D-6 * (Nt_c*am_r* ccg(2) * ocg1 / r_c(i))**obmr
            N0_c = 1.0D-18 * Nt_c*ocg1 * lamc**cce(1)
            sum1 = 0.0d0
            sumn2 = 0.0d0
            do n = nbc, 1, -1
               y = Dc(n)*1.0D6
               vol = massc(n)*orho_w
               prob = 1.0D0 - DEXP(-120.0D0*vol*5.2D-4 * Texp)
               N_c(n) = N0_c* y**mu_c * EXP(-lamc*y)*dtc(n)
               N_c(n) = 1.0D24 * N_c(n)
               sumn2 = sumn2 + prob*N_c(n)
               sum1 = sum1 + prob*N_c(n)*massc(n)
               if (sum1 .ge. r_c(i)) EXIT
            enddo
            tpi_qcfz(i,k) = sum1
            tni_qcfz(i,k) = sumn2
         enddo
      enddo

      end subroutine freezeH2O
!+---+-----------------------------------------------------------------+
!
!+---+-----------------------------------------------------------------+
!..Cloud ice converting to snow since portion greater than min snow
!.. size.  Given cloud ice content (kg/m**3), number concentration
!.. (#/m**3) and gamma shape parameter, mu_i, break the distrib into
!.. bins and figure out the mass/number of ice with sizes larger than
!.. D0s.  Also, compute incomplete gamma function for the integration
!.. of ice depositional growth from diameter=0 to D0s.  Amount of
!.. ice depositional growth is this portion of distrib while larger
!.. diameters contribute to snow growth (as in Harrington et al. 1995).
!+---+-----------------------------------------------------------------+

      subroutine qi_aut_qs

      implicit none

!..Local variables
      INTEGER:: i, j, n2
      DOUBLE PRECISION, DIMENSION(nbi):: N_i
      DOUBLE PRECISION:: N0_i, lami, Di_mean, t1, t2
      REAL:: xlimit_intg

!+---+

      do j = 1, ntb_i1
         do i = 1, ntb_i
            lami = (am_i*cig(2)*oig1*Nt_i(j)/r_i(i))**obmi
            Di_mean = (bm_i + mu_i + 1.) / lami
            N0_i = Nt_i(j)*oig1 * lami**cie(1)
            t1 = 0.0d0
            t2 = 0.0d0
            if (SNGL(Di_mean) .gt. 5.*D0s) then
             t1 = r_i(i)
             t2 = Nt_i(j)
             tpi_ide(i,j) = 0.0D0
            elseif (SNGL(Di_mean) .lt. D0i) then
             t1 = 0.0D0
             t2 = 0.0D0
             tpi_ide(i,j) = 1.0D0
            else
             xlimit_intg = lami*D0s
             tpi_ide(i,j) = GAMMP(mu_i+2.0, xlimit_intg) * 1.0D0
             do n2 = 1, nbi
               N_i(n2) = N0_i*Di(n2)**mu_i * DEXP(-lami*Di(n2))*dti(n2)
               if (Di(n2).ge.D0s) then
                  t1 = t1 + N_i(n2) * am_i*Di(n2)**bm_i
                  t2 = t2 + N_i(n2)
               endif
             enddo
            endif
            tps_iaus(i,j) = t1
            tni_iaus(i,j) = t2
         enddo
      enddo

      end subroutine qi_aut_qs
!
!+---+-----------------------------------------------------------------+
!..Variable collision efficiency for rain collecting cloud water using
!.. method of Beard and Grover, 1974 if a/A less than 0.25; otherwise
!.. uses polynomials to get close match of Pruppacher & Klett Fig 14-9.
!+---+-----------------------------------------------------------------+

      subroutine table_Efrw

      implicit none

!..Local variables
      DOUBLE PRECISION:: vtr, stokes, reynolds, Ef_rw
      DOUBLE PRECISION:: p, yc0, F, G, H, z, K0, X
      INTEGER:: i, j

      do j = 1, nbc
      do i = 1, nbr
         Ef_rw = 0.0
         p = Dc(j)/Dr(i)
         if (Dr(i).lt.50.E-6 .or. Dc(j).lt.3.E-6) then
          t_Efrw(i,j) = 0.0
         elseif (p.gt.0.25) then
          X = Dc(j)*1.D6
          if (Dr(i) .lt. 75.e-6) then
             Ef_rw = 0.026794*X - 0.20604
          elseif (Dr(i) .lt. 125.e-6) then
             Ef_rw = -0.00066842*X*X + 0.061542*X - 0.37089
          elseif (Dr(i) .lt. 175.e-6) then
             Ef_rw = 4.091e-06*X*X*X*X - 0.00030908*X*X*X               &
                   + 0.0066237*X*X - 0.0013687*X - 0.073022
          elseif (Dr(i) .lt. 250.e-6) then
             Ef_rw = 9.6719e-5*X*X*X - 0.0068901*X*X + 0.17305*X        &
                   - 0.65988
          elseif (Dr(i) .lt. 350.e-6) then
             Ef_rw = 9.0488e-5*X*X*X - 0.006585*X*X + 0.16606*X         &
                   - 0.56125
          else
             Ef_rw = 0.00010721*X*X*X - 0.0072962*X*X + 0.1704*X        &
                   - 0.46929
          endif
         else
          vtr = -0.1021 + 4.932E3*Dr(i) - 0.9551E6*Dr(i)*Dr(i) &
              + 0.07934E9*Dr(i)*Dr(i)*Dr(i) &
              - 0.002362E12*Dr(i)*Dr(i)*Dr(i)*Dr(i)
          stokes = Dc(j)*Dc(j)*vtr*rho_w/(9.*1.718E-5*Dr(i))
          reynolds = 9.*stokes/(p*p*rho_w)

          F = DLOG(reynolds)
          G = -0.1007D0 - 0.358D0*F + 0.0261D0*F*F
          K0 = DEXP(G)
          z = DLOG(stokes/(K0+1.D-15))
          H = 0.1465D0 + 1.302D0*z - 0.607D0*z*z + 0.293D0*z*z*z
          yc0 = 2.0D0/PI * ATAN(H)
          Ef_rw = (yc0+p)*(yc0+p) / ((1.+p)*(1.+p))

         endif

         t_Efrw(i,j) = MAX(0.0, MIN(SNGL(Ef_rw), 0.95))

      enddo
      enddo

      end subroutine table_Efrw
!
!+---+-----------------------------------------------------------------+
!..Variable collision efficiency for snow collecting cloud water using
!.. method of Wang and Ji, 2000 except equate melted snow diameter to
!.. their "effective collision cross-section."
!+---+-----------------------------------------------------------------+

      subroutine table_Efsw

      implicit none

!..Local variables
      DOUBLE PRECISION:: Ds_m, vts, vtc, stokes, reynolds, Ef_sw
      DOUBLE PRECISION:: p, yc0, F, G, H, z, K0
      INTEGER:: i, j

      do j = 1, nbc
      vtc = 1.19D4 * (1.0D4*Dc(j)*Dc(j)*0.25D0)
      do i = 1, nbs
         vts = av_s*Ds(i)**bv_s * DEXP(-fv_s*Ds(i)) - vtc
         Ds_m = (am_s*Ds(i)**bm_s / am_r)**obmr
         p = Dc(j)/Ds_m
         if (p.gt.0.25 .or. Ds(i).lt.D0s .or. Dc(j).lt.6.E-6 &
               .or. vts.lt.1.E-3) then
          t_Efsw(i,j) = 0.0
         else
          stokes = Dc(j)*Dc(j)*vts*rho_w/(9.*1.718E-5*Ds_m)
          reynolds = 9.*stokes/(p*p*rho_w)

          F = DLOG(reynolds)
          G = -0.1007D0 - 0.358D0*F + 0.0261D0*F*F
          K0 = DEXP(G)
          z = DLOG(stokes/(K0+1.D-15))
          H = 0.1465D0 + 1.302D0*z - 0.607D0*z*z + 0.293D0*z*z*z
          yc0 = 2.0D0/PI * ATAN(H)
          Ef_sw = (yc0+p)*(yc0+p) / ((1.+p)*(1.+p))

          t_Efsw(i,j) = MAX(0.0, MIN(SNGL(Ef_sw), 0.95))
         endif

      enddo
      enddo

      end subroutine table_Efsw
!
!+---+-----------------------------------------------------------------+
!..Integrate rain size distribution from zero to D-star to compute the
!.. number of drops smaller than D-star that evaporate in a single
!.. timestep.  Drops larger than D-star dont evaporate entirely so do
!.. not affect number concentration.
!+---+-----------------------------------------------------------------+

      subroutine table_dropEvap

      implicit none

!..Local variables
      DOUBLE PRECISION:: Nt_r, N0, lam_exp, lam
      REAL:: xlimit_intg
      INTEGER:: i, j, k

      do k = 1, ntb_r
      do j = 1, ntb_r1
         lam_exp = (N0r_exp(j)*am_r*crg(1)/r_r(k))**ore1
         lam = lam_exp * (crg(3)*org2*org1)**obmr
         N0 = N0r_exp(j)/(crg(2)*lam_exp) * lam**cre(2)
         Nt_r = N0 * crg(2) / lam**cre(2)

         do i = 1, nbr
            xlimit_intg = lam*Dr(i)
            tnr_rev(i,j,k) = GAMMP(mu_r+1.0, xlimit_intg) * Nt_r
         enddo

      enddo
      enddo

      end subroutine table_dropEvap

! TO APPLY TABLE ABOVE
!..Rain lookup table indexes.
!         Dr_star = DSQRT(-2.D0*DT * t1_evap/(2.*PI) &
!                 * 0.78*4.*diffu(k)*xsat*rvs/rho_w)
!         idx_d = NINT(1.0 + FLOAT(nbr) * DLOG(Dr_star/D0r)             &
!               / DLOG(Dr(nbr)/D0r))
!         idx_d = MAX(1, MIN(idx_d, nbr))
!
!         nir = NINT(ALOG10(rr(k)))
!         do nn = nir-1, nir+1
!            n = nn
!            if ( (rr(k)/10.**nn).ge.1.0 .and. &
!                 (rr(k)/10.**nn).lt.10.0) goto 154
!         enddo
!154      continue
!         idx_r = INT(rr(k)/10.**n) + 10*(n-nir2) - (n-nir2)
!         idx_r = MAX(1, MIN(idx_r, ntb_r))
!
!         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
!         lam_exp = lamr * (crg(3)*org2*org1)**bm_r
!         N0_exp = org1*rr(k)/am_r * lam_exp**cre(1)
!         nir = NINT(DLOG10(N0_exp))
!         do nn = nir-1, nir+1
!            n = nn
!            if ( (N0_exp/10.**nn).ge.1.0 .and. &
!                 (N0_exp/10.**nn).lt.10.0) goto 155
!         enddo
!155      continue
!         idx_r1 = INT(N0_exp/10.**n) + 10*(n-nir3) - (n-nir3)
!         idx_r1 = MAX(1, MIN(idx_r1, ntb_r1))
!
!         pnr_rev(k) = MIN(nr(k)*odts, SNGL(tnr_rev(idx_d,idx_r1,idx_r) &   ! RAIN2M
!                    * odts))
!
!
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
      SUBROUTINE GCF(GAMMCF,A,X,GLN)
!     --- RETURNS THE INCOMPLETE GAMMA FUNCTION Q(A,X) EVALUATED BY ITS
!     --- CONTINUED FRACTION REPRESENTATION AS GAMMCF.  ALSO RETURNS
!     --- LN(GAMMA(A)) AS GLN.  THE CONTINUED FRACTION IS EVALUATED BY
!     --- A MODIFIED LENTZ METHOD.
!     --- USES GAMMLN
      IMPLICIT NONE
      INTEGER, PARAMETER:: ITMAX=100
      REAL, PARAMETER:: gEPS=3.E-7
      REAL, PARAMETER:: FPMIN=1.E-30
      REAL, INTENT(IN):: A, X
      REAL:: GAMMCF,GLN
      INTEGER:: I
      REAL:: AN,B,C,D,DEL,H
      GLN=GAMMLN(A)
      B=X+1.-A
      C=1./FPMIN
      D=1./B
      H=D
      DO 11 I=1,ITMAX
        AN=-I*(I-A)
        B=B+2.
        D=AN*D+B
        IF(ABS(D).LT.FPMIN)D=FPMIN
        C=B+AN/C
        IF(ABS(C).LT.FPMIN)C=FPMIN
        D=1./D
        DEL=D*C
        H=H*DEL
        IF(ABS(DEL-1.).LT.gEPS)GOTO 1
 11   CONTINUE
      PRINT *, 'A TOO LARGE, ITMAX TOO SMALL IN GCF'
 1    GAMMCF=EXP(-X+A*LOG(X)-GLN)*H
      END SUBROUTINE GCF
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      SUBROUTINE GSER(GAMSER,A,X,GLN)
!     --- RETURNS THE INCOMPLETE GAMMA FUNCTION P(A,X) EVALUATED BY ITS
!     --- ITS SERIES REPRESENTATION AS GAMSER.  ALSO RETURNS LN(GAMMA(A)) 
!     --- AS GLN.
!     --- USES GAMMLN
      IMPLICIT NONE
      INTEGER, PARAMETER:: ITMAX=100
      REAL, PARAMETER:: gEPS=3.E-7
      REAL, INTENT(IN):: A, X
      REAL:: GAMSER,GLN
      INTEGER:: N
      REAL:: AP,DEL,SUM
      GLN=GAMMLN(A)
      IF(X.LE.0.)THEN
        IF(X.LT.0.) PRINT *, 'X < 0 IN GSER'
        GAMSER=0.
        RETURN
      ENDIF
      AP=A
      SUM=1./A
      DEL=SUM
      DO 11 N=1,ITMAX
        AP=AP+1.
        DEL=DEL*X/AP
        SUM=SUM+DEL
        IF(ABS(DEL).LT.ABS(SUM)*gEPS)GOTO 1
 11   CONTINUE
      PRINT *,'A TOO LARGE, ITMAX TOO SMALL IN GSER'
 1    GAMSER=SUM*EXP(-X+A*LOG(X)-GLN)
      END SUBROUTINE GSER
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      REAL FUNCTION GAMMLN(XX)
!     --- RETURNS THE VALUE LN(GAMMA(XX)) FOR XX > 0.
      IMPLICIT NONE
      REAL, INTENT(IN):: XX
      DOUBLE PRECISION, PARAMETER:: STP = 2.5066282746310005D0
      DOUBLE PRECISION, DIMENSION(6), PARAMETER:: &
               COF = (/76.18009172947146D0, -86.50532032941677D0, &
                       24.01409824083091D0, -1.231739572450155D0, &
                      .1208650973866179D-2, -.5395239384953D-5/)
      DOUBLE PRECISION:: SER,TMP,X,Y
      INTEGER:: J

      X=XX
      Y=X
      TMP=X+5.5D0
      TMP=(X+0.5D0)*LOG(TMP)-TMP
      SER=1.000000000190015D0
      DO 11 J=1,6
        Y=Y+1.D0
        SER=SER+COF(J)/Y
11    CONTINUE
      GAMMLN=TMP+LOG(STP*SER/X)
      END FUNCTION GAMMLN
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      REAL FUNCTION GAMMP(A,X)
!     --- COMPUTES THE INCOMPLETE GAMMA FUNCTION P(A,X)
!     --- SEE ABRAMOWITZ AND STEGUN 6.5.1
!     --- USES GCF,GSER
      IMPLICIT NONE
      REAL, INTENT(IN):: A,X
      REAL:: GAMMCF,GAMSER,GLN
      GAMMP = 0.
      IF((X.LT.0.) .OR. (A.LE.0.)) THEN
        PRINT *, 'BAD ARGUMENTS IN GAMMP'
        RETURN
      ELSEIF(X.LT.A+1.)THEN
        CALL GSER(GAMSER,A,X,GLN)
        GAMMP=GAMSER
      ELSE
        CALL GCF(GAMMCF,A,X,GLN)
        GAMMP=1.-GAMMCF
      ENDIF
      END FUNCTION GAMMP
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      REAL FUNCTION WGAMMA(y)

      IMPLICIT NONE
      REAL, INTENT(IN):: y

      WGAMMA = EXP(GAMMLN(y))

      END FUNCTION WGAMMA
!+---+-----------------------------------------------------------------+
! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS
! A FUNCTION OF TEMPERATURE AND PRESSURE
!
      REAL FUNCTION RSLF(P,T)

      IMPLICIT NONE
      REAL, INTENT(IN):: P, T
      REAL:: ESL,X
      REAL, PARAMETER:: C0= .611583699E03
      REAL, PARAMETER:: C1= .444606896E02
      REAL, PARAMETER:: C2= .143177157E01
      REAL, PARAMETER:: C3= .264224321E-1
      REAL, PARAMETER:: C4= .299291081E-3
      REAL, PARAMETER:: C5= .203154182E-5
      REAL, PARAMETER:: C6= .702620698E-8
      REAL, PARAMETER:: C7= .379534310E-11
      REAL, PARAMETER:: C8=-.321582393E-13

!      X=MAX(-80.,T-273.16)
!
!      ESL=612.2*EXP(17.67*X/(T-29.65))
!      ESL=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSLF=.622*ESL/(P-ESL)
      ! GHB:  to be consistent with cm1  (this can be changed back, later)
      ESL=611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
      RSLF=ep_2*ESL/(P-ESL)

!    ALTERNATIVE
!  ; Source: Murphy and Koop, Review of the vapour pressure of ice and
!             supercooled water for atmospheric applications, Q. J. R.
!             Meteorol. Soc (2005), 131, pp. 1539-1565.
!    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T
!        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22
!        / T - 9.44523 * ALOG(T) + 0.014025 * T))

      END FUNCTION RSLF
!+---+-----------------------------------------------------------------+
! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A
! FUNCTION OF TEMPERATURE AND PRESSURE
!
      REAL FUNCTION RSIF(P,T)

      IMPLICIT NONE
      REAL, INTENT(IN):: P, T
      REAL:: ESI,X
      REAL, PARAMETER:: C0= .609868993E03
      REAL, PARAMETER:: C1= .499320233E02
      REAL, PARAMETER:: C2= .184672631E01
      REAL, PARAMETER:: C3= .402737184E-1
      REAL, PARAMETER:: C4= .565392987E-3
      REAL, PARAMETER:: C5= .521693933E-5
      REAL, PARAMETER:: C6= .307839583E-7
      REAL, PARAMETER:: C7= .105785160E-9
      REAL, PARAMETER:: C8= .161444444E-12

!      X=MAX(-80.,T-273.16)
!      ESI=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSIF=.622*ESI/(P-ESI)
      ESI=611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
      RSIF=ep_2*ESI/(P-ESI)

!    ALTERNATIVE
!  ; Source: Murphy and Koop, Review of the vapour pressure of ice and
!             supercooled water for atmospheric applications, Q. J. R.
!             Meteorol. Soc (2005), 131, pp. 1539-1565.
!     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T)

      END FUNCTION RSIF
!+---+-----------------------------------------------------------------+

!+---+-----------------------------------------------------------------+
!..Compute radar reflectivity assuming 10 cm wavelength radar and using
!.. Rayleigh approximation.  Only complication is melted snow/graupel
!.. which we treat as water-coated ice spheres and use Uli Blahak's
!.. library of routines.  The meltwater fraction is simply the amount
!.. of frozen species remaining from what initially existed at the
!.. melting level interface.
!+---+-----------------------------------------------------------------+

      subroutine calc_refl10cm (qv1d, qc1d, qr1d, nr1d, qs1d, qg1d,     &
                          t1d, p1d, rho1d, dBZ, kts, kte, ii, jj)

      IMPLICIT NONE

!..Sub arguments
      INTEGER, INTENT(IN):: kts, kte, ii, jj
      REAL, DIMENSION(kts:kte), INTENT(IN)::                            &
                          qv1d, qc1d, qr1d, nr1d, qs1d, qg1d, t1d, p1d, rho1d
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: dBZ
!     REAL, DIMENSION(kts:kte), INTENT(INOUT):: vt_dBZ

!..Local variables
      REAL, DIMENSION(kts:kte):: temp, pres, qv, rho, rhof
      REAL, DIMENSION(kts:kte):: rc, rr, nr, rs, rg

      DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilamg, N0_r, N0_g
      REAL, DIMENSION(kts:kte):: mvd_r
      REAL, DIMENSION(kts:kte):: smob, smo2, smoc, smoz
      REAL:: oM3, M0, Mrat, slam1, slam2, xDs
      REAL:: ils1, ils2, t1_vts, t2_vts, t3_vts, t4_vts
      REAL:: vtr_dbz_wt, vts_dbz_wt, vtg_dbz_wt

      REAL, DIMENSION(kts:kte):: ze_rain, ze_snow, ze_graupel

      DOUBLE PRECISION:: N0_exp, N0_min, lam_exp, lamr, lamg
      REAL:: a_, b_, loga_, tc0
      DOUBLE PRECISION:: fmelt_s, fmelt_g

      INTEGER:: i, k, k_0, kbot, n
      LOGICAL:: melti
      LOGICAL, DIMENSION(kts:kte):: L_qr, L_qs, L_qg

      DOUBLE PRECISION:: cback, x, eta, f_d
      REAL:: xslw1, ygra1, zans1

!+---+

      do k = kts, kte
         dBZ(k) = -35.0
      enddo

!+---+-----------------------------------------------------------------+
!..Put column of data into local arrays.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k)
         qv(k) = MAX(1.E-10, qv1d(k))
         pres(k) = p1d(k)
!!!         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         rho(k) = rho1d(k)
         rhof(k) = SQRT(RHO_NOT/rho(k))
         rc(k) = MAX(R1, qc1d(k)*rho(k))
         if (qr1d(k) .gt. R1) then
            rr(k) = qr1d(k)*rho(k)
            nr(k) = MAX(R2, nr1d(k)*rho(k))
            lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
            ilamr(k) = 1./lamr
            N0_r(k) = nr(k)*org2*lamr**cre(2)
            mvd_r(k) = (3.0 + mu_r + 0.672) * ilamr(k)
            L_qr(k) = .true.
         else
            rr(k) = R1
            nr(k) = R1
            mvd_r(k) = 50.E-6
            L_qr(k) = .false.
         endif
         if (qs1d(k) .gt. R2) then
            rs(k) = qs1d(k)*rho(k)
            L_qs(k) = .true.
         else
            rs(k) = R1
            L_qs(k) = .false.
         endif
         if (qg1d(k) .gt. R2) then
            rg(k) = qg1d(k)*rho(k)
            L_qg(k) = .true.
         else
            rg(k) = R1
            L_qg(k) = .false.
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope, and useful moments for snow.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         tc0 = MIN(-0.1, temp(k)-273.15)
         smob(k) = rs(k)*oams

!..All other moments based on reference, 2nd moment.  If bm_s.ne.2,
!.. then we must compute actual 2nd moment and use as reference.
         if (bm_s.gt.(2.0-1.e-3) .and. bm_s.lt.(2.0+1.e-3)) then
            smo2(k) = smob(k)
         else
            loga_ = sa(1) + sa(2)*tc0 + sa(3)*bm_s &
               + sa(4)*tc0*bm_s + sa(5)*tc0*tc0 &
               + sa(6)*bm_s*bm_s + sa(7)*tc0*tc0*bm_s &
               + sa(8)*tc0*bm_s*bm_s + sa(9)*tc0*tc0*tc0 &
               + sa(10)*bm_s*bm_s*bm_s
            a_ = 10.0**loga_
            b_ = sb(1) + sb(2)*tc0 + sb(3)*bm_s &
               + sb(4)*tc0*bm_s + sb(5)*tc0*tc0 &
               + sb(6)*bm_s*bm_s + sb(7)*tc0*tc0*bm_s &
               + sb(8)*tc0*bm_s*bm_s + sb(9)*tc0*tc0*tc0 &
               + sb(10)*bm_s*bm_s*bm_s
            smo2(k) = (smob(k)/a_)**(1./b_)
         endif

!..Calculate bm_s+1 (th) moment.  Useful for diameter calcs.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(1) &
               + sa(4)*tc0*cse(1) + sa(5)*tc0*tc0 &
               + sa(6)*cse(1)*cse(1) + sa(7)*tc0*tc0*cse(1) &
               + sa(8)*tc0*cse(1)*cse(1) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(1)*cse(1)*cse(1)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(1) + sb(4)*tc0*cse(1) &
              + sb(5)*tc0*tc0 + sb(6)*cse(1)*cse(1) &
              + sb(7)*tc0*tc0*cse(1) + sb(8)*tc0*cse(1)*cse(1) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(1)*cse(1)*cse(1)
         smoc(k) = a_ * smo2(k)**b_

!..Calculate bm_s*2 (th) moment.  Useful for reflectivity.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(3) &
               + sa(4)*tc0*cse(3) + sa(5)*tc0*tc0 &
               + sa(6)*cse(3)*cse(3) + sa(7)*tc0*tc0*cse(3) &
               + sa(8)*tc0*cse(3)*cse(3) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(3)*cse(3)*cse(3)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(3) + sb(4)*tc0*cse(3) &
              + sb(5)*tc0*tc0 + sb(6)*cse(3)*cse(3) &
              + sb(7)*tc0*tc0*cse(3) + sb(8)*tc0*cse(3)*cse(3) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(3)*cse(3)*cse(3)
         smoz(k) = a_ * smo2(k)**b_
      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+

      N0_min = gonv_max
      do k = kte, kts, -1
         if (temp(k).lt.270.65 .and. L_qr(k) .and. mvd_r(k).gt.100.E-6) then
            xslw1 = 4.01 + alog10(mvd_r(k))
         else
            xslw1 = 0.01
         endif
         ygra1 = 4.31 + alog10(max(5.E-5, rg(k)))
         zans1 = 3.1 + (100./(300.*xslw1*ygra1/(10./xslw1+1.+0.25*ygra1)+30.+10.*ygra1))
         N0_exp = 10.**(zans1)
         N0_exp = MAX(DBLE(gonv_min), MIN(N0_exp, DBLE(gonv_max)))
         N0_min = MIN(N0_exp, N0_min)
         N0_exp = N0_min
         lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1
         lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
         ilamg(k) = 1./lamg
         N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2)
      enddo

!+---+-----------------------------------------------------------------+
!..Locate K-level of start of melting (k_0 is level above).
!+---+-----------------------------------------------------------------+
      melti = .false.
      k_0 = kts
      do k = kte-1, kts, -1
         if ( (temp(k).gt.273.15) .and. L_qr(k)                         &
                                  .and. (L_qs(k+1).or.L_qg(k+1)) ) then
            k_0 = MAX(k+1, k_0)
            melti=.true.
            goto 195
         endif
      enddo
 195  continue

!+---+-----------------------------------------------------------------+
!..Assume Rayleigh approximation at 10 cm wavelength. Rain (all temps)
!.. and non-water-coated snow and graupel when below freezing are
!.. simple. Integrations of m(D)*m(D)*N(D)*dD.
!+---+-----------------------------------------------------------------+

      do k = kts, kte
         ze_rain(k) = 1.e-22
         ze_snow(k) = 1.e-22
         ze_graupel(k) = 1.e-22
         if (L_qr(k)) ze_rain(k) = N0_r(k)*crg(4)*ilamr(k)**cre(4)
         if (L_qs(k)) ze_snow(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)     &
                                 * (am_s/900.0)*(am_s/900.0)*smoz(k)
         if (L_qg(k)) ze_graupel(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)  &
                                    * (am_g/900.0)*(am_g/900.0)         &
                                    * N0_g(k)*cgg(4)*ilamg(k)**cge(4)
      enddo

!+---+-----------------------------------------------------------------+
!..Special case of melting ice (snow/graupel) particles.  Assume the
!.. ice is surrounded by the liquid water.  Fraction of meltwater is
!.. extremely simple based on amount found above the melting level.
!.. Uses code from Uli Blahak (rayleigh_soak_wetgraupel and supporting
!.. routines).
!+---+-----------------------------------------------------------------+

      if (.not. iiwarm .and. melti .and. k_0.ge.2) then
       do k = k_0-1, kts, -1

!..Reflectivity contributed by melting snow
          if (L_qs(k) .and. L_qs(k_0) ) then
           fmelt_s = MAX(0.05d0, MIN(1.0d0-rs(k)/rs(k_0), 0.99d0))
           eta = 0.d0
           oM3 = 1./smoc(k)
           M0 = (smob(k)*oM3)
           Mrat = smob(k)*M0*M0*M0
           slam1 = M0 * Lam0
           slam2 = M0 * Lam1
           do n = 1, nrbins
              x = am_s * xxDs(n)**bm_s
              call rayleigh_soak_wetgraupel (x, DBLE(ocms), DBLE(obms), &
                    fmelt_s, melt_outside_s, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_s, matrixstring_s,          &
                    inclusionstring_s, hoststring_s,                    &
                    hostmatrixstring_s, hostinclusionstring_s)
              f_d = Mrat*(Kap0*DEXP(-slam1*xxDs(n))                     &
                    + Kap1*(M0*xxDs(n))**mu_s * DEXP(-slam2*xxDs(n)))
              eta = eta + f_d * CBACK * simpson(n) * xdts(n)
           enddo
           ze_snow(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif

!..Reflectivity contributed by melting graupel

          if (L_qg(k) .and. L_qg(k_0) ) then
           fmelt_g = MAX(0.05d0, MIN(1.0d0-rg(k)/rg(k_0), 0.99d0))
           eta = 0.d0
           lamg = 1./ilamg(k)
           do n = 1, nrbins
              x = am_g * xxDg(n)**bm_g
              call rayleigh_soak_wetgraupel (x, DBLE(ocmg), DBLE(obmg), &
                    fmelt_g, melt_outside_g, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_g, matrixstring_g,          &
                    inclusionstring_g, hoststring_g,                    &
                    hostmatrixstring_g, hostinclusionstring_g)
              f_d = N0_g(k)*xxDg(n)**mu_g * DEXP(-lamg*xxDg(n))
              eta = eta + f_d * CBACK * simpson(n) * xdtg(n)
           enddo
           ze_graupel(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif

       enddo
      endif

      do k = kte, kts, -1
         dBZ(k) = 10.*log10((ze_rain(k)+ze_snow(k)+ze_graupel(k))*1.d18)
      enddo


!..Reflectivity-weighted terminal velocity (snow, rain, graupel, mix).
!     do k = kte, kts, -1
!        vt_dBZ(k) = 1.E-3
!        if (rs(k).gt.R2) then
!         Mrat = smob(k) / smoc(k)
!         ils1 = 1./(Mrat*Lam0 + fv_s)
!         ils2 = 1./(Mrat*Lam1 + fv_s)
!         t1_vts = Kap0*csg(5)*ils1**cse(5)
!         t2_vts = Kap1*Mrat**mu_s*csg(11)*ils2**cse(11)
!         ils1 = 1./(Mrat*Lam0)
!         ils2 = 1./(Mrat*Lam1)
!         t3_vts = Kap0*csg(6)*ils1**cse(6)
!         t4_vts = Kap1*Mrat**mu_s*csg(12)*ils2**cse(12)
!         vts_dbz_wt = rhof(k)*av_s * (t1_vts+t2_vts)/(t3_vts+t4_vts)
!         if (temp(k).ge.273.15 .and. temp(k).lt.275.15) then
!            vts_dbz_wt = vts_dbz_wt*1.5
!         elseif (temp(k).ge.275.15) then
!            vts_dbz_wt = vts_dbz_wt*2.0
!         endif
!        else
!         vts_dbz_wt = 1.E-3
!        endif

!        if (rr(k).gt.R1) then
!         lamr = 1./ilamr(k)
!         vtr_dbz_wt = rhof(k)*av_r*crg(13)*(lamr+fv_r)**(-cre(13))      &
!                    / (crg(4)*lamr**(-cre(4)))
!        else
!         vtr_dbz_wt = 1.E-3
!        endif

!        if (rg(k).gt.R2) then
!         lamg = 1./ilamg(k)
!         vtg_dbz_wt = rhof(k)*av_g*cgg(5)*lamg**(-cge(5))               &
!                    / (cgg(4)*lamg**(-cge(4)))
!        else
!         vtg_dbz_wt = 1.E-3
!        endif

!        vt_dBZ(k) = (vts_dbz_wt*ze_snow(k) + vtr_dbz_wt*ze_rain(k)      &
!                     + vtg_dbz_wt*ze_graupel(k))                        &
!                     / (ze_rain(k)+ze_snow(k)+ze_graupel(k))
!     enddo

      end subroutine calc_refl10cm

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!..This set of routines facilitates computing radar reflectivity.
!.. This module is more library code whereas the individual microphysics
!.. schemes contains specific details needed for the final computation,
!.. so refer to location within each schemes calling the routine named
!.. rayleigh_soak_wetgraupel.
!.. The bulk of this code originated from Ulrich Blahak (Germany) and
!.. was adapted to WRF by G. Thompson.  This version of code is only
!.. intended for use when Rayleigh scattering principles dominate and
!.. is not intended for wavelengths in which Mie scattering is a
!.. significant portion.  Therefore, it is well-suited to use with
!.. 5 or 10 cm wavelength like USA NEXRAD radars.
!.. This code makes some rather simple assumptions about water
!.. coating on outside of frozen species (snow/graupel).  Fraction of
!.. meltwater is simply the ratio of mixing ratio below melting level
!.. divided by mixing ratio at level just above highest T>0C.  Also,
!.. immediately 90% of the melted water exists on the ice's surface
!.. and 10% is embedded within ice.  No water is "shed" at all in these
!.. assumptions. The code is quite slow because it does the reflectivity
!.. calculations based on 50 individual size bins of the distributions.
!+---+-----------------------------------------------------------------+

!!!MODULE module_mp_radar

!!!      USE module_wrf_error


!!!CONTAINS

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      subroutine radar_init

      IMPLICIT NONE
      INTEGER:: n
      PI5 = 3.14159*3.14159*3.14159*3.14159*3.14159
      lamda4 = lamda_radar*lamda_radar*lamda_radar*lamda_radar
      m_w_0 = m_complex_water_ray (lamda_radar, 0.0d0)
      m_i_0 = m_complex_ice_maetzler (lamda_radar, 0.0d0)
      K_w = (ABS( (m_w_0*m_w_0 - 1.0) /(m_w_0*m_w_0 + 2.0) ))**2

      do n = 1, nrbins+1
         simpson(n) = 0.0d0
      enddo
      do n = 1, nrbins-1, 2
         simpson(n) = simpson(n) + basis(1)
         simpson(n+1) = simpson(n+1) + basis(2)
         simpson(n+2) = simpson(n+2) + basis(3)
      enddo

      do n = 1, slen
         mixingrulestring_s(n:n) = char(0)
         matrixstring_s(n:n) = char(0)
         inclusionstring_s(n:n) = char(0)
         hoststring_s(n:n) = char(0)
         hostmatrixstring_s(n:n) = char(0)
         hostinclusionstring_s(n:n) = char(0)
         mixingrulestring_g(n:n) = char(0)
         matrixstring_g(n:n) = char(0)
         inclusionstring_g(n:n) = char(0)
         hoststring_g(n:n) = char(0)
         hostmatrixstring_g(n:n) = char(0)
         hostinclusionstring_g(n:n) = char(0)
      enddo

      mixingrulestring_s = 'maxwellgarnett'
      hoststring_s = 'air'
      matrixstring_s = 'water'
      inclusionstring_s = 'spheroidal'
      hostmatrixstring_s = 'icewater'
      hostinclusionstring_s = 'spheroidal'

      mixingrulestring_g = 'maxwellgarnett'
      hoststring_g = 'air'
      matrixstring_g = 'water'
      inclusionstring_g = 'spheroidal'
      hostmatrixstring_g = 'icewater'
      hostinclusionstring_g = 'spheroidal'

!..Create bins of snow (from 100 microns up to 2 cm).
      xxDx(1) = 100.D-6
      xxDx(nrbins+1) = 0.02d0
      do n = 2, nrbins
         xxDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nrbins) &
                  *DLOG(xxDx(nrbins+1)/xxDx(1)) +DLOG(xxDx(1)))
      enddo
      do n = 1, nrbins
         xxDs(n) = DSQRT(xxDx(n)*xxDx(n+1))
         xdts(n) = xxDx(n+1) - xxDx(n)
      enddo

!..Create bins of graupel (from 100 microns up to 5 cm).
      xxDx(1) = 100.D-6
      xxDx(nrbins+1) = 0.05d0
      do n = 2, nrbins
         xxDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nrbins) &
                  *DLOG(xxDx(nrbins+1)/xxDx(1)) +DLOG(xxDx(1)))
      enddo
      do n = 1, nrbins
         xxDg(n) = DSQRT(xxDx(n)*xxDx(n+1))
         xdtg(n) = xxDx(n+1) - xxDx(n)
      enddo


!..The calling program must set the m(D) relations and gamma shape
!.. parameter mu for rain, snow, and graupel.  Easily add other types
!.. based on the template here.  For majority of schemes with simpler
!.. exponential number distribution, mu=0.

      xcre(1) = 1. + xbm_r
      xcre(2) = 1. + xmu_r
      xcre(3) = 1. + xbm_r + xmu_r
      xcre(4) = 1. + 2.*xbm_r + xmu_r
      do n = 1, 4
         xcrg(n) = WGAMMA(xcre(n))
      enddo
      xorg2 = 1./xcrg(2)

      xcse(1) = 1. + xbm_s
      xcse(2) = 1. + xmu_s
      xcse(3) = 1. + xbm_s + xmu_s
      xcse(4) = 1. + 2.*xbm_s + xmu_s
      do n = 1, 4
         xcsg(n) = WGAMMA(xcse(n))
      enddo
      xosg2 = 1./xcsg(2)

      xcge(1) = 1. + xbm_g
      xcge(2) = 1. + xmu_g
      xcge(3) = 1. + xbm_g + xmu_g
      xcge(4) = 1. + 2.*xbm_g + xmu_g
      do n = 1, 4
         xcgg(n) = WGAMMA(xcge(n))
      enddo
      xogg2 = 1./xcgg(2)

      xobmr = 1./xbm_r
      xoams = 1./xam_s
      xobms = 1./xbm_s
      xocms = xoams**xobms
      xoamg = 1./xam_g
      xobmg = 1./xbm_g
      xocmg = xoamg**xobmg


      end subroutine radar_init

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_water_ray(lambda,T)

!      Complex refractive Index of Water as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.001,1.0] m; T in [-10.0,30.0] deg C
!      after Ray (1972)

      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: epsinf,epss,epsr,epsi
      DOUBLE PRECISION:: alpha,lambdas,sigma,nenner
      COMPLEX*16, PARAMETER:: i = (0d0,1d0)
      DOUBLE PRECISION, PARAMETER:: PIx=3.1415926535897932384626434d0

      epsinf  = 5.27137d0 + 0.02164740d0 * T - 0.00131198d0 * T*T
      epss    = 78.54d+0 * (1.0 - 4.579d-3 * (T - 25.0)                 &
              + 1.190d-5 * (T - 25.0)*(T - 25.0)                        &
              - 2.800d-8 * (T - 25.0)*(T - 25.0)*(T - 25.0))
      alpha   = -16.8129d0/(T+273.16) + 0.0609265d0
      lambdas = 0.00033836d0 * exp(2513.98d0/(T+273.16)) * 1e-2

      nenner = 1.d0+2.d0*(lambdas/lambda)**(1d0-alpha)*sin(alpha*PIx*0.5) &
             + (lambdas/lambda)**(2d0-2d0*alpha)
      epsr = epsinf + ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)   &
           * sin(alpha*PIx*0.5)+1d0)) / nenner
      epsi = ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)            &
           * cos(alpha*PIx*0.5)+0d0)) / nenner                           &
           + lambda*1.25664/1.88496
      
      m_complex_water_ray = SQRT(CMPLX(epsr,-epsi))
      
      END FUNCTION m_complex_water_ray

!+---+-----------------------------------------------------------------+
      
      COMPLEX*16 FUNCTION m_complex_ice_maetzler(lambda,T)
      
!      complex refractive index of ice as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.0001,30] m; T in [-250.0,0.0] C
!      Original comment from the Matlab-routine of Prof. Maetzler:
!      Function for calculating the relative permittivity of pure ice in
!      the microwave region, according to C. Maetzler, "Microwave
!      properties of ice and snow", in B. Schmitt et al. (eds.) Solar
!      System Ices, Astrophys. and Space Sci. Library, Vol. 227, Kluwer
!      Academic Publishers, Dordrecht, pp. 241-257 (1998). Input:
!      TK = temperature (K), range 20 to 273.15
!      f = frequency in GHz, range 0.01 to 3000
         
      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: f,c,TK,B1,B2,b,deltabeta,betam,beta,theta,alfa

      c = 2.99d8
      TK = T + 273.16
      f = c / lambda * 1d-9

      B1 = 0.0207
      B2 = 1.16d-11
      b = 335.0d0
      deltabeta = EXP(-10.02 + 0.0364*(TK-273.16))
      betam = (B1/TK) * ( EXP(b/TK) / ((EXP(b/TK)-1)**2) ) + B2*f*f
      beta = betam + deltabeta
      theta = 300. / TK - 1.
      alfa = (0.00504d0 + 0.0062d0*theta) * EXP(-22.1d0*theta)
      m_complex_ice_maetzler = 3.1884 + 9.1e-4*(TK-273.16)
      m_complex_ice_maetzler = m_complex_ice_maetzler                   &
                             + CMPLX(0.0d0, (alfa/f + beta*f)) 
      m_complex_ice_maetzler = SQRT(CONJG(m_complex_ice_maetzler))
      
      END FUNCTION m_complex_ice_maetzler

!+---+-----------------------------------------------------------------+

      subroutine rayleigh_soak_wetgraupel (x_g, a_geo, b_geo, fmelt,    &
                     meltratio_outside, m_w, m_i, lambda, C_back,       &
                     mixingrule,matrix,inclusion,                       &
                     host,hostmatrix,hostinclusion)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: x_g, a_geo, b_geo, fmelt, lambda,  &
                                     meltratio_outside
      DOUBLE PRECISION, INTENT(out):: C_back
      COMPLEX*16, INTENT(in):: m_w, m_i
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion,     &
                                     host, hostmatrix, hostinclusion

      COMPLEX*16:: m_core, m_air
      DOUBLE PRECISION:: D_large, D_g, rhog, x_w, xw_a, fm, fmgrenz,    &
                         volg, vg, volair, volice, volwater,            &
                         meltratio_outside_grenz, mra
      INTEGER:: error
      DOUBLE PRECISION, PARAMETER:: PIx=3.1415926535897932384626434d0

!     refractive index of air:
      m_air = (1.0d0,0.0d0)

!     Limiting the degree of melting --- for safety: 
      fm = DMAX1(DMIN1(fmelt, 1.0d0), 0.0d0)
!     Limiting the ratio of (melting on outside)/(melting on inside):
      mra = DMAX1(DMIN1(meltratio_outside, 1.0d0), 0.0d0)

!    ! The relative portion of meltwater melting at outside should increase
!    ! from the given input value (between 0 and 1)
!    ! to 1 as the degree of melting approaches 1,
!    ! so that the melting particle "converges" to a water drop.
!    ! Simplest assumption is linear:
      mra = mra + (1.0d0-mra)*fm

      x_w = x_g * fm

      D_g = a_geo * x_g**b_geo

      if (D_g .ge. 1d-12) then

       vg = PIx/6. * D_g**3
       rhog = DMAX1(DMIN1(x_g / vg, 900.0d0), 10.0d0)
       vg = x_g / rhog
      
       meltratio_outside_grenz = 1.0d0 - rhog / 1000.

       if (mra .le. meltratio_outside_grenz) then
        !..In this case, it cannot happen that, during melting, all the
        !.. air inclusions within the ice particle get filled with
        !.. meltwater. This only happens at the end of all melting.
        volg = vg * (1.0d0 - mra * fm)
 
       else
        !..In this case, at some melting degree fm, all the air
        !.. inclusions get filled with meltwater.
        fmgrenz=(900.0-rhog)/(mra*900.0-rhog+900.0*rhog/1000.)

        if (fm .le. fmgrenz) then
         !.. not all air pockets are filled:
         volg = (1.0 - mra * fm) * vg
        else
         !..all air pockets are filled with meltwater, now the
         !.. entire ice sceleton melts homogeneously:
         volg = (x_g - x_w) / 900.0 + x_w / 1000.
        endif

       endif

       D_large  = (6.0 / PIx * volg) ** (1./3.)
       volice = (x_g - x_w) / (volg * 900.0)
       volwater = x_w / (1000. * volg)
       volair = 1.0 - volice - volwater
      
       !..complex index of refraction for the ice-air-water mixture
       !.. of the particle:
       m_core = get_m_mix_nested (m_air, m_i, m_w, volair, volice,      &
                         volwater, mixingrule, host, matrix, inclusion, &
                         hostmatrix, hostinclusion, error)
       if (error .ne. 0) then
        C_back = 0.0d0
        return
       endif

       !..Rayleigh-backscattering coefficient of melting particle: 
       C_back = (ABS((m_core**2-1.0d0)/(m_core**2+2.0d0)))**2           &
                * PI5 * D_large**6 / lamda4

      else
       C_back = 0.0d0
      endif

      end subroutine rayleigh_soak_wetgraupel

!+---+-----------------------------------------------------------------+

      complex*16 function get_m_mix_nested (m_a, m_i, m_w, volair,      &
                     volice, volwater, mixingrule, host, matrix,        &
                     inclusion, hostmatrix, hostinclusion, cumulerror)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, host, matrix,          &
                     inclusion, hostmatrix, hostinclusion
      INTEGER, INTENT(out):: cumulerror

      DOUBLE PRECISION:: vol1, vol2
      COMPLEX*16:: mtmp
      INTEGER:: error

      !..Folded: ( (m1 + m2) + m3), where m1,m2,m3 could each be
      !.. air, ice, or water

      cumulerror = 0
      get_m_mix_nested = CMPLX(1.0d0,0.0d0)

      if (host .eq. 'air') then

       if (matrix .eq. 'air') then
        write(radar_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, radar_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volice / MAX(volice+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, 0.0d0, vol1, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error
          
        if (hostmatrix .eq. 'air') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'icewater') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error
        else
         write(radar_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!!!         CALL wrf_debug(150, radar_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'ice') then

       if (matrix .eq. 'ice') then
        write(radar_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, radar_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volair+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, 0.0d0, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'ice') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airwater') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         'air', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(radar_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!!!         CALL wrf_debug(150, radar_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'water') then

       if (matrix .eq. 'water') then
        write(radar_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, radar_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volice+volair,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, vol2, 0.0d0,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'water') then
         get_m_mix_nested = get_m_mix (2*m_a, mtmp, m_w,                &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airice') then
         get_m_mix_nested = get_m_mix (2*m_a, mtmp, m_w,                &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(radar_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',         &
                           hostmatrix
!!!         CALL wrf_debug(150, radar_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'none') then

       get_m_mix_nested = get_m_mix (m_a, m_i, m_w,                     &
                       volair, volice, volwater, mixingrule,            &
                       matrix, inclusion, error)
       cumulerror = cumulerror + error
        
      else
       write(radar_debug,*) 'GET_M_MIX_NESTED: unknown matrix: ', host
!!!       CALL wrf_debug(150, radar_debug)
       cumulerror = cumulerror + 1
      endif

      IF (cumulerror .ne. 0) THEN
       write(radar_debug,*) 'GET_M_MIX_NESTED: error encountered'
!!!       CALL wrf_debug(150, radar_debug)
       get_m_mix_nested = CMPLX(1.0d0,0.0d0)    
      endif

      end function get_m_mix_nested

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION get_m_mix (m_a, m_i, m_w, volair, volice,     &
                     volwater, mixingrule, matrix, inclusion, error)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion
      INTEGER, INTENT(out):: error

      error = 0
      get_m_mix = CMPLX(1.0d0,0.0d0)

      if (mixingrule .eq. 'maxwellgarnett') then
       if (matrix .eq. 'ice') then
        get_m_mix = m_complex_maxwellgarnett(volice, volair, volwater,  &
                           m_i, m_a, m_w, inclusion, error)
       elseif (matrix .eq. 'water') then
        get_m_mix = m_complex_maxwellgarnett(volwater, volair, volice,  &
                           m_w, m_a, m_i, inclusion, error)
       elseif (matrix .eq. 'air') then
        get_m_mix = m_complex_maxwellgarnett(volair, volwater, volice,  &
                           m_a, m_w, m_i, inclusion, error)
       else
        write(radar_debug,*) 'GET_M_MIX: unknown matrix: ', matrix
!!!        CALL wrf_debug(150, radar_debug)
        error = 1
       endif

      else
       write(radar_debug,*) 'GET_M_MIX: unknown mixingrule: ', mixingrule
!!!       CALL wrf_debug(150, radar_debug)
       error = 2
      endif

      if (error .ne. 0) then
       write(radar_debug,*) 'GET_M_MIX: error encountered'
!!!       CALL wrf_debug(150, radar_debug)
      endif

      END FUNCTION get_m_mix

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_maxwellgarnett(vol1, vol2, vol3,    &
                     m1, m2, m3, inclusion, error)

      IMPLICIT NONE

      COMPLEX*16 :: m1, m2, m3
      DOUBLE PRECISION :: vol1, vol2, vol3
      CHARACTER(len=*) :: inclusion

      COMPLEX*16 :: beta2, beta3, m1t, m2t, m3t
      INTEGER, INTENT(out) :: error

      error = 0

      if (DABS(vol1+vol2+vol3-1.0d0) .gt. 1d-6) then
       write(radar_debug,*) 'M_COMPLEX_MAXWELLGARNETT: sum of the ',       &
              'partial volume fractions is not 1...ERROR'
!!!       CALL wrf_debug(150, radar_debug)
       m_complex_maxwellgarnett=CMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m1t = m1**2
      m2t = m2**2
      m3t = m3**2

      if (inclusion .eq. 'spherical') then
       beta2 = 3.0d0*m1t/(m2t+2.0d0*m1t)
       beta3 = 3.0d0*m1t/(m3t+2.0d0*m1t)
      elseif (inclusion .eq. 'spheroidal') then
       beta2 = 2.0d0*m1t/(m2t-m1t) * (m2t/(m2t-m1t)*LOG(m2t/m1t)-1.0d0)
       beta3 = 2.0d0*m1t/(m3t-m1t) * (m3t/(m3t-m1t)*LOG(m3t/m1t)-1.0d0)
      else
       write(radar_debug,*) 'M_COMPLEX_MAXWELLGARNETT: ',                  &
                         'unknown inclusion: ', inclusion
!!!       CALL wrf_debug(150, radar_debug)
       m_complex_maxwellgarnett=DCMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m_complex_maxwellgarnett = &
       SQRT(((1.0d0-vol2-vol3)*m1t + vol2*beta2*m2t + vol3*beta3*m3t) / &
       (1.0d0-vol2-vol3+vol2*beta2+vol3*beta3))

      END FUNCTION m_complex_maxwellgarnett

!+---+-----------------------------------------------------------------+
!!!END MODULE module_mp_radar
!+---+-----------------------------------------------------------------+
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine satadj3(tnew,prs,qvnew,qcnew,qrnew,qinew,qsnew,qgnew,rho)
      implicit none

      ! CM1 iterative saturation adjustment scheme for Morrison microphysics

      real, intent(inout) :: tnew,prs,qvnew,qcnew
      real, intent(in) :: qrnew,qinew,qsnew,qgnew,rho

      integer :: n,iflag
      real :: esl,qvs,cvml,rm,lhv,tlast,dqv
      real :: converge,t1,d1,tem,ql,qi
      logical :: doit

      real, parameter :: tsmall = 0.0001

!--------------------------------------------------------------------
!  iterative sat adj.

    iflag=0

        converge=2.0*tsmall

        esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
        qvs=ep_2*esl/(prs-esl)

        IF(qcnew.gt.1.0e-12 .or. qvnew.gt.qvs)THEN

          ql=max(0.0,qcnew+qrnew)
          qi=max(0.0,qinew+qsnew+qgnew)
          cvml=cv+cvv*qvnew+cpl*ql+cpi*qi
          lhv = lvap0 + (2106.0 - 4218.0)*(tnew-273.15)

          t1=(lhv-rv*tnew)/cvml
          d1=t1*17.67*243.5

          n=0
          tlast=tnew
          doit=.true.

          do while( doit )
            n=n+1
            dqv=(qvs-qvnew)/(1.0+d1*qvs/((tnew-29.65)**2) )
            dqv=min(dqv,qcnew)
            if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew

            qvnew=qvnew+dqv
            qcnew=qcnew-dqv
            tnew=tnew-dqv*t1
            prs=rho*(R+rv*qvnew)*tnew

            doit = .false.
            if( abs(tnew-tlast).gt.converge )then
              tlast=tnew
              esl=611.2*exp( 17.67 * ( tnew - 273.15 ) / ( tnew - 29.65 ) )
              qvs=ep_2*esl/(prs-esl)
              doit = .true.
            endif

            if(n.gt.50) print *,'  satadj3:',n,tnew,prs
            if(n.eq.100)then
              print *,'  infinite loop!'
              iflag=1
              doit=.false.
            endif

          enddo

        ENDIF

      if(iflag.ne.0)then
        print *
        print *,' Convergence cannot be reached in satadj3 subroutine.'
        print *
        print *,' This may be a problem with the algorithm in satadj3.'
        print *,' However, the model may have became unstable somewhere'
        print *,' else and the symptoms first appeared here.'
        print *
        print *,' Try decreasing the timestep (dtl and/or nsound).'
        print *
        print *,'  ... stopping cm1 ... '
        print *
        call stopcm1
      endif

      END subroutine satadj3

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
END MODULE module_mp_thompson
turb.F          1587424407  1602  20    100644  144071    `

      subroutine sfc_and_turb(getsfc,nstep,dt,dosfcflx,cloudvar,qbudget,    &
                   xh,rxh,arh1,arh2,uh,ruh,xf,rxf,arf1,arf2,uf,ruf,  &
                   yh,vh,rvh,yf,vf,rvf,                              &
                   rds,sigma,rdsf,sigmaf,zh,mh,rmh,c1,c2,zf,mf,rmf,  &
                   pi0s,rth0s,pi0,rho0,prs0,thv0,th0,qv0,            &
                   zs,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv,        &
                   tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,tlh,          &
                   dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,          &
                   divx,rho,rr,rf,prs,                               &
                   t11,t12,t13,t22,t23,t33,                          &
                   u0,ua,v0,va,wa,                                   &
                   ppi,pp3d,ppten,                                   &
                   tha,th3d,thten,thten1,qa,                         &
                   kmh,kmv,khh,khv,tkea,tke3d,                       &
                   nm,defv,defh,dissten,radsw,radswnet,radlwin,      &
                   thpten,qvpten,qcpten,qipten,upten,vpten,          &
                   lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,znt,ust,    &
                   hpbl,wspd,psim,psih,gz1oz0,br,                    &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                    &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                 &
                   CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,    &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh,  &
                   mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d,   &
                   num_soil_layers,slab_zs,slab_dzs,tslb,tmn,        &
                   tml,t0ml,hml,h0ml,huml,hvml,tmoml,                &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,               &
                   nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   kw1,kw2,ke1,ke2,ks1,ks2,kn1,kn2,                  &
                   rtime,ntdiag,tdiag,update_sfc)
      ! end_sfc_and_turb
      use module_sf_sfclay
      use module_sf_sfclayrev
      use module_sf_slab
      use module_sf_oml
      use module_bl_ysu
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'radcst.incl'
      include 'timestat.incl'

!-----------------------------------------------------------------------
! Arrays and variables passed into solve

      logical, intent(in) :: getsfc
      integer, intent(in) :: nstep
      real, intent(inout) :: dt
      logical, intent(in) :: dosfcflx
      logical, intent(in), dimension(maxq) :: cloudvar
      double precision, intent(inout), dimension(nbudget) :: qbudget
      real, intent(in), dimension(ib:ie) :: xh,rxh,arh1,arh2,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf,ruf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf,rvf
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf,rmf
      real, intent(in), dimension(ib:ie,jb:je) :: pi0s,rth0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,prs0,thv0,th0,qv0
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,znt,ust,thflux,qvflux,cd,ch,cq,u1,v1,s1,xland,psfc,tlh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,divx,rho,rr,rf,prs
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thten,thten1
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, intent(inout), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: nm,defv,defh,dissten
      real, intent(inout), dimension(ni,nj) :: radsw,radswnet,radlwin
      real, intent(inout), dimension(ibb:ieb,jbb:jeb,kbb:keb) :: thpten,qvpten,qcpten,qipten,upten,vpten
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: lu_index,kpbl2d
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: u10,v10,s10,hfx,qfx, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,       &
                                      CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,dsxy,wstar,delta,fm,fh
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: mznt,smois,taux,tauy,hpbl2d,evap2d,heat2d,rc2d
      integer, intent(in) :: num_soil_layers
      real, intent(in), dimension(num_soil_layers) :: slab_zs,slab_dzs
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      real, intent(inout), dimension(jmp,kmp) :: vw1,vw2,ve1,ve2
      real, intent(inout), dimension(imp,kmp) :: vs1,vs2,vn1,vn2
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(jmp,kmt,4)     :: kw1,kw2,ke1,ke2
      real, intent(inout), dimension(imp,kmt,4)     :: ks1,ks2,kn1,kn2
      real, intent(in) :: rtime
      integer, intent(in) :: ntdiag
      real, intent(inout) , dimension(ibd:ied,jbd:jed,kbd:ked,ntdiag) :: tdiag
      logical, intent(in) :: update_sfc

!-----------------------------------------------------------------------

      integer :: i,j,k,k2
      integer :: isfflx,ifsnow
      real :: ep1,ep2,rovg,dtmin,dz1
      real :: SVP1,SVP2,SVP3,SVPT0,p1000mb,eomeg,stbolt,tem,tem1,tem2,tem3

      integer :: NTSFLG
      real :: SFENTH
      logical :: flag_qi
      integer :: p_qi,p_first_scalar
      logical :: disheat
      real :: alpha,beta,var_ric,coef_ric_l,coef_ric_s
      real :: qx

!-----------------------------------------------------------------------

      IF( iturb.ge.1 .or. ipbl.ge.1 .or. idiss.eq.1 .or. output_dissten.eq.1 )THEN

        ! cm1r17:  dissten is defined on w (full) levels:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dissten(i,j,k)=0.0
        enddo
        enddo
        enddo

      ENDIF

      do j=1,nj
      do i=1,ni
        psfc(i,j) = cgs1*prs(i,j,1)+cgs2*prs(i,j,2)+cgs3*prs(i,j,3)
      enddo
      enddo

      IF( (sfcmodel.eq.2) .or. (sfcmodel.eq.3) .or. (sfcmodel.eq.4) .or. (ipbl.eq.1) .or. (ipbl.eq.2) .or.  (oceanmodel.eq.2) )THEN

        ! variables for wrf physics:

        if( ipbl.ge.1 )then
          k2 = nk
        else
          k2 = 1
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do j=1,nj
          do k=1,k2
          do i=1,ni
            dum1(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
            dum2(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
            dum3(i,j,k)=th0(i,j,k)+tha(i,j,k)
            dum7(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
            dum4(i,j,k)=dum3(i,j,k)*dum7(i,j,k)
          enddo
          enddo
          do k=1,max(2,k2)
          do i=1,ni
            dum5(i,j,k) = dz*rmh(i,j,k)
          enddo
          enddo
          do k=2,max(2,k2)
          do i=1,ni
            dum6(i,j,k) = c1(i,j,k)*prs(i,j,k-1)+c2(i,j,k)*prs(i,j,k)
          enddo
          enddo
          ! surface:
          do i=1,ni
            dum6(i,j,1) = psfc(i,j)
          enddo
          ! top of model:
          if( k2.gt.1 )then
          do i=1,ni
            dum6(i,j,nk+1)= cgt1*prs(i,j,nk)+cgt2*prs(i,j,nk-1)+cgt3*prs(i,j,nk-2)
          enddo
          endif
        enddo

        ! dum1 = u at scalars
        ! dum2 = v at scalars
        ! dum3 = th
        ! dum7 = pi
        ! dum4 = t
        ! dum5 = dz8w
        ! dum6 = p3di

        isfflx = 1
        SVP1=0.6112
        SVP2=17.67
        SVP3=29.65
        SVPT0=273.15
        p1000mb      = 100000.
        EOMEG=7.2921E-5
        STBOLT=5.67051E-8
        ep1 = rv/rd - 1.0
        ep2 = rd/rv
        rovg = rd/g

        IF(radopt.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            gsw(i,j)=radswnet(i,j)
            glw(i,j)=radlwin(i,j)
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            gsw(i,j)=0.0
            glw(i,j)=0.0
          enddo
          enddo
        ENDIF

      ENDIF

!-----------------------------------------------------------------------

    dosfc:  IF( getsfc )THEN

      bbc3:  IF( bbc.eq.3 )THEN

        !-------------------------------
        ! u1 is u at lowest model level
        ! v1 is v at lowest model level
        ! s1 is horizontal wind speed at lowest model level
        ! (all defined at the scalar point of the staggered grid)
        ! for pertflx=1, account for domain (i.e., surface) motion 
        !                in calculation of wind speed
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
          IF( pertflx.eq.1 .or. imove.eq.1 )THEN
            do i=1,ni
              u1(i,j) = 0.5*( ua(i,j,1)+umove + ua(i+1,j,1)+umove )
              v1(i,j) = 0.5*( va(i,j,1)+vmove + va(i,j+1,1)+vmove )
              s1(i,j) = sqrt(u1(i,j)**2+v1(i,j)**2)
            enddo
          ELSE 
            do i=1,ni 
              u1(i,j) = 0.5*( ua(i,j,1) + ua(i+1,j,1) )
              v1(i,j) = 0.5*( va(i,j,1) + va(i,j+1,1) )
              s1(i,j) = sqrt(u1(i,j)**2+v1(i,j)**2)
            enddo
          ENDIF
          IF(imoist.eq.1)THEN
            do k=1,nk
            do i=1,ni
              divx(i,j,k) = qa(i,j,k,nqv)
            enddo
            enddo
          ELSE
            do k=1,nk
            do i=1,ni
              divx(i,j,k) = 0.0
            enddo
            enddo
          ENDIF
          IF( terrain_flag )THEN
            do i=1,ni
              ppten(i,j,1) = zh(i,j,1)-zs(i,j)
            enddo
          ELSE
            do i=1,ni
              ppten(i,j,1) = zh(i,j,1)
            enddo
          ENDIF

        enddo

        !-------------------------------
        ! NOTE:
        ! divx stores qv
        ! ppten stores height of first model level above surface

        IF( ipbl.eq.0 )THEN
          call gethpbl(zh,th0,tha,divx,hpbl)
          IF( terrain_flag )THEN
            do j=1,nj
            do i=1,ni
              hpbl(i,j) = hpbl(i,j)-zs(i,j)
            enddo
            enddo
          ENDIF
        ENDIF

        IF( sfcmodel.eq.1 )THEN

          call getcecd(u0,v0,u1,v1,s1,ua,va,ppten(ib,jb,1),u10,v10,s10,xland,znt,ust,cd,ch,cq)
          if(isfcflx.eq.1)then
            call sfcflux(dt,ruh,xf,rvh,pi0s,ch,cq,pi0,thv0,th0,u0,v0,tsk,thflux,qvflux,mavail, &
                         rho,rf,u1,v1,s1,ua,va,ppi,tha,qa(ibm,jbm,kbm,nqv), &
                         qbudget(8),psfc,u10,v10,s10,qsfc,znt,rtime)
          endif
          ! get sfc diagnostics needed by pbl scheme:
          call sfcdiags(tsk,thflux,qvflux,cd,ch,cq,u1,v1,s1,             &
                        xland,psfc,qsfc,u10,v10,hfx,qfx,cda,znt,gz1oz0,  &
                        psim,psih,br,zol,mol,hpbl,dsxy,th2,t2,q2,fm,fh,  &
                        zs,ppten(ib,jb,1),pi0s,pi0,th0,ppi,tha,rho,rf,divx,ua,va)
          if( ipbl.ge.1 )then
            do j=1,nj
            do i=1,ni
              wspd(i,j) = max( s1(i,j) , 1.0e-6 )
              CPMM(i,j)=CP*(1.0+0.8*divx(i,j,1))                                   
              hfx(i,j) = thflux(i,j)*CPMM(i,j)*rf(i,j,1)
              qvflux(i,j) = qfx(i,j)*rf(i,j,1)
            enddo
            enddo
          endif

        ENDIF


        IF( (sfcmodel.eq.2) .or. (sfcmodel.eq.3) .or. (sfcmodel.eq.4) )THEN
          ! surface layer:
          ! (needed by sfcmodel=2,3,4 and ipbl=1,2)
        if( sfcmodel.eq.2 )then
          call SFCLAY(dum1,dum2,dum4,qa(ib,jb,kb,nqv),prs,dum5,      &
                       CP,G,ROVCP,RD,XLV,lv1,lv2,PSFC,CHS,CHS2,CQS2,CPMM, &
                       ZNT,UST,hpbl,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
                       FM,FH,                                        &
                       XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                       U10,V10,TH2,T2,Q2,rf(ib,jb,1),                &
                       GZ1OZ0,WSPD,BR,ISFFLX,dsxy,                   &
                       SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                       KARMAN,EOMEG,STBOLT,                          &
                       P1000mb,                                      &
                       1  ,ni+1 , 1  ,nj+1 , 1  ,nk+1 ,              &
                       ib ,ie , jb ,je , kb ,ke ,                    &
                       1  ,ni , 1  ,nj , 1  ,nk ,                    &
                       ustm,ck,cka,cd,cda,isftcflx,iz0tlnd           )
        elseif( sfcmodel.eq.3 )then
          call SFCLAYREV(dum1,dum2,dum4,qa(ib,jb,kb,nqv),prs,dum5,   &
                       CP,G,ROVCP,RD,XLV,lv1,lv2,PSFC,CHS,CHS2,CQS2,CPMM, &
                       ZNT,UST,hpbl,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
                       FM,FH,                                        &
                       XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                       U10,V10,TH2,T2,Q2,rf(ib,jb,1),                &
                       GZ1OZ0,WSPD,BR,ISFFLX,dsxy,                   &
                       SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                       KARMAN,EOMEG,STBOLT,                          &
                       P1000mb,                                      &
                       1  ,ni+1 , 1  ,nj+1 , 1  ,nk+1 ,              &
                       ib ,ie , jb ,je , kb ,ke ,                    &
                       1  ,ni , 1  ,nj , 1  ,nk ,                    &
                       ustm,ck,cka,cd,cda,isftcflx,iz0tlnd           )
        endif

          ifsnow = 0
          dtmin = dt/60.0

        IF( update_sfc )THEN
          ! slab scheme (MM5/WRF):
          call SLAB(dum4,qa(ib,jb,kb,nqv),prs,FLHC,FLQC,            &
                       PSFC,XLAND,TMN,HFX,QFX,LH,TSK,QSFC,CHKLOWQ,  &
                       GSW,GLW,CAPG,THC,SNOWC,EMISS,MAVAIL,         &
                       DT,ROVCP,XLV,lv1,lv2,DTMIN,IFSNOW,           &
                       SVP1,SVP2,SVP3,SVPT0,EP2,                    &
                       KARMAN,EOMEG,STBOLT,                         &
                       TSLB,slab_ZS,slab_DZS,num_soil_layers, .true. ,       &
                       P1000mb,                                     &
                         1, ni+1,   1, nj+1,   1, nk+1,             &
                        ib, ie,  jb, je,  kb, ke,                   &
                         1, ni,   1, nj,   1, nk                    )
        ELSE
          ! dont update tsk, but diagnose qsfc:
          do j=1,nj
          do i=1,ni
            qx = divx(i,j,1)
            if ( FLQC(i,j) .ne. 0.) then
               QSFC(i,j)=QX+QFX(i,j)/FLQC(i,j)
            else
               QSFC(i,j) = QX
            end if
            CHKLOWQ(i,j)=MAVAIL(i,j)
          enddo
          enddo
        ENDIF

          ! put WRF parameters into CM1 arrays:
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            ch(i,j) = chs2(i,j)
            cq(i,j) = cqs2(i,j)
            s10(i,j) = sqrt( u10(i,j)**2 + v10(i,j)**2 )
          enddo
          enddo
          IF( dosfcflx .or. output_sfcflx.eq.1 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              thflux(i,j) = hfx(i,j)/(CPMM(i,j)*rf(i,j,1))
              qvflux(i,j) = qfx(i,j)/rf(i,j,1)
            enddo
            enddo
          ENDIF

        ENDIF

      ENDIF  bbc3
      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

    ELSE

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  ... skipping sfc stuff ... '
      if(dowr) write(outfile,*)

    ENDIF  dosfc

!---------------------------------------------
! bc/comms (very important):

  IF( bbc.eq.3 )THEN
    !-------------!
    call bc2d(ust)
#ifdef MPI
    call comm_1s2d_start(ust,uw31(1,1,1),uw32(1,1,1),ue31(1,1,1),ue32(1,1,1),  &
                             us31(1,1,1),us32(1,1,1),un31(1,1,1),un32(1,1,1),reqs_s)
#endif
    call bc2d(u1)
#ifdef MPI
    call comm_1s2d_start(u1 ,uw31(1,1,2),uw32(1,1,2),ue31(1,1,2),ue32(1,1,2),  &
                             us31(1,1,2),us32(1,1,2),un31(1,1,2),un32(1,1,2),reqs_u)
#endif
    call bc2d(v1)
#ifdef MPI
    call comm_1s2d_start(v1 ,uw31(1,1,3),uw32(1,1,3),ue31(1,1,3),ue32(1,1,3),  &
                             us31(1,1,3),us32(1,1,3),un31(1,1,3),un32(1,1,3),reqs_v)
#endif
    call bc2d(s1)
#ifdef MPI
    call comm_1s2d_start(s1 ,uw31(1,1,4),uw32(1,1,4),ue31(1,1,4),ue32(1,1,4),  &
                             us31(1,1,4),us32(1,1,4),un31(1,1,4),un32(1,1,4),reqs_w)
#endif
    call bc2d(znt)
#ifdef MPI
    call comm_1s2d_start(znt,uw31(1,1,5),uw32(1,1,5),ue31(1,1,5),ue32(1,1,5),  &
                             us31(1,1,5),us32(1,1,5),un31(1,1,5),un32(1,1,5),reqs_p)
#endif
    !-------------!

#ifdef MPI
    !-------------!
    call comm_1s2d_end(ust,uw31(1,1,1),uw32(1,1,1),ue31(1,1,1),ue32(1,1,1),  &
                           us31(1,1,1),us32(1,1,1),un31(1,1,1),un32(1,1,1),reqs_s)
    call bcs2_2d(ust)

    call comm_1s2d_end(u1 ,uw31(1,1,2),uw32(1,1,2),ue31(1,1,2),ue32(1,1,2),  &
                           us31(1,1,2),us32(1,1,2),un31(1,1,2),un32(1,1,2),reqs_u)
    call bcs2_2d(u1 )

    call comm_1s2d_end(v1 ,uw31(1,1,3),uw32(1,1,3),ue31(1,1,3),ue32(1,1,3),  &
                           us31(1,1,3),us32(1,1,3),un31(1,1,3),un32(1,1,3),reqs_v)
    call bcs2_2d(v1 )

    call comm_1s2d_end(s1 ,uw31(1,1,4),uw32(1,1,4),ue31(1,1,4),ue32(1,1,4),  &
                           us31(1,1,4),us32(1,1,4),un31(1,1,4),un32(1,1,4),reqs_w)
    call bcs2_2d(s1 )

    call comm_1s2d_end(znt,uw31(1,1,5),uw32(1,1,5),ue31(1,1,5),ue32(1,1,5),  &
                           us31(1,1,5),us32(1,1,5),un31(1,1,5),un32(1,1,5),reqs_p)
    call bcs2_2d(znt)
    !-------------!

    !-------------!
    call comm_2d_corner(ust)
    call comm_2d_corner(u1)
    call comm_2d_corner(v1)
    call comm_2d_corner(s1)
    call comm_2d_corner(znt)
    !-------------!
#endif
  ENDIF

!-------------------------------------------------------------------
! simple ocean mixed layer model based Pollard, Rhines and Thompson (1973)
!   (from WRF)

    IF(oceanmodel.eq.2)THEN
    IF( update_sfc )THEN
      if( getsfc )then

        CALL oceanml(tml,t0ml,hml,h0ml,huml,hvml,ust,dum1,dum2, &
                     tmoml,f2d,g,oml_gamma,                     &
                     xland,hfx,lh,tsk,gsw,glw,emiss,            &
                     dt,STBOLT,                                 &
                       1, ni+1,   1, nj+1,   1, nk+1,           &
                      ib, ie,  jb, je,  kb, ke,                 &
                       1, ni,   1, nj,   1, nk                  )

        if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

      endif
    ENDIF
    ENDIF

!-------------------------------------------------------------------
!  PBL scheme:

      IF(ipbl.ge.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        DO k=1,nk
          ! store qi in dum8:
          if( nqi.ge.1 )then
            do j=1,nj
            do i=1,ni
              dum8(i,j,k) = qa(i,j,k,nqi)
            enddo
            enddo
          else
            do j=1,nj
            do i=1,ni
              dum8(i,j,k) = 0.0
            enddo
            enddo
          endif
          IF(output_km.eq.1.or.output_kh.eq.1)THEN
            do j=1,nj
            do i=1,ni
              thten1(i,j,k)=0.0
              thten(i,j,k)=0.0
            enddo
            enddo
          ENDIF
        ENDDO

        if( iice.eq.1 )then
          flag_qi = .true.
        else
          flag_qi = .false.
        endif

      if(ipbl.eq.1)then
        ! PBL:
        call ysu(u3d=dum1,v3d=dum2,th3d=dum3,t3d=dum4,qv3d=qa(ib,jb,kb,nqv),        &
                  qc3d=qa(ib,jb,kb,nqc),qi3d=dum8,p3d=prs,p3di=dum6,pi3d=dum7,      &
                  rublten=upten,rvblten=vpten,rthblten=thpten,                      &
                  rqvblten=qvpten,rqcblten=qcpten,rqiblten=qipten,flag_qi=flag_qi,  &
                  cp=cp,g=g,rovcp=rovcp,rd=rd,rovg=rovg,ep1=ep1,ep2=ep2,            &
                  karman=karman,xlv=xlv,lv1=lv1,lv2=lv2,rv=rv,                      &
                  dz8w=dum5 ,psfc=psfc,                                             &
                  znt=znt,ust=ust,hpbl=hpbl,psim=fm,psih=fh,                        &
                  xland=xland,hfx=hfx,qfx=qfx,wspd=wspd,br=br,                      &
                  dt=dt,kpbl2d=kpbl2d,                                              &
                  exch_h=thten1,exch_m=thten,                                       &
                  wstar=wstar,delta=delta,                                          &
                  u10=u10,v10=v10,                                                  &
                  ids=1  ,ide=ni+1 , jds= 1 ,jde=nj+1 , kds=1  ,kde=nk+1 ,          &
                  ims=ib ,ime=ie   , jms=jb ,jme=je   , kms=kb ,kme=ke ,            &
                  its=1  ,ite=ni   , jts=1  ,jte=nj   , kts=1  ,kte=nk ,            &
                  regime=regime)
        IF(output_km.eq.1.or.output_kh.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            khv(i,j,k) = thten1(i,j,k)
            kmv(i,j,k) = thten(i,j,k)
          enddo
          enddo
          enddo
        ENDIF
      endif
        if(timestats.ge.1) time_pbl=time_pbl+mytime()

        call bcs(upten)
#ifdef MPI
        call comm_1s_start(upten,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
#endif
        call bcs(vpten)
#ifdef MPI
        call comm_1s_start(vpten,vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,reqs_p)
#endif
        ! Dissipative heating from ysu scheme:
        IF( idiss.eq.1 .or. output_dissten.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
          do j=1,nj
          do i=1,ni
            ! assume t13,t23 are zero at top of domain:
            t13(i,j,nk+1) = 0.0
            t23(i,j,nk+1) = 0.0
            do k=nk,1,-1
              tem = rho(i,j,k)*dz*rmh(i,j,k)/rf(i,j,k)
              t13(i,j,k) = t13(i,j,k+1)-upten(i,j,k)*tem
              t23(i,j,k) = t23(i,j,k+1)-vpten(i,j,k)*tem
            enddo
            do k=2,nk
              tem = rdz*mf(i,j,k)
              dum3(i,j,k)=( dum1(i,j,k)-dum1(i,j,k-1) )*tem
              dum4(i,j,k)=( dum2(i,j,k)-dum2(i,j,k-1) )*tem
            enddo
            dissten(i,j,1) = dissten(i,j,1) + (ust(i,j)**3)/(karman*znt(i,j))
            do k=2,nk
              ! NOTE:  dissten is defined at w points:
              dissten(i,j,k) = dissten(i,j,k)         &
                            +( t13(i,j,k)*dum3(i,j,k) &
                              +t23(i,j,k)*dum4(i,j,k) )
            enddo
          enddo
          enddo
        ENDIF
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
#ifdef MPI
        call comm_1s_end(upten,pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,reqs_s)
        call comm_1s_end(vpten,vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,reqs_p)
#endif

      ENDIF

!---------------------------------------------

      IF( iturb.ge.1 .or. output_nm.eq.1 )THEN
        ! squared Brunt-Vaisala frequency:
        call calcnm(c1,c2,mf,pi0,thv0,th0,cloudvar,nm,dum1,dum2,dum3,dum4,   &
                    prs,ppi,tha,qa)
      ENDIF

      IF( iturb.ge.1 .or. output_def.eq.1 )THEN
        ! deformation:
        call calcdef(    rds,sigma,rdsf,sigmaf,zs,gz,rgz,gzu,rgzu,gzv,rgzv,                &
                     xh,rxh,arh1,arh2,uh,xf,rxf,arf1,arf2,uf,vh,vf,mh,c1,c2,mf,defv,defh,  &
                     dum1,dum2,ua,va,wa,t11,t12,t13,t22,t23,t33,gx,gy,rho,rr,rf)

      ENDIF
      if(timestats.ge.1) time_turb=time_turb+mytime()

!--------------------------------------
!  next section is for iturb >= 1 only:

    IF(iturb.ge.1)THEN

      IF(iturb.eq.1)THEN
        call tkekm(nstep,dt,ruh,rvh,rmh,zf,mf,rmf,znt,ust,rf,         &
                   nm,defv,defh,dum1,dum2,dum3,dum4,dum5,             &
                   kmh,kmv,khh,khv,tkea,ua,va,dissten,                &
                   nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                   &
                   kw1(1,1,1),kw2(1,1,1),ke1(1,1,1),ke2(1,1,1),       &
                   ks1(1,1,1),ks2(1,1,1),kn1(1,1,1),kn2(1,1,1),       &
                   kw1(1,1,2),kw2(1,1,2),ke1(1,1,2),ke2(1,1,2),       &
                   ks1(1,1,2),ks2(1,1,2),kn1(1,1,2),kn2(1,1,2),       &
                   kw1(1,1,3),kw2(1,1,3),ke1(1,1,3),ke2(1,1,3),       &
                   ks1(1,1,3),ks2(1,1,3),kn1(1,1,3),kn2(1,1,3),       &
                   kw1(1,1,4),kw2(1,1,4),ke1(1,1,4),ke2(1,1,4),       &
                   ks1(1,1,4),ks2(1,1,4),kn1(1,1,4),kn2(1,1,4))
      ELSEIF(iturb.eq.2)THEN
        call turbsmag(nstep,dt,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,rf, &
                      nm,defv,defh,dum4,dum5,thten1,zf,znt,ust,        &
                      kmh,kmv,khh,khv,ua,va,dissten,                   &
                      nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                      kw1(1,1,1),kw2(1,1,1),ke1(1,1,1),ke2(1,1,1),     &
                      ks1(1,1,1),ks2(1,1,1),kn1(1,1,1),kn2(1,1,1),     &
                      kw1(1,1,2),kw2(1,1,2),ke1(1,1,2),ke2(1,1,2),     &
                      ks1(1,1,2),ks2(1,1,2),kn1(1,1,2),kn2(1,1,2))
      ELSEIF(iturb.eq.3)THEN
        call turbparam(nstep,zf,dt,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,rf, &
                      nm,defv,defh,dum4,kmh,kmv,khh,khv,ua,va,dissten,zs,znt,ust,xland,psfc,tlh, &
                      nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                      kw1(1,1,1),kw2(1,1,1),ke1(1,1,1),ke2(1,1,1),     &
                      ks1(1,1,1),ks2(1,1,1),kn1(1,1,1),kn2(1,1,1),     &
                      kw1(1,1,2),kw2(1,1,2),ke1(1,1,2),ke2(1,1,2),     &
                      ks1(1,1,2),ks2(1,1,2),kn1(1,1,2),kn2(1,1,2))
      ENDIF


        !  now, get turbulent stresses:
        call     gettau(xf,rxf,arf1,arf2,ust,u1,v1,s1,rf,  &
                        kmh,kmv,t11,t12,t13,t22,t23,t33,ua)


      !  last step:  Surface dissipation:
      IF(bbc.eq.2)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,tem1)
        do j=1,nj
        do i=1,ni
          tem1 = ( ( t13(i  ,j,1)*ua(i  ,j,1)     &
                    +t13(i+1,j,1)*ua(i+1,j,1) )   &
                 + ( t23(i,j  ,1)*va(i,j  ,1)     &
                    +t23(i,j+1,1)*va(i,j+1,1) )   &
                 )*rdz*mf(i,j,1)/rf(i,j,1)
          dissten(i,j,1) = dissten(i,j,1) + max(tem1,0.0)
        enddo
        enddo
      ENDIF
      IF( bbc.eq.3 .and. ipbl.eq.0 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dissten(i,j,1) = dissten(i,j,1) + (ust(i,j)**3)/(karman*znt(i,j))
        enddo
        enddo
      ENDIF

      IF(iturb.eq.1)THEN
        do j=0,nj+1
        do i=0,ni+1
          tke3d(i,j,1) = tkea(i,j,1)
        enddo
        enddo
      ENDIF

      if(timestats.ge.1) time_turb=time_turb+mytime()

    ENDIF  ! endif section for iturb.ge.1

      end subroutine sfc_and_turb

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      subroutine tkekm(nstep,dt,ruh,rvh,rmh,zf,mf,rmf,znt,ust,rf,           &
                         nm,defv,defh,tk,lenscl,lenh,grdscl,rgrdscl,        &
                         kmh,kmv,khh,khv,tkea,ua,va,dissten,                &
                         nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                   &
                         khcw1,khcw2,khce1,khce2,khcs1,khcs2,khcn1,khcn2,   &
                         khdw1,khdw2,khde1,khde2,khds1,khds2,khdn1,khdn2,   &
                         kvcw1,kvcw2,kvce1,kvce2,kvcs1,kvcs2,kvcn1,kvcn2,   &
                         kvdw1,kvdw2,kvde1,kvde2,kvds1,kvds2,kvdn1,kvdn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer, intent(in) :: nstep
      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: ruh
      real, intent(in), dimension(jb:je) :: rvh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, intent(in),dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf,rmf
      real, intent(in), dimension(ib:ie,jb:je) :: znt,ust
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: nm,defv,defh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tk,lenscl,lenh,grdscl,rgrdscl
      real, intent(inout), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: dissten
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmt) :: khcw1,khcw2,khce1,khce2
      real, intent(inout), dimension(imp,kmt) :: khcs1,khcs2,khcn1,khcn2
      real, intent(inout), dimension(jmp,kmt) :: khdw1,khdw2,khde1,khde2
      real, intent(inout), dimension(imp,kmt) :: khds1,khds2,khdn1,khdn2
      real, intent(inout), dimension(jmp,kmt) :: kvcw1,kvcw2,kvce1,kvce2
      real, intent(inout), dimension(imp,kmt) :: kvcs1,kvcs2,kvcn1,kvcn2
      real, intent(inout), dimension(jmp,kmt) :: kvdw1,kvdw2,kvde1,kvde2
      real, intent(inout), dimension(imp,kmt) :: kvds1,kvds2,kvdn1,kvdn2

!----------------------------------------

      integer :: i,j,k
      real :: prinv,tem1,tem2

#ifdef MPI
      integer reqs_khc(8)
      integer reqs_kvc(8)
      integer reqs_khd(8)
      integer reqs_kvd(8)
#endif

!------------------------------------------------------------------
!  Get length scales:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=2,nk

    !  get grid scale
    IF(tconfig.eq.1)THEN
      ! single length scale:  appropriate if dx,dy are nearly the same as dz
      do j=1,nj
      do i=1,ni
        grdscl(i,j,k)=( ((dx*ruh(i))*(dy*rvh(j)))*(dz*rmf(i,j,k)) )**0.33333333
        ! cm1r17:  wall condition near surface
        grdscl(i,j,k) = sqrt(1.0/( 1.0/(grdscl(i,j,k)**2)                                  &
                                  +1.0/((karman*((zf(i,j,k)-zf(i,j,1))+znt(i,j))*rcs)**2)  &
                               ) )
        rgrdscl(i,j,k)=1.0/grdscl(i,j,k)
      enddo
      enddo
    ELSEIF(tconfig.eq.2)THEN
      ! two length scales:  one for horizontal, one for vertical
      do j=1,nj
      do i=1,ni
        lenh(i,j,k)=sqrt( (dx*ruh(i))*(dy*rvh(j)) )
      enddo
      enddo
      do j=1,nj
      do i=1,ni
        grdscl(i,j,k)=dz*rmf(i,j,k)
        ! cm1r17:  wall condition near surface
        grdscl(i,j,k) = sqrt(1.0/( 1.0/(grdscl(i,j,k)**2)                                  &
                                  +1.0/((karman*((zf(i,j,k)-zf(i,j,1))+znt(i,j))*rcs)**2)  &
                               ) )
        rgrdscl(i,j,k)=1.0/grdscl(i,j,k)
      enddo
      enddo
    ENDIF

      ! Get turbulence length scale
      do j=1,nj
      do i=1,ni
        tk(i,j,k)=max(tkea(i,j,k),1.0e-6)
        lenscl(i,j,k)=grdscl(i,j,k)
        if(nm(i,j,k).gt.1.0e-6.and.tk(i,j,k).ge.1.0e-3)then
          lenscl(i,j,k)=c_l*sqrt(tk(i,j,k)/nm(i,j,k))
          lenscl(i,j,k)=min(lenscl(i,j,k),grdscl(i,j,k))
          lenscl(i,j,k)=max(lenscl(i,j,k),1.0e-6*grdscl(i,j,k))
        endif 
      enddo
      enddo

    ENDDO

    if( nstep.eq.0 .and. myid.eq.0 )then
      print *
      print *,'  zf,grdscl:'
      i = 1
      j = 1
      do k=2,nk
        print *,k,(zf(i,j,k)-zf(i,j,1)),grdscl(i,j,k)
      enddo
    endif

!------------------------------------------------------------------

      tem1 = 0.125*dx*dx/dt
      tem2 = 0.125*dy*dy/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k,prinv)
    DO k=2,nk

    !  Get km, kh
    IF(tconfig.eq.1)THEN

      do j=1,nj
      do i=1,ni
        kmh(i,j,k)=c_m*sqrt(tk(i,j,k))*lenscl(i,j,k)
        kmv(i,j,k)=kmh(i,j,k)
        prinv=3.00
        if(nm(i,j,k).gt.1.0e-6)then
          prinv=min(1.0+2.00*lenscl(i,j,k)*rgrdscl(i,j,k),3.00)
        endif
        khh(i,j,k)=kmh(i,j,k)*prinv
        khv(i,j,k)=khh(i,j,k)
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN

      do j=1,nj
      do i=1,ni
        kmh(i,j,k)=c_m*sqrt(tk(i,j,k))*lenh(i,j,k)
        kmv(i,j,k)=c_m*sqrt(tk(i,j,k))*lenscl(i,j,k)
        prinv=3.00
        if(nm(i,j,k).gt.1.0e-6)then
          prinv=min(1.0+2.00*lenscl(i,j,k)*rgrdscl(i,j,k),3.00)
        endif
        khh(i,j,k)=kmh(i,j,k)*prinv
        khv(i,j,k)=kmv(i,j,k)*prinv
      enddo
      enddo

    ENDIF

      !  limit for numerical stability:
      do j=1,nj
      do i=1,ni
        kmh(i,j,k) = min( kmh(i,j,k) , tem1*ruh(i)*ruh(i) , tem2*rvh(j)*rvh(j) )
        khh(i,j,k) = min( khh(i,j,k) , tem1*ruh(i)*ruh(i) , tem2*rvh(j)*rvh(j) )
      enddo
      enddo

    ENDDO

      if(timestats.ge.1) time_turb=time_turb+mytime()

!------------------------------------------------------------
! Set values at boundaries, start comms:

      call bcw(kmh,1)
#ifdef MPI
      call comm_1t_start(kmh,khcw1,khcw2,khce1,khce2,   &
                             khcs1,khcs2,khcn1,khcn2,reqs_khc)
#endif

      call bcw(kmv,1)
#ifdef MPI
      call comm_1t_start(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                             kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
#endif

      call bcw(khh,1)
#ifdef MPI
      call comm_1t_start(khh,khdw1,khdw2,khde1,khde2,   &
                             khds1,khds2,khdn1,khdn2,reqs_khd)
#endif

      call bcw(khv,1)
#ifdef MPI
      call comm_1t_start(khv,kvdw1,kvdw2,kvde1,kvde2,   &
                             kvds1,kvds2,kvdn1,kvdn2,reqs_kvd)
#endif

!--------------------------------------------------------------
!  Dissipation:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=2,nk
      do j=1,nj
      do i=1,ni
        dissten(i,j,k) = dissten(i,j,k)                           &
                     +(c_e1+c_e2*lenscl(i,j,k)*rgrdscl(i,j,k))    &
                     *tk(i,j,k)*sqrt(tk(i,j,k))/lenscl(i,j,k)
      enddo
      enddo
    ENDDO
    if(timestats.ge.1) time_turb=time_turb+mytime()

!--------------------------------------------------------------
!  Finish comms:
#ifdef MPI
      call comm_1t_end(kmh,khcw1,khcw2,khce1,khce2,   &
                           khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call bct2(kmh)
      call comm_1t_end(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                           kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call bct2(kmv)
      call comm_1t_end(khh,khdw1,khdw2,khde1,khde2,   &
                           khds1,khds2,khdn1,khdn2,reqs_khd)
      call comm_1t_end(khv,kvdw1,kvdw2,kvde1,kvde2,   &
                           kvds1,kvds2,kvdn1,kvdn2,reqs_kvd)
      call getcornert(kmh,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      call getcornert(kmv,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
#endif

!--------------------------------------------------------------
!  cm1r18: surface

      IF( bbc.eq.3 )THEN

        tem1 = (c_s/c_m)**2

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          tkea(i,j,1) = tem1*ust(i,j)*ust(i,j)
          kmh(i,j,1) = karman*znt(i,j)*ust(i,j)
        enddo
        enddo

        !-----
        call bc2d(tkea(ibt,jbt,1))
#ifdef MPI
        call comm_1s2d_start(tkea(ibt,jbt,1),kvcw1(1,1),kvcw2(1,1),kvce1(1,1),kvce2(1,1),   &
                                             kvcs1(1,1),kvcs2(1,1),kvcn1(1,1),kvcn2(1,1),reqs_kvc)
#endif
        call bc2d(kmh(ibc,jbc,1))
#ifdef MPI
        call comm_1s2d_start(kmh(ibc,jbc,1),khcw1(1,1),khcw2(1,1),khce1(1,1),khce2(1,1),   &
                                            khcs1(1,1),khcs2(1,1),khcn1(1,1),khcn2(1,1),reqs_khc)
        !-----
        call comm_1s2d_end(tkea(ibt,jbt,1),kvcw1(1,1),kvcw2(1,1),kvce1(1,1),kvce2(1,1),   &
                                           kvcs1(1,1),kvcs2(1,1),kvcn1(1,1),kvcn2(1,1),reqs_kvc)
        call bcs2_2d(tkea(ibt,jbt,1))
        call comm_1s2d_end(kmh(ibc,jbc,1),khcw1(1,1),khcw2(1,1),khce1(1,1),khce2(1,1),   &
                                          khcs1(1,1),khcs2(1,1),khcn1(1,1),khcn2(1,1),reqs_khc)
        call bcs2_2d(kmh(ibc,jbc,1))
        !-----
        call comm_2d_corner(tkea(ibt,jbt,1))
        call comm_2d_corner(kmh(ibc,jbc,1))
        !-----
#endif

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          kmv(i,j,1) = kmh(i,j,1)
          khv(i,j,1) = kmv(i,j,1)*(khv(i,j,2)/(1.0e-10+kmv(i,j,2)))
          khh(i,j,1) = kmh(i,j,1)*(khh(i,j,2)/(1.0e-10+kmh(i,j,2)))
        enddo
        enddo

      ENDIF

!--------------------------------------------------------------
!  finished
      
      return
      end subroutine tkekm


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbsmag(nstep,dt,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,rf, &
                          nm,defv,defh,lenscl,grdscl,lenh,zf,znt,ust,      &
                          kmh,kmv,khh,khv,ua,va,dissten,                   &
                          nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                 &
                          khcw1,khcw2,khce1,khce2,khcs1,khcs2,khcn1,khcn2, &
                          kvcw1,kvcw2,kvce1,kvce2,kvcs1,kvcs2,kvcn1,kvcn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer, intent(in) :: nstep
      real, intent(in) :: dt
      logical, intent(in) :: dosfcflx
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: th0
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,rth0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rf
      real, dimension(ib:ie,jb:je,kb:ke+1) :: nm,defv,defh
      real, dimension(ib:ie,jb:je,kb:ke) :: lenscl,grdscl,lenh
      real, intent(in), dimension(ib:ie,jb:je) :: znt,ust
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: dissten
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmt) :: khcw1,khcw2,khce1,khce2
      real, intent(inout), dimension(imp,kmt) :: khcs1,khcs2,khcn1,khcn2
      real, intent(inout), dimension(jmp,kmt) :: kvcw1,kvcw2,kvce1,kvce2
      real, intent(inout), dimension(imp,kmt) :: kvcs1,kvcs2,kvcn1,kvcn2

      integer i,j,k
      real :: tem,temx,temy

#ifdef MPI
      integer reqs_khc(8)
      integer reqs_kvc(8)
#endif

      real, parameter :: cs      = 0.18
      real, parameter :: csinv   = 1.0/cs
      real, parameter :: prandtl = 1.0/3.00
      real, parameter :: prinv   = 1.0/prandtl
      real, parameter :: dmin    = 1.0e-10

!-----------------------------------------------------------------------

      temx = 0.125*dx*dx/dt
      temy = 0.125*dy*dy/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    jloop:  DO j=1,nj

    IF(tconfig.eq.1)THEN
      ! single length scale:  appropriate if dx,dy are nearly the same as dz

      do k=2,nk
      do i=1,ni
        grdscl(i,j,k)=( ((dx*ruh(i))*(dy*rvh(j)))*(dz*rmf(i,j,k)) )**0.33333333
        grdscl(i,j,k) = sqrt(1.0/( 1.0/(grdscl(i,j,k)**2)                                    &
                                  +1.0/((karman*((zf(i,j,k)-zf(i,j,1))+znt(i,j))*csinv)**2)  &
                               ) )
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN
      ! two length scales:  one for horizontal, one for vertical

      do i=1,ni
        tem=sqrt( (dx*ruh(i))*(dy*rvh(j)) )
        do k=2,nk
          lenh(i,j,k)=tem
        enddo
      enddo

      do k=2,nk
      do i=1,ni
        grdscl(i,j,k)=dz*rmf(i,j,k)
        grdscl(i,j,k) = sqrt(1.0/( 1.0/(grdscl(i,j,k)**2)                                    &
                                  +1.0/((karman*((zf(i,j,k)-zf(i,j,1))+znt(i,j))*csinv)**2)  &
                               ) )
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------

    IF(tconfig.eq.1)THEN

      do k=2,nk
      do i=1,ni
        kmh(i,j,k)=((cs*grdscl(i,j,k))**2)     &
                 *sqrt( max(defv(i,j,k)+defh(i,j,k)-nm(i,j,k)*prinv,dmin) )
        kmh(i,j,k) = min( kmh(i,j,k) , temx*ruh(i)*ruh(i)   &
                                     , temy*rvh(j)*rvh(j) )
        kmv(i,j,k)=kmh(i,j,k)
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN

      do k=2,nk
      do i=1,ni
        kmh(i,j,k)=((cs*lenh(i,j,k))**2)     &
                 *sqrt( max(defh(i,j,k),dmin) )
        kmh(i,j,k) = min( kmh(i,j,k) , temx*ruh(i)*ruh(i)   &
                                     , temy*rvh(j)*rvh(j) )
        kmv(i,j,k)=((cs*grdscl(i,j,k))**2)     &
                 *sqrt( max(defv(i,j,k)-nm(i,j,k)*prinv,dmin) )
      enddo
      enddo

    ENDIF

    ENDDO  jloop

    if( nstep.eq.0 .and. myid.eq.0 )then
      print *
      print *,'  cs,csinv = ',cs,csinv
      print *,'  zf,grdscl:'
      i = 1
      j = 1
      do k=2,nk
        print *,k,(zf(i,j,k)-zf(i,j,1)),grdscl(i,j,k)
      enddo
    endif

!--------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()
      call bcw(kmh,1)
      call bcw(kmv,1)
#ifdef MPI
      call comm_1t_start(kmh,khcw1,khcw2,khce1,khce2,   &
                             khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call comm_1t_start(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                             kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call comm_1t_end(kmh,khcw1,khcw2,khce1,khce2,   &
                           khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call comm_1t_end(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                           kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call getcornert(kmh,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      call getcornert(kmv,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      call bct2(kmh)
      call bct2(kmv)
#endif

!--------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    do j=0,nj+1

      do k=1,nk+1
      do i=0,ni+1
        khh(i,j,k)=kmh(i,j,k)*prinv
        ! limit for numerical stability:
        khh(i,j,k) = min( khh(i,j,k) , temx*ruh(i)*ruh(i)   &
                                     , temy*rvh(j)*rvh(j) )
        khv(i,j,k)=kmv(i,j,k)*prinv
      enddo
      enddo

    IF( idiss.eq.1 .or. output_dissten.eq.1 )THEN
    IF( j.ge.1 .and. j.le.nj )THEN
    IF( tconfig.eq.1 )THEN
      do k=2,nk
      do i=1,ni
        dissten(i,j,k) = dissten(i,j,k) + (kmv(i,j,k)**3)/((cs*grdscl(i,j,k))**4)
      enddo
      enddo
    ELSEIF( tconfig.eq.2 )THEN
      do k=2,nk
      do i=1,ni
        dissten(i,j,k) = dissten(i,j,k) + (kmv(i,j,k)**3)/((cs*grdscl(i,j,k))**4)    &
                                        + (kmh(i,j,k)**3)/((cs*lenh(i,j,k))**4)
      enddo
      enddo
    ENDIF
    ENDIF
    ENDIF

    enddo

!--------------------------------------------------------------
!  cm1r18: surface

      IF( bbc.eq.3 )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          kmv(i,j,1) = karman*znt(i,j)*ust(i,j)
        enddo
        enddo

        call bc2d(kmv(ibc,jbc,1))
#ifdef MPI
        call comm_1s2d_start(kmv(ibc,jbc,1),khcw1(1,1),khcw2(1,1),khce1(1,1),khce2(1,1),   &
                                            khcs1(1,1),khcs2(1,1),khcn1(1,1),khcn2(1,1),reqs_khc)
        call comm_1s2d_end(kmv(ibc,jbc,1),khcw1(1,1),khcw2(1,1),khce1(1,1),khce2(1,1),   &
                                          khcs1(1,1),khcs2(1,1),khcn1(1,1),khcn2(1,1),reqs_khc)
        call comm_2d_corner(kmv(ibc,jbc,1))
        call bcs2_2d(kmv(ibc,jbc,1))
#endif

      IF( tconfig.eq.1 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          kmh(i,j,1) = kmv(i,j,1)
          khv(i,j,1) = kmv(i,j,1)*prinv
          khh(i,j,1) = khv(i,j,1)
        enddo
        enddo
      ELSEIF( tconfig.eq.2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          khv(i,j,1) = kmv(i,j,1)*prinv
        enddo
        enddo
      ENDIF

      ENDIF

!--------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end subroutine turbsmag


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbparam(nstep,zf,dt,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,rf, &
                          nm,defv,defh,lvz,kmh,kmv,khh,khv,ua,va,dissten,zs,znt,ust,xland,psfc,tlh,  &
                          nw1,nw2,ne1,ne2,sw1,sw2,se1,se2,                         &
                          khcw1,khcw2,khce1,khce2,khcs1,khcs2,khcn1,khcn2,         &
                          kvcw1,kvcw2,kvce1,kvce2,kvcs1,kvcs2,kvcn1,kvcn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer, intent(in) :: nstep
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in) :: dt
      logical, intent(in) :: dosfcflx
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: th0
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,rth0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rf
      real, dimension(ib:ie,jb:je,kb:ke+1) :: nm,defv,defh
      real, dimension(ib:ie,jb:je,kb:ke) :: lvz
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: dissten
      real, intent(in), dimension(ib:ie,jb:je) :: zs,znt,ust,xland,psfc
      real, intent(inout), dimension(ib:ie,jb:je) :: tlh
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      real, intent(inout), dimension(jmp,kmt) :: khcw1,khcw2,khce1,khce2
      real, intent(inout), dimension(imp,kmt) :: khcs1,khcs2,khcn1,khcn2
      real, intent(inout), dimension(jmp,kmt) :: kvcw1,kvcw2,kvce1,kvce2
      real, intent(inout), dimension(imp,kmt) :: kvcs1,kvcs2,kvcn1,kvcn2

      integer i,j,k
      real :: rlinf,tem,tem1,temx,temy

#ifdef MPI
      integer reqs_khc(8)
      integer reqs_kvc(8)
#endif

      real, parameter :: prandtl = 1.0
      real, parameter :: prinv   = 1.0/prandtl
      real, parameter :: dmin    = 1.0e-10

!--------------------------------------------------------------
!  Smagorinsky-type scheme for parameterized turbulence:
!--------------------------------------------------------------
!  Interior:

!!!    tem = 1.0/(1.0e-6+l_inf)
    rlinf = (1.0e-6+l_inf)**(-2)
    if(ny.eq.1)then
      temx =  0.250*dx*dx/dt
      temy = 1000.0*dy*dy/dt
    elseif(nx.eq.1)then
      temx = 1000.0*dx*dx/dt
      temy =  0.250*dy*dy/dt
    else
      temx =  0.125*dx*dx/dt
      temy =  0.125*dy*dy/dt
    endif

  IF( l_h.gt.1.0e-12 .or. lhref1.gt.1.0e-12 .or. lhref2.gt.1.0e-12 )THEN
    ! cm1r18:
    ! Over water, make tlh a function of surface pressure.
    !   (designed for hurricanes)
    ! Over land, simply set to tlh to l_h.
!$omp parallel do default(shared)   &
!$omp private(i,j)
    do j=1,nj
    do i=1,ni
      IF( (xland(i,j).gt.1.5) .and. (zs(i,j).lt.1.0) )THEN
        ! over water (sea level only):
        tlh(i,j) = lhref2+(lhref1-lhref2)   &
                      *(psfc(i,j)-90000.0)  &
                      /( 101500.0-90000.0)
      ELSE
        ! all other cases:
        tlh(i,j) = l_h
      ENDIF
    enddo
    enddo
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    do k=2,nk
    do j=1,nj
    do i=1,ni
      kmh(i,j,k)=(tlh(i,j)**2)*sqrt( max(defh(i,j,k),dmin) )
      kmh(i,j,k) = min( kmh(i,j,k) , temx*ruh(i)*ruh(i) , temy*rvh(j)*rvh(j) )
    enddo
    enddo
    enddo
  ENDIF
  IF( l_inf.gt.1.0e-12 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    do k=2,nk
    do j=1,nj
    do i=1,ni
      lvz(i,j,k)=sqrt( ( rlinf + (karman*((zf(i,j,k)-zf(i,j,1))+znt(i,j)))**(-2) )**(-1) )
      kmv(i,j,k)=(lvz(i,j,k)**2)*sqrt( max(defv(i,j,k)-nm(i,j,k)*prinv,dmin) )
    enddo
    enddo
    enddo
  ENDIF

!--------------------------------------------------------------
! boundary conditions:

      if(timestats.ge.1) time_turb=time_turb+mytime()

    IF( l_h.gt.1.0e-12 .or. lhref1.gt.1.0e-12 .or. lhref2.gt.1.0e-12 )THEN
      call bcw(kmh,1)
#ifdef MPI
      call comm_1t_start(kmh,khcw1,khcw2,khce1,khce2,   &
                             khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call comm_1t_end(kmh,khcw1,khcw2,khce1,khce2,   &
                           khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call getcornert(kmh,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      call bct2(kmh)
#endif
    ENDIF
    IF( l_inf.gt.1.0e-12 )THEN
      call bcw(kmv,1)
#ifdef MPI
      call comm_1t_start(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                             kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call comm_1t_end(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                           kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call getcornert(kmv,nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
      call bct2(kmv)
#endif
    ENDIF

        do j=0,nj+1
        do i=0,ni+1
          kmh(i,j,1) = 2.0*kmh(i,j,2) - kmh(i,j,3)
        enddo
        enddo

!--------------------------------------------------------------
!  calculate Kh
!  and also limit horizontal coeffs for numerical stability:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem1)
    do j=0,nj+1

    IF( l_h.gt.1.0e-12 .or. lhref1.gt.1.0e-12 .or. lhref2.gt.1.0e-12 )THEN
      do k=1,nk+1
      do i=0,ni+1
        khh(i,j,k)=kmh(i,j,k)*prinv
        khh(i,j,k) = min( khh(i,j,k) , temx*ruh(i)*ruh(i) , temy*rvh(j)*rvh(j) )
      enddo
      enddo
    ENDIF
    IF( l_inf.gt.1.0e-12 )THEN
      do k=1,nk+1
      do i=0,ni+1
        khv(i,j,k)=kmv(i,j,k)*prinv
      enddo
      enddo
    ENDIF

    IF( idiss.eq.1 .or. output_dissten.eq.1 )THEN
    IF( j.ge.1 .and. j.le.nj )THEN
    IF( l_h.gt.1.0e-12 .or. lhref1.gt.1.0e-12 .or. lhref2.gt.1.0e-12 )THEN
      do k=2,nk
      do i=1,ni
        dissten(i,j,k) = dissten(i,j,k) + (kmh(i,j,k)**3)/(tlh(i,j)**4)
      enddo
      enddo
    ENDIF
    IF( l_inf.gt.1.0e-12 )THEN
      do k=2,nk
      do i=1,ni
        dissten(i,j,k) = dissten(i,j,k) + (kmv(i,j,k)**3)/(lvz(i,j,k)**4)
      enddo
      enddo
    ENDIF
    ENDIF
    ENDIF

    enddo

!--------------------------------------------------------------
!  cm1r18: surface

      IF( bbc.eq.3 .and. l_inf.gt.1.0e-12 )THEN

        do j=1,nj
        do i=1,ni
          kmv(i,j,1) = karman*znt(i,j)*ust(i,j)
        enddo
        enddo

        call bc2d(kmv(ibc,jbc,1))
#ifdef MPI
        call comm_1s2d_start(kmv(ibc,jbc,1),khcw1(1,1),khcw2(1,1),khce1(1,1),khce2(1,1),   &
                                            khcs1(1,1),khcs2(1,1),khcn1(1,1),khcn2(1,1),reqs_khc)
        call comm_1s2d_end(kmv(ibc,jbc,1),khcw1(1,1),khcw2(1,1),khce1(1,1),khce2(1,1),   &
                                          khcs1(1,1),khcs2(1,1),khcn1(1,1),khcn2(1,1),reqs_khc)
        call comm_2d_corner(kmv(ibc,jbc,1))
        call bcs2_2d(kmv(ibc,jbc,1))
#endif

        do j=0,nj+1
        do i=0,ni+1
          khv(i,j,1) = kmv(i,j,1)*prinv
        enddo
        enddo

      ENDIF

!--------------------------------------------------------------

      if(nstep.eq.1.and.myid.eq.0)then
        print *,'  k,zf,lvz:  znt = ',znt(1,1)
        do k=2,nk
          print *,k,(zf(1,1,k)-zf(1,1,1)),lvz(1,1,k)
        enddo
      endif

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end subroutine turbparam


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      ! gettau
      subroutine gettau(xf,rxf,arf1,arf2,ust,u1,v1,s1,rf,  &
                        kmh,kmv,t11,t12,t13,t22,t23,t33,ua)
      implicit none
      
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie+1) :: xf,rxf,arf1,arf2
      real, intent(in), dimension(ib:ie,jb:je) :: ust,u1,v1,s1
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rf
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
        
      integer i,j,k
      real :: tem

!----------------------------------------------------------------------
!
!  This subroutine calculates the subgrid stress terms.
!
!    t_ij  =  2 * rho * K * S_ij
!
!  NOTE:  upon entering this subroutine, the t_ij arrays must already 
!         contain rho * S_ij  (see calcdef subroutine)
!
!  Since cm1r18, surface stress (ie, surface drag) is incorporated into
!  the stress arrays here.
!
!  Note:  Turbulent viscosities are defined on w points.
!
!  Note:  For axisymmetric simulations, t11 and t12 herein are 
!         actually not stresses:  the actual stresses are
!         combined in a convienent form for the sake of flux-form
!         calculations in the turbu and turbv subroutines.
!         Also note that t22 is never calculated.
!         So, if you need the actual stress components for something, 
!         beware that you will need to re-calculate t11,t12,t22.
!
!----------------------------------------------------------------------

  IF(axisymm.eq.0)THEN

    ! Cartesian grid:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
    do k=1,nk

      do j=0,nj+1
      do i=0,ni+1
        !  2.0 * 0.5 = 1.0
        tem = (kmh(i,j,k)+kmh(i,j,k+1))
        t11(i,j,k)=t11(i,j,k)*tem
        t22(i,j,k)=t22(i,j,k)*tem
        t33(i,j,k)=t33(i,j,k)*tem
      enddo
      enddo

      do j=1,nj+1
      do i=1,ni+1
        !  2.0 * 0.125 = 0.25
        t12(i,j,k)=t12(i,j,k)*0.25                                            &
     *( ( (kmh(i-1,j-1,k  )+kmh(i,j,k  ))+(kmh(i-1,j,k  )+kmh(i,j-1,k  )) )   &
       +( (kmh(i-1,j-1,k+1)+kmh(i,j,k+1))+(kmh(i-1,j,k+1)+kmh(i,j-1,k+1)) ) )
      enddo
      enddo
          !-----
          ! lateral boundary conditions:
          if(wbc.eq.3.and.ibw.eq.1)then
            ! free slip b.c.
            do j=1,nj+1
              t12(1,j,k) = t12(2,j,k)
            enddo
          endif
          if(ebc.eq.3.and.ibe.eq.1)then
            ! free slip b.c.
            do j=1,nj+1
              t12(ni+1,j,k) = t12(ni,j,k)
            enddo
          endif
          !-----
          !-----
          if(sbc.eq.3.and.ibs.eq.1)then
            ! free slip b.c.
            do i=1,ni+1
              t12(i,1,k) = t12(i,2,k)
            enddo
          endif
          if(nbc.eq.3.and.ibn.eq.1)then
            ! free slip b.c.
            do i=1,ni+1
              t12(i,nj+1,k) = t12(i,nj,k)
            enddo
          endif
          !-----

    IF(k.ge.2)THEN
      do j=1,nj+1
      do i=1,ni+1
        !  2.0 x 0.5 = 1.0
        t13(i,j,k)=t13(i,j,k)*( kmv(i-1,j,k)+kmv(i,j,k) )
        t23(i,j,k)=t23(i,j,k)*( kmv(i,j-1,k)+kmv(i,j,k) )
      enddo
      enddo
            !-----
            ! lateral boundary conditions:
            if(wbc.eq.3.and.ibw.eq.1)then
              ! free slip b.c.
              do j=1,nj
                t13(1,j,k) = t13(2,j,k)
              enddo
            endif
            if(ebc.eq.3.and.ibe.eq.1)then
              ! free slip b.c.
              do j=1,nj
                t13(ni+1,j,k) = t13(ni,j,k)
              enddo
            endif
            !-----
            !-----
            if(sbc.eq.3.and.ibs.eq.1)then
              ! free slip b.c.
              do i=1,ni
                t23(i,1,k) = t23(i,2,k)
              enddo
            endif
            if(nbc.eq.3.and.ibn.eq.1)then
              ! free slip b.c.
              do i=1,ni
                t23(i,nj+1,k) = t23(i,nj,k)
              enddo
            endif
            !-----
    ENDIF

    enddo

!------------------------------------

  ELSE

    ! axisymmetric grid:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
    DO k=1,nk

      do j=1,nj
      do i=1,ni+1
        !  2.0 * 0.5 = 1.0
        tem = (kmh(i,j,k)+kmh(i,j,k+1))
        t11(i,j,k)=t11(i,j,k)*tem
        t33(i,j,k)=t33(i,j,k)*tem
        !  2.0 * 0.25  =  0.5
        t12(i,j,k)=0.5*t12(i,j,k)*( arf2(i)*(kmh(i  ,j,k+1)+kmh(i  ,j,k)) &
                                   +arf1(i)*(kmh(i-1,j,k+1)+kmh(i-1,j,k)) )
      enddo
      enddo
          !-----
          ! lateral boundary conditions:
          j = 1
          if(wbc.eq.3)then
            ! free slip b.c.
!!!            t12(1,j,k) = t12(2,j,k)
            t12(1,j,k) = 0.0
          endif
          if(ebc.eq.3)then
            ! free slip b.c.
            t12(ni+1,j,k) = t12(ni,j,k)
          endif
          !-----
    IF(k.ge.2)THEN
      do j=1,nj
      do i=1,ni+1
        !  2.0 * 0.5  =  1.0
        t13(i,j,k)=t13(i,j,k)*( arf1(i)*kmv(i-1,j,k)+arf2(i)*kmv(i,j,k) )
        t23(i,j,k)=2.0*t23(i,j,k)*kmv(i,j,k)
      enddo
      enddo
    ENDIF

    ENDDO

  ENDIF

!------------------------------------------------------------------
!  open boundary conditions:

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=1,nk
        !-----
        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=0,nj+1
            t11(0,j,k) = t11(1,j,k)
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=0,nj+1
            t11(ni+1,j,k) = t11(ni,j,k)
          enddo
        ENDIF
        !-----
        !ccccc
        !-----
        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=0,ni+1
            t22(i,0,k) = t22(i,1,k)
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=0,ni+1
            t22(i,nj+1,k) = t22(i,nj,k)
          enddo
        ENDIF
        !-----
        !ccccc
        !-----
        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj+1
            t12(1,j,k) = t12(2,j,k)
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj+1
            t12(ni+1,j,k) = t12(ni,j,k)
          enddo
        ENDIF
        !-----
        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni+1
            t12(i,1,k) = t12(i,2,k)
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni+1
            t12(i,nj+1,k) = t12(i,nj,k)
          enddo
        ENDIF
        !-----
        ! corner points:
        !-----
        IF( sbc.eq.2 .and. ibs.eq.1 .and. &
            wbc.eq.2 .and. ibw.eq.1 )THEN
          t12(1,1,k) = t12(2,2,k)
        ENDIF
        IF( sbc.eq.2 .and. ibs.eq.1 .and. &
            ebc.eq.2 .and. ibe.eq.1 )THEN
          t12(ni+1,1,k) = t12(ni,2,k)
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 .and. &
            wbc.eq.2 .and. ibw.eq.1 )THEN
          t12(1,nj+1,k) = t12(2,nj,k)
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 .and. &
            ebc.eq.2 .and. ibe.eq.1 )THEN
          t12(ni+1,nj+1,k) = t12(ni,nj,k)
        ENDIF
        !-----
      ENDDO
    ENDIF

!--------------------------------------------------------------
!  lower boundary conditions

    IF(bbc.eq.1)THEN
      ! free slip:

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni+1
        t13(i,j,1)=t13(i,j,2)
        t23(i,j,1)=t23(i,j,2)
      enddo
      enddo

    ELSEIF(bbc.eq.2)THEN
      ! no slip:

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni+1
          t13(i,j,1)=t13(i,j,1)*0.5*( kmv(i-1,j,2)+kmv(i,j,2) )
          t23(i,j,1)=t23(i,j,1)*0.5*( kmv(i,j-1,2)+kmv(i,j,2) )
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni+1
          t13(i,j,1)=t13(i,j,1)*0.5*( arf1(i)*kmv(i-1,j,2)+arf2(i)*kmv(i,j,2) )
          t23(i,j,1)=t23(i,j,1)*kmv(i,j,2)
        enddo
        enddo

      ENDIF

    ELSEIF(bbc.eq.3)THEN
      !--------------------------------------------------------!
      !--------  surface stress for semi-slip lower bc --------!
      !-------- (this is where "drag" is set for bbc=3) -------!

      IF(axisymm.eq.0)THEN

        ! Cartesian grid:
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni+1
        t13(i,j,1) = 0.25*( (ust(i-1,j)**2)*(u1(i-1,j)/max(s1(i-1,j),0.01))    &
                           +(ust(i  ,j)**2)*(u1(i  ,j)/max(s1(i  ,j),0.01)) )  &
                         *( rf(i-1,j,1)+rf(i,j,1) )
        t23(i,j,1) = 0.25*( (ust(i,j-1)**2)*(v1(i,j-1)/max(s1(i,j-1),0.01))    &
                           +(ust(i,j  )**2)*(v1(i,j  )/max(s1(i,j  ),0.01)) )  &
                         *( rf(i,j-1,1)+rf(i,j,1) )
      enddo
      enddo

      ELSE

        ! axisymmetric grid:
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni+1
        t13(i,j,1) = 0.25*( arf1(i)*(ust(i-1,j)**2)*(u1(i-1,j)/max(s1(i-1,j),0.01))    &
                           +arf2(i)*(ust(i  ,j)**2)*(u1(i  ,j)/max(s1(i  ,j),0.01)) )  &
                         *(arf1(i)*rf(i-1,j,1)+arf2(i)*rf(i,j,1))
        t23(i,j,1) = rf(i,j,1)*(ust(i,j)**2)*(v1(i,j)/max(s1(i,j),0.01))
      enddo
      enddo

      ENDIF

    ENDIF

!--------------------------------------------------------------
!  upper boundary conditions

    IF(tbc.eq.1)THEN
      ! free slip:

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni+1
        t13(i,j,nk+1)=t13(i,j,nk)
        t23(i,j,nk+1)=t23(i,j,nk)
      enddo
      enddo

    ELSEIF(tbc.eq.2)THEN
      ! no slip:

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni+1
          t13(i,j,nk+1)=t13(i,j,nk+1)*0.5*( kmv(i-1,j,nk)+kmv(i,j,nk) )
          t23(i,j,nk+1)=t23(i,j,nk+1)*0.5*( kmv(i,j-1,nk)+kmv(i,j,nk) )
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni+1
          t13(i,j,nk+1)=t13(i,j,nk+1)*0.5*( arf1(i)*kmv(i-1,j,nk)+arf2(i)*kmv(i,j,nk) )
          t23(i,j,nk+1)=t23(i,j,nk+1)*kmv(i,j,nk)
        enddo
        enddo

      ENDIF

    ENDIF

!--------------------------------------------------------------

    IF( axisymm.eq.1 )THEN
      ! lateral boundary condition:
!$omp parallel do default(shared)   &
!$omp private(k)
      do k=0,nk+1
        t13(1,1,k)=0.0
      enddo
    ENDIF

!--------------------------------------------------------------
!  finished

      if(timestats.ge.1) time_turb=time_turb+mytime()
 
      return
      end subroutine gettau
      ! gettau


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      ! calcdef
      subroutine calcdef(rds,sigma,rdsf,sigmaf,zs,gz,rgz,gzu,rgzu,gzv,rgzv,                &
                     xh,rxh,arh1,arh2,uh,xf,rxf,arf1,arf2,uf,vh,vf,mh,c1,c2,mf,defv,defh,  &
                     dum1,dum2,ua,va,wa,s11,s12,s13,s22,s23,s33,gx,gy,rho,rr,rf)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv
      real, intent(in), dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf
      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh,c1,c2
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: defv,defh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: s11,s12,s13,s22,s23,s33
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gy
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr,rf
        
      integer :: i,j,k
      real :: r1,r2,r3,r4
      real :: tmp11,tmp22,tmp33,tmp12,tmp13,tmp23,rrf
      real :: temz

!----------------------------------------------------------------------
!
!  This subroutine calculates the strain rate terms
!
!    S_ij  =  0.5 * ( d(u_i)/d(x_j) + d(u_j)/d(x_i) )
!
!  (note: multiplied by density herein)
!  and then uses these variables to calculate deformation.
!
!  Note:
!  Since cm1r18, surface stress (ie, surface drag) is no longer 
!  calculated in this subroutine.  See gettau subroutine instead.
!
!  Note:  For axisymmetric simulations, s11 and s12 herein are 
!         actually not rate-of-strain components:  the actual 
!         components have been combined mathematically in a 
!         way to be consistent with the flux-form calculations 
!         in the turbu and turbv subroutines.
!         Also note that s22 is never calculated.
!         So, if you need the actual strain components for something, 
!         beware that you will need to re-calculate s11,s12,s22.
!
!----------------------------------------------------------------------

  IF(.not.terrain_flag)THEN

  IF( axisymm.eq.0 )THEN
    ! Cartesian without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,temz)
    DO k=1,nk

      temz = rdz*mh(1,1,k)

      do j=0,nj+1
      do i=0,ni+1 
        s11(i,j,k)=rho(i,j,k)*(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)
        s22(i,j,k)=rho(i,j,k)*(va(i,j+1,k)-va(i,j,k))*rdy*vh(j)
        s33(i,j,k)=rho(i,j,k)*(wa(i,j,k+1)-wa(i,j,k))*temz
      enddo
      enddo
      do j=1,nj+1 
      do i=1,ni+1
        s12(i,j,k)=0.5*( (ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)   &
                        +(va(i,j,k)-va(i-1,j,k))*rdx*uf(i) ) &
              *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
      enddo
      enddo       
          !-----
          ! lateral boundary conditions:
          if(wbc.eq.3.and.ibw.eq.1)then
            ! free slip b.c.
            do j=1,nj+1
              s12(1,j,k) = s12(2,j,k)
            enddo
          elseif(wbc.eq.4.and.ibw.eq.1)then
            ! no slip b.c.
            i = 1
            do j=1,nj+1
              s12(1,j,k) = 2.0*va(1,j,k)*rdx*uf(1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          if(ebc.eq.3.and.ibe.eq.1)then
            ! free slip b.c.
            do j=1,nj+1
              s12(ni+1,j,k) = s12(ni,j,k)
            enddo
          elseif(ebc.eq.4.and.ibe.eq.1)then
            ! no slip b.c.
            i = ni+1
            do j=1,nj+1
              s12(ni+1,j,k) = -2.0*va(ni,j,k)*rdx*uf(ni+1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          !-----
          !-----
          if(sbc.eq.3.and.ibs.eq.1)then
            ! free slip b.c.
            do i=1,ni+1
              s12(i,1,k) = s12(i,2,k)
            enddo
          elseif(sbc.eq.4.and.ibs.eq.1)then
            ! no slip b.c.
            j = 1
            do i=1,ni+1
              s12(i,1,k) = 2.0*ua(i,1,k)*rdy*vf(1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          if(nbc.eq.3.and.ibn.eq.1)then
            ! free slip b.c.
            do i=1,ni+1
              s12(i,nj+1,k) = s12(i,nj,k)
            enddo
          elseif(nbc.eq.4.and.ibn.eq.1)then
            ! no slip b.c.
            j = nj+1
            do i=1,ni+1
              s12(i,nj+1,k) = -2.0*ua(i,nj,k)*rdy*vf(nj+1)   &
                   *0.25*( (rho(i-1,j-1,k)+rho(i,j,k))+(rho(i-1,j,k)+rho(i,j-1,k)) )
            enddo
          endif
          !-----
    IF(k.ge.2)THEN
      do j=1,nj
      do i=1,ni+1
        s13(i,j,k)=0.5*( (wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)   &
                        +(ua(i,j,k)-ua(i,j,k-1))*rdz*0.5*(mf(i-1,j,k)+mf(i,j,k))  &
                       )*0.5*( rf(i-1,j,k)+rf(i,j,k) )
      enddo
      enddo
            !-----
            ! lateral boundary conditions:
            if(wbc.eq.3.and.ibw.eq.1)then
              ! free slip b.c.
              do j=1,nj
                s13(1,j,k) = s13(2,j,k)
              enddo
            elseif(wbc.eq.4.and.ibw.eq.1)then
              ! no slip b.c.
              do j=1,nj
                s13(1,j,k) = 2.0*wa(1,j,k)*rdx*uf(1)
              enddo
            endif
            if(ebc.eq.3.and.ibe.eq.1)then
              ! free slip b.c.
              do j=1,nj
                s13(ni+1,j,k) = s13(ni,j,k)
              enddo
            elseif(ebc.eq.4.and.ibe.eq.1)then
              ! no slip b.c.
              do j=1,nj
                s13(ni+1,j,k) = -2.0*wa(ni,j,k)*rdx*uf(ni+1)
              enddo
            endif
            !-----
      do j=1,nj+1   
      do i=1,ni
        s23(i,j,k)=0.5*( (wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j)   &
                        +(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))  &
                       )*0.5*( rf(i,j-1,k)+rf(i,j,k) )
      enddo
      enddo
            !-----
            if(sbc.eq.3.and.ibs.eq.1)then
              ! free slip b.c.
              do i=1,ni
                s23(i,1,k) = s23(i,2,k)
              enddo
            elseif(sbc.eq.4.and.ibs.eq.1)then
              ! no slip b.c.
              do i=1,ni
                s23(i,1,k) = 2.0*wa(i,1,k)*rdy*vf(1)
              enddo
            endif
            if(nbc.eq.3.and.ibn.eq.1)then
              ! free slip b.c.
              do i=1,ni
                s23(i,nj+1,k) = s23(i,nj,k)
              enddo
            elseif(nbc.eq.4.and.ibn.eq.1)then
              ! no slip b.c.
              do i=1,ni
                s23(i,nj+1,k) = -2.0*wa(i,nj,k)*rdy*vf(nj+1)
              enddo
            endif
            !-----
    ENDIF  ! endif for k.ge.2

    ENDDO  ! endif for k-loop

!-------------------------------------------------------------------------------

  ELSE
    ! axisymmetric:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=1,nk

      do j=1,nj
      do i=1,ni+1
        s11(i,j,k)=rho(i,j,k)*(ua(i+1,j,k)*arf1(i+1)-ua(i,j,k)*arf2(i))*rdx*uh(i)
        s33(i,j,k)=rho(i,j,k)*(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(1,1,k)
        !  0.5 * 0.5  =  0.25
        s12(i,j,k)=0.25*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))   &
                       *(arh1(i)*va(i,j,k)-arh2(i-1)*va(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
          !-----
          ! lateral boundary conditions:
          j = 1
          if(wbc.eq.3)then
            ! free slip b.c.
!!!            s12(1,j,k) = s12(2,j,k)
            s12(1,j,k) = 0.0
          elseif(wbc.eq.4)then
            ! no slip b.c.
            i = 1
            s12(1,j,k) = 2.0*va(1,j,k)*rdx*uf(1)   &
                      *0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))
          endif
          if(ebc.eq.3)then
            ! free slip b.c.
            s12(ni+1,j,k) = s12(ni,j,k)
          elseif(ebc.eq.4)then
            ! no slip b.c.
            i = ni+1
            s12(ni+1,j,k) = -2.0*va(ni,j,k)*rdx*uf(ni+1)   &
                      *0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))
          endif
          !-----
    IF(k.ge.2)THEN
      do j=1,nj
      do i=1,ni+1
        !  0.5 * 0.5  =  0.25
        s13(i,j,k)=0.25*(arf1(i)*rf(i-1,j,k)+arf2(i)*rf(i,j,k))  &
                       *( (ua(i,j,k)-ua(i,j,k-1))*rdz*mf(1,1,k)  &
                         +(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i) )
        s23(i,j,k)=0.5*rf(i,j,k)*(va(i,j,k)-va(i,j,k-1))*rdz*mf(1,1,k)
      enddo
      enddo
    ENDIF  ! endif for k.ge.2

    ENDDO  ! endif for k-loop

  ENDIF

!-------------------------------------------------------------------------------
!  Cartesian with terrain:

  ELSE

    ! dum1 stores u at w-pts:
    ! dum2 stores v at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
    do j=0,nj+2
      ! lowest model level:
      do i=0,ni+2
        dum1(i,j,1) = cgs1*ua(i,j,1)+cgs2*ua(i,j,2)+cgs3*ua(i,j,3)
        dum2(i,j,1) = cgs1*va(i,j,1)+cgs2*va(i,j,2)+cgs3*va(i,j,3)
      enddo

      ! upper-most model level:
      do i=0,ni+2
        dum1(i,j,nk+1) = cgt1*ua(i,j,nk)+cgt2*ua(i,j,nk-1)+cgt3*ua(i,j,nk-2)
        dum2(i,j,nk+1) = cgt1*va(i,j,nk)+cgt2*va(i,j,nk-1)+cgt3*va(i,j,nk-2)
      enddo

      ! interior:
      do k=2,nk
      r2 = (sigmaf(k)-sigma(k-1))*rds(k)
      r1 = 1.0-r2
      do i=0,ni+2
        dum1(i,j,k) = r1*ua(i,j,k-1)+r2*ua(i,j,k)
        dum2(i,j,k) = r1*va(i,j,k-1)+r2*va(i,j,k)
      enddo
      enddo
    enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1)
    DO k=1,nk
      do j=0,nj+1
      do i=0,ni+1 
        s11(i,j,k)=gz(i,j)*(ua(i+1,j,k)*rgzu(i+1,j)-ua(i,j,k)*rgzu(i,j))*rdx*uh(i) &
                  +( gx(i,j,k+1)*(dum1(i,j,k+1)+dum1(i+1,j,k+1))      &
                    -gx(i,j,k  )*(dum1(i,j,k  )+dum1(i+1,j,k  ))      &
                   )*0.5*rdsf(k)
        s11(i,j,k)=s11(i,j,k)*rho(i,j,k)
        s22(i,j,k)=gz(i,j)*(va(i,j+1,k)*rgzv(i,j+1)-va(i,j,k)*rgzv(i,j))*rdy*vh(j) &
                  +( gy(i,j,k+1)*(dum2(i,j,k+1)+dum2(i,j+1,k+1))      &
                    -gy(i,j,k  )*(dum2(i,j,k  )+dum2(i,j+1,k  ))      &
                   )*0.5*rdsf(k)
        s22(i,j,k)=s22(i,j,k)*rho(i,j,k)
        s33(i,j,k)=(wa(i,j,k+1)-wa(i,j,k))*rdsf(k)*gz(i,j)
        s33(i,j,k)=s33(i,j,k)*rho(i,j,k)
      enddo
      enddo
      do j=1,nj+1 
      do i=1,ni+1
        r1 = 0.25*( ( rho(i-1,j-1,k)*gz(i-1,j-1)   &
                     +rho(i  ,j  ,k)*gz(i  ,j  ) ) &
                   +( rho(i-1,j  ,k)*gz(i-1,j  )   &
                     +rho(i  ,j-1,k)*gz(i  ,j-1) ) )
        s12(i,j,k)=0.5*(                                                         &
                   ( r1*(ua(i,j,k)*rgzu(i,j)-ua(i,j-1,k)*rgzu(i,j-1))*rdy*vf(j)  &
                    +0.5*( (zt-sigmaf(k+1))*(dum1(i,j-1,k+1)+dum1(i,j,k+1))      &
                          -(zt-sigmaf(k  ))*(dum1(i,j-1,k  )+dum1(i,j,k  ))      &
                         )*rdsf(k)*r1*(rgzu(i,j)-rgzu(i,j-1))*rdy*vf(j) )        &
                  +( r1*(va(i,j,k)*rgzv(i,j)-va(i-1,j,k)*rgzv(i-1,j))*rdx*uf(i)  &
                    +0.5*( (zt-sigmaf(k+1))*(dum2(i-1,j,k+1)+dum2(i,j,k+1))      &
                          -(zt-sigmaf(k  ))*(dum2(i-1,j,k  )+dum2(i,j,k  ))      &
                         )*rdsf(k)*r1*(rgzv(i,j)-rgzv(i-1,j))*rdx*uf(i) )    )
      enddo
      enddo       
    ENDDO

    ! now, dum1 stores w at scalar-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=1,nk
      do j=0,nj+1
      do i=0,ni+1
        dum1(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
      enddo
      enddo
    ENDDO
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=2,nk
      do j=1,nj
      do i=1,ni+1
        s13(i,j,k)=0.5*(                                                              &
                   (ua(i,j,k)-ua(i,j,k-1))*rds(k)                                     &
                  +(wa(i,j,k)*rgz(i,j)-wa(i-1,j,k)*rgz(i-1,j))*rdx*uf(i)              &
                  +0.5*rds(k)*( (zt-sigma(k  ))*(dum1(i,j,k  )+dum1(i-1,j,k  ))       &
                               -(zt-sigma(k-1))*(dum1(i,j,k-1)+dum1(i-1,j,k-1)) )     &
                             *(rgz(i,j)-rgz(i-1,j))*rdx*uf(i)                         )
        s13(i,j,k)=s13(i,j,k)*0.5*( gz(i-1,j)*rf(i-1,j,k)+gz(i,j)*rf(i,j,k) )
      enddo
      enddo
      do j=1,nj+1   
      do i=1,ni
        s23(i,j,k)=0.5*(                                                              &
                   (va(i,j,k)-va(i,j,k-1))*rds(k)                                     &
                  +(wa(i,j,k)*rgz(i,j)-wa(i,j-1,k)*rgz(i,j-1))*rdy*vf(j)              &
                  +0.5*rds(k)*( (zt-sigma(k  ))*(dum1(i,j,k  )+dum1(i,j-1,k  ))       &
                               -(zt-sigma(k-1))*(dum1(i,j,k-1)+dum1(i,j-1,k-1)) )     &
                             *(rgz(i,j)-rgz(i,j-1))*rdy*vf(j)                         )
        s23(i,j,k)=s23(i,j,k)*0.5*( gz(i,j-1)*rf(i,j-1,k)+gz(i,j)*rf(i,j,k) )
      enddo
      enddo
    ENDDO

  ENDIF

!  end of calculations for terrain
!-------------------------------------------------------------------------------
!  open boundary conditions:

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=1,nk
        !-----
        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=0,nj+1
            s11(0,j,k) = s11(1,j,k)
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=0,nj+1
            s11(ni+1,j,k) = s11(ni,j,k)
          enddo
        ENDIF
        !-----
        !ccccc
        !-----
        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=0,ni+1
            s22(i,0,k) = s22(i,1,k)
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=0,ni+1
            s22(i,nj+1,k) = s22(i,nj,k)
          enddo
        ENDIF
        !-----
        !ccccc
        !-----
        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj+1
            s12(1,j,k) = s12(2,j,k)
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj+1
            s12(ni+1,j,k) = s12(ni,j,k)
          enddo
        ENDIF
        !-----
        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni+1
            s12(i,1,k) = s12(i,2,k)
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni+1
            s12(i,nj+1,k) = s12(i,nj,k)
          enddo
        ENDIF
        !-----
        ! corner points:
        !-----
        IF( sbc.eq.2 .and. ibs.eq.1 .and. &
            wbc.eq.2 .and. ibw.eq.1 )THEN
          s12(1,1,k) = s12(2,2,k)
        ENDIF
        IF( sbc.eq.2 .and. ibs.eq.1 .and. &
            ebc.eq.2 .and. ibe.eq.1 )THEN
          s12(ni+1,1,k) = s12(ni,2,k)
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 .and. &
            wbc.eq.2 .and. ibw.eq.1 )THEN
          s12(1,nj+1,k) = s12(2,nj,k)
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 .and. &
            ebc.eq.2 .and. ibe.eq.1 )THEN
          s12(ni+1,nj+1,k) = s12(ni,nj,k)
        ENDIF
        !-----
      ENDDO
    ENDIF

!----------------------------------------------------------------------
!  if l_h or l_v is zero, set appropriate terms to zero:
!    (just to be sure)

    IF( iturb.eq.3 .and. l_h*lhref1*lhref2.lt.1.0e-12 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        s11(i,j,k) = 0.0
        s12(i,j,k) = 0.0
        s33(i,j,k) = 0.0
        s22(i,j,k) = 0.0
      enddo
      enddo
      enddo
    ENDIF

    IF( iturb.eq.3 .and. l_inf.lt.tsmall )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        s13(i,j,k) = 0.0
        s23(i,j,k) = 0.0
      enddo
      enddo
      enddo
    ENDIF

!--------------------------------------------------------------

    IF( axisymm.eq.1 )THEN
      ! lateral boundary condition:
!$omp parallel do default(shared)   &
!$omp private(k)
      do k=0,nk+1
        s13(1,1,k)=0.0
      enddo
    ENDIF

!----------------------------------------------------------------------
!  calculate deformation:
!  Note:  deformation is defined at w points.

    IF(axisymm.eq.0)THEN
      ! Cartesian domain:

      ! Def = 2.0 * S_ij * S_ij
      !
      !     = 2.0 * (  S11*S11 + S12*S12 + S13*S13 
      !              + S21*S21 + S22*S22 + S23*S23 
      !              + S31*S31 + S32*S32 + S33*S33 )
      !
      !     =   2.0*( S11*S11 + S22*S22 + S33*S33 )
      !       + 4.0*( S12*S12 + S13*S13 + S23*S23 )

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23,rrf)
      do k=2,nk
      do j=1,nj
      do i=1,ni

        tmp11=( c1(i,j,k)*s11(i,j,k-1)**2 + c2(i,j,k)*s11(i,j,k)**2 )
        tmp22=( c1(i,j,k)*s22(i,j,k-1)**2 + c2(i,j,k)*s22(i,j,k)**2 )
        tmp33=( c1(i,j,k)*s33(i,j,k-1)**2 + c2(i,j,k)*s33(i,j,k)**2 )

        tmp12=0.25*( c1(i,j,k)*( ( s12(i,j  ,k-1)**2 + s12(i+1,j+1,k-1)**2 )     &
                               + ( s12(i,j+1,k-1)**2 + s12(i+1,j  ,k-1)**2 ) )   &
                    +c2(i,j,k)*( ( s12(i,j  ,k  )**2 + s12(i+1,j+1,k  )**2 )     &
                               + ( s12(i,j+1,k  )**2 + s12(i+1,j  ,k  )**2 ) ) )

        tmp13=0.5*( s13(i,j,k)**2 + s13(i+1,j,k)**2 )

        tmp23=0.5*( s23(i,j,k)**2 + s23(i,j+1,k)**2 )

        rrf = 1.0/(rf(i,j,k)**2)

        defv(i,j,k)= 4.0*( tmp13 + tmp23 )*rrf

        defh(i,j,k) = ( 2.0*( ( tmp11 + tmp22 ) + tmp33 ) + 4.0*tmp12 )*rrf

      enddo
      enddo
      enddo

!--------------------------------------------
    ELSE
      ! axisymmetric domain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23,rrf,r1,r2,r3,r4)
      do k=2,nk
      do j=1,nj
      do i=1,ni

        tmp11=( c1(1,1,k)*(s11(i,j,k-1)**2) + c2(1,1,k)*(s11(i,j,k)**2) )
        tmp33=( c1(1,1,k)*(s33(i,j,k-1)**2) + c2(1,1,k)*(s33(i,j,k)**2) )

        tmp12=0.5*(  c1(1,1,k)*( s12(i,j  ,k-1)**2 + s12(i+1,j  ,k-1)**2 )     &
                   + c2(1,1,k)*( s12(i,j  ,k  )**2 + s12(i+1,j  ,k  )**2 ) )

        tmp13=0.5*( s13(i,j,k)**2 + s13(i+1,j,k)**2 )

        tmp23=      s23(i,j,k)**2

        rrf = 1.0/(rf(i,j,k)**2)

        defv(i,j,k)= 4.0*( tmp13 + tmp23 )*rrf

        defh(i,j,k) = ( 2.0*( tmp11 + tmp33 ) + 4.0*tmp12 )*rrf

      enddo
      enddo
      enddo

    ENDIF  ! endif for axisymm

!--------------------------------------------------------------
!  finished

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end subroutine calcdef
      ! calcdef


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine calcnm(c1,c2,mf,pi0,thv0,th0,cloudvar,nm,t,qt,thv,cloud,   &
                        prs,pp,th,qa)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      logical, dimension(maxq) :: cloudvar
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,th0
      real, dimension(ib:ie,jb:je,kb:ke+1) :: nm
      real, dimension(ib:ie,jb:je,kb:ke) :: t,qt,thv,cloud,prs
      real, dimension(ib:ie,jb:je,kb:ke) :: pp,th
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa

      integer i,j,k,n
      real pavg,tavg,qtavg,esl,qvs,lhv,cpml,gamma,qiavg,qsavg,qgavg,drdt
      real qlavg,qvl,qvi,fliq,fice,nmtmp

!----------------------------------------------------------------------
!  Dry nm

    IF(imoist.eq.0)then

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    do j=1,nj

      do k=2,nk
      do i=1,ni
        nm(i,j,k)=alog( (th0(i,j,k)+th(i,j,k))/(th0(i,j,k-1)+th(i,j,k-1)) ) &
                    *g*rdz*mf(i,j,k)
      enddo
      enddo
      do i=1,ni
        nm(i,j,   1)=0.0
        nm(i,j,nk+1)=0.0
      enddo

    enddo

!-----------------------------------------------------------------------
!  Moist nm

    ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,pavg,tavg,qtavg,esl,qvs,lhv,cpml,drdt,gamma,nmtmp)
    DO j=1,nj

      do k=1,nk
      do i=1,ni
        t(i,j,k)=(th0(i,j,k)+th(i,j,k))*(pi0(i,j,k)+pp(i,j,k))
      enddo
      enddo

      do k=1,nk
      do i=1,ni
        qt(i,j,k)=0.0
      enddo
      enddo

      DO n=1,numq
        IF( (n.eq.nqv) .or.                                 &
            (n.ge.nql1.and.n.le.nql2) .or.                  &
            (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
          do k=1,nk
          do i=1,ni
            qt(i,j,k)=qt(i,j,k)+qa(i,j,k,n)
          enddo
          enddo
        ENDIF
      ENDDO

      do k=1,nk
      do i=1,ni
        thv(i,j,k)=(th0(i,j,k)+th(i,j,k))*(1.0+reps*qa(i,j,k,nqv))   &
                                         /(1.0+qt(i,j,k))
      enddo
      enddo

      do k=2,nk
      do i=1,ni
        nm(i,j,k)=g*alog(thv(i,j,k)/thv(i,j,k-1))*rdz*mf(i,j,k)
      enddo
      enddo

      do i=1,ni
        nm(i,j,   1)=0.0
        nm(i,j,nk+1)=0.0
      enddo

      do k=1,nk
      do i=1,ni
        cloud(i,j,k)=0.0
      enddo
      enddo
      do n=1,numq
        if(cloudvar(n))then
          do k=1,nk
          do i=1,ni
            cloud(i,j,k)=cloud(i,j,k)+qa(i,j,k,n)
          enddo
          enddo
        endif
      enddo

      do k=2,nk
      do i=1,ni
        IF( (cloud(i,j,k).ge.clwsat) .or. (cloud(i,j,k-1).ge.clwsat) )THEN
          pavg = c1(i,j,k)*prs(i,j,k-1)+c2(i,j,k)*prs(i,j,k)
          tavg =   c1(i,j,k)*t(i,j,k-1)+  c2(i,j,k)*t(i,j,k)
          qtavg=  c1(i,j,k)*qt(i,j,k-1)+ c2(i,j,k)*qt(i,j,k)
          esl = 611.2*exp( 17.67 * ( tavg - 273.15 ) / ( tavg - 29.65 ) )
          qvs = eps*esl/(pavg-esl)
          lhv=lv1-lv2*tavg
          cpml=cp+cpv*qvs+cpl*(qtavg-qvs)

          drdt=17.67*(273.15-29.65)*qvs/((tavg-29.65)**2)
          gamma=g*(1.0+qtavg)*(1.0+lhv*qvs/(rd*tavg))/(cpml+lhv*drdt)
          nmtmp=g*( ( alog(t(i,j,k)/t(i,j,k-1))*rdz*mf(i,j,k)      &
                            +gamma/tavg )*(1.0+tavg*drdt/(eps+qvs))   &
                         -alog((1.0+qt(i,j,k))/(1.0+qt(i,j,k-1)))*rdz*mf(i,j,k) )
        IF( (cloud(i,j,k).ge.clwsat) .and. (cloud(i,j,k-1).ge.clwsat) )THEN
          nm(i,j,k)=nmtmp
        ELSE
          nm(i,j,k)=0.5*(nm(i,j,k)+nmtmp)
        ENDIF
        ENDIF
      enddo
      enddo

    ENDDO

    ENDIF    ! endif for imoist

!----------------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end subroutine calcnm


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbs(iflux,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,sflux,  &
                       rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                       turbx,turby,turbz,dumx,dumy,dumz,rho,rr,rf,s,sten,khh,khv,dum7,dum8)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer iflux
      real :: dt
      logical, intent(in) :: dosfcflx
      real, intent(in), dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: xf,arf1,arf2,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je) :: sflux
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gxu,gy,gyv
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dumx,dumy,dumz,rho,rr,rf,s,sten
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: khh,khv
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: dum7,dum8

      integer :: i,j,k,k1,k2
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2,cfa,cfb,cfc,cfd

!---------------------------------------------------------------

  IF(.not.terrain_flag)THEN

    IF(axisymm.eq.0)THEN
      ! Cartesian without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk

        !  x-direction
        do j=1,nj
        do i=1,ni+1
          dumx(i,j,k)= -0.125*( rho(i,j,k)+rho(i-1,j,k) )           &
                             *(  (khh(i,j,k  )+ khh(i-1,j,k  ))     &
                                +(khh(i,j,k+1)+ khh(i-1,j,k+1)) )   &
                             *(    s(i,j,k)-   s(i-1,j,k) )*rdx*uf(i)
        enddo
        enddo
        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj
            dumx(1,j,k) = dumx(2,j,k)
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj
            dumx(ni+1,j,k) = dumx(ni,j,k)
          enddo
        ENDIF
        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=-(dumx(i+1,j,k)-dumx(i,j,k))*rdx*uh(i)
        enddo
        enddo

        !  y-direction
        do j=1,nj+1
        do i=1,ni
          dumy(i,j,k)= -0.125*( rho(i,j,k)+rho(i,j-1,k) )           &
                             *(  (khh(i,j,k  )+ khh(i,j-1,k  ))     &
                                +(khh(i,j,k+1)+ khh(i,j-1,k+1)) )   &
                            *(    s(i,j,k)-   s(i,j-1,k) )*rdy*vf(j)
        enddo
        enddo
        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni
            dumy(i,1,k) = dumy(i,2,k)
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni
            dumy(i,nj+1,k) = dumy(i,nj,k)
          enddo
        ENDIF
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=-(dumy(i,j+1,k)-dumy(i,j,k))*rdy*vh(j)
        enddo
        enddo

      enddo

    ELSE
      ! axisymmetric:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj

        do i=1,ni+1
          dumx(i,j,k)= -0.125*( rho(i,j,k)+rho(i-1,j,k) )           &
                             *(  (khh(i,j,k  )+ khh(i-1,j,k  ))     &
                                +(khh(i,j,k+1)+ khh(i-1,j,k+1)) )   &
                             *(    s(i,j,k)-   s(i-1,j,k) )*rdx*uf(i)
        enddo
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          dumx(ni+1,j,k) = arh1(ni)*dumx(ni,j,k)/arh2(ni)
        ENDIF
        !-----
        if(wbc.eq.3.or.wbc.eq.4)then
          ! assume zero flux:
          dumx(1,j,k) = 0.0
        endif
        if(ebc.eq.3.or.ebc.eq.4)then
        ! assume zero flux:
          dumx(ni+1,j,k) = 0.0
        endif
        !-----
        do i=1,ni
          turbx(i,j,k)=-(arh2(i)*dumx(i+1,j,k)-arh1(i)*dumx(i,j,k))*rdx*uh(i)
        enddo
        do i=1,ni
          turby(i,j,k)=0.0
        enddo

      enddo
      enddo

    ENDIF   ! endif for axisymm check

!---------------------------------------------------------------

  ELSE
      ! Cartesian with terrain:

      ! use turbz as a temporary array for s at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do j=0,nj+1

        ! lowest model level:
        do i=0,ni+1
          turbz(i,j,1) = cgs1*s(i,j,1)+cgs2*s(i,j,2)+cgs3*s(i,j,3)
        enddo

        ! upper-most model level:
        do i=0,ni+1
          turbz(i,j,nk+1) = cgt1*s(i,j,nk)+cgt2*s(i,j,nk-1)+cgt3*s(i,j,nk-2)
        enddo

        ! interior:
        do k=2,nk
        r2 = (sigmaf(k)-sigma(k-1))*rds(k)
        r1 = 1.0-r2
        do i=0,ni+1
          turbz(i,j,k) = r1*s(i,j,k-1)+r2*s(i,j,k)
        enddo
        enddo

      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk

        ! x-flux
        do j=1,nj
        do i=1,ni+1
          dumx(i,j,k)= -0.125*( gz(i,j)*rho(i,j,k)+gz(i-1,j)*rho(i-1,j,k) )  &
                             *(  (khh(i,j,k  )+ khh(i-1,j,k  ))     &
                                +(khh(i,j,k+1)+ khh(i-1,j,k+1)) )*( &
                  (s(i,j,k)*rgz(i,j)-s(i-1,j,k)*rgz(i-1,j))         &
                   *rdx*uf(i)                                       &
              +0.5*( gxu(i,j,k+1)*(turbz(i,j,k+1)+turbz(i-1,j,k+1)) &
                    -gxu(i,j,k  )*(turbz(i,j,k  )+turbz(i-1,j,k  )) &
                   )*rdsf(k)*rgzu(i,j) )
        enddo
        enddo

        ! y-flux
        do j=1,nj+1
        do i=1,ni
          dumy(i,j,k)= -0.125*( gz(i,j)*rho(i,j,k)+gz(i,j-1)*rho(i,j-1,k) )  &
                             *(  (khh(i,j,k  )+ khh(i,j-1,k  ))     &
                                +(khh(i,j,k+1)+ khh(i,j-1,k+1)) )*( &
                  (s(i,j,k)*rgz(i,j)-s(i,j-1,k)*rgz(i,j-1))         &
                   *rdy*vf(j)                                       &
              +0.5*( gyv(i,j,k+1)*(turbz(i,j,k+1)+turbz(i,j-1,k+1)) &
                    -gyv(i,j,k  )*(turbz(i,j,k  )+turbz(i,j-1,k  )) &
                   )*rdsf(k)*rgzv(i,j) )
        enddo
        enddo

      enddo

      ! use turbz,dumz as temporary arrays for fluxes at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do j=1,nj+1
        ! lowest model level:
        do i=1,ni+1
          turbz(i,j,1) = cgs1*dumx(i,j,1)+cgs2*dumx(i,j,2)+cgs3*dumx(i,j,3)
           dumz(i,j,1) = cgs1*dumy(i,j,1)+cgs2*dumy(i,j,2)+cgs3*dumy(i,j,3)
        enddo

        ! upper-most model level:
        do i=1,ni+1
          turbz(i,j,nk+1) = cgt1*dumx(i,j,nk)+cgt2*dumx(i,j,nk-1)+cgt3*dumx(i,j,nk-2)
           dumz(i,j,nk+1) = cgt1*dumy(i,j,nk)+cgt2*dumy(i,j,nk-1)+cgt3*dumy(i,j,nk-2)
        enddo

        ! interior:
        do k=2,nk
        r2 = (sigmaf(k)-sigma(k-1))*rds(k)
        r1 = 1.0-r2
        do i=1,ni+1
          turbz(i,j,k) = r1*dumx(i,j,k-1)+r2*dumx(i,j,k)
           dumz(i,j,k) = r1*dumy(i,j,k-1)+r2*dumy(i,j,k)
        enddo
        enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk

        ! x-tendency
        do j=1,nj
        do i=1,ni
          turbx(i,j,k) = -gz(i,j)*( dumx(i+1,j,k)*rgzu(i+1,j)             &
                                   -dumx(i  ,j,k)*rgzu(i  ,j) )*rdx*uh(i) &
                -( ( gx(i,j,k+1)*(turbz(i,j,k+1)+turbz(i+1,j,k+1))        &
                    -gx(i,j,k  )*(turbz(i,j,k  )+turbz(i+1,j,k  )) )      &
                 )*0.5*rdsf(k)
        enddo
        enddo

        ! y-tendency
        do j=1,nj
        do i=1,ni
          turby(i,j,k) = -gz(i,j)*( dumy(i,j+1,k)*rgzv(i,j+1)             &
                                   -dumy(i,j  ,k)*rgzv(i,j  ) )*rdy*vh(j) &
                -( ( gy(i,j,k+1)*( dumz(i,j,k+1)+ dumz(i,j+1,k+1))        &
                    -gy(i,j,k  )*( dumz(i,j,k  )+ dumz(i,j+1,k  )) )      &
                 )*0.5*rdsf(k)
        enddo
        enddo

      enddo

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
      !  open boundary conditions:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=1,nk

        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj
            turbx(1,j,k) = 0.0
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj
            turbx(ni,j,k) = 0.0
          enddo
        ENDIF

        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni
            turby(i,1,k) = 0.0
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni
            turby(i,nj,k) = 0.0
          enddo
        ENDIF

      ENDDO
    ENDIF

  ENDIF  ! endif for terrain check

!---------------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_inf.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 1.0/dt
      tema = -1.0*dt*vialpha*rdz*rdz
      temb = dt*vibeta*rdz*rdz
      temc = dt*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,tem)
    DO j=1,nj
      k = 1
      DO i=1,ni
          r1 = 0.0
          r2 = dum8(i,j,k)
          cfa = 0.0
          cfc = tema*r2
          cfb = 1.0 - cfc
          cfd = s(i,j,k) + temb*( -r2*s(i,j,k)+r2*s(i,j,k+1) )
          IF(bcturbs.eq.1)THEN
            dumz(i,j,1)=0.0
          ELSEIF(bcturbs.eq.2)THEN
            dumz(i,j,1) = -khv(i,j,2)*(s(i,j,2)-s(i,j,1))*rdz*mf(i,j,2)*rf(i,j,2)
          ENDIF
          if(iflux.eq.1 .and. dosfcflx)then
            dumz(i,j,1)=sflux(i,j)*rf(i,j,1)
          endif
          cfd = cfd + temc*dumz(i,j,1)*mh(i,j,1)*rr(i,j,1)
        tem = 1.0/cfb
        dumx(i,j,1)=-cfc*tem
        dumy(i,j,1)= cfd*tem
      ENDDO
        !--------
        do k=2,nk-1
        do i=1,ni
          r1 = dum7(i,j,k)
          r2 = dum8(i,j,k)
          cfa = tema*r1
          cfc = tema*r2
          cfb = 1.0 - cfa - cfc
          cfd = s(i,j,k) + temb*(r1*s(i,j,k-1)-(r1+r2)*s(i,j,k)+r2*s(i,j,k+1) )
          tem = 1.0/(cfa*dumx(i,j,k-1)+cfb)
          dumx(i,j,k)=-cfc*tem
          dumy(i,j,k)=(cfd-cfa*dumy(i,j,k-1))*tem
        enddo
        enddo
        !--------
        k = nk
        do i=1,ni
          r1 = dum7(i,j,k)
          r2 = 0.0
          cfa = tema*r1
          cfc = 0.0
          cfb = 1.0 - cfa
          cfd = s(i,j,k) + temb*( r1*s(i,j,k-1)-r1*s(i,j,k) )
          IF(bcturbs.eq.1)THEN
            dumz(i,j,nk+1)=0.0
          ELSEIF(bcturbs.eq.2)THEN
            dumz(i,j,nk+1) = -khv(i,j,nk)*(s(i,j,nk)-s(i,j,nk-1))*rdz*mf(i,j,nk)*rf(i,j,nk)
          ENDIF
          cfd = cfd - temc*dumz(i,j,nk+1)*mh(i,j,nk)*rr(i,j,nk)
          tem = 1.0/(cfa*dumx(i,j,k-1)+cfb)
!!!          dumx(i,j,k)=-cfc*tem
          dumy(i,j,k)=(cfd-cfa*dumy(i,j,k-1))*tem
          dumz(i,j,k)=dumy(i,j,k)
          turbz(i,j,k) = rho(i,j,k)*(dumz(i,j,k)-s(i,j,k))*rdt
        enddo
        !--------

      do k=nk-1,1,-1
      DO i=1,ni
          dumz(i,j,k)=dumx(i,j,k)*dumz(i,j,k+1)+dumy(i,j,k)
          turbz(i,j,k) = rho(i,j,k)*(dumz(i,j,k)-s(i,j,k))*rdt
      ENDDO
      enddo

    ENDDO

  ENDIF

!---------------------------------------------------------------------

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+((turbx(i,j,k)+turby(i,j,k))+turbz(i,j,k))*rr(i,j,k)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+(turbx(i,j,k)+turbz(i,j,k))*rr(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

!---------------------------------------------------------------------

      if(timestats.ge.1) time_tmix=time_tmix+mytime()

      return
      end subroutine turbs


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbt(dt,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho,rr,rf,          &
                       rds,sigma,gz,rgz,gzu,rgzu,gzv,rgzv,                &
                       turbx,turby,turbz,dumx,dumy,dumz,t,tten,kmh,kmv)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,rxh,uh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: rf
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,rgzu,gzv,rgzv
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dumx,dumy,dumz
      real, intent(in), dimension(ibt:iet,jbt:jet,kbt:ket) :: t
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tten
      real, intent(in), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv

      integer :: i,j,k
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2,rrf
      real :: cfa,cfb,cfc,cfd

!---------------------------------------------------------------

    IF(.not.terrain_flag)THEN
      ! Cartesian without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk

        !  x-direction
        do j=1,nj
        do i=1,ni+1
          ! note:  K is multiplied by 2:
          dumx(i,j,k)= -0.25*( rf(i,j,k)+rf(i-1,j,k) )   &
                       *2.0*( kmh(i,j,k)+kmh(i-1,j,k) )   &
                           *(   t(i,j,k)-  t(i-1,j,k) )*rdx*uf(i)
        enddo
        enddo
        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj
            dumx(1,j,k) = dumx(2,j,k)
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj
            dumx(ni+1,j,k) = dumx(ni,j,k)
          enddo
        ENDIF
        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=-(dumx(i+1,j,k)-dumx(i,j,k))*rdx*uh(i)
        enddo
        enddo

        !  y-direction
        do j=1,nj+1
        do i=1,ni
          ! note:  K is multiplied by 2:
          dumy(i,j,k)= -0.25*( rf(i,j,k)+rf(i,j-1,k) )   &
                       *2.0*( kmh(i,j,k)+kmh(i,j-1,k) )   &
                           *(   t(i,j,k)-  t(i,j-1,k) )*rdy*vf(j)
        enddo
        enddo
        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni
            dumy(i,1,k) = dumy(i,2,k)
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni
            dumy(i,nj+1,k) = dumy(i,nj,k)
          enddo
        ENDIF
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=-(dumy(i,j+1,k)-dumy(i,j,k))*rdy*vh(j)
        enddo
        enddo

      enddo

!---------------------------------------------------------------
!  Cartesian with terrain:

    ELSE

      ! turbz stores t at s-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          turbz(i,j,k) = 0.5*(t(i,j,k)+t(i,j,k+1))
        enddo
        enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk

        ! x-flux:
        do j=1,nj
        do i=1,ni+1
          ! note:  K is multiplied by 2:
          dumx(i,j,k)= -0.25*( gz(i,j)*rf(i,j,k)+gz(i-1,j)*rf(i-1,j,k) )                 &
                       *2.0*( kmh(i,j,k)+kmh(i-1,j,k) )*(                                &
                            (t(i,j,k)*rgz(i,j)-t(i-1,j,k)*rgz(i-1,j))*rdx*uf(i)          &
                     +0.5*( (zt-sigma(k  ))*(turbz(i-1,j,k  )+turbz(i,j,k  ))            &
                           -(zt-sigma(k-1))*(turbz(i-1,j,k-1)+turbz(i,j,k-1))            &
                          )*rds(k)*(rgz(i,j)-rgz(i-1,j))*rdx*uf(i)                       &
                                                        )
        enddo
        enddo

        ! y-flux:
        do j=1,nj+1
        do i=1,ni
          ! note:  K is multiplied by 2:
          dumy(i,j,k)= -0.25*( gz(i,j)*rf(i,j,k)+gz(i,j-1)*rf(i,j-1,k) )                 &
                       *2.0*( kmh(i,j,k)+kmh(i,j-1,k) )*(                                &
                            (t(i,j,k)*rgz(i,j)-t(i,j-1,k)*rgz(i,j-1))*rdy*vf(j)          &
                     +0.5*( (zt-sigma(k  ))*(turbz(i,j-1,k  )+turbz(i,j,k  ))            &
                           -(zt-sigma(k-1))*(turbz(i,j-1,k-1)+turbz(i,j,k-1))            &
                          )*rds(k)*(rgz(i,j)-rgz(i,j-1))*rdy*vf(j)                       &
                                                        )
        enddo
        enddo

      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do j=1,nj+1
        do i=1,ni+1
          dumx(i,j,   1)=0.0
          dumx(i,j,nk+1)=0.0
          dumy(i,j,   1)=0.0
          dumy(i,j,nk+1)=0.0
        enddo
        enddo

      ! turbz stores dumx at s-pts:
      !  dumz stores dumy at s-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          turbz(i,j,k)=0.5*(dumx(i,j,k)+dumx(i,j,k+1))
           dumz(i,j,k)=0.5*(dumy(i,j,k)+dumy(i,j,k+1))
        enddo
        enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk

        ! x-tendency:
        do j=1,nj
        do i=1,ni
          turbx(i,j,k) = -(dumx(i+1,j,k)*rgzu(i+1,j)-dumx(i,j,k)*rgzu(i,j))*gz(i,j)*rdx*uh(i) &
                         -0.5*( (zt-sigma(k  ))*(turbz(i,j,k  )+turbz(i+1,j,k  ))             &
                               -(zt-sigma(k-1))*(turbz(i,j,k-1)+turbz(i+1,j,k-1))             &
                              )*rds(k)*(rgzu(i+1,j)-rgzu(i,j))*gz(i,j)*rdx*uh(i)
        enddo
        enddo

        ! y-tendency:
        do j=1,nj
        do i=1,ni
          turby(i,j,k) = -(dumy(i,j+1,k)*rgzv(i,j+1)-dumy(i,j,k)*rgzv(i,j))*gz(i,j)*rdy*vh(j) &
                         -0.5*( (zt-sigma(k  ))*( dumz(i,j,k  )+ dumz(i,j+1,k  ))             &
                               -(zt-sigma(k-1))*( dumz(i,j,k-1)+ dumz(i,j+1,k-1))             &
                              )*rds(k)*(rgzv(i,j+1)-rgzv(i,j))*gz(i,j)*rdy*vh(j)
        enddo
        enddo

      enddo

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
      !  open boundary conditions:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=2,nk

        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj
            turbx(1,j,k) = 0.0
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj
            turbx(ni,j,k) = 0.0
          enddo
        ENDIF

        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni
            turby(i,1,k) = 0.0
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni
            turby(i,nj,k) = 0.0
          enddo
        ENDIF

      ENDDO
    ENDIF

    ENDIF  ! endif for terrain check

!---------------------------------------------------------------------
!  z-direction

      rdt = 1.0/dt
      tema = -1.0*dt*vialpha*rdz*rdz
      temb =      dt*vibeta*rdz*rdz
      temc = dt*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,tem,rrf)
      do j=1,nj

        k=2
        do i=1,ni
          rrf = mf(i,j,k)/rf(i,j,k)
          r2 = (kmh(i,j,k  )+kmh(i,j,k+1))*mh(i,j,k  )*rho(i,j,k  )*rrf
          cfc = tema*r2
          cfb = 1.0 - cfc
          cfd = t(i,j,k) + temb*( r2*t(i,j,k+1)-r2*t(i,j,k) )
          tem = -(kmv(i,j,k-1)+kmv(i,j,k))*(t(i,j,k)-t(i,j,k-1))*rdz*mh(i,j,k-1)*rho(i,j,k-1)
          cfd = cfd + temc*tem*rrf
          tem = 1.0/cfb
          dumx(i,j,k) = -cfc*tem
          dumy(i,j,k) =  cfd*tem
        enddo

        do k=3,(nk-1)
        do i=1,ni
          rrf = mf(i,j,k)/rf(i,j,k)
          r1 = (kmh(i,j,k-1)+kmh(i,j,k  ))*mh(i,j,k-1)*rho(i,j,k-1)*rrf
          r2 = (kmh(i,j,k  )+kmh(i,j,k+1))*mh(i,j,k  )*rho(i,j,k  )*rrf
          cfa = tema*r1
          cfc = tema*r2
          cfb = 1.0 - cfa - cfc
          cfd = t(i,j,k) + temb*(r2*t(i,j,k+1)-(r1+r2)*t(i,j,k)+r1*t(i,j,k-1))
          tem = 1.0/(cfa*dumx(i,j,k-1)+cfb)
          dumx(i,j,k) = -cfc*tem
          dumy(i,j,k) = (cfd-cfa*dumy(i,j,k-1))*tem
        enddo
        enddo

        k = nk
        do i=1,ni
          rrf = mf(i,j,k)/rf(i,j,k)
          r1 = (kmh(i,j,k-1)+kmh(i,j,k  ))*mh(i,j,k-1)*rho(i,j,k-1)*rrf
          cfa = tema*r1
          cfb = 1.0 - cfa
          cfd = t(i,j,k) + temb*( -r1*t(i,j,k)+r1*t(i,j,k-1) )
          tem = -(kmv(i,j,k)+kmv(i,j,k+1))*(t(i,j,k+1)-t(i,j,k))*rdz*mh(i,j,k)*rho(i,j,k)
          cfd = cfd - temc*tem*rrf
          tem = 1.0/(cfa*dumx(i,j,k-1)+cfb)
          dumy(i,j,k) = (cfd-cfa*dumy(i,j,k-1))*tem
          !---
          dumz(i,j,k) = dumy(i,j,k)
          turbz(i,j,k) = rf(i,j,k)*(dumz(i,j,k)-t(i,j,k))*rdt
        enddo

        do k=(nk-1),2,-1
        do i=1,ni
          dumz(i,j,k) = dumx(i,j,k)*dumz(i,j,k+1)+dumy(i,j,k)
          turbz(i,j,k) = rf(i,j,k)*(dumz(i,j,k)-t(i,j,k))*rdt
        enddo
        enddo

      enddo

!---------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        tten(i,j,k)=tten(i,j,k)+((turbx(i,j,k)+turby(i,j,k))+turbz(i,j,k))/rf(i,j,k)
      enddo
      enddo
      enddo

!---------------------------------------------------------------------

      if(timestats.ge.1) time_tmix=time_tmix+mytime()

      return
      end subroutine turbt


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbu(dt,xh,ruh,xf,rxf,arf1,arf2,uf,vh,mh,mf,rmf,rho,rf,  &
                       zs,gz,rgz,gzu,gzv,rds,sigma,rdsf,sigmaf,gxu,     &
                       turbx,turby,turbz,dum1,dum2,dum3,u,uten,w,t11,t12,t13,t22,kmv)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,rxf,arf1,arf2,uf
      real, intent(in), dimension(jb:je) :: vh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,gzv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gxu
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum1,dum2,dum3
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: uten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: w
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22
      real, intent(in), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmv

      integer :: i,j,k,ip
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2,rru0
      real :: cfa,cfb,cfc,cfd

!---------------------------------------------------------------

  IF(.not.terrain_flag)THEN

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk

        !  x-direction
        do j=1,nj
        do i=1,ni+1
          turbx(i,j,k)=(t11(i,j,k)-t11(i-1,j,k))*rdx*uf(i)
        enddo
        enddo

        !  y-direction
        do j=1,nj
        do i=1,ni+1
          turby(i,j,k)=(t12(i,j+1,k)-t12(i,j,k))*rdy*vh(j)
        enddo
        enddo

      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(j,k)
      do k=1,nk

        do j=1,nj
        turbx(1,j,k)=0.0
        do i=2,ni+1
          turbx(i,j,k) = ( arf2(i)*arf2(i)*t11(i,j,k) - arf1(i)*arf1(i)*t11(i-1,j,k) )*rdx*uf(i)
        enddo
        IF(ebc.eq.3.or.ebc.eq.4)THEN
          turbx(ni+1,j,k)=0.0
        ENDIF
        enddo

      enddo

    ENDIF

!---------------------------------------------------------------
!  Terrain:

  ELSE

      ! dum1 stores t11 at w-pts:
      ! dum2 stores t12 at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do j=1,nj+1

          ! lowest model level:
          do i=0,ni+1
            dum1(i,j,1) = cgs1*t11(i,j,1)+cgs2*t11(i,j,2)+cgs3*t11(i,j,3)
            dum2(i,j,1) = cgs1*t12(i,j,1)+cgs2*t12(i,j,2)+cgs3*t12(i,j,3)
          enddo

          ! upper-most model level:
          do i=0,ni+1
            dum1(i,j,nk+1) = cgt1*t11(i,j,nk)+cgt2*t11(i,j,nk-1)+cgt3*t11(i,j,nk-2)
            dum2(i,j,nk+1) = cgt1*t12(i,j,nk)+cgt2*t12(i,j,nk-1)+cgt3*t12(i,j,nk-2)
          enddo

          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=0,ni+1
            dum1(i,j,k) = r1*t11(i,j,k-1)+r2*t11(i,j,k)
            dum2(i,j,k) = r1*t12(i,j,k-1)+r2*t12(i,j,k)
          enddo
          enddo

      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do k=1,nk

        !  x-direction
        do j=1,nj
        do i=1,ni+1
          turbx(i,j,k)=gzu(i,j)*(t11(i,j,k)*rgz(i,j)-t11(i-1,j,k)*rgz(i-1,j))*rdx*uf(i)  &
                      +0.5*( gxu(i,j,k+1)*(dum1(i-1,j,k+1)+dum1(i,j,k+1))                &
                            -gxu(i,j,k  )*(dum1(i-1,j,k  )+dum1(i,j,k  )) )*rdsf(k)
        enddo
        enddo

        !  y-direction
        do j=1,nj
        do i=1,ni+1
          r1 = 0.25*((rgz(i-1,j-1)+rgz(i,j))+(rgz(i-1,j)+rgz(i,j-1)))
          r2 = 0.25*((rgz(i-1,j+1)+rgz(i,j))+(rgz(i-1,j)+rgz(i,j+1)))
          turby(i,j,k)=gzu(i,j)*(t12(i,j+1,k)*r2-t12(i,j,k)*r1)*rdy*vh(j)      &
                      +0.5*( (zt-sigmaf(k+1))*(dum2(i,j,k+1)+dum2(i,j+1,k+1))  &
                            -(zt-sigmaf(k  ))*(dum2(i,j,k  )+dum2(i,j+1,k  ))  &
                           )*gzu(i,j)*(r2-r1)*rdy*vh(j)*rdsf(k)
        enddo
        enddo

      enddo

  ENDIF  ! endif for terrain check

!-----------------------------------------------------------------
!  open boundary conditions:

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=1,nk

        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj
            turbx(1,j,k) = 0.0
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj
            turbx(ni+1,j,k) = 0.0
          enddo
        ENDIF

        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni+1
            turby(i,1,k) = 0.0
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni+1
            turby(i,nj,k) = 0.0
          enddo
        ENDIF

      ENDDO
    ENDIF

!-----------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_inf.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

    IF(axisymm.eq.0)THEN
      rdt = 0.5/dt
      tema = -0.0625*dt*vialpha*rdz*rdz
      temb =  0.0625*dt*vibeta*rdz*rdz
      temc =  0.5*dt*rdz
    ELSE
      rdt = 0.5/dt
      tema = -0.25*dt*vialpha*rdz*rdz
      temb =  0.25*dt*vibeta*rdz*rdz
      temc =  dt*rdz
    ENDIF

      ip = 0
      if( axisymm.eq.1 ) ip = 1

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,tem,rru0)
    DO j=1,nj

      check_grid:  IF(axisymm.eq.0)THEN
        ! Cartesian grid:

        !--------
        k = 1
        do i=1+ip,ni+1
          rru0 = 1.0/(0.5*(rho(i-1,j,k)+rho(i,j,k)))
          tem = (mh(i-1,j,k)+mh(i,j,k))*rru0
          r1 = 0.0
          r2 = (kmv(i-1,j,k+1)+kmv(i,j,k+1))*(mf(i-1,j,k+1)+mf(i,j,k+1))   &
              *(rf(i-1,j,k+1)+rf(i,j,k+1))*tem
          cfa = 0.0
          cfc = tema*r2
          cfb = 1.0 - cfc
          cfd = u(i,j,k) + temb*( r2*u(i,j,k+1)-r2*u(i,j,k) )
          tem = temc*t13(i,j,1)*(mh(i-1,j,1)+mh(i,j,1))*rru0
          cfd = cfd - tem
          tem = 1.0/cfb
          dum1(i,j,1)=-cfc*tem
          dum2(i,j,1)= cfd*tem
        enddo
        !--------
        do k=2,nk-1
        do i=1+ip,ni+1
          rru0 = 1.0/(0.5*(rho(i-1,j,k)+rho(i,j,k)))
          tem = (mh(i-1,j,k)+mh(i,j,k))*rru0
          r1 = (kmv(i-1,j,k  )+kmv(i,j,k  ))*(mf(i-1,j,k  )+mf(i,j,k  ))   &
              *(rf(i-1,j,k  )+rf(i,j,k  ))*tem
          r2 = (kmv(i-1,j,k+1)+kmv(i,j,k+1))*(mf(i-1,j,k+1)+mf(i,j,k+1))   &
              *(rf(i-1,j,k+1)+rf(i,j,k+1))*tem
          cfa = tema*r1
          cfc = tema*r2
          cfb = 1.0 - cfa - cfc
          cfd = u(i,j,k) + temb*( r2*u(i,j,k+1)-(r1+r2)*u(i,j,k)+r1*u(i,j,k-1) )
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
          dum1(i,j,k)=-cfc*tem
          dum2(i,j,k)=(cfd-cfa*dum2(i,j,k-1))*tem
        enddo
        enddo
        !--------
        k = nk
        do i=1+ip,ni+1
          rru0 = 1.0/(0.5*(rho(i-1,j,k)+rho(i,j,k)))
          tem = (mh(i-1,j,k)+mh(i,j,k))*rru0
          r1 = (kmv(i-1,j,k  )+kmv(i,j,k  ))*(mf(i-1,j,k  )+mf(i,j,k  ))   &
              *(rf(i-1,j,k  )+rf(i,j,k  ))*tem
          r2 = 0.0
          cfa = tema*r1
          cfc = 0.0
          cfb = 1.0 - cfa
          cfd = u(i,j,k) + temb*( -r1*u(i,j,k)+r1*u(i,j,k-1) )
          tem = temc*t13(i,j,nk+1)*(mh(i-1,j,nk)+mh(i,j,nk))*rru0
          cfd = cfd + tem
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
!!!          dum1(i,j,k)=-cfc*tem
          dum2(i,j,k)=(cfd-cfa*dum2(i,j,k-1))*tem
          dum3(i,j,k)=dum2(i,j,k)
          turbz(i,j,k) = (rho(i-1,j,k)+rho(i,j,k))*(dum3(i,j,k)-u(i,j,k))*rdt
        enddo
        !--------

        do k=nk-1,1,-1
        do i=1+ip,ni+1
          dum3(i,j,k)=dum1(i,j,k)*dum3(i,j,k+1)+dum2(i,j,k)
          turbz(i,j,k) = (rho(i-1,j,k)+rho(i,j,k))*(dum3(i,j,k)-u(i,j,k))*rdt
        enddo
        enddo

      !------------------------------------------------------------
      !------------------------------------------------------------
      !------------------------------------------------------------

      ELSEIF(axisymm.eq.1)THEN
        ! axisymmetric grid:

        !--------
        k = 1
        do i=1+ip,ni+1
          rru0 = 1.0/(0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k)))
          tem = mh(1,1,k)*rru0
          r1 = 0.0
          r2 = (kmv(i-1,j,k+1)+kmv(i,j,k+1))*mf(1,1,k+1)   &
              *(arf1(i)*rf(i-1,j,k+1)+arf2(i)*rf(i,j,k+1))*tem
          cfa = 0.0
          cfc = tema*r2
          cfb = 1.0 - cfc
          cfd = u(i,j,k) + temb*( r2*u(i,j,k+1)-r2*u(i,j,k) )
          tem = temc*t13(i,j,1)*mh(1,1,1)*rru0
          cfd = cfd - tem
          tem = 1.0/cfb
          dum1(i,j,1)=-cfc*tem
          dum2(i,j,1)= cfd*tem
        enddo
        !--------
        do k=2,nk-1
        do i=1+ip,ni+1
          rru0 = 1.0/(0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k)))
          tem = mh(1,1,k)*rru0
          r1 = (kmv(i-1,j,k  )+kmv(i,j,k  ))*mf(1,1,k  )   &
              *(arf1(i)*rf(i-1,j,k  )+arf2(i)*rf(i,j,k  ))*tem
          r2 = (kmv(i-1,j,k+1)+kmv(i,j,k+1))*mf(1,1,k+1)   &
              *(arf1(i)*rf(i-1,j,k+1)+arf2(i)*rf(i,j,k+1))*tem
          cfa = tema*r1
          cfc = tema*r2
          cfb = 1.0 - cfa - cfc
          cfd = u(i,j,k) + temb*( r2*u(i,j,k+1)-(r1+r2)*u(i,j,k)+r1*u(i,j,k-1) )
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
          dum1(i,j,k)=-cfc*tem
          dum2(i,j,k)=(cfd-cfa*dum2(i,j,k-1))*tem
        enddo
        enddo
        !--------
        k = nk
        do i=1+ip,ni+1
          rru0 = 1.0/(0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k)))
          tem = mh(1,1,k)*rru0
          r1 = (kmv(i-1,j,k  )+kmv(i,j,k  ))*mf(1,1,k  )   &
              *(arf1(i)*rf(i-1,j,k  )+arf2(i)*rf(i,j,k  ))*tem
          r2 = 0.0
          cfa = tema*r1
          cfc = 0.0
          cfb = 1.0 - cfa
          cfd = u(i,j,k) + temb*( -r1*u(i,j,k)+r1*u(i,j,k-1) )
          tem = temc*t13(i,j,nk+1)*mh(1,1,nk)*rru0
          cfd = cfd + tem
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
!!!          dum1(i,j,k)=-cfc*tem
          dum2(i,j,k)=(cfd-cfa*dum2(i,j,k-1))*tem
          dum3(i,j,k)=dum2(i,j,k)
          turbz(i,j,k) = (arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))*(dum3(i,j,k)-u(i,j,k))*rdt
        enddo
        !--------

        do k=nk-1,1,-1
        do i=1+ip,ni+1
          dum3(i,j,k)=dum1(i,j,k)*dum3(i,j,k+1)+dum2(i,j,k)
          turbz(i,j,k) = (arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k))*(dum3(i,j,k)-u(i,j,k))*rdt
        enddo
        enddo

      ENDIF  check_grid

    ENDDO

  IF( terrain_flag )THEN
    ! dum1 stores w at scalar-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=1,nk
      do j=0,nj+1
      do i=0,ni+1
        dum1(i,j,k)=0.5*(w(i,j,k)+w(i,j,k+1))
      enddo
      enddo
    ENDDO
  ENDIF

      ! explicit piece ... dwdx term

    DO j=1,nj
      do i=1+ip,ni+1
        dum2(i,j,1) = 0.0
        dum2(i,j,nk+1) = 0.0
      enddo
      IF(.not.terrain_flag)THEN
        IF( axisymm.eq.0 )THEN
          do k=2,nk
          do i=1+ip,ni+1
            dum2(i,j,k)=(w(i,j,k)-w(i-1,j,k))*rdx*uf(i)
            dum2(i,j,k)=dum2(i,j,k)*0.25*( kmv(i-1,j,k)+kmv(i,j,k) )                 &
                                        *( rf(i-1,j,k)+rf(i,j,k) )
          enddo
          enddo
        ELSEIF( axisymm.eq.1 )THEN
          do k=2,nk
          do i=1+ip,ni+1
            dum2(i,j,k)=(w(i,j,k)-w(i-1,j,k))*rdx*uf(i)
            dum2(i,j,k)=dum2(i,j,k)*0.25*( arf1(i)*kmv(i-1,j,k)+arf2(i)*kmv(i,j,k) )  &
                                        *(arf1(i)*rf(i-1,j,k)+arf2(i)*rf(i,j,k))
          enddo
          enddo
        ENDIF
      ELSE
        do k=2,nk
        do i=1+ip,ni+1
          dum2(i,j,k)=(w(i,j,k)*rgz(i,j)-w(i-1,j,k)*rgz(i-1,j))*rdx*uf(i)          &
                  +0.5*rds(k)*( (zt-sigma(k  ))*(dum1(i,j,k  )+dum1(i-1,j,k  ))    &
                               -(zt-sigma(k-1))*(dum1(i,j,k-1)+dum1(i-1,j,k-1)) )  &
                             *(rgz(i,j)-rgz(i-1,j))*rdx*uf(i)
          dum2(i,j,k)=dum2(i,j,k)*0.25*( kmv(i-1,j,k)+kmv(i,j,k) )                 &
                                      *( gz(i-1,j)*rf(i-1,j,k)+gz(i,j)*rf(i,j,k) )
        enddo
        enddo
      ENDIF
      do k=1,nk
      do i=1+ip,ni+1
        turbz(i,j,k)=turbz(i,j,k)+(dum2(i,j,k+1)-dum2(i,j,k))*rdz*0.5*(mh(i-1,j,k)+mh(i,j,k))
      enddo
      enddo
    ENDDO


      IF(axisymm.eq.1)THEN
        DO k=1,nk
          turbz(1,1,k) = 0.0
        ENDDO
        IF( ebc.eq.3 .or. ebc.eq.4 )THEN
          do k=1,nk
            turbz(ni+1,1,k)=0.0
          enddo
        ENDIF
      ENDIF

  ENDIF

!-----------------------------------------------------------------

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,rru0)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        rru0 = 1.0/(0.5*(rho(i-1,j,k)+rho(i,j,k)))
        uten(i,j,k)=uten(i,j,k)+((turbx(i,j,k)+turby(i,j,k))+turbz(i,j,k))*rru0
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k,rru0)
      do k=1,nk
      do j=1,nj
      do i=2,ni+1
        rru0 = 1.0/(0.5*(arf1(i)*rho(i-1,j,k)+arf2(i)*rho(i,j,k)))
        uten(i,j,k)=uten(i,j,k)+(turbx(i,j,k)+turbz(i,j,k))*rru0
      enddo
      enddo
      enddo

    ENDIF

!-------------------------------------------------------------------
!  All done

      if(timestats.ge.1) time_tmix=time_tmix+mytime()

      return
      end subroutine turbu


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbv(dt,xh,rxh,arh1,arh2,uh,xf,rvh,vf,mh,mf,rho,rr,rf,   &
                       zs,gz,rgz,gzu,gzv,rds,sigma,rdsf,sigmaf,gyv,  &
                       turbx,turby,turbz,dum1,dum2,dum3,v,vten,w,t12,t22,t23,kmv)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: rvh
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,rr,rf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,gzv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, intent(in), dimension(kb:ke+1) :: rdsf,sigmaf
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gyv
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum1,dum2,dum3
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: vten
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: w
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: t12,t22,t23
      real, intent(in), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmv
 
      integer :: i,j,k,ip
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2,rrv0
      real :: cfa,cfb,cfc,cfd
      real :: foo1,foo2

!---------------------------------------------------------------

  IF(.not.terrain_flag)THEN

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk

        !  x-direction
        do j=1,nj+1
        do i=1,ni
          turbx(i,j,k)=(t12(i+1,j,k)-t12(i,j,k))*rdx*uh(i)
        enddo
        enddo

        !  y-direction
        do j=1,nj+1
        do i=1,ni
          turby(i,j,k)=(t22(i,j,k)-t22(i,j-1,k))*rdy*vf(j)
        enddo
        enddo

      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk

        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=(arh2(i)*arh2(i)*t12(i+1,j,k)-arh1(i)*arh1(i)*t12(i,j,k))*rdx*uh(i)
        enddo
        enddo

        do j=1,nj
        do i=1,ni
          turby(i,j,k)=0.0
        enddo
        enddo

      enddo

    ENDIF

!---------------------------------------------------------------
!  Terrain:

  ELSE

      ! dum1 stores t12 at w-pts:
      ! dum2 stores t22 at w-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do j=0,nj+1

          ! lowest model level:
          do i=1,ni+1
            dum1(i,j,1) = cgs1*t12(i,j,1)+cgs2*t12(i,j,2)+cgs3*t12(i,j,3)
            dum2(i,j,1) = cgs1*t22(i,j,1)+cgs2*t22(i,j,2)+cgs3*t22(i,j,3)
          enddo

          ! upper-most model level:
          do i=1,ni+1
            dum1(i,j,nk+1) = cgt1*t12(i,j,nk)+cgt2*t12(i,j,nk-1)+cgt3*t12(i,j,nk-2)
            dum2(i,j,nk+1) = cgt1*t22(i,j,nk)+cgt2*t22(i,j,nk-1)+cgt3*t22(i,j,nk-2)
          enddo

          ! interior:
          do k=2,nk
          r2 = (sigmaf(k)-sigma(k-1))*rds(k)
          r1 = 1.0-r2
          do i=1,ni+1
            dum1(i,j,k) = r1*t12(i,j,k-1)+r2*t12(i,j,k)
            dum2(i,j,k) = r1*t22(i,j,k-1)+r2*t22(i,j,k)
          enddo
          enddo

      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2)
      do k=1,nk

        !  x-direction
        do j=1,nj+1
        do i=1,ni
          r1 = 0.25*((rgz(i-1,j-1)+rgz(i,j))+(rgz(i-1,j)+rgz(i,j-1)))
          r2 = 0.25*((rgz(i+1,j-1)+rgz(i,j))+(rgz(i+1,j)+rgz(i,j-1)))
          turbx(i,j,k)=gzv(i,j)*(t12(i+1,j,k)*r2-t12(i,j,k)*r1)*rdx*uh(i)      &
                      +0.5*( (zt-sigmaf(k+1))*(dum1(i,j,k+1)+dum1(i+1,j,k+1))  &
                            -(zt-sigmaf(k  ))*(dum1(i,j,k  )+dum1(i+1,j,k  ))  &
                           )*gzv(i,j)*(r2-r1)*rdx*uh(i)*rdsf(k)
        enddo
        enddo

        !  y-direction
        do j=1,nj+1
        do i=1,ni
          turby(i,j,k)=gzv(i,j)*(t22(i,j,k)*rgz(i,j)-t22(i,j-1,k)*rgz(i,j-1))*rdy*vf(j)  &
                      +0.5*( gyv(i,j,k+1)*(dum2(i,j-1,k+1)+dum2(i,j,k+1))                &
                            -gyv(i,j,k  )*(dum2(i,j-1,k  )+dum2(i,j,k  )) )*rdsf(k)
        enddo
        enddo

      enddo

  ENDIF  ! endif for terrain check

!-----------------------------------------------------------------
!  open boundary conditions:

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=1,nk

        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj+1
            turbx(1,j,k) = 0.0
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj+1
            turbx(ni,j,k) = 0.0
          enddo
        ENDIF

        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni
            turby(i,1,k) = 0.0
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni
            turby(i,nj+1,k) = 0.0
          enddo
        ENDIF

      ENDDO
    ENDIF

!-----------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_inf.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 0.5/dt
      tema = -0.0625*dt*vialpha*rdz*rdz
      temb =  0.0625*dt*vibeta*rdz*rdz
      temc =  0.5*dt*rdz

      ip = 1
      if( axisymm.eq.1 ) ip = 0

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,tem,rrv0)
    do j=1,nj+ip

        !--------
        k = 1
        do i=1,ni
          rrv0 = 1.0/(0.5*(rho(i,j-1,k)+rho(i,j,k)))
          tem = (mh(i,j-1,k)+mh(i,j,k))*rrv0
          r1 = 0.0
          r2 = (kmv(i,j-1,k+1)+kmv(i,j,k+1))*(mf(i,j-1,k+1)+mf(i,j,k+1))   &
              *(rf(i,j-1,k+1)+rf(i,j,k+1))*tem
          cfa = 0.0
          cfc = tema*r2
          cfb = 1.0 - cfc
          cfd = v(i,j,k) + temb*( r2*v(i,j,k+1)-r2*v(i,j,k) )
          tem = temc*t23(i,j,1)*(mh(i,j-1,1)+mh(i,j,1))*rrv0
          cfd = cfd - tem
          tem = 1.0/cfb
          dum1(i,j,1)=-cfc*tem
          dum2(i,j,1)= cfd*tem
        enddo
        !--------
        do k=2,nk-1
        do i=1,ni
          rrv0 = 1.0/(0.5*(rho(i,j-1,k)+rho(i,j,k)))
          tem = (mh(i,j-1,k)+mh(i,j,k))*rrv0
          r1 = (kmv(i,j-1,k  )+kmv(i,j,k  ))*(mf(i,j-1,k  )+mf(i,j,k  ))   &
              *(rf(i,j-1,k  )+rf(i,j,k  ))*tem
          r2 = (kmv(i,j-1,k+1)+kmv(i,j,k+1))*(mf(i,j-1,k+1)+mf(i,j,k+1))   &
              *(rf(i,j-1,k+1)+rf(i,j,k+1))*tem
          cfa = tema*r1
          cfc = tema*r2
          cfb = 1.0 - cfa - cfc
          cfd = v(i,j,k) + temb*( r2*v(i,j,k+1)-(r1+r2)*v(i,j,k)+r1*v(i,j,k-1) )
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
          dum1(i,j,k)=-cfc*tem
          dum2(i,j,k)=(cfd-cfa*dum2(i,j,k-1))*tem
        enddo
        enddo
        !--------
        k = nk
        do i=1,ni
          rrv0 = 1.0/(0.5*(rho(i,j-1,k)+rho(i,j,k)))
          tem = (mh(i,j-1,k)+mh(i,j,k))*rrv0
          r1 = (kmv(i,j-1,k  )+kmv(i,j,k  ))*(mf(i,j-1,k  )+mf(i,j,k  ))   &
              *(rf(i,j-1,k  )+rf(i,j,k  ))*tem
          r2 = 0.0
          cfa = tema*r1
          cfc = 0.0
          cfb = 1.0 - cfa
          cfd = v(i,j,k) + temb*( -r1*v(i,j,k)+r1*v(i,j,k-1) )
          tem = temc*t23(i,j,nk+1)*(mh(i,j-1,nk)+mh(i,j,nk))*rrv0
          cfd = cfd + tem
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
!!!          dum1(i,j,k)=-cfc*tem
          dum2(i,j,k)=(cfd-cfa*dum2(i,j,k-1))*tem
          dum3(i,j,k)=dum2(i,j,k)
          turbz(i,j,k) = (rho(i,j-1,k)+rho(i,j,k))*(dum3(i,j,k)-v(i,j,k))*rdt
        enddo
        !--------

        do k=nk-1,1,-1
        do i=1,ni
          dum3(i,j,k)=dum1(i,j,k)*dum3(i,j,k+1)+dum2(i,j,k)
          turbz(i,j,k) = (rho(i,j-1,k)+rho(i,j,k))*(dum3(i,j,k)-v(i,j,k))*rdt
        enddo
        enddo

    enddo

  IF( terrain_flag )THEN
    ! dum1 stores w at scalar-pts:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    DO k=1,nk
      do j=0,nj+1
      do i=0,ni+1
        dum1(i,j,k)=0.5*(w(i,j,k)+w(i,j,k+1))
      enddo
      enddo
    ENDDO
  ENDIF

    IF(axisymm.eq.0)THEN
      ! explicit piece ... dwdy term
      ! Cartesian grid only:
    DO j=1,nj+ip
      do i=1,ni
        dum2(i,j,1) = 0.0
        dum2(i,j,nk+1) = 0.0
      enddo
      IF(.not.terrain_flag)THEN
        do k=2,nk
        do i=1,ni
          dum2(i,j,k)=(w(i,j,k)-w(i,j-1,k))*rdy*vf(j)
          dum2(i,j,k)=dum2(i,j,k)*0.25*( kmv(i,j-1,k)+kmv(i,j,k) )                 &
                                      *( rf(i,j-1,k)+rf(i,j,k) )
        enddo
        enddo
      ELSE
        do k=2,nk
        do i=1,ni
          dum2(i,j,k)=(w(i,j,k)*rgz(i,j)-w(i,j-1,k)*rgz(i,j-1))*rdy*vf(j)          &
                  +0.5*rds(k)*( (zt-sigma(k  ))*(dum1(i,j,k  )+dum1(i,j-1,k  ))    &
                               -(zt-sigma(k-1))*(dum1(i,j,k-1)+dum1(i,j-1,k-1)) )  &
                             *(rgz(i,j)-rgz(i,j-1))*rdy*vf(j)
          dum2(i,j,k)=dum2(i,j,k)*0.25*( kmv(i,j-1,k)+kmv(i,j,k) )                 &
                                      *( gz(i,j-1)*rf(i,j-1,k)+gz(i,j)*rf(i,j,k) )
        enddo
        enddo
      ENDIF
      do k=1,nk
      do i=1,ni
        turbz(i,j,k)=turbz(i,j,k)+(dum2(i,j,k+1)-dum2(i,j,k))*rdz*0.5*(mh(i,j-1,k)+mh(i,j,k))
      enddo
      enddo
    ENDDO
    ENDIF

  ENDIF

!-----------------------------------------------------------------

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,rrv0)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        rrv0 = 1.0/(0.5*(rho(i,j-1,k)+rho(i,j,k)))
        vten(i,j,k)=vten(i,j,k)+((turbx(i,j,k)+turby(i,j,k))+turbz(i,j,k))*rrv0
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+(turbx(i,j,k)+turbz(i,j,k))*rr(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

!-------------------------------------------------------------------
!  All done
 
      if(timestats.ge.1) time_tmix=time_tmix+mytime()
 
      return
      end subroutine turbv


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

 
      subroutine turbw(dt,xh,rxh,arh1,arh2,uh,xf,vh,mh,mf,rho,rf,gz,rgzu,rgzv,rds,sigma,   &
                       turbx,turby,turbz,dum1,dum2,dum3,w,wten,t13,t23,t33,t22,kmh)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      real, intent(in), dimension(ib:ie) :: xh,rxh,arh1,arh2,uh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,rf
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgzu,rgzv
      real, intent(in), dimension(kb:ke) :: rds,sigma
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum1,dum2,dum3
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: t13,t23,t33,t22
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh
 
      integer :: i,j,k
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2,rrf
      real :: cfa,cfb,cfc,cfd
      real :: foo1,foo2

!----------------------------------------------------------------

  IF(.not.terrain_flag)THEN

    IF(axisymm.eq.0)THEN
      ! Cartesian without terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk

        !  x-direction
        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=(t13(i+1,j,k)-t13(i,j,k))*rdx*uh(i)
        enddo
        enddo

        !  y-direction
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=(t23(i,j+1,k)-t23(i,j,k))*rdy*vh(j)
        enddo
        enddo

      enddo

    ELSE
      ! axisymmetric:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk

        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=(arh2(i)*t13(i+1,j,k)-arh1(i)*t13(i,j,k))*rdx*uh(i)
        enddo
        enddo

        !  y-direction
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=0.0
        enddo
        enddo

      enddo

    ENDIF

!----------------------------------------------------------------

  ELSE
      ! Cartesian with terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k) = 0.25*( (t13(i,j,k+1)+t13(i+1,j,k+1)) &
                              +(t13(i,j,k  )+t13(i+1,j,k  )) )
        enddo
        enddo
        do j=1,nj
        do i=1,ni
          dum2(i,j,k) = 0.25*( (t23(i,j,k+1)+t23(i,j+1,k+1)) &
                              +(t23(i,j,k  )+t23(i,j+1,k  )) )
        enddo
        enddo
      enddo


!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk

        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=gz(i,j)*( t13(i+1,j,k)*rgzu(i+1,j)             &
                                -t13(i  ,j,k)*rgzu(i  ,j) )*rdx*uh(i) &
              +( (zt-sigma(k  ))*dum1(i,j,k  )                        &
                -(zt-sigma(k-1))*dum1(i,j,k-1)                        &
               )*gz(i,j)*(rgzu(i+1,j)-rgzu(i,j))*rdx*uh(i)*rds(k)
        enddo
        enddo

        do j=1,nj
        do i=1,ni
          turby(i,j,k)=gz(i,j)*( t23(i,j+1,k)*rgzv(i,j+1)             &
                                -t23(i,j  ,k)*rgzv(i,j  ) )*rdy*vh(j) &
              +( (zt-sigma(k  ))*dum2(i,j,k  )                        &
                -(zt-sigma(k-1))*dum2(i,j,k-1)                        &
               )*gz(i,j)*(rgzv(i,j+1)-rgzv(i,j))*rdy*vh(j)*rds(k)
        enddo
        enddo

      enddo

  ENDIF

!-----------------------------------------------------------------
!  open boundary conditions:

    IF( wbc.eq.2 .or. ebc.eq.2 .or. sbc.eq.2 .or. nbc.eq.2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      DO k=2,nk

        IF( wbc.eq.2 .and. ibw.eq.1 )THEN
          do j=1,nj
            turbx(1,j,k) = 0.0
          enddo
        ENDIF
        IF( ebc.eq.2 .and. ibe.eq.1 )THEN
          do j=1,nj
            turbx(ni,j,k) = 0.0
          enddo
        ENDIF

        IF( sbc.eq.2 .and. ibs.eq.1 )THEN
          do i=1,ni
            turby(i,1,k) = 0.0
          enddo
        ENDIF
        IF( nbc.eq.2 .and. ibn.eq.1 )THEN
          do i=1,ni
            turby(i,nj,k) = 0.0
          enddo
        ENDIF

      ENDDO
    ENDIF

!-----------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_inf.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 1.0/dt
      tema = -1.0*dt*vialpha*rdz*rdz
      temb =      dt*vibeta*rdz*rdz
      temc = dt*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,tem,rrf)
      do j=1,nj

        k=2
        do i=1,ni
          rrf = mf(i,j,k)/rf(i,j,k)
          r2 = (kmh(i,j,k  )+kmh(i,j,k+1))*mh(i,j,k  )*rho(i,j,k  )*rrf
          cfc = tema*r2
          cfb = 1.0 - cfc
          cfd = w(i,j,k) + temb*( r2*w(i,j,k+1)-r2*w(i,j,k) )
          cfd = cfd - temc*t33(i,j,k-1)*rrf
          tem = 1.0/cfb
          dum1(i,j,k) = -cfc*tem
          dum2(i,j,k) =  cfd*tem
        enddo

        do k=3,(nk-1)
        do i=1,ni
          rrf = mf(i,j,k)/rf(i,j,k)
          r1 = (kmh(i,j,k-1)+kmh(i,j,k  ))*mh(i,j,k-1)*rho(i,j,k-1)*rrf
          r2 = (kmh(i,j,k  )+kmh(i,j,k+1))*mh(i,j,k  )*rho(i,j,k  )*rrf
          cfa = tema*r1
          cfc = tema*r2
          cfb = 1.0 - cfa - cfc
          cfd = w(i,j,k) + temb*(r2*w(i,j,k+1)-(r1+r2)*w(i,j,k)+r1*w(i,j,k-1))
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
          dum1(i,j,k) = -cfc*tem
          dum2(i,j,k) = (cfd-cfa*dum2(i,j,k-1))*tem
        enddo
        enddo

        k = nk
        do i=1,ni
          rrf = mf(i,j,k)/rf(i,j,k)
          r1 = (kmh(i,j,k-1)+kmh(i,j,k  ))*mh(i,j,k-1)*rho(i,j,k-1)*rrf
          cfa = tema*r1
          cfb = 1.0 - cfa
          cfd = w(i,j,k) + temb*( -r1*w(i,j,k)+r1*w(i,j,k-1) )
          cfd = cfd + temc*t33(i,j,k)*rrf
          tem = 1.0/(cfa*dum1(i,j,k-1)+cfb)
          dum2(i,j,k) = (cfd-cfa*dum2(i,j,k-1))*tem
          !---
          dum3(i,j,k) = dum2(i,j,k)
          turbz(i,j,k) = rf(i,j,k)*(dum3(i,j,k)-w(i,j,k))*rdt
        enddo

        do k=(nk-1),2,-1
        do i=1,ni
          dum3(i,j,k) = dum1(i,j,k)*dum3(i,j,k+1)+dum2(i,j,k)
          turbz(i,j,k) = rf(i,j,k)*(dum3(i,j,k)-w(i,j,k))*rdt
        enddo
        enddo

      enddo

    ENDIF

!-----------------------------------------------------------------

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+((turbx(i,j,k)+turby(i,j,k))+turbz(i,j,k))/rf(i,j,k)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+(turbx(i,j,k)+turbz(i,j,k))/rf(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

!-------------------------------------------------------------------
!  All done

      if(timestats.ge.1) time_tmix=time_tmix+mytime()
 
      return
      end subroutine turbw


writeout.F      1587424407  1602  20    100644  146627    `

      subroutine setup_output(tdef,qname,budname,xh,xf,yh,yf,xfref,yfref,sigma,sigmaf,zh,zf)
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'

      !------------------------------------------------------------
      ! This subroutine gets things ready for writeouts
      ! (mostly, but not entirely, related to GrADS-format output)
      !------------------------------------------------------------

      character*15, intent(inout) :: tdef
      character*3, intent(in), dimension(maxq) :: qname
      character*6, intent(in), dimension(maxq) :: budname
      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh
      real, intent(in), dimension(jb:je+1) :: yf
      real, intent(in), dimension(-2:nx+4) :: xfref
      real, intent(in), dimension(-2:ny+4) :: yfref
      real, intent(in), dimension(kb:ke) :: sigma
      real, intent(in), dimension(kb:ke+1) :: sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf

!-----------------------------------------------------------------------

      integer :: i,j,k,n,flag,n2
      character*8 text1
      character*30 text2
      character*50 fname
      character*8,  dimension(:), allocatable :: varname
      character*30, dimension(:), allocatable :: vardesc

      maxk = min(maxk,nk)

!-----------------------------------------------------------------------
! get length of output_path string

    flag=0
    n=0
    do while( flag.eq.0 .and. n.le.70 )
      n=n+1
      if( output_path(n:n).eq.' ' .or. output_path(n:n).eq.'.' ) flag=1
    enddo

    strlen=n-1

!--------------------------------------
! get length of output_basename string

    flag=0
    n=0
    do while( flag.eq.0 .and. n.le.70 )
      n=n+1
      if( output_basename(n:n).eq.' ' .or. output_basename(n:n).eq.'.' ) flag=1
    enddo

    baselen=n-1

!------

    totlen = strlen + baselen

    IF( totlen .gt. (70-22) )THEN
      IF(myid.eq.0)THEN
      print *
      print *,'  baselen = ',baselen
      print *,'  strlen  = ',strlen
      print *,'  totlen  = ',totlen
      print *
      print *,'  totlen is too long ... make either baselen or strlen shorter '
      print *
      print *,'  stopping cm1 .... '
      print *
      ENDIF
#ifdef MPI
      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
      call stopcm1
    ENDIF

!------

      string = '                                                                      '
    statfile = '                                                                      '
     sstring = '                                                                      '

  if(strlen.gt.0)then
      string(1:strlen) = output_path(1:strlen)
    statfile(1:strlen) = output_path(1:strlen)
  endif

      string(strlen+1:strlen+baselen) = output_basename(1:baselen)
    statfile(strlen+1:strlen+baselen) = output_basename(1:baselen)
     sstring(1:baselen) = output_basename(1:baselen)

    statfile(totlen+1:totlen+22) = '_stats.dat            '

  IF(output_format.eq.1)THEN
    if(dowr) write(outfile,*)
    if(dowr) write(outfile,*) '  writing ctl files ... '
  ENDIF
    if(dowr) write(outfile,*)
    if(dowr) write(outfile,*) '  strlen          = ',strlen
    if(dowr) write(outfile,*) '  baselen         = ',baselen
    if(dowr) write(outfile,*) '  totlen          = ',totlen
  if(strlen.gt.0)then
    if(dowr) write(outfile,*) '  output_path     = ',output_path(1:strlen)
  endif
    if(dowr) write(outfile,*) '  output_basename = ',output_basename(1:baselen)
    if(dowr) write(outfile,*) '  statfile        = ',statfile
    if(dowr) write(outfile,*)

      IF( myid.eq.0 )THEN
        if(output_filetype.ge.2)then
          tdef = '00:00Z03JUL0001'
        else
          tdef = '00:00Z03JUL2000'
        endif
        IF( radopt.ge.1 )THEN
          write(tdef( 1: 2),237) hour
          write(tdef( 4: 5),237) minute
          write(tdef( 7: 8),237) day
        if(output_filetype.ge.2)then
          write(tdef(12:15),238) 1
        else
          write(tdef(12:15),238) year
        endif
237       format(i2.2)
238       format(i4.4)
          IF( month.eq.1 )THEN
            write(tdef(9:11),239) 'JAN'
          ELSEIF( month.eq.2 )THEN
            write(tdef(9:11),239) 'FEB'
          ELSEIF( month.eq.3 )THEN
            write(tdef(9:11),239) 'MAR'
          ELSEIF( month.eq.4 )THEN
            write(tdef(9:11),239) 'APR'
          ELSEIF( month.eq.5 )THEN
            write(tdef(9:11),239) 'MAY'
          ELSEIF( month.eq.6 )THEN
            write(tdef(9:11),239) 'JUN'
          ELSEIF( month.eq.7 )THEN
            write(tdef(9:11),239) 'JUL'
          ELSEIF( month.eq.8 )THEN
            write(tdef(9:11),239) 'AUG'
          ELSEIF( month.eq.9 )THEN
            write(tdef(9:11),239) 'SEP'
          ELSEIF( month.eq.10 )THEN
            write(tdef(9:11),239) 'OCT'
          ELSEIF( month.eq.11 )THEN
            write(tdef(9:11),239) 'NOV'
          ELSEIF( month.eq.12 )THEN
            write(tdef(9:11),239) 'DEC'
          ELSE
            print *
            print *,'  Invalid value for MONTH '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
239       format(a3)
        ENDIF
      ENDIF

!-----------------------------------------------------------------------
!  GrADS descriptor files
!-----------------------------------------------------------------------

  grads_descriptors: IF( output_format.eq.1 )THEN

      IF(myid.eq.0)THEN

        allocate( varname(1000) )
        allocate( vardesc(1000) )

!----------------------------
! s file:
! accounts for both 2d and 3d variables:

    sout2d = 0
    s_out = 0

    ! all 2d variables MUST be listed first:

    if(output_rain   .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'rn      '
      vardesc(s_out) = 'accumulated rainfall (cm)     '
    endif
    if(output_sws    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'sws     '
      vardesc(s_out) = 'max wind speed lwst lvl (m/s) '
    endif
    if(output_svs    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'svs     '
      vardesc(s_out) = 'max vert vort lwst lvl (s-1)  '
    endif
    if(output_sps    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'sps     '
      vardesc(s_out) = 'min pressure lowest level (Pa)'
    endif
    if(output_srs    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'srs     '
      vardesc(s_out) = 'max sfc rainwater (kg/kg)     '
    endif
    if(output_sgs    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'sgs     '
      vardesc(s_out) = 'max sfc graupel/hail (kg/kg)  '
    endif
    if(output_sus    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'sus     '
      vardesc(s_out) = 'max w at 5 km AGL (m/s)       '
    endif
    if(output_shs    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'shs     '
      vardesc(s_out) = 'max integrated uh (m2/s2)     '
    endif
    if(nrain.eq.2)then
      if(output_rain   .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'rn2     '
        vardesc(s_out) = 'translated rainfall (cm)      '
      endif
      if(output_sws    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'sws2    '
        vardesc(s_out) = 'translated max wind (m/s)     '
      endif
      if(output_svs    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'svs2    '
        vardesc(s_out) = 'translated max vorticity (s-1)'
      endif
      if(output_sps    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'sps2    '
        vardesc(s_out) = 'translated min pressure (Pa)  '
      endif
      if(output_srs    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'srs2    '
        vardesc(s_out) = 'translated max rainwater      '
      endif
      if(output_sgs    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'sgs2    '
        vardesc(s_out) = 'translated max graupel/hail   '
      endif
      if(output_sus    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'sus2    '
        vardesc(s_out) = 'translated max w at 5 km (m/s)'
      endif
      if(output_shs    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'shs2    '
        vardesc(s_out) = 'translated max integrated uh  '
      endif
    endif
    if(output_uh.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'uh      '
      vardesc(s_out) = 'integ. updraft helicity (m2/s2'
    endif
    if(output_coldpool.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'cpc     '
      vardesc(s_out) = 'cold pool intensity C (m/s)   '
      s_out = s_out + 1
      varname(s_out) = 'cph     '
      vardesc(s_out) = 'cold pool depth h (m AGL)     '
    endif
    if(output_sfcflx .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'thflux  '
      vardesc(s_out) = 'sfc theta flux (K m/s)        '
      s_out = s_out + 1
      varname(s_out) = 'qvflux  '
      vardesc(s_out) = 'sfc water vapor flux (g/g m/s)'
      s_out = s_out + 1
      varname(s_out) = 'tsk     '
      vardesc(s_out) = 'soil/ocean temperature (K)    '
    endif
    if(output_sfcparams.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'cd      '
      vardesc(s_out) = 'exchange coeff for momentum   '
      s_out = s_out + 1
      varname(s_out) = 'ch      '
      vardesc(s_out) = 'exchange coeff for sens. heat '
      s_out = s_out + 1
      varname(s_out) = 'cq      '
      vardesc(s_out) = 'exchange coeff for moisture   '
      s_out = s_out + 1
      varname(s_out) = 'tlh     '
      vardesc(s_out) = 'horiz lengthscale for iturb=3 '
    endif
    if(output_psfc   .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'psfc    '
      vardesc(s_out) = 'surface pressure (Pa)         '
    endif
    if(output_zs     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'zs      '
      vardesc(s_out) = 'terrain height (m)            '
    endif
    if(output_dbz    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'cref    '
      vardesc(s_out) = 'composite reflectivity (dBZ)  '
    endif
    if(output_sfcparams.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'xland   '
      vardesc(s_out) = 'land/water flag (1=land,2=wtr)'
      s_out = s_out + 1
      varname(s_out) = 'lu      '
      vardesc(s_out) = 'land use index                '
      s_out = s_out + 1
      varname(s_out) = 'mavail  '
      vardesc(s_out) = 'surface moisture availability '
    endif
    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4.or.oceanmodel.eq.2))then
      s_out = s_out + 1
      varname(s_out) = 'tmn     '
      vardesc(s_out) = 'deep-layer soil temperature (K'
      s_out = s_out + 1
      varname(s_out) = 'hfx     '
      vardesc(s_out) = 'heat flux at surface (W/m^2)  '
      s_out = s_out + 1
      varname(s_out) = 'qfx     '
      vardesc(s_out) = 'moisture flux at sfc (kg/m^2/s'
      s_out = s_out + 1
      varname(s_out) = 'gsw     '
      vardesc(s_out) = 'downward SW flux at sfc (W/m2)'
      s_out = s_out + 1
      varname(s_out) = 'glw     '
      vardesc(s_out) = 'downward LW flux at sfc (W/m2)'
    endif
    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4))then
      s_out = s_out + 1
      varname(s_out) = 'tslb1   '
      vardesc(s_out) = 'soil temp, layer 1 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb2   '
      vardesc(s_out) = 'soil temp, layer 2 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb3   '
      vardesc(s_out) = 'soil temp, layer 3 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb4   '
      vardesc(s_out) = 'soil temp, layer 4 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb5   '
      vardesc(s_out) = 'soil temp, layer 5 (K)        '
    endif
    if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
      s_out = s_out + 1
      varname(s_out) = 'tml     '
      vardesc(s_out) = 'ocean mixed layer temp (K)    '
      s_out = s_out + 1
      varname(s_out) = 'hml     '
      vardesc(s_out) = 'ocean mixed layer depth (m)   '
      s_out = s_out + 1
      varname(s_out) = 'huml    '
      vardesc(s_out) = 'ocean mixed layer u vel. (m/s)'
      s_out = s_out + 1
      varname(s_out) = 'hvml    '
      vardesc(s_out) = 'ocean mixed layer v vel. (m/s)'
    endif
    if(output_radten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'radsw   '
      vardesc(s_out) = 'solar radiation at surface    '
      s_out = s_out + 1
      varname(s_out) = 'rnflx   '
      vardesc(s_out) = 'net radiation absorbed by sfc '
      s_out = s_out + 1
      varname(s_out) = 'radswnet'
      vardesc(s_out) = 'net solar radiation           '
      s_out = s_out + 1
      varname(s_out) = 'radlwin '
      vardesc(s_out) = 'incoming longwave radiation   '
! MS addition - toa fluxes
      s_out = s_out + 1
      varname(s_out) = 'olr     '
      vardesc(s_out) = 'TOA net outgoing longwave rad.'
      s_out = s_out + 1
      varname(s_out) = 'dsr     '
      vardesc(s_out) = 'TOA net incoming solar rad.   '
    endif
    IF(output_sfcdiags.eq.1)THEN
      s_out = s_out + 1
      varname(s_out) = 'u10     '
      vardesc(s_out) = 'diagnostic 10m u wind (m/s)   '
      s_out = s_out + 1
      varname(s_out) = 'v10     '
      vardesc(s_out) = 'diagnostic 10m v wind (m/s)   '
      s_out = s_out + 1
      varname(s_out) = 't2      '
      vardesc(s_out) = 'diagnostic 2m temperature (K) '
      s_out = s_out + 1
      varname(s_out) = 'q2      '
      vardesc(s_out) = 'diagnostic 2m mixing ratio g/g'
      s_out = s_out + 1
      varname(s_out) = 'znt     '
      vardesc(s_out) = 'roughness length (m)          '
      s_out = s_out + 1
      varname(s_out) = 'ust     '
      vardesc(s_out) = 'u* in similarity theory (m/s) '
      s_out = s_out + 1
      varname(s_out) = 'hpbl    '
    if(ipbl.eq.1)then
      vardesc(s_out) = 'PBL height (m) (from PBL schem'
    else
      vardesc(s_out) = 'rough estimate of PBL hght (m)'
    endif
      s_out = s_out + 1
      varname(s_out) = 'zol     '
      vardesc(s_out) = 'z/L (z over Monin-Obukhov len)'
      s_out = s_out + 1
      varname(s_out) = 'mol     '
      vardesc(s_out) = 'T* (similarity theory) (K)    '
      s_out = s_out + 1
      varname(s_out) = 'br      '
      vardesc(s_out) = 'bulk Richardson No in sfc lay.'
      s_out = s_out + 1
      varname(s_out) = 'psim    '
      vardesc(s_out) = 'similarity stab. func. (mo.)  '
      s_out = s_out + 1
      varname(s_out) = 'psih    '
      vardesc(s_out) = 'similarity stab. func. (heat) '
      s_out = s_out + 1
      varname(s_out) = 'qsfc    '
      vardesc(s_out) = 'land/ocean wtr vpr mx rat (g/g'
    ENDIF

    ! done with 2d variables

    sout2d = s_out

    ! Now, all 3d variables:

    if(output_zh     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'zh      '
      vardesc(s_out) = 'height on model levels (m)    '
    endif
    if(output_th     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'th      '
      vardesc(s_out) = 'potential temp. (K)           '
    endif
    if(output_thpert .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'thpert  '
      vardesc(s_out) = 'potential temp. pert. (K)     '
    endif
    if(output_prs    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'prs     '
      vardesc(s_out) = 'pressure (Pa)                 '
    endif
    if(output_prspert.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'prspert '
      vardesc(s_out) = 'pressure pert. (Pa)           '
    endif
    if(output_pi     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pi      '
      vardesc(s_out) = 'nondimensional pressure       '
    endif
    if(output_pipert .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pipert  '
      vardesc(s_out) = 'nondimensional pressure pert. '
    endif
    if(output_rho    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'rho     '
      vardesc(s_out) = 'dry-air density (kg/m^3)      '
    endif
    if(output_rhopert.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'rhopert '
      vardesc(s_out) = 'dry-air density pert. (kg/m^3)'
    endif
    if(iptra         .eq.1)then
      do n=1,npt
        text1='pt      '
        if(n.le.9)then
          write(text1(3:3),155) n
155       format(i1.1)
        else
          write(text1(3:4),154) n
154       format(i2.2)
        endif
        s_out = s_out + 1
        varname(s_out) = text1
        vardesc(s_out) = 'passive tracer                '
      enddo
    endif
    if(output_qv     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'qv      '
      vardesc(s_out) = 'water vapor mixing ratio      '
    endif
    if(output_qvpert .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'qvpert  '
      vardesc(s_out) = 'qv pert                       '
    endif
    if(output_q      .eq.1)then
      do n=1,numq
        if(n.ne.nqv)then
          text1='        '
          text2='                              '
          write(text1(1:3),156) qname(n)
          write(text2(1:3),156) qname(n)
156       format(a3)
          s_out = s_out + 1
          varname(s_out) = text1
          vardesc(s_out) = text2
        endif
      enddo
    endif
    if(output_dbz    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'dbz     '
      vardesc(s_out) = 'reflectivity (dBZ)            '
    endif
    if(output_buoyancy.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'buoyancy'
      vardesc(s_out) = 'buoyancy (m s^-2)             '
    endif
    if(output_uinterp.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'uinterp '
      vardesc(s_out) = 'u interp. to scalar points    '
    endif
    if(output_vinterp.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'vinterp '
      vardesc(s_out) = 'v interp. to scalar points    '
    endif
    if(output_winterp.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'winterp '
      vardesc(s_out) = 'w interp. to scalar points    '
    endif
    if(output_vort.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'xvort   '
      vardesc(s_out) = 'horiz vorticity (x) (s^-1)    '
      s_out = s_out + 1
      varname(s_out) = 'yvort   '
      vardesc(s_out) = 'horiz vorticity (y) (s^-1)    '
      s_out = s_out + 1
      varname(s_out) = 'zvort   '
      vardesc(s_out) = 'vertical vorticity (s^-1)     '
    endif
    if(output_pv.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pv      '
      vardesc(s_out) = 'pot. vort. (K m^2 kg^-1 s^-1) '
    endif
    if(output_basestate.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pi0     '
      vardesc(s_out) = 'base-state nondim. pressure   '
      s_out = s_out + 1
      varname(s_out) = 'th0     '
      vardesc(s_out) = 'base-state potential temp (K) '
      s_out = s_out + 1
      varname(s_out) = 'prs0    '
      vardesc(s_out) = 'base-state pressure (Pa)      '
      s_out = s_out + 1
      varname(s_out) = 'qv0     '
      vardesc(s_out) = 'base-state qv (kg/kg)         '
    endif
    if(output_pblten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'thpten  '
      vardesc(s_out) = 'pbl tendency:  theta          '
      s_out = s_out + 1
      varname(s_out) = 'qvpten  '
      vardesc(s_out) = 'pbl tendency:  qv             '
      s_out = s_out + 1
      varname(s_out) = 'qcpten  '
      vardesc(s_out) = 'pbl tendency:  qc             '
      s_out = s_out + 1
      varname(s_out) = 'qipten  '
      vardesc(s_out) = 'pbl tendency:  qi             '
      s_out = s_out + 1
      varname(s_out) = 'upten   '
      vardesc(s_out) = 'pbl tendency:  u              '
      s_out = s_out + 1
      varname(s_out) = 'vpten   '
      vardesc(s_out) = 'pbl tendency:  v              '
    endif
    if(output_radten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'swten   '
      vardesc(s_out) = 'pot temp tendency, sw rad (K/s'
      s_out = s_out + 1
      varname(s_out) = 'lwten   '
      vardesc(s_out) = 'pot temp tendency, lw rad (K/s'
    endif

    if(output_turbten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'ftt     '
      vardesc(s_out) = 'theta tend, turb scheme (K/s) '
      if(imoist.eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'ftq     '
        vardesc(s_out) = 'qv tend, turb scheme (g/g/s)  '
      endif
    endif

    IF( output_dissheat.eq.1 )THEN
      s_out = s_out + 1
      varname(s_out) = 'dissheat'
      vardesc(s_out) = 'dissip. heating (K/s) (theta) '
    ENDIF
    IF( output_mptend.eq.1 )THEN
      s_out = s_out + 1
      varname(s_out) = 'mptend  '
      vardesc(s_out) = 'pot temp tend from microp (K/s'
    ENDIF
    IF( output_fallvel.eq.1 )THEN
      if( qd_vtc.gt.0 )then
        s_out = s_out + 1
        varname(s_out) = 'vtc     '
        vardesc(s_out) = 'terminal fall veloc: qc (m/s) '
      endif
      if( qd_vtr.gt.0 )then
        s_out = s_out + 1
        varname(s_out) = 'vtr     '
        vardesc(s_out) = 'terminal fall veloc: qr (m/s) '
      endif
      if( qd_vts.gt.0 )then
        s_out = s_out + 1
        varname(s_out) = 'vts     '
        vardesc(s_out) = 'terminal fall veloc: qs (m/s) '
      endif
      if( qd_vtg.gt.0 )then
        s_out = s_out + 1
        varname(s_out) = 'vtg     '
        vardesc(s_out) = 'terminal fall veloc: qg (m/s) '
      endif
      if( qd_vti.gt.0 )then
        s_out = s_out + 1
        varname(s_out) = 'vti     '
        vardesc(s_out) = 'terminal fall veloc: qi (m/s) '
      endif
    ENDIF

    sout3d = s_out - sout2d

!----------------------------
!  ready to write GrADS descriptor file:

  IF(s_out.ge.1)THEN
    string(totlen+1:totlen+22) = '_s.ctl                '
    if(dowr) write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_s.dat'
  elseif(output_filetype.ge.2)then
    sstring(baselen+1:baselen+1+12) = '_00%y4_s.dat'
  endif
    write(50,201) sstring
!!!    write(50,222)
    if(output_filetype.ge.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) maxk,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) maxk
      do k=1,maxk
        write(50,217) 0.001*sigma(k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.ge.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) s_out
    ! account for both 2d and 3d output files:
    do n=1,sout2d
      write(50,209) varname(n), 0,vardesc(n)
    enddo
    do n=sout2d+1,s_out
      write(50,209) varname(n),maxk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! i file:  (for interpolated output when using terrain)
!   follows s file very closely:
!   no need to re-define varname,vardesc...

  IF(s_out.ge.1 .and. terrain_flag .and. output_interp.eq.1)THEN
    string(totlen+1:totlen+22) = '_i.ctl                '
    if(dowr) write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_i.dat'
  elseif(output_filetype.ge.2)then
    sstring(baselen+1:baselen+1+12) = '_00%y4_i.dat'
  endif

    write(50,201) sstring
!!!    write(50,222)
    if(output_filetype.ge.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) maxk,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) maxk
      do k=1,maxk
        write(50,217) 0.001*sigma(k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.ge.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) s_out
    ! account for both 2d and 3d output files:
    do n=1,sout2d
      write(50,209) varname(n), 0,vardesc(n)
    enddo
    do n=sout2d+1,s_out
      write(50,209) varname(n),maxk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! u file:
! I have assumed that all variables are 3d for this file.

    u_out = 0

    if(output_u    .eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'u       '
      vardesc(u_out) = 'E-W velocity (m/s)            '
    endif
    if(output_upert.eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'upert   '
      vardesc(u_out) = 'u pert. (m/s)                 '
    endif
    if(output_basestate.eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'u0      '
      vardesc(u_out) = 'base-state u (m/s)            '
    endif
    if(output_turbten.eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'ftu     '
      vardesc(u_out) = 'u tendency: turbulence scheme '
    endif
    if(output_impdiften.eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'fdu     '
      vardesc(u_out) = 'u tendency: implicit diffusion'
    endif

  IF(u_out.ge.1)THEN
    string(totlen+1:totlen+22) = '_u.ctl                '
    if(dowr) write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_u.dat'
  elseif(output_filetype.ge.2)then
    sstring(baselen+1:baselen+1+12) = '_00%y4_u.dat'
  endif

    write(50,201) sstring
    if(output_filetype.ge.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx+1
      do i=1,nx+1
        write(50,217) 0.001*xfref(i)
      enddo
    else
      write(50,204) nx+1,xf(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) maxk,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) maxk
      do k=1,maxk
        write(50,217) 0.001*sigma(k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.ge.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) u_out
    ! assumes all variables are 3d:
    do n=1,u_out
      write(50,209) varname(n),maxk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! v file:
! I have assumed that all variables are 3d for this file.

    v_out = 0

    if(output_v    .eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'v       '
      vardesc(v_out) = 'N-S velocity (m/s)            '
    endif
    if(output_vpert.eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'vpert   '
      vardesc(v_out) = 'v pert (m/s)                  '
    endif
    if(output_basestate.eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'v0      '
      vardesc(v_out) = 'base-state v (m/s)            '
    endif
    if(output_turbten.eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'ftv     '
      vardesc(v_out) = 'v tendency: turbulence scheme '
    endif
    if(output_impdiften.eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'fdv     '
      vardesc(v_out) = 'v tendency: implicit diffusion'
    endif

  IF(v_out.ge.1)THEN
    string(totlen+1:totlen+22) = '_v.ctl                '
    if(dowr) write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_v.dat'
  elseif(output_filetype.ge.2)then
    sstring(baselen+1:baselen+1+12) = '_00%y4_v.dat'
  endif

    write(50,201) sstring
    if(output_filetype.ge.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny+1
      do j=1,ny+1
        write(50,217) 0.001*yfref(j)
      enddo
    else
      write(50,205) ny+1,yf(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) maxk,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) maxk
      do k=1,maxk
        write(50,217) 0.001*sigma(k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.ge.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) v_out
    ! assumes all variables are 3d:
    do n=1,v_out
      write(50,209) varname(n),maxk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! w file:
! I have assumed that all variables are 3d for this file.

    w_out = 0

    if(output_w  .eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'w       '
      vardesc(w_out) = 'vertical velocity (m/s)       '
    endif
    if(output_tke.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'tke     '
      vardesc(w_out) = 'turb. kinetic energy (m^2/s^2)'
    endif
    if(output_km .eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'kmh     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for mo. (2D Smag.)'
      ELSE
        vardesc(w_out) = 'turb. coef. for mo. (m^2/s)   '
      ENDIF
      w_out = w_out + 1
      varname(w_out) = 'kmv     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for mo. (from YSU)'
      ELSE
        vardesc(w_out) = 'turb. coef. for mo. (m^2/s)   '
      ENDIF
    endif
    if(output_kh .eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'khh     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for scalar (2D Sm)'
      ELSE
        vardesc(w_out) = 'turb. coef. for scalar (m^2/s)'
      ENDIF
      w_out = w_out + 1
      varname(w_out) = 'khv     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for scalar (YSU)  '
      ELSE
        vardesc(w_out) = 'turb. coef. for scalar (m^2/s)'
      ENDIF
    endif
    if(output_dissten.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'dissten '
      vardesc(w_out) = 'dissipation rate (m^2/s^3)    '
    endif
    if(output_nm.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'nm      '
      vardesc(w_out) = 'squared Brunt-Vaisala freq    '
    endif
    if(output_def.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'defv    '
      vardesc(w_out) = 'vertical deformation          '
      w_out = w_out + 1
      varname(w_out) = 'defh    '
      vardesc(w_out) = 'horizontal deformation        '
    endif
    if(output_turbten.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'ftw     '
      vardesc(w_out) = 'w tendency: turbulence scheme '
    endif
    if(output_impdiften.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'fdw     '
      vardesc(w_out) = 'w tendency: implicit diffusion'
    endif

  IF(w_out.ge.1)THEN
    string(totlen+1:totlen+22) = '_w.ctl                '
    if(dowr) write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_w.dat'
  elseif(output_filetype.ge.2)then
    sstring(baselen+1:baselen+1+12) = '_00%y4_w.dat'
  endif

    write(50,201) sstring
    if(output_filetype.ge.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) maxk+1,0.0,dz/1000.0
    else
      write(50,216) maxk+1
      do k=1,maxk+1
        write(50,217) 0.001*sigmaf(k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.ge.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) w_out
    ! assumes all variables are 3d:
    do n=1,w_out
      write(50,209) varname(n),maxk+1,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------

    if(dowr) write(outfile,*)

201   format('dset ^',a70)
202   format('title CM1 output')
221   format('options template')
222   format('byteswapped')
203   format('undef -99999999.')
204   format('xdef ',i6,' linear ',f13.6,1x,f13.6)
214   format('xdef ',i6,' levels ')
205   format('ydef ',i6,' linear ',f13.6,1x,f13.6)
215   format('ydef ',i6,' levels ')
206   format('zdef ',i6,' linear ',f13.6,1x,f13.6)
216   format('zdef ',i6,' levels ')
217   format(2x,f13.6)
207   format('tdef ',i10,' linear ',a15,' ',i5,'MN')
227   format('tdef ',i10,' linear ',a15,' 1YR')
208   format('vars ',i4)
209   format(a8,2x,i6,'  99  ',a30)
210   format('endvars')

211   format(2x,f7.3)

!-----------------------------------------------------------------------

      if( stat_out.gt.0 )  &
      call write_statsctl(tdef,qname,budname,1+nint(timax/max(statfrq,dtl)))

!-----------------------------------------------------------------------
!  Parcel data file:

      if(iprcl.eq.1.and.myid.eq.0)then

        string(totlen+1:totlen+22) = '_pdata.ctl            '
        if(dowr) write(outfile,*) string
        open(unit=50,file=string,status='unknown')

        sstring(baselen+1:baselen+1+12) = '_pdata.dat  '

        write(50,401) sstring
        write(50,402)
        write(50,403)
        write(50,404) nparcels
        write(50,405)
        write(50,406)
      if( prclfrq.gt.0 )then
        write(50,407) 1+int(timax/prclfrq),tdef,max(1,int(prclfrq/60.0))
      else
        write(50,407) 1000000000,tdef,max(1,int(prclfrq/60.0))
      endif
        write(50,408) npvals
                       write(50,409) 'x       ','x (m)                         '
                       write(50,409) 'y       ','y (m)                         '
                       write(50,409) 'z       ','z (m)                         '
                       write(50,409) 'u       ','u (m/s)                       '
                       write(50,409) 'v       ','v (m/s)                       '
                       write(50,409) 'w       ','w (m/s)                       '
        if(prth .ge.1) write(50,409) 'th      ','potential temperature (K)     '
        if(prt  .ge.1) write(50,409) 't       ','temperature (K)               '
        if(prprs.ge.1) write(50,409) 'prs     ','pressure (Pa)                 '

        if(prpt1.ge.1)then
          do n=1,npt
            text1='pt      '
            if(n.le.9)then
              write(text1(3:3),155) n
            else
              write(text1(3:4),154) n
            endif
                      write(50,409) text1     ,'passive tracer conc. (g/g)    '
          enddo
        endif

        if(prqv.ge.1) write(50,409) 'qv      ','water vapor mixing ratio (g/g)'

        if(prq1.ge.1)then
          n2 = nql2
          if( iice.eq.1 ) n2 = nqs2
          do n=nql1,n2
          text1='        '
          text2='                              '
          write(text1(1:3),156) qname(n)
          write(text2(1:3),156) qname(n)
                      write(50,409) text1,text2
          enddo
        endif

        if(prnc1.ge.1)then
          do n=nnc1,nnc2
          text1='        '
          text2='                              '
          write(text1(1:3),156) qname(n)
          write(text2(1:3),156) qname(n)
                      write(50,409) text1,text2
          enddo
        endif

        if(prkm   .ge.1) write(50,409) 'kmh     ','turb. coef. for mo. (m^2/s)   '
        if(prkm   .ge.1) write(50,409) 'kmv     ','turb. coef. for mo. (m^2/s)   '
        if(prkh   .ge.1) write(50,409) 'khh     ','turb. coef. for scalar (m^2/s)'
        if(prkh   .ge.1) write(50,409) 'khv     ','turb. coef. for scalar (m^2/s)'
        if(prtke  .ge.1) write(50,409) 'tke     ','turb. kinetic energy (m^2/s^2)'
        if(prdbz  .ge.1) write(50,409) 'dbz     ','reflectivity (dBZ)            '
        if(prb    .ge.1) write(50,409) 'b       ','buoyancy (m^2/s)              '
        if(prvpg  .ge.1) write(50,409) 'vpg     ','vert. pres. grad. (m^2/s)     '
        if(przv   .ge.1) write(50,409) 'zv      ','vert. vorticity (1/s)         '
        if(prrho  .ge.1) write(50,409) 'rho     ','dry-air density (kg/m^3)      '
        if(prqsl  .ge.1) write(50,409) 'qsl     ','sat. mixing ratio wrt liq     '
        if(prqsi  .ge.1) write(50,409) 'qsi     ','sat. mixing ratio wrt ice     '
        if(prznt  .ge.1) write(50,409) 'znt     ','sfc roughness length (m)      '
        if(prust  .ge.1) write(50,409) 'ust     ','sfc friction velocity (m/s)   '
        write(50,410)

401     format('dset ^',a70)
402     format('undef -99999999.')
403     format('title ctl file for pdata.dat')
404     format('xdef ',i10,' linear 1 1')
405     format('ydef          1 linear 1 1')
406     format('zdef          1 linear 1 1')
407     format('tdef ',i10,' linear ',a15,' ',i5,'MN')
408     format('vars ',i6)
409     format(a8,' 1 99 ',a30)
410     format('endvars')

        close(unit=50)

      endif

!-----------------------------------------------------------------------

        deallocate( varname )
        deallocate( vardesc )

      ENDIF     ! endif for myid=0

#ifdef MPI
      call MPI_BCAST(sout2d,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sout3d,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(s_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(u_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(v_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(w_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(z_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
#endif

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  sout2d = ',sout2d
      if(dowr) write(outfile,*) '  sout3d = ',sout3d
      if(dowr) write(outfile,*) '  s_out  = ',s_out
      if(dowr) write(outfile,*) '  u_out  = ',u_out
      if(dowr) write(outfile,*) '  v_out  = ',v_out
      if(dowr) write(outfile,*) '  w_out  = ',w_out
      if(dowr) write(outfile,*) '  z_out  = ',z_out

  ENDIF grads_descriptors

      if(dowr) write(outfile,*)

!-----------------------------------------------------------------------

      end subroutine setup_output


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine write_statsctl(tdef,qname,budname,numt)
      implicit none
      include 'input.incl'

      !---------------------------------------------------------------
      ! This subroutine creates the GrADS-format stats descriptor file
      !---------------------------------------------------------------

      character*15, intent(in) :: tdef
      character*3, intent(in), dimension(maxq) :: qname
      character*6, intent(in), dimension(maxq) :: budname
      integer, intent(in) :: numt

      integer :: n
      character*8 text1
      character*30 text2
      character*50 fname

!  Subroutine to write GrADS stats descriptor file:
!-----------------------------------------------------------------------
!  write descriptors for stats file:

    string(totlen+1:totlen+22) = '_stats.ctl            '
    if(dowr) write(outfile,*) string
    open(unit=50,file=string,status='unknown')

    sstring(baselen+1:baselen+1+12) = '_stats.dat  '

    write(50,301) sstring
    write(50,302)
    write(50,303)
    write(50,304)
    write(50,305)
    write(50,306)
    write(50,307) numt,tdef,max(1,int(max(statfrq,60.0)/60.0))
    write(50,308) stat_out
    IF( adapt_dt.eq.1 )   write(50,309) 'dt      ','average timestep dt (s)       '
    if(stat_w      .eq.1) write(50,309) 'wmax    ','max vertical velocity (m/s)   '
    if(stat_w      .eq.1) write(50,309) 'wmin    ','min vertical velocity (m/s)   '
    if(stat_u      .eq.1) write(50,309) 'umax    ','max E-W velocity (m/s)        '
    if(stat_u      .eq.1) write(50,309) 'umin    ','min E-W velocity (m/s)        '
    if(stat_u      .eq.1) write(50,309) 'sumax   ','max E-W velocity lwst lvl(m/s)'
    if(stat_u      .eq.1) write(50,309) 'sumin   ','min E-W velocity lwst lvl(m/s)'
    if(stat_v      .eq.1) write(50,309) 'vmax    ','max N-S velocity (m/s)        '
    if(stat_v      .eq.1) write(50,309) 'vmin    ','min N-S velocity (m/s)        '
    if(stat_v      .eq.1) write(50,309) 'svmax   ','max N-S velocity lwst lvl(m/s)'
    if(stat_v      .eq.1) write(50,309) 'svmin   ','min N-S velocity lwst lvl(m/s)'
    if(stat_rmw    .eq.1) write(50,309) 'rmw     ','radius (m) of maximum windspd '
    if(stat_rmw    .eq.1) write(50,309) 'zmw     ','height (m) of maximum windspd '
    if(stat_pipert .eq.1) write(50,309) 'ppimax  ','max pi pert.                  '
    if(stat_pipert .eq.1) write(50,309) 'ppimin  ','min pi pert.                  '
    if(stat_prspert.eq.1) write(50,309) 'ppmax   ','max prs pert.(Pa)             '
    if(stat_prspert.eq.1) write(50,309) 'ppmin   ','min prs pert.(Pa)             '
    if(stat_thpert .eq.1) write(50,309) 'thpmax  ','max potential temp. pert. (K) '
    if(stat_thpert .eq.1) write(50,309) 'thpmin  ','min potential temp. pert. (K) '
    if(stat_thpert .eq.1) write(50,309) 'sthpmax ','max pot temp pert lwst lvl (K)'
    if(stat_thpert .eq.1) write(50,309) 'sthpmin ','min pot temp pert lwst lvl (K)'
    if(stat_q      .eq.1)then
      do n=1,numq
        text1='max     '
        text2='max                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
        write(50,309) text1,text2
        text1='min     '
        text2='min                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
        write(50,309) text1,text2
      enddo
    endif
    if(stat_tke    .eq.1) write(50,309) 'tkemax  ','max tke (m^2/s^2)             '
    if(stat_tke    .eq.1) write(50,309) 'tkemin  ','min tke (m^2/s^2)             '
    if(stat_km     .eq.1) write(50,309) 'kmhmax  ','max kmh (m^2/s)               '
    if(stat_km     .eq.1) write(50,309) 'kmhmin  ','min kmh (m^2/s)               '
    if(stat_km     .eq.1) write(50,309) 'kmvmax  ','max kmv (m^2/s)               '
    if(stat_km     .eq.1) write(50,309) 'kmvmin  ','min kmv (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khhmax  ','max khh (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khhmin  ','min khh (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khvmax  ','max khv (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khvmin  ','min khv (m^2/s)               '
    if(stat_div    .eq.1) write(50,309) 'divmax  ','max 3d divergence             '
    if(stat_div    .eq.1) write(50,309) 'divmin  ','min 3d divergence             '
    if(stat_rh     .eq.1) write(50,309) 'rhmax   ','max relative humidity         '
    if(stat_rh     .eq.1) write(50,309) 'rhmin   ','min relative humidity         '
    if(stat_rhi    .eq.1) write(50,309) 'rhimax  ','max relative humidity wrt ice '
    if(stat_rhi    .eq.1) write(50,309) 'rhimin  ','min relative humidity wrt ice '
    if(iptra       .eq.1)then
      do n=1,npt
        text1='maxpt   '
        text2='max pt                        '
        if( n.le.9 )then
          write(text1(6:6),157) n
          write(text2(7:7),157) n
        else
          write(text1(6:7),257) n
          write(text2(7:8),257) n
        endif
        write(50,309) text1,text2
        text1='minpt   '
        text2='min pt                        '
        if( n.le.9 )then
          write(text1(6:6),157) n
          write(text2(7:7),157) n
        else
          write(text1(6:7),257) n
          write(text2(7:8),257) n
        endif
157     format(i1)
257     format(i2)
        write(50,309) text1,text2
      enddo
    endif
    if(stat_the    .eq.1) write(50,309) 'themax  ','max theta-e below 10 km       '
    if(stat_the    .eq.1) write(50,309) 'themin  ','min theta-e below 10 km       '
    if(stat_the    .eq.1) write(50,309) 'sthemax ','max theta-e at lowest level   '
    if(stat_the    .eq.1) write(50,309) 'sthemin ','min theta-e at lowest level   '
    if(stat_cloud  .eq.1) write(50,309) 'qctop   ','max cloud top height (m)      '
    if(stat_cloud  .eq.1) write(50,309) 'qcbot   ','min cloud base height (m)     '
    if(stat_sfcprs .eq.1) write(50,309) 'sprsmax ','max pressure at lowest lvl (Pa'
    if(stat_sfcprs .eq.1) write(50,309) 'sprsmin ','min pressure at lowest lvl (Pa'
    if(stat_sfcprs .eq.1) write(50,309) 'psfcmax ','max surface pressure (Pa)     '
    if(stat_sfcprs .eq.1) write(50,309) 'psfcmin ','min surface pressure (Pa)     '
    if(stat_wsp    .eq.1) write(50,309) 'wspmax  ','max wind speed (m/s)          '
    if(stat_wsp    .eq.1) write(50,309) 'wspmin  ','min wind speed (m/s)          '
    if(stat_wsp    .eq.1) write(50,309) 'swspmax ','max wind speed lowst lvl (m/s)'
    if(stat_wsp    .eq.1) write(50,309) 'swspmin ','min wind speed lowst lvl (m/s)'
  IF(bbc.eq.3)THEN
    if(stat_wsp    .eq.1) write(50,309) 'wsp10max','max 10 m wind speed (m/s)     '
    if(stat_wsp    .eq.1) write(50,309) 'wsp10min','min 10 m wind speed (m/s)     '
  ENDIF
  IF( adapt_dt.eq.1 )THEN
    if(stat_cfl    .eq.1) write(50,309) 'cflmax  ','max Courant number (average)  '
  ELSE
    if(stat_cfl    .eq.1) write(50,309) 'cflmax  ','max Courant number            '
  ENDIF
    if(stat_cfl    .eq.1.and.iturb.ge.1) write(50,309) 'kshmax  ','max horiz K stability factor  '
    if(stat_cfl    .eq.1.and.iturb.ge.1) write(50,309) 'ksvmax  ','max vert K stability factor   '
    if(stat_vort   .eq.1) write(50,309) 'vortsfc ','max vert. vort. lwst lvl (1/s)'
    if(stat_vort   .eq.1) write(50,309) 'vort1km ','max vert. vort. at 1 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort2km ','max vert. vort. at 2 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort3km ','max vert. vort. at 3 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort4km ','max vert. vort. at 4 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort5km ','max vert. vort. at 5 km (1/s) '
    if(stat_tmass  .eq.1) write(50,309) 'tmass   ','total mass of (dry) air       '
    if(stat_tmois  .eq.1) write(50,309) 'tmois   ','total moisture                '
    if(stat_qmass  .eq.1)then
      do n=1,numq
        IF( (n.eq.nqv) .or.                                 &
            (n.ge.nql1.and.n.le.nql2) .or.                  &
            (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
          text1='mass    '
          text2='total mass of                 '
          write(text1( 5: 7),156) qname(n)
          write(text2(15:17),156) qname(n)
          write(50,309) text1,text2
        ENDIF
      enddo
    endif
    if(stat_tenerg .eq.1) write(50,309) 'ek      ','total kinetic energy          '
    if(stat_tenerg .eq.1) write(50,309) 'ei      ','total internal energy         '
    if(stat_tenerg .eq.1) write(50,309) 'ep      ','total potential energy        '
    if(stat_tenerg .eq.1) write(50,309) 'le      ','total latent energy (sort of) '
    if(stat_tenerg .eq.1) write(50,309) 'et      ','total energy                  '
    if(stat_mo     .eq.1) write(50,309) 'tmu     ','total E-W momentum            '
    if(stat_mo     .eq.1) write(50,309) 'tmv     ','total N-S momentum            '
    if(stat_mo     .eq.1) write(50,309) 'tmw     ','total vertical momentum       '
    if(stat_tmf    .eq.1) write(50,309) 'tmfu    ','total upward mass flux        '
    if(stat_tmf    .eq.1) write(50,309) 'tmfd    ','total downward mass flux      '
    if(stat_pcn    .eq.1)then
      do n=1,nbudget
        text1='        '
        text2='                              '
        write(text1(1:6),158) budname(n)
        write(text2(1:6),158) budname(n)
158     format(a6)
        write(50,309) text1,text2
      enddo
    endif
    if(stat_qsrc   .eq.1)then
      do n=1,numq
        text1='as      '
        text2='artificial source of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        write(50,309) text1,text2
      enddo
      do n=1,numq
        text1='bs      '
        text2='bndry source/sink of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        write(50,309) text1,text2
      enddo
    endif
    write(50,310)

156   format(a3)
301   format('dset ^',a70)
302   format('undef -99999999.')
303   format('title ctl file for stats.dat')
304   format('xdef 1 linear 1 1')
305   format('ydef 1 linear 1 1')
306   format('zdef 1 linear 1 1')
307   format('tdef ',i10,' linear ',a15,' ',i5,'MN')
308   format('vars ',i6)
309   format(a8,' 1 99 ',a30)
310   format('endvars')

      close(unit=50)

      end subroutine write_statsctl


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine writeout(rtime,dt,fnum,nwrite,qname,xh,xf,uf,yh,yf,vf,xfref,yfref,            &
                        rds,sigma,rdsf,sigmaf,zh,zf,mf,gx,gy,                                  &
                        pi0,prs0,rho0,rr0,rf0,rrf0,th0,qv0,u0,v0,                              &
                        zs,rgzu,rgzv,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,psfc,      &
                        rxh,arh1,arh2,uh,ruh,rxf,arf1,arf2,vh,rvh,mh,rmf,rr,rf,                &
                        gz,rgz,gzu,gzv,gxu,gyv,dzdx,dzdy,c1,c2,                                &
                        cd,ch,cq,tlh,dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8,                  &
                        t11,t12,t13,t22,t23,t33,rho,prs,dbz ,                                  &
                        rru,ua,u3d,dumu,rrv,va,v3d,dumv,rrw,wa,w3d,dumw,ppi,tha,               &
                        us,vs,ws,thadv,thten,nm,defv,defh,dissten,                             &
                        thpten,qvpten,qcpten,qipten,upten,vpten,                               &
                        lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,  &
                        qa,kmh,kmv,khh,khv,tkea,swten,lwten,                                   &
                        radsw,rnflx,radswnet,radlwin,dsr,olr,pta,                              &
                        num_soil_layers,u10,v10,t2,q2,znt,ust,u1,v1,s1,                        &
                        hpbl,zol,mol,br,psim,psih,qsfc,                                        &
                        dat1,dat2,dat3,reqt,ntdiag,nqdiag,tdiag,qdiag,                         &
                        nw1,nw2,ne1,ne2,sw1,sw2,se1,se2)
#ifdef MPI
      use mpi
#endif
#ifdef NETCDF
      use netcdf
#endif
      implicit none

      !----------------------------------------------------------
      ! This subroutine organizes writeouts for GrADS-format and
      ! netcdf-format output.
      !----------------------------------------------------------

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout) :: rtime,dt
      integer, intent(in) :: fnum,nwrite
      character*3, dimension(maxq), intent(in) :: qname
      real, dimension(ib:ie), intent(in) :: xh
      real, dimension(ib:ie+1), intent(in) :: xf,uf
      real, dimension(jb:je), intent(in) :: yh
      real, dimension(jb:je+1), intent(in) :: yf,vf
      real, intent(in), dimension(-2:nx+4) :: xfref
      real, intent(in), dimension(-2:ny+4) :: yfref
      real, dimension(kb:ke), intent(in) :: rds,sigma
      real, dimension(kb:ke+1), intent(in) :: rdsf,sigmaf
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: zh
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: zf,mf
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gx,gy
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: pi0,prs0,rho0,rr0,rf0,rrf0,th0,qv0
      real, dimension(ib:ie,jb:je), intent(in) :: zs
      real, dimension(itb:ite,jtb:jte), intent(in) :: rgzu,rgzv
      real, dimension(ib:ie,jb:je,nrain), intent(in) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je), intent(in) :: xland,psfc,thflux,qvflux,cd,ch,cq,tlh
      real, intent(in), dimension(ib:ie) :: rxh,arh1,arh2,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: rxf,arf1,arf2
      real, intent(in), dimension(jb:je) :: vh,rvh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: mh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: rmf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rr,rf
      real, intent(in), dimension(itb:ite,jtb:jte) :: gz,rgz,gzu,gzv
      real, intent(in), dimension(itb:ite,jtb:jte,ktb:kte) :: gxu,gyv
      real, intent(in), dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: c1,c2
      real, dimension(ib:ie,jb:je,kb:ke), intent(inout) :: dum1,dum2,dum3,dum4,dum5,dum6,dum7,dum8
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: t11,t12,t13,t22,t23,t33
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: rho,prs,dbz
      real, dimension(ib:ie+1,jb:je,kb:ke), intent(in) :: u0,ua
      real, dimension(ib:ie+1,jb:je,kb:ke), intent(inout) :: u3d,rru,dumu
      real, dimension(ib:ie,jb:je+1,kb:ke), intent(in) :: v0,va
      real, dimension(ib:ie,jb:je+1,kb:ke), intent(inout) :: v3d,rrv,dumv
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: wa
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(inout) :: w3d,rrw,dumw
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: ppi,tha
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: us
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: vs
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: ws
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: thadv,thten
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: nm,defv,defh,dissten
      real, dimension(ibb:ieb,jbb:jeb,kbb:keb), intent(in) :: thpten,qvpten,qcpten,qipten,upten,vpten
      integer, dimension(ibl:iel,jbl:jel), intent(in) :: lu_index
      real, dimension(ib:ie,jb:je), intent(in) :: tsk
      real, dimension(ibl:iel,jbl:jel), intent(in) :: mavail,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw
      real, dimension(ibl:iel,jbl:jel,num_soil_layers), intent(in) :: tslb
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq), intent(in) :: qa
      real, dimension(ibc:iec,jbc:jec,kbc:kec), intent(in) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket), intent(in) :: tkea
      real, dimension(ibr:ier,jbr:jer,kbr:ker), intent(in) :: swten,lwten
      real, dimension(ni,nj), intent(in) :: radsw,rnflx,radswnet,radlwin,dsr,olr
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt), intent(in) :: pta
      integer, intent(in) :: num_soil_layers
      real, dimension(ibl:iel,jbl:jel), intent(in) :: u10,v10,t2,q2,hpbl,zol,mol,br,psim,psih,qsfc
      real, dimension(ib:ie,jb:je), intent(in) :: znt,ust,u1,v1,s1
      real, intent(inout), dimension(ni+1,nj+1) :: dat1
      real, intent(inout), dimension(d2i,d2j) :: dat2
      real, intent(inout), dimension(d3i,d3j,d3n) :: dat3
      integer, intent(inout), dimension(d3t) :: reqt
      integer, intent(in) ::ntdiag,nqdiag
      real, intent(in) , dimension(ibd:ied,jbd:jed,kbd:ked,ntdiag) :: tdiag
      real, intent(in) , dimension(ibd:ied,jbd:jed,kbd:ked,nqdiag) :: qdiag
      real, intent(inout), dimension(kmt) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2

      integer i,j,k,n,irec
      integer :: ncid,time_index,varid
      real :: tnew,pnew,thold,thnew,rdt
      real :: tem,r1,r2,epsd
      character*8 :: chid
      logical :: opens,openu,openv,openw
      logical, parameter :: dosfcflx = .true.
#ifdef MPI
      character*80 sname,uname,vname,wname
      integer, dimension(MPI_STATUS_SIZE) :: status
      logical :: doit
      integer, parameter :: nlim = 1000
      integer :: reqs
#endif

!--------------------------------------------------------------
!  writeout data on scalar-points

      opens = .false.
      openu = .false.
      openv = .false.
      openw = .false.

      irec = 1
      ncid = 1
      time_index = 1

      if( myid.eq.0 ) print *,'  nwrite = ',nwrite

  IF(output_format.eq.1)THEN
  ! grads stuff:
  IF( output_filetype.eq.1 .and. myid.eq.nodemaster )THEN
    ! one output file:
    if(dowr) write(outfile,*)
    if(s_out.ge.1)then
      if(fnum.eq.51)then
        string(totlen+1:totlen+22) = '_s.dat                '
      elseif(fnum.eq.71)then
        string(totlen+1:totlen+22) = '_i.dat                '
      endif
      if(dowr) write(outfile,*) string
      open(unit=fnum,file=string,form='unformatted',access='direct',   &
           recl=(nx*ny*4),status='unknown')
      irec=1+(nwrite-1)*( sout2d + maxk*sout3d )
      opens = .true.
    endif
    if(u_out.ge.1.and.fnum.ne.71)then
      string(totlen+1:totlen+22) = '_u.dat                '
      if(dowr) write(outfile,*) string
      open(unit=52,file=string,form='unformatted',access='direct',   &
           recl=((nx+1)*ny*4),status='unknown')
      openu = .true.
    endif
    if(v_out.ge.1.and.fnum.ne.71)then
      string(totlen+1:totlen+22) = '_v.dat                '
      if(dowr) write(outfile,*) string
      open(unit=53,file=string,form='unformatted',access='direct',   &
           recl=(nx*(ny+1)*4),status='unknown')
      openv = .true.
    endif
    if(w_out.ge.1.and.fnum.ne.71)then
      string(totlen+1:totlen+22) = '_w.dat                '
      if(dowr) write(outfile,*) string
      open(unit=54,file=string,form='unformatted',access='direct',   &
           recl=(nx*ny*4),status='unknown')
      openw = .true.
    endif
  ELSEIF( output_filetype.eq.2 .and. myid.eq.nodemaster )THEN
    ! one output file per output time:
    if(s_out.ge.1)then
      if(fnum.eq.51)then
        string(totlen+1:totlen+22) = '_XXXXXX_s.dat         '
      elseif(fnum.eq.71)then
        string(totlen+1:totlen+22) = '_XXXXXX_i.dat         '
      endif
      write(string(totlen+2:totlen+7),102) nwrite
102   format(i6.6)
      if(dowr) write(outfile,*) string
      open(unit=fnum,file=string,form='unformatted',access='direct',   &
           recl=(nx*ny*4),status='unknown')
      irec=1
      opens = .true.
    endif
    if(u_out.ge.1.and.fnum.ne.71)then
      string(totlen+1:totlen+22) = '_XXXXXX_u.dat         '
      write(string(totlen+2:totlen+7),102) nwrite
      if(dowr) write(outfile,*) string
      open(unit=52,file=string,form='unformatted',access='direct',   &
           recl=((nx+1)*ny*4),status='unknown')
      openu = .true.
    endif
    if(v_out.ge.1.and.fnum.ne.71)then
      string(totlen+1:totlen+22) = '_XXXXXX_v.dat         '
      write(string(totlen+2:totlen+7),102) nwrite
      if(dowr) write(outfile,*) string
      open(unit=53,file=string,form='unformatted',access='direct',   &
           recl=(nx*(ny+1)*4),status='unknown')
      openv = .true.
    endif
    if(w_out.ge.1.and.fnum.ne.71)then
      string(totlen+1:totlen+22) = '_XXXXXX_w.dat         '
      write(string(totlen+2:totlen+7),102) nwrite
      if(dowr) write(outfile,*) string
      open(unit=54,file=string,form='unformatted',access='direct',   &
           recl=(nx*ny*4),status='unknown')
      openw = .true.
    endif
  ELSEIF(output_filetype.eq.3)THEN
    ! one output file per output time AND one output file per processor:
    ! (MPI only)
#ifdef MPI
      irec=1

      sname = '                                                                                '
      uname = '                                                                                '
      vname = '                                                                                '
      wname = '                                                                                '

    if(strlen.gt.0)then
      sname(1:strlen) = output_path(1:strlen)
      uname(1:strlen) = output_path(1:strlen)
      vname(1:strlen) = output_path(1:strlen)
      wname(1:strlen) = output_path(1:strlen)
    endif

      sname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      uname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      vname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      wname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      if(fnum.eq.51)then
        sname(totlen+1:totlen+22) = '_XXXXXX_YYYYYY_s.dat  '
      elseif(fnum.eq.71)then
        sname(totlen+1:totlen+22) = '_XXXXXX_YYYYYY_i.dat  '
      endif
      uname(totlen+1:totlen+22) = '_XXXXXX_YYYYYY_u.dat  '
      vname(totlen+1:totlen+22) = '_XXXXXX_YYYYYY_v.dat  '
      wname(totlen+1:totlen+22) = '_XXXXXX_YYYYYY_w.dat  '

      write(sname(totlen+2:totlen+ 7),100) myid
      write(sname(totlen+9:totlen+14),100) nwrite

      write(uname(totlen+2:totlen+ 7),100) myid
      write(uname(totlen+9:totlen+14),100) nwrite

      write(vname(totlen+2:totlen+ 7),100) myid
      write(vname(totlen+9:totlen+14),100) nwrite

      write(wname(totlen+2:totlen+ 7),100) myid
      write(wname(totlen+9:totlen+14),100) nwrite

100   format(i6.6)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  myid,sname=',myid,'   ',sname
      open(unit=fnum,file=sname,                   &
           form='unformatted',access='direct',   &
           recl=(ni*nj*4),status='unknown')
      opens = .true.

      if(u_out.ge.1.and.fnum.ne.71)then
        if(dowr) write(outfile,*) '  myid,uname=',myid,'   ',uname
        open(unit=52,file=uname,                   &
             form='unformatted',access='direct',   &
             recl=((ni+1)*nj*4),status='unknown')
        openu = .true.
      endif

      if(v_out.ge.1.and.fnum.ne.71)then
        if(dowr) write(outfile,*) '  myid,vname=',myid,'   ',vname
        open(unit=53,file=vname,                   &
             form='unformatted',access='direct',   &
             recl=(ni*(nj+1)*4),status='unknown')
        openv = .true.
      endif

      if(w_out.ge.1.and.fnum.ne.71)then
        if(dowr) write(outfile,*) '  myid,wname=',myid,'   ',wname
        open(unit=54,file=wname,                   &
             form='unformatted',access='direct',   &
             recl=(ni*nj*4),status='unknown')
        openw = .true.
      endif
      !  limit to "nlim" writes at a time:
      IF( numprocs.gt.nlim )THEN
        doit = .false.
        IF( myid.ge.nlim )THEN
          call MPI_IRECV(doit,1,mpi_logical,myid-nlim,999999,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,status,ierr)
        ENDIF
      ENDIF
#else
    print *,'  output_filetype = ',output_filetype
    print *,'  This option is only available for MPI runs '
    print *,'  Stopping cm1 .... '
    call stopcm1
#endif
  ELSEIF(output_filetype.eq.4)THEN
    ! (MPI only)
#ifdef MPI
    IF( myid.eq.0 )THEN
      irec=1

      sname = '                                                                                '
      uname = '                                                                                '
      vname = '                                                                                '
      wname = '                                                                                '

    if(strlen.gt.0)then
      sname(1:strlen) = output_path(1:strlen)
      uname(1:strlen) = output_path(1:strlen)
      vname(1:strlen) = output_path(1:strlen)
      wname(1:strlen) = output_path(1:strlen)
    endif

      sname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      uname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      vname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      wname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      if(fnum.eq.51)then
        sname(totlen+1:totlen+22) = '_XXXXXX_s.dat  '
      elseif(fnum.eq.71)then
        sname(totlen+1:totlen+22) = '_XXXXXX_i.dat  '
      endif
      uname(totlen+1:totlen+22) = '_XXXXXX_u.dat  '
      vname(totlen+1:totlen+22) = '_XXXXXX_v.dat  '
      wname(totlen+1:totlen+22) = '_XXXXXX_w.dat  '

!!!      write(sname(totlen+2:totlen+ 7),100) mynode
      write(sname(totlen+2:totlen+7),100) nwrite

!!!      write(uname(totlen+2:totlen+ 7),100) mynode
      write(uname(totlen+2:totlen+7),100) nwrite

!!!      write(vname(totlen+2:totlen+ 7),100) mynode
      write(vname(totlen+2:totlen+7),100) nwrite

!!!      write(wname(totlen+2:totlen+ 7),100) mynode
      write(wname(totlen+2:totlen+7),100) nwrite

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  myid,sname=',myid,'   ',sname
      open(unit=fnum,file=sname,                   &
           form='unformatted',access='direct',   &
           recl=(nx*nj*4),status='unknown')
      opens = .true.

      if(u_out.ge.1.and.fnum.ne.71)then
        if(dowr) write(outfile,*) '  myid,uname=',myid,'   ',uname
        open(unit=52,file=uname,                   &
             form='unformatted',access='direct',   &
             recl=((nx+1)*nj*4),status='unknown')
        openu = .true.
      endif

      if(v_out.ge.1.and.fnum.ne.71)then
        if(dowr) write(outfile,*) '  myid,vname=',myid,'   ',vname
        open(unit=53,file=vname,                   &
             form='unformatted',access='direct',   &
             recl=(nx*nj*4),status='unknown')
        openv = .true.
      endif

      if(w_out.ge.1.and.fnum.ne.71)then
        if(dowr) write(outfile,*) '  myid,wname=',myid,'   ',wname
        open(unit=54,file=wname,                   &
             form='unformatted',access='direct',   &
             recl=(nx*nj*4),status='unknown')
        openw = .true.
      endif
    ENDIF ! endif for myid.eq.nodemaster
#else
    print *,'  output_filetype = ',output_filetype
    print *,'  This option is only available for MPI runs '
    print *,'  Stopping cm1 .... '
    call stopcm1
#endif
  ENDIF ! endif for outout_filetype
  ENDIF ! endif for output_format=1
#ifdef NETCDF
  IF(output_format.eq.2)THEN
    ! netcdf stuff:
    opens = .false.
    if( output_filetype.eq.3 .or. myid.eq.0 )then
      call netcdf_prelim(rtime,nwrite,ncid,time_index,qname,xh,xf,yh,yf,               &
                         xfref,yfref,sigma,sigmaf,zs,zh,zf,                            &
                         dum1(ib,jb,kb),dum2(ib,jb,kb),dum3(ib,jb,kb),dum4(ib,jb,kb),  &
                         dum5(ib,jb,kb),dat2(1,1),dat2(1,2))
      opens = .true.
    endif
  ENDIF
#endif

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!--- 2D vars:
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      if( myid.eq.0 ) print *,'    2d vars '

      if(output_rain.eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,rain(ib,jb,1),'rain    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sws .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sws(ib,jb,1),'sws     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_svs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,svs(ib,jb,1),'svs     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sps .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sps(ib,jb,1),'sps     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_srs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,srs(ib,jb,1),'srs     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sgs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sgs(ib,jb,1),'sgs     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sus .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sus(ib,jb,1),'sus     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_shs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,shs(ib,jb,1),'shs     ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    IF(nrain.eq.2)THEN
      if(output_rain.eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,rain(ib,jb,2),'rain2   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sws .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sws(ib,jb,2),'sws2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_svs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,svs(ib,jb,2),'svs2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sps .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sps(ib,jb,2),'sps2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_srs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,srs(ib,jb,2),'srs2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sgs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sgs(ib,jb,2),'sgs2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sus .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,sus(ib,jb,2),'sus2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_shs .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,shs(ib,jb,2),'shs2    ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
      if(output_uh.eq.1)then
        ! get height AGL:
        if( terrain_flag )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = zh(i,j,k)-zs(i,j)
            dumw(i,j,k) = zf(i,j,k)-zs(i,j)
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = zh(i,j,k)
            dumw(i,j,k) = zf(i,j,k)
          enddo
          enddo
          enddo
        endif
        if(timestats.ge.1) time_write=time_write+mytime()
        call calcuh(uf,vf,dum3,dumw,ua,va,wa,dum1(ib,jb,1),dum2,dum5,dum6, &
                    zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf)
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'uh      ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_coldpool.eq.1)then
        if(timestats.ge.1) time_write=time_write+mytime()
        call calccpch(zh,zf,th0,qv0,dum1(ib,jb,1),dum1(ib,jb,2),tha,qa)
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'cpc     ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,2),'cph     ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_sfcflx.eq.1)                                        &
        call writeo(ni,nj,1,1,nx,ny,thflux(ib,jb),'thflux  ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sfcflx.eq.1)                                        &
        call writeo(ni,nj,1,1,nx,ny,qvflux(ib,jb),'qvflux  ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sfcflx.eq.1)                                        &
        call writeo(ni,nj,1,1,nx,ny,tsk(ib,jb),'tsk     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_sfcparams.eq.1)then
        call writeo(ni,nj,1,1,nx,ny,cd(ib,jb),'cd      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,ch(ib,jb),'ch      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,cq(ib,jb),'cq      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,tlh(ib,jb),'tlh     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_psfc.eq.1)then
        call writeo(ni,nj,1,1,nx,ny,psfc(ib,jb),'psfc    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_zs  .eq.1)                                          &
        call writeo(ni,nj,1,1,nx,ny,zs(ib,jb),'zs      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_dbz   .eq.1)then
        if(timestats.ge.1) time_write=time_write+mytime()
        call calccref(dum1(ib,jb,1),dbz)
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'cref    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if(output_sfcparams.eq.1)then
        call writeo(ni,nj,1,1,nx,ny,xland(ib,jb),'xland   ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1)=float(lu_index(i,j))
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'lu      ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,mavail(ib,jb),'mavail  ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4.or.oceanmodel.eq.2))then
        call writeo(ni,nj,1,1,nx,ny,tmn(ib,jb),'tmn     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,hfx(ib,jb),'hfx     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,qfx(ib,jb),'qfx     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,gsw(ib,jb),'gsw     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,glw(ib,jb),'glw     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif

    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3.or.sfcmodel.eq.4))then
        call writeo(ni,nj,1,1,nx,ny,tslb(ib,jb,1),'tslb1   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,tslb(ib,jb,2),'tslb2   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,tslb(ib,jb,3),'tslb3   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,tslb(ib,jb,4),'tslb4   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,tslb(ib,jb,5),'tslb5   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
        call writeo(ni,nj,1,1,nx,ny,tml(ib,jb),'tml     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,hml(ib,jb),'hml     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,huml(ib,jb),'huml    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,hvml(ib,jb),'hvml    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if( output_radten.eq.1 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = radsw(i,j)
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radsw   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = rnflx(i,j)
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'rnflx   ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = radswnet(i,j)
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radswnet',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = radlwin(i,j)
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radlwin ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = olr(i,j)
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'olr     ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = dsr(i,j)
        enddo
        enddo
        call writeo(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'dsr     ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      IF(output_sfcdiags.eq.1)THEN
        call writeo(ni,nj,1,1,nx,ny,u10(ib,jb),'u10     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,v10(ib,jb),'v10     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,t2(ib,jb),'t2      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,q2(ib,jb),'q2      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,znt(ib,jb),'znt     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,ust(ib,jb),'ust     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,hpbl(ib,jb),'hpbl    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,zol(ib,jb),'zol     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,mol(ib,jb),'mol     ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,br(ib,jb),'br      ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,psim(ib,jb),'psim    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,psih(ib,jb),'psih    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,1,nx,ny,qsfc(ib,jb),'qsfc    ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!--- 3D vars below here:
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      if( myid.eq.0 ) print *,'    s vars '

      dum1=zh
      if(fnum.eq.71)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=sigma(k)-zs(i,j)
        enddo
        enddo
        enddo
      endif
      if(output_zh  .eq.1)                                          &
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'zh      ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_th  .eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=th0(i,j,k)+tha(i,j,k)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'th      ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_thpert .eq.1)then
        dum1=tha
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'thpert  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_prs    .eq.1)then
        dum1=prs
        if( psolver.eq.6 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=( (pi0(i,j,k)+ppi(i,j,k)/(cp*th0(i,j,k)))**cpdrd )*p00
          enddo
          enddo
          enddo
        endif
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'prs     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_prspert.eq.1)then
        if( psolver.eq.6 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=( (pi0(i,j,k)+ppi(i,j,k)/(cp*th0(i,j,k)))**cpdrd )*p00 - prs0(i,j,k)
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=prs(i,j,k)-prs0(i,j,k)
          enddo
          enddo
          enddo
        endif
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'prspert ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_pi.eq.1)then  
        if( psolver.eq.6 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=pi0(i,j,k)+ppi(i,j,k)/(cp*th0(i,j,k))
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
          enddo
          enddo
          enddo
        endif
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'pi      ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_pipert .eq.1)then
        dum1=ppi
        if( psolver.eq.6 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=ppi(i,j,k)/(cp*th0(i,j,k))
          enddo
          enddo
          enddo
        endif
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'pipert  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_rho    .eq.1)then
        dum1=rho
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'rho     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_rhopert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=rho(i,j,k)-rho0(i,j,k)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'rhopert ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(iptra.eq.1)then
        chid = 'pt      '
        do n=1,npt
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=pta(i,j,k,n)
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          if( n.le.9 )then
            write(chid(3:3),111) n
111         format(i1)
          else
            write(chid(3:4),141) n
141         format(i2)
          endif
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),chid,            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        enddo
      endif
    IF(imoist.eq.1)THEN
      if(output_qv    .eq.1)then
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=qa(i,j,k,nqv)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'qv      ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_qvpert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=qa(i,j,k,nqv)-qv0(i,j,k)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'qvpert  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_q.eq.1)then
        chid = '        '
        do n=1,numq
          if(n.ne.nqv)then
            do k=1,maxk
            do j=1,nj
            do i=1,ni
              dum1(i,j,k)=qa(i,j,k,n)
            enddo
            enddo
            enddo
            if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
            write(chid(1:3),110) qname(n)
110         format(a3)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),chid,            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
          endif
        enddo
      endif
      if(output_dbz   .eq.1)then
        dum1=dbz
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'dbz     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
    ENDIF  ! endif for imoist=1

      if(output_buoyancy.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n)
        do k=1,maxk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=g*tha(i,j,k)/th0(i,j,k)
          enddo
          enddo
          IF(imoist.eq.1)THEN
            do j=1,nj
            do i=1,ni
              dum1(i,j,k)=dum1(i,j,k)+g*repsm1*(qa(i,j,k,nqv)-qv0(i,j,k))
            enddo
            enddo
            do n=nql1,nql2
              do j=1,nj
              do i=1,ni
                dum1(i,j,k)=dum1(i,j,k)-g*qa(i,j,k,n)
              enddo
              enddo
            enddo
            IF(iice.eq.1)THEN
            do n=nqs1,nqs2
              do j=1,nj
              do i=1,ni
                dum1(i,j,k)=dum1(i,j,k)-g*qa(i,j,k,n)
              enddo
              enddo
            enddo
            ENDIF
          ENDIF
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'buoyancy',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if(output_uinterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'uinterp ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_vinterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vinterp ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_winterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'winterp ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if( output_vort.eq.1 .or. output_pv.eq.1 )then
        if(timestats.ge.1) time_write=time_write+mytime()
        call     calcvort(xh,xf,uf,vf,zh,mh,zf,mf,zs,gz,gzu,gzv,rgz,rgzu,rgzv,gxu,gyv,rds,sigma,rdsf,sigmaf,  &
                          ua,va,wa,dum2 ,dum3 ,dum4 ,dum1,dum5,dum6,dum8,dum7,th0,tha,rr,  &
                          ust,znt,u1,v1,s1)
      endif
      if(output_vort.eq.1)then
        dum1=dum2
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'xvort   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=dum3
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'yvort   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=dum4
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'zvort   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_pv.eq.1)then
        dum1=dum8
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'pv      ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if(output_basestate.eq.1)then
        dum1=pi0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'pi0     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=th0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'th0     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=prs0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'prs0    ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=qv0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'qv0     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if(output_pblten.eq.1)then
        dum1=thpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'thpten  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=qvpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'qvpten  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=qcpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'qcpten  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=qipten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'qipten  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=upten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'upten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        dum1=vpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vpten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if( output_radten.eq.1 )then
        rdt = 1.0/dt
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tnew,pnew,thold,thnew)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          thold = (th0(i,j,k)+tha(i,j,k))
          tnew = thold*(pi0(i,j,k)+ppi(i,j,k)) + dt*swten(i,j,k)
          pnew = rho(i,j,k)*(rd+rv*qa(i,j,k,nqv))*tnew
          thnew = tnew/((pnew*rp00)**rovcp)
          dum1(i,j,k) = (thnew-thold)*rdt
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'swten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tnew,pnew,thold,thnew)
        do k=1,maxk
        do j=1,nj
        do i=1,ni
          thold = (th0(i,j,k)+tha(i,j,k))
          tnew = thold*(pi0(i,j,k)+ppi(i,j,k)) + dt*lwten(i,j,k)
          pnew = rho(i,j,k)*(rd+rv*qa(i,j,k,nqv))*tnew
          thnew = tnew/((pnew*rp00)**rovcp)
          dum1(i,j,k) = (thnew-thold)*rdt
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'lwten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

    if(output_turbten.eq.1)then
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            thadv(i,j,k)=(th0(i,j,k)-th0r)+tha(i,j,k)
            dum7(i,j,k) = khv(i,j,k  )*mf(i,j,k  )*rf(i,j,k  )*mh(i,j,k)*rr(i,j,k)
            dum8(i,j,k) = khv(i,j,k+1)*mf(i,j,k+1)*rf(i,j,k+1)*mh(i,j,k)*rr(i,j,k)
          enddo
          enddo
          enddo
          thten = 0.0
          if(timestats.ge.1) time_write=time_write+mytime()
        call turbs(1,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,thflux,   &
                   rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                   dum1,dum2,dum3,dum4,dum5,dum6,rho,rr,rf,thadv,thten,khh,khv,dum7,dum8)
        dum1 = thten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'ftt     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(imoist.eq.1)then
          thten = 0.0
          if(timestats.ge.1) time_write=time_write+mytime()
              call turbs(1,dt,dosfcflx,xh,rxh,arh1,arh2,uh,xf,arf1,arf2,uf,vh,vf,qvflux,   &
                         rds,sigma,rdsf,sigmaf,mh,mf,gz,rgz,gzu,rgzu,gzv,rgzv,gx,gxu,gy,gyv, &
                         dum1,dum2,dum3,dum4,dum5,dum6,rho,rr,rf,qa(ib,jb,kb,nqv),thten,khh,khv,dum7,dum8)
        dum1 = thten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'ftq     ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
    endif

      IF( output_dissheat.eq.1 )THEN
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k) = tdiag(i,j,k,td_diss)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'dissheat',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      ENDIF
      IF( output_mptend.eq.1 )THEN
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k) = tdiag(i,j,k,td_mptend)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'mptend  ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      ENDIF
      IF( output_fallvel.eq.1 )THEN
        if( qd_vtc.gt.0 )then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k) = qdiag(i,j,k,qd_vtc)
            if( qa(i,j,k,nqc).le.qsmall ) dum1(i,j,k) = 0.0
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vtc     ',      &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                      ncid,time_index,output_format,output_filetype,  &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        endif
        if( qd_vtr.gt.0 )then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k) = qdiag(i,j,k,qd_vtr)
            if( qa(i,j,k,nqr).le.qsmall ) dum1(i,j,k) = 0.0
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vtr     ',      &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                      ncid,time_index,output_format,output_filetype,  &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        endif
        if( qd_vts.gt.0 )then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k) = qdiag(i,j,k,qd_vts)
            if( qa(i,j,k,nqs).le.qsmall ) dum1(i,j,k) = 0.0
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vts     ',      &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                      ncid,time_index,output_format,output_filetype,  &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        endif
        if( qd_vtg.gt.0 )then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k) = qdiag(i,j,k,qd_vtg)
            if( qa(i,j,k,nqg).le.qsmall ) dum1(i,j,k) = 0.0
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vtg     ',      &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                      ncid,time_index,output_format,output_filetype,  &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        endif
        if( qd_vti.gt.0 )then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k) = qdiag(i,j,k,qd_vti)
            if( qa(i,j,k,nqi).le.qsmall ) dum1(i,j,k) = 0.0
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call writeo(ni,nj,1,maxk,nx,ny,dum1(ib,jb,1),'vti     ',      &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fnum, &
                      ncid,time_index,output_format,output_filetype,  &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        endif
      ENDIF

!--------------------------------------------------------------

    IF(output_impdiften.eq.1)THEN
      IF(.not.terrain_flag)THEN
        ! without terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k=1,nk
          do j=0,nj+1
          do i=0,ni+2
            rru(i,j,k)=rho0(1,1,k)*u3d(i,j,k)
          enddo
          enddo
          do j=0,nj+2
          do i=0,ni+1
            rrv(i,j,k)=rho0(1,1,k)*v3d(i,j,k)
          enddo
          enddo
          IF(k.eq.1)THEN
            do j=0,nj+1
            do i=0,ni+1
              rrw(i,j,   1) = 0.0
              rrw(i,j,nk+1) = 0.0
            enddo
            enddo
          ELSE
            do j=0,nj+1
            do i=0,ni+1
              rrw(i,j,k)=rf0(1,1,k)*w3d(i,j,k)
            enddo
            enddo
          ENDIF
        ENDDO
      ELSE
        ! with terrain:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k=1,nk
          do j=0,nj+1
          do i=0,ni+2
            rru(i,j,k)=0.5*(rho0(i-1,j,k)+rho0(i,j,k))*u3d(i,j,k)*rgzu(i,j)
          enddo
          enddo
          do j=0,nj+2
          do i=0,ni+1
            rrv(i,j,k)=0.5*(rho0(i,j-1,k)+rho0(i,j,k))*v3d(i,j,k)*rgzv(i,j)
          enddo
          enddo
        ENDDO
!$omp parallel do default(shared)  &
!$omp private(i,j,k,r1,r2)
        DO k=1,nk
          IF(k.eq.1)THEN
            do j=0,nj+1
            do i=0,ni+1  
              rrw(i,j,   1) = 0.0
              rrw(i,j,nk+1) = 0.0
            enddo
            enddo
          ELSE 
            r2 = (sigmaf(k)-sigma(k-1))*rds(k)
            r1 = 1.0-r2
            do j=0,nj+1
            do i=0,ni+1
              rrw(i,j,k)=rf0(i,j,k)*w3d(i,j,k)                                  &
                        +0.5*( ( r2*(rru(i,j,k  )+rru(i+1,j,k  ))               &
                                +r1*(rru(i,j,k-1)+rru(i+1,j,k-1)) )*dzdx(i,j)   &
                              +( r2*(rrv(i,j,k  )+rrv(i,j+1,k  ))               &
                                +r1*(rrv(i,j,k-1)+rrv(i,j+1,k-1)) )*dzdy(i,j)   &
                             )*(sigmaf(k)-zt)*gz(i,j)*rzt
            enddo
            enddo
          ENDIF
        ENDDO
      ENDIF  ! endif for terrain_flag

      do j=0,nj+2
      do i=0,ni+2
        u3d(i,j,nk+1) = u3d(i,j,nk)
        v3d(i,j,nk+1) = v3d(i,j,nk)
        w3d(i,j,nk+2) = -w3d(i,j,nk)
      enddo
      enddo

      ! 140501:  extrapolate:
      do j=0,nj+2
      do i=0,ni+2
        u3d(i,j,0) = 2.0*u3d(i,j,1) - u3d(i,j,2)
        v3d(i,j,0) = 2.0*v3d(i,j,1) - v3d(i,j,2)
        w3d(i,j,0) = 2.0*w3d(i,j,1) - w3d(i,j,2)
      enddo
      enddo

#ifdef MPI
      if(timestats.ge.1) time_write=time_write+mytime()
      call getcorneru(u3d,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcu2(u3d)
      call getcornerv(v3d,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcv2(v3d)
      call getcornerw(w3d,nw1(1),nw2(1),ne1(1),ne2(1),sw1(1),sw2(1),se1(1),se2(1))
      call bcw2(w3d)
#endif

    ENDIF    ! endif for output_impdiften=1

!--------------------------------------------------------------
!  writeout data on u-points

      if( myid.eq.0 ) print *,'    u vars '

    IF(fnum.ne.71)THEN
      irec=1+(nwrite-1)*maxk*u_out
      if(output_filetype.ge.2) irec=1

      if(output_u    .eq.1)                                         &
        call writeo(ni+1,nj,1,maxk,nx+1,ny,ua(ib,jb,1),'u       ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,52,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)


      if(output_upert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj
        do i=1,ni+1
          dumu(i,j,k)=ua(i,j,k)-u0(i,j,k)
        enddo
        enddo
        enddo
        call writeo(ni+1,nj,1,maxk,nx+1,ny,dumu(ib,jb,1),'upert   ',  &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,52,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)
      endif

      if(output_basestate.eq.1)                                     &
        call writeo(ni+1,nj,1,maxk,nx+1,ny,u0(ib,jb,1),'u0      ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,52,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)

      if(output_turbten.eq.1)then
        dumu = 0.0
        if(timestats.ge.1) time_write=time_write+mytime()
        call turbu(dt,xh,ruh,xf,rxf,arf1,arf2,uf,vh,mh,mf,rmf,rho,rf,  &
                   zs,gz,rgz,gzu,gzv,rds,sigma,rdsf,sigmaf,gxu,     &
                   dum1,dum2,dum3,dum4,dum5,dum6,ua,dumu,wa,t11,t12,t13,t22,kmv)
        call writeo(ni+1,nj,1,maxk,nx+1,ny,dumu(ib,jb,1),'ftu     ',  &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,52,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)
      endif

      if(output_impdiften.eq.1)then
        dumu = 0.0
        if(timestats.ge.1) time_write=time_write+mytime()
        call impldiffu(uf,vh,arh1,arh2,arf1,arf2,mh,rdsf,gzu,rho0,rr0,dum1,dum2,dum3,rru,rrv,rrw,u3d,dumu)
        call writeo(ni+1,nj,1,maxk,nx+1,ny,dumu(ib,jb,1),'fdu     ',  &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,52,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)
      endif

    ENDIF

!--------------------------------------------------------------
!  writeout data on v-points

      if( myid.eq.0 ) print *,'    v vars '

    IF(fnum.ne.71)THEN
      irec=1+(nwrite-1)*maxk*v_out
      if(output_filetype.ge.2) irec=1

      if(output_v    .eq.1)                                         &
        call writeo(ni,nj+1,1,maxk,nx,ny+1,va(ib,jb,1),'v       ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,53,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)

      if(output_vpert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,maxk
        do j=1,nj+1
        do i=1,ni
          dumv(i,j,k)=va(i,j,k)-v0(i,j,k)
        enddo
        enddo
        enddo
        call writeo(ni,nj+1,1,maxk,nx,ny+1,dumv(ib,jb,1),'vpert   ',  &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,53,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)
      endif

      if(output_basestate.eq.1)                                     &
        call writeo(ni,nj+1,1,maxk,nx,ny+1,v0(ib,jb,1),'v0      ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,53,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)

      if(output_turbten.eq.1)then
        dumv = 0.0
        if(timestats.ge.1) time_write=time_write+mytime()
        call turbv(dt,xh,rxh,arh1,arh2,uh,xf,rvh,vf,mh,mf,rho,rr,rf,   &
                   zs,gz,rgz,gzu,gzv,rds,sigma,rdsf,sigmaf,gyv,  &
                   dum1,dum2,dum3,dum4,dum5,dum6,va,dumv,wa,t12,t22,t23,kmv)
        call writeo(ni,nj+1,1,maxk,nx,ny+1,dumv(ib,jb,1),'ftv     ',  &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,53,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)
      endif

      if(output_impdiften.eq.1)then
        dumv = 0.0
        if(timestats.ge.1) time_write=time_write+mytime()
        call impldiffv(uh,vf,arh1,arh2,mh,rdsf,gzv,rho0,rr0,dum1,dum2,dum3,rru,rrv,rrw,v3d,dumv)
        call writeo(ni,nj+1,1,maxk,nx,ny+1,dumv(ib,jb,1),'fdv     ',  &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,53,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)
      endif

    ENDIF

!--------------------------------------------------------------
!  writeout data on w-points

      if( myid.eq.0 ) print *,'    w vars '

    IF(fnum.ne.71)THEN
      irec=1+(nwrite-1)*(maxk+1)*w_out
      if(output_filetype.ge.2) irec=1

      if(output_w  .eq.1)                                           &
        call writeo(ni,nj,1,maxk+1,nx,ny,wa(ib,jb,1),'w       ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_tke.eq.1.and.iturb.eq.1)                            &
        call writeo(ni,nj,1,maxk+1,nx,ny,tkea(ib,jb,1),'tke     ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_km .eq.1)                                           &
        call writeo(ni,nj,1,maxk+1,nx,ny,kmh(ib,jb,1),'kmh     ',     &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_km .eq.1)                                           &
        call writeo(ni,nj,1,maxk+1,nx,ny,kmv(ib,jb,1),'kmv     ',     &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_kh .eq.1)                                           &
        call writeo(ni,nj,1,maxk+1,nx,ny,khh(ib,jb,1),'khh     ',     &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if(output_kh .eq.1)                                           &
        call writeo(ni,nj,1,maxk+1,nx,ny,khv(ib,jb,1),'khv     ',     &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)


      if(output_dissten.eq.1)then
        call writeo(ni,nj,1,maxk+1,nx,ny,dissten(ib,jb,1),'dissten ', &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_nm.eq.1)then
        call writeo(ni,nj,1,maxk+1,nx,ny,nm(ib,jb,1),'nm      ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(output_def.eq.1)then
        call writeo(ni,nj,1,maxk+1,nx,ny,defv(ib,jb,1),'defv    ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writeo(ni,nj,1,maxk+1,nx,ny,defh(ib,jb,1),'defh    ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if(output_turbten.eq.1)then
        dumw = 0.0
        if(timestats.ge.1) time_write=time_write+mytime()
        call turbw(dt,xh,rxh,arh1,arh2,uh,xf,vh,mh,mf,rho,rf,gz,rgzu,rgzv,rds,sigma,   &
                   dum1,dum2,dum3,dum4,dum5,dum6,wa,dumw,t13,t23,t33,t22,kmh)
        call writeo(ni,nj,1,maxk+1,nx,ny,dumw(ib,jb,1),'ftw     ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

      if(output_impdiften.eq.1)then
        dumw = 0.0
        if(timestats.ge.1) time_write=time_write+mytime()
        call impldiffw(uh,vh,arh1,arh2,mf,gz,rds,rrf0,dum1,dum2,dum3,rru,rrv,rrw,w3d,dumw,c1,c2)
        call writeo(ni,nj,1,maxk+1,nx,ny,dumw(ib,jb,1),'fdw     ',    &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,54,   &
                    ncid,time_index,output_format,output_filetype,  &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

    ENDIF

!---------------------------------------------------------------
#ifdef MPI
    IF( output_filetype.eq.3 )THEN
      !  limit to "nlim" writes at a time:
      IF( numprocs.gt.nlim )THEN
        doit = .true.
        IF( myid+nlim .le. (numprocs-1) )THEN
          call MPI_ISEND(doit,1,mpi_logical,myid+nlim,999999,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,status,ierr)
        ENDIF
      ENDIF
    ENDIF
#endif
!--------------------------------------------------------------

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) 'Done Writing Data to File '
      if(dowr) write(outfile,*)

    IF(output_format.eq.1)THEN
      if( opens ) close(unit=fnum)
      if( openu ) close(unit=52)
      if( openv ) close(unit=53)
      if( openw ) close(unit=54)
#ifdef NETCDF
    ELSEIF( output_format.eq.2 )THEN
      if( opens ) call disp_err( nf90_close(ncid) , .true. )
#endif
    ENDIF

#ifdef MPI
      if(timestats.ge.1)then
        ! this is needed for proper accounting of timing:
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
      endif
#endif

      end subroutine writeout


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


    ! writeo:
    subroutine writeo(numi,numj,numk1,numk2,nxr,nyr,var,aname,             &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,irec,fileunit,  &
                      ncid,time_index,output_format,output_filetype,       &
                      dat1,dat2,dat3,reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)
#ifdef MPI
    use mpi
#endif
#ifdef NETCDF
    use netcdf
#endif
    implicit none

    !-------------------------------------------------------------------
    ! This subroutine collects data (from other processors if this is a
    ! MPI run) and does the actual writing to disk.
    !-------------------------------------------------------------------

    integer, intent(in) :: numi,numj,numk1,numk2,nxr,nyr
    integer, intent(in) :: ppnode,d3n,d3t,d2i,d2j,d3i,d3j
    real, intent(in), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy,numk1:numk2) :: var
    character*8, intent(in) :: aname
    integer, intent(in) :: ni,nj,ngxy,myid,numprocs,nodex,nodey,fileunit
    integer, intent(inout) :: irec,ncid
    integer, intent(in) :: time_index,output_format,output_filetype
    real, intent(inout), dimension(numi,numj) :: dat1
    real, intent(inout), dimension(d2i,d2j) :: dat2
    real, intent(inout), dimension(d3i,d3j,0:d3n-1) :: dat3
    integer, intent(inout), dimension(d3t) :: reqt
    integer, intent(in) :: mynode,nodemaster,nodes

    integer :: i,j,k,msk
#ifdef DP
    real*4, dimension(nxr,nyr) :: vout
#endif
#ifdef MPI
    integer :: index2,fooi,fooj,proc,nn,nnn,ntot,n1,n2
    integer :: reqs,index,ierr,tag
    logical :: recv1,recv2
#endif
#ifdef NETCDF
    integer :: varid,status
#endif

  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  !-----------------------------------------------------------------------------
  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

  IF(output_filetype.eq.1.or.output_filetype.eq.2)THEN
    ! For these two options, processor 0 writes out the entire domain:
    ! (Note:  this is the only option for single-processor runs)

    msk = 0
#ifdef MPI
    recv1 = .true.
    recv2 = .true.
    tag = 1
#endif

    kloop:  DO k=numk1,numk2

#ifndef MPI
      !-------------------- non-MPI section --------------------!
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,numj
      do i=1,numi
        dat2(i,j)=var(i,j,k)
      enddo
      enddo
#ifdef NETCDF
      if( output_format.eq.2 )then
      if( k.eq.numk1 )then
        status = nf90_inq_varid(ncid,aname,varid)
        if(status.ne.nf90_noerr)then
          print *,'  Error1a in writeo, aname = ',aname
          print *,nf90_strerror(status)
          call stopcm1
        endif
      endif
      endif
#endif
#else
      !-------------------- MPI section --------------------!
      IF(myid.ne.nodemaster)THEN
        ! ordinary processor ... send data to nodemaster:
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          dat1(i,j)=var(i,j,k)
        enddo
        enddo
        call MPI_ISEND(dat1(1,1),numi*numj,MPI_REAL,nodemaster,tag,MPI_COMM_WORLD,reqs,ierr)
        call MPI_WAIT(reqs,MPI_STATUS_IGNORE,ierr)
        ! DONE, ordinary processors
      ELSE
        ! begin nodemaster section:
        if( recv1 )then
          ! start receives from all other processors on a node:
          do proc=myid+1,myid+(ppnode-1)
            call MPI_IRECV(dat3(1,1,proc),numi*numj,MPI_REAL,proc,tag,MPI_COMM_WORLD,reqt(proc-myid),ierr)
          enddo
        endif
        IF(myid.ne.msk)THEN
          ! nodemaster, not proc msk:
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,numj
          do i=1,numi
            dat3(i,j,myid)=var(i,j,k)
          enddo
          enddo
          ! wait for receives to finish:
          call mpi_waitall(ppnode-1,reqt(1:ppnode-1),MPI_STATUSES_IGNORE,ierr)
          ! send data to processor msk:
          call MPI_ISEND(dat3(1,1,myid),numi*numj*ppnode,MPI_REAL,msk,tag+1,MPI_COMM_WORLD,reqs,ierr)
          ! wait for send to finish:
          call MPI_WAIT(reqs,MPI_STATUS_IGNORE,ierr)
          recv1 = .true.
          ! DONE, nodemaster (not proc msk)
        ELSE
          ! proc msk:
          if( recv2 )then
            ! start receives from other nodemasters:
            do nn = 1,(nodes-1)
              if( nn.le.mynode )then
                proc = (nn-1)*ppnode
              else
                proc = nn*ppnode
              endif
              call MPI_IRECV(dat3(1,1,proc),numi*numj*ppnode,MPI_REAL,proc,tag+1,MPI_COMM_WORLD,reqt(ppnode-1+nn),ierr)
            enddo
          endif
#ifdef NETCDF
          if( output_format.eq.2 )then
          if( k.eq.numk1 )then
            status = nf90_inq_varid(ncid,aname,varid)
            if(status.ne.nf90_noerr)then
              print *,'  Error1b in writeo, aname = ',aname
              print *,nf90_strerror(status)
              call stopcm1
            endif
          endif
          endif
#endif
          ! my data:
          if( myid.eq.0 )then
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,numj
            do i=1,numi
              dat2(i,j)=var(i,j,k)
            enddo
            enddo
          else
            fooj = myid / nodex + 1
            fooi = myid - (fooj-1)*nodex  + 1
            fooi = (fooi-1)*ni
            fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,numj
            do i=1,numi
              dat2(fooi+i,fooj+j)=var(i,j,k)
            enddo
            enddo
          endif
          ! wait for data to arrive:
          ntot = ppnode-1 + nodes-1 
          do nn=1,ntot
            call mpi_waitany(ntot,reqt(1:ntot),index,MPI_STATUS_IGNORE,ierr)
            if( index.le.(ppnode-1) )then
              ! data from ordinary procs on node:
              proc = myid+index
              fooj = proc / nodex + 1
              fooi = proc - (fooj-1)*nodex  + 1
              fooi = (fooi-1)*ni
              fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
              do j=1,numj
              do i=1,numi
                dat2(fooi+i,fooj+j) = dat3(i,j,proc)
              enddo
              enddo
            else
              ! data from other nodemasters:
              index2 = index-(ppnode-1)
              if( index2.le.mynode )then
                index2 = index2-1
              endif
              n1 = index2*ppnode
              n2 = (index2+1)*ppnode-1
              do nnn = n1,n2
                proc = nnn
                fooj = proc / nodex + 1
                fooi = proc - (fooj-1)*nodex  + 1
                fooi = (fooi-1)*ni
                fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
                do j=1,numj
                do i=1,numi
                  dat2(fooi+i,fooj+j) = dat3(i,j,proc)
                enddo
                enddo
              enddo
            endif
          enddo
          ! processor msk is ready to write.
          IF( k.lt.numk2 )THEN
            ! start receives for next level:
            do proc=myid+1,myid+(ppnode-1)
              call MPI_IRECV(dat3(1,1,proc),numi*numj,MPI_REAL,proc,tag+2,MPI_COMM_WORLD,reqt(proc-myid),ierr)
            enddo
            recv1 = .false.
!!!#ifdef NETCDF
!!!            IF( output_format.eq.2 )THEN
              do nn = 1,(nodes-1)
                proc = nn*ppnode
                call MPI_IRECV(dat3(1,1,proc),numi*numj*ppnode,MPI_REAL,proc,tag+3,MPI_COMM_WORLD,reqt(ppnode-1+nn),ierr)
              enddo
              recv2 = .false.
!!!            ENDIF
!!!#endif
          ENDIF
          ! DONE, proc 0
        ENDIF
        !-------------------- end MPI section --------------------!
      ENDIF
#endif

      !-------------------- write data --------------------!
      IF(myid.eq.msk)THEN
        ! only processor msk writes:
        IF(output_format.eq.1)THEN
          ! ----- grads format -----
#ifdef DP
          ! double precision:
          do j=1,nyr
          do i=1,nxr
            vout(i,j) = dat2(i,j)
          enddo
          enddo
          write(fileunit,rec=irec) ((vout(i,j),i=1,nxr),j=1,nyr)
#else
          ! normal:
          write(fileunit,rec=irec) ((dat2(i,j),i=1,nxr),j=1,nyr)
#endif
#ifdef NETCDF
        ELSEIF(output_format.eq.2)THEN
          ! ----- netcdf format -----
          if(numk1.eq.numk2)then
            status = nf90_put_var(ncid,varid,dat2,(/1,1,time_index/),(/nxr,nyr,1/))
          else
            status = nf90_put_var(ncid,varid,dat2,(/1,1,k,time_index/),(/nxr,nyr,1,1/))
          endif
          if(status.ne.nf90_noerr)then
            print *,'  Error2 in writeo, aname = ',aname
            print *,'  ncid,varid,time_index = ',ncid,varid,time_index
            print *,nf90_strerror(status)
            call stopcm1
          endif
#endif
        ENDIF
      ENDIF
      !-------------------- end write data --------------------!

      IF( output_format.eq.1 )THEN
        irec=irec+1
!!!#ifdef MPI
!!!        msk = msk+ppnode
!!!        if( msk.ge.numprocs ) msk = msk-numprocs
!!!#endif
      ENDIF
#ifdef MPI
      tag = tag+2
#endif

    ENDDO  kloop

#ifdef MPI
    ! helps with memory:
    call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif

  ENDIF  ! endif for output_filetype=1,2


  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  !-----   output_filetype = 3   ----------------------------------------------!
  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  !  this section wites one output file per MPI process:
  !  (for MPI runs only)

  IF(output_filetype.eq.3)THEN
    IF( output_format.eq.1 )THEN
      ! grads format:
      DO k=numk1,numk2
        write(fileunit,rec=irec) ((var(i,j,k),i=1,numi),j=1,numj)
        irec=irec+1
      ENDDO
#ifdef NETCDF
    ELSEIF( output_format.eq.2 )THEN
      ! netcdf format:
      DO k=numk1,numk2
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          dat1(i,j)=var(i,j,k)
        enddo
        enddo
        if(numk1.eq.numk2)then
          call write2d_nc(aname,ncid,time_index,numi,numj,dat1(1,1))
        else
          call write3d_nc(aname,k,ncid,time_index,numi,numj,dat1(1,1))
        endif
      ENDDO
#endif
    ENDIF
  ENDIF

  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  !-----------------------------------------------------------------------------
  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      end subroutine writeo


restart.F       1587424407  1602  20    100644  172783    `
MODULE module_restart


CONTAINS

      subroutine write_restart(nstep,nrec,prec,nwrite,nrst,num_soil_layers,         &
                               dt,dtlast,mtime,ndt,adt,acfl,dbldt,mass1,            &
                               stattim,taptim,rsttim,radtim,prcltim,                &
                               qbudget,asq,bsq,qname,                               &
                               xfref,yfref,zh,zf,sigma,sigmaf,zs,                   &
                               th0,prs0,pi0,rho0,qv0,u0,v0,                         &
                               rain,sws,svs,sps,srs,sgs,sus,shs,                    &
                               tsk,znt,ust,cd,ch,cq,u1,v1,s1,thflux,qvflux,         &
                               radbcw,radbce,radbcs,radbcn,                         &
                               rho,prs,ua,va,wa,ppi,tha,qa,tkea,                    &
                               swten,lwten,radsw,rnflx,radswnet,radlwin,rad2d,      &
                               effc,effi,effs,effr,effg,effis,                      &
                               lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,      &
                               hpbl,wspd,psim,psih,gz1oz0,br,                       &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                       &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                    &
                               CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,       &
                               f2d,gsw,glw,chklowq,capg,snowc,fm,fh,tslb,           &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,               &
                               qpten,qtten,qvten,qcten,pta,pdata,ploc,ppx,dbz ,     &
                               ntdiag,nqdiag,tdiag,qdiag,                           &
                               dum1,dat1,dat2,dat3,reqt)
#ifdef MPI
      use mpi
#endif
#ifdef NETCDF
      use netcdf
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'radcst.incl'

      !----------------------------------------------------------
      ! This subroutine organizes the writing of restart files
      !----------------------------------------------------------

      integer, intent(in) :: nstep,nrec,prec,nwrite,nrst
      integer, intent(in) :: num_soil_layers
      real, intent(in) :: dt,dtlast
      integer, intent(in) :: ndt
      double precision, intent(in) :: adt,acfl,dbldt,mass1
      double precision, intent(in) :: mtime,stattim,taptim,rsttim,radtim,prcltim
      double precision, intent(inout), dimension(nbudget) :: qbudget
      double precision, intent(inout), dimension(numq) :: asq,bsq
      character*3, intent(in), dimension(maxq) :: qname
      real, intent(in), dimension(-2:nx+4) :: xfref
      real, intent(in), dimension(-2:ny+4) :: yfref
      real, intent(in), dimension(kb:ke) :: sigma
      real, intent(in), dimension(kb:ke+1) :: sigmaf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: th0,prs0,pi0,rho0,qv0
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(in), dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, intent(in), dimension(ib:ie,jb:je) :: tsk,znt,ust,cd,ch,cq,u1,v1,s1,xland,psfc,thflux,qvflux
      real, intent(in), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(in), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,prs
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, intent(in), dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, intent(in), dimension(ibr:ier,jbr:jer,kbr:ker) :: swten,lwten,effc,effi,effs,effr,effg,effis
      real, intent(in), dimension(ni,nj) :: radsw,rnflx,radswnet,radlwin
      real, intent(in), dimension(ni,nj,nrad2d) :: rad2d
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: kpbl2d
      real, intent(in), dimension(ibl:iel,jbl:jel) :: u10,v10,s10,hfx,qfx,    &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,   &
                                      CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,fm,fh
      real, intent(in), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(in), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem) :: qpten,qtten,qvten,qcten
      real, intent(in), dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, intent(in), dimension(npvals,nparcels) :: pdata
      real, intent(inout), dimension(3,nparcels) :: ploc
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: ppx,dbz
      integer, intent(in) :: ntdiag,nqdiag
      real, intent(in   ) , dimension(ibd:ied,jbd:jed,kbd:ked,ntdiag) :: tdiag
      real, intent(in   ) , dimension(ibd:ied,jbd:jed,kbd:ked,nqdiag) :: qdiag
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1
      real, intent(inout), dimension(ni+1,nj+1) :: dat1
      real, intent(inout), dimension(d2i,d2j) :: dat2
      real, intent(inout), dimension(d3i,d3j,d3n) :: dat3
      integer, intent(inout), dimension(d3t) :: reqt

      character*80 fname
      character*8 :: text1
      character*6 :: aname
      integer :: i,j,k,n,np,nvar,reqs,orecs,orecu,orecv,orecw,ndum
      integer :: ncid,time_index
      real, dimension(:), allocatable :: dumx,dumy
#ifdef MPI
      integer :: proc,index,count,req1,req2,req3,reqp
      double precision, dimension(nbudget) :: cfoo
      double precision, dimension(numq) :: afoo,bfoo
#endif
#ifdef NETCDF
      integer :: varid,ncstatus
#endif

!-----------------------------------------------------------------------

  IF( restart_format.eq.1 )THEN
    ! unformatted direct-access (grads) format:

  IF( restart_filetype.eq.1 )THEN

    !------------------
    ! one restart file (per stagger type):
    IF(myid.eq.nodemaster)THEN
      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      fname(totlen+1:totlen+1+10) = '_rst_x.dat'

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Writing to restart file!'
      if(dowr) write(outfile,*) '  fname=',fname

      if( myid.eq.0 )  &
      open(unit=50,file=fname,form='unformatted',status='unknown')

      fname(totlen+1:totlen+1+10) = '_rst_s.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=51,file=fname,form='unformatted',access='direct',recl=4*nx*ny)
      orecs = 1

      fname(totlen+1:totlen+1+10) = '_rst_u.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=52,file=fname,form='unformatted',access='direct',recl=4*(nx+1)*ny)
      orecu = 1

      fname(totlen+1:totlen+1+10) = '_rst_v.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=53,file=fname,form='unformatted',access='direct',recl=4*nx*(ny+1))
      orecv = 1

      fname(totlen+1:totlen+1+10) = '_rst_w.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=54,file=fname,form='unformatted',access='direct',recl=4*nx*ny)
      orecw = 1

      if(dowr) write(outfile,*)
    ENDIF

  ELSEIF( restart_filetype.eq.2 )THEN

    !------------------
    ! one restart file (per restart time):
    IF(myid.eq.nodemaster)THEN
      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_x.dat'
      write(fname(totlen+ 6:totlen+11),101) nrst
101   format(i6.6)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Writing to restart file!'
      if(dowr) write(outfile,*) '  fname=',fname

      if( myid.eq.0 )  &
      open(unit=50,file=fname,form='unformatted',status='unknown')

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_s.dat'
      write(fname(totlen+ 6:totlen+11),101) nrst
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=51,file=fname,form='unformatted',access='direct',recl=4*nx*ny)
      orecs = 1

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_u.dat'
      write(fname(totlen+ 6:totlen+11),101) nrst
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=52,file=fname,form='unformatted',access='direct',recl=4*(nx+1)*ny)
      orecu = 1

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_v.dat'
      write(fname(totlen+ 6:totlen+11),101) nrst
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=53,file=fname,form='unformatted',access='direct',recl=4*nx*(ny+1))
      orecv = 1

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_w.dat'
      write(fname(totlen+ 6:totlen+11),101) nrst
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=54,file=fname,form='unformatted',access='direct',recl=4*nx*ny)
      orecw = 1

      if(dowr) write(outfile,*)
    ENDIF

  ELSEIF( restart_filetype.eq.3 )THEN

    !------------------
    ! one restart file per node (cm1r17 format):
    IF(myid.eq.nodemaster)THEN
      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      fname(totlen+1:totlen+1+22) = '_rst_XXXXXX_YYYYYY.dat'

      write(fname(totlen+ 6:totlen+11),102) mynode
      write(fname(totlen+13:totlen+18),102) nrst
102   format(i6.6)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Writing to restart file!'
      if(dowr) write(outfile,*) '  fname=',fname
      if(dowr) write(outfile,*)

      open(unit=50,file=fname,form='unformatted',status='unknown')
    ENDIF
  ELSE
    stop 12388
  ENDIF

#ifdef NETCDF
  ELSEIF( restart_format.eq.2 )THEN
    ! netcdf format:

    if( myid.eq.0 )then
      call     restart_prelim(nrst,ncid,mtime,xfref,yfref,zh,zf,sigma,sigmaf,  &
                              qname,num_soil_layers,nrad2d,dat2(1,1),dat2(1,2),dum1(ib,jb,kb),time_index)
    endif

#endif
  ELSE

    if( myid.eq.0 )then
      print *
      print *,'  unrecognized value for restart_format '
      print *
      print *,'      restart_format = ',restart_format
      print *
    endif
#ifdef MPI
    call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
    call stopcm1

  ENDIF

!---------------------------------------------------------------
! metadata:

  IF( restart_format.eq.1 )THEN
    IF(myid.eq.0)THEN
      ! only processor 0 really need to do this:
      write(50) nstep
      write(50) nrec
      write(50) prec
      write(50) nwrite
      write(50) nrst
      write(50) ndt
      write(50) output_format
      write(50) dt
      write(50) dtlast
      write(50) cflmax
      write(50) mtime
      write(50) stattim
      write(50) taptim
      write(50) rsttim
      write(50) radtim
      write(50) prcltim
      write(50) adt
      write(50) acfl
      write(50) dbldt
      write(50) mass1
    ENDIF
#ifdef NETCDF
  ELSEIF( restart_format.eq.2 )THEN
    IF(myid.eq.0)THEN

      call disp_err( nf90_inq_varid(ncid,"nstep",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,nstep,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"nrec",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,nrec,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"prec",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,prec,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"nwrite",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,nwrite,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"nrst",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,nrst,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"ndt",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,ndt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"old_format",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,output_format,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"dt",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,dt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"dtlast",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,dtlast,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"cflmax",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,cflmax,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"mtime",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,mtime,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"stattim",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,stattim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"taptim",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,taptim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"rsttim",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,rsttim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"radtim",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,radtim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"prcltim",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,prcltim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"adt",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,adt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"acfl",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,acfl,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"dbldt",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,dbldt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"mass1",varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,mass1,(/time_index/)) , .true. )

    ENDIF
#endif
  ENDIF

!-----------------------------------------------------------------------
#ifdef MPI
      cfoo = 0.0
      call MPI_REDUCE(qbudget(1),cfoo(1),nbudget,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      if( myid.eq.0 )then
        do n=1,nbudget
          qbudget(n)=cfoo(n)
        enddo
      else
        qbudget = 0.0
      endif
      if( imoist.eq.1 )then
        afoo = 0.0
        call MPI_REDUCE(asq(1),afoo(1),numq,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                        MPI_COMM_WORLD,ierr)
        if( myid.eq.0 )then
          do n=1,numq
            asq(n)=afoo(n)
          enddo
        else
          asq = 0.0
        endif
        bfoo = 0.0
        call MPI_REDUCE(bsq(1),bfoo(1),numq,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                        MPI_COMM_WORLD,ierr)
        if( myid.eq.0 )then
          do n=1,numq
            bsq(n)=bfoo(n)
          enddo
        else
          bsq = 0.0
        endif
      endif
#endif
!-----------------------------------------------------------------------
! budget variables:

    IF( myid.eq.0 )THEN

      IF( restart_format.eq.1 )THEN
        write(50) qbudget
        write(50) asq
        write(50) bsq
#ifdef NETCDF
      ELSEIF( restart_format.eq.2 )THEN
        call disp_err( nf90_inq_varid(ncid,"qbudget",varid) , .true. )
        call disp_err( nf90_put_var(ncid,varid,qbudget,(/1,time_index/),(/nbudget,1/)) , .true. )
        call disp_err( nf90_inq_varid(ncid,"asq",varid) , .true. )
        call disp_err( nf90_put_var(ncid,varid,asq,(/1,time_index/),(/numq,1/)) , .true. )
        call disp_err( nf90_inq_varid(ncid,"bsq",varid) , .true. )
        call disp_err( nf90_put_var(ncid,varid,bsq,(/1,time_index/),(/numq,1/)) , .true. )
#endif
      ENDIF

    ENDIF

!---------------------------------------------------------------
! standard 2D:

      n = 1
      call writer(ni,nj,1,1,nx,ny,rain(ib,jb,n),'rain    ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sws(ib,jb,n),'sws     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,svs(ib,jb,n),'svs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sps(ib,jb,n),'sps     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,srs(ib,jb,n),'srs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sgs(ib,jb,n),'sgs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sus(ib,jb,n),'sus     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,shs(ib,jb,n),'shs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    if( nrain.eq.2 )then
      n = 2
      call writer(ni,nj,1,1,nx,ny,rain(ib,jb,n),'rain2   ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sws(ib,jb,n),'sws2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,svs(ib,jb,n),'svs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sps(ib,jb,n),'sps2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,srs(ib,jb,n),'srs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sgs(ib,jb,n),'sgs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,sus(ib,jb,n),'sus2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,1,nx,ny,shs(ib,jb,n),'shs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif
      call writer(ni,nj,1,1,nx,ny,tsk(ib,jb),'tsk     ',           &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)

!---------------------------------------------------------------
! standard 3D:

      call writer(ni,nj,1,nk,nx,ny,rho(ib,jb,1),'rho     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,prs(ib,jb,1),'prs     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni+1,nj,1,nk,nx+1,ny,ua(ib,jb,1),'ua      ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecu,52,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)
      call writer(ni,nj+1,1,nk,nx,ny+1,va(ib,jb,1),'va      ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecv,53,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)
      call writer(ni,nj,1,nk+1,nx,ny,wa(ib,jb,1),'wa      ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecw,54,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,ppi(ib,jb,1),'ppi     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,tha(ib,jb,1),'tha     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,ppx(ib,jb,1),'ppx     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    IF(imoist.eq.1)THEN
    do n=1,numq
      text1 = '        '
      write(text1(1:3),156) qname(n)
156   format(a3)
      call writer(ni,nj,1,nk,nx,ny,qa(ib,jb,1,n),text1     ,       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    enddo
    ENDIF
    if(imoist.eq.1.and.eqtset.eq.2)then
      call writer(ni,nj,1,nk,nx,ny,qpten(ib,jb,1),'qpten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,qtten(ib,jb,1),'qtten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,qvten(ib,jb,1),'qvten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call writer(ni,nj,1,nk,nx,ny,qcten(ib,jb,1),'qcten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif
    if(iturb.eq.1)then
      call writer(ni,nj,1,nk+1,nx,ny,tkea(ib,jb,1),'tkea    ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecw,54,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif

!---------------------------------------------------------------
!  radiation:

      if(radopt.eq.1)then
        call writer(ni,nj,1,nk,nx,ny,lwten(ib,jb,1),'lwten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,nk,nx,ny,swten(ib,jb,1),'swten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = radsw(i,j)
        enddo
        enddo
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radsw   ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = rnflx(i,j)
        enddo
        enddo
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'rnflx   ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = radswnet(i,j)
        enddo
        enddo
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radswnet',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = radlwin(i,j)
        enddo
        enddo
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radlwin ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        do n=1,nrad2d
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = rad2d(i,j,n)
        enddo
        enddo
        if( n.lt.10 )then
          text1 = 'radX    '
          write(text1(4:4),181) n
181       format(i1.1)
        elseif( n.lt.100 )then
          text1 = 'radXX   '
          write(text1(4:5),182) n
182       format(i2.2)
        elseif( n.lt.1000 )then
          text1 = 'radXXX  '
          write(text1(4:6),183) n
183       format(i3.3)
        else
          stop 11611
        endif
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),text1,             &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        enddo
      endif

      if( radopt.ge.1 .and. ptype.eq.5 )then
        call writer(ni,nj,1,nk,nx,ny,effc(ib,jb,1),'effc    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,nk,nx,ny,effi(ib,jb,1),'effi    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,nk,nx,ny,effs(ib,jb,1),'effs    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,nk,nx,ny,effr(ib,jb,1),'effr    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,nk,nx,ny,effg(ib,jb,1),'effg    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,nk,nx,ny,effis(ib,jb,1),'effis   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

!---------------------------------------------------------------
!  surface:
!     I don't know how many of these are really needed in restart
!     files, but let's include them all for now ... just to be safe

      if((oceanmodel.eq.2).or.(ipbl.eq.1).or.(sfcmodel.ge.1))then
        !---- (1) ----!
      if(sfcmodel.ge.1)then
        call writer(ni,nj,1,1,nx,ny,ust(ib,jb),'ust     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,znt(ib,jb),'znt     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,cd(ib,jb),'cd      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,ch(ib,jb),'ch      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,cq(ib,jb),'cq      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,u1(ib,jb),'u1      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,v1(ib,jb),'v1      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,s1(ib,jb),'s1      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,u10(ib,jb),'u10     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,v10(ib,jb),'v10     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,s10(ib,jb),'s10     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,xland(ib,jb),'xland   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,thflux(ib,jb),'thflux  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,qvflux(ib,jb),'qvflux  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,psfc(ib,jb),'psfc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif


      if(sfcmodel.eq.2.or.sfcmodel.eq.3)then
        !---- (2) ----!
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = lu_index(i,j)
        enddo
        enddo
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'lu_index',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1) = kpbl2d(i,j)
        enddo
        enddo
        call writer(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'kpbl2d  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,hfx(ib,jb),'hfx     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,qfx(ib,jb),'qfx     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,hpbl(ib,jb),'hpbl    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,wspd(ib,jb),'wspd    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,psim(ib,jb),'psim    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,psih(ib,jb),'psih    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,gz1oz0(ib,jb),'gz1oz0  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,br(ib,jb),'br      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CHS(ib,jb),'chs     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CHS2(ib,jb),'chs2    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CQS2(ib,jb),'cqs2    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CPMM(ib,jb),'cpmm    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,ZOL(ib,jb),'zol     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,MAVAIL(ib,jb),'mavail  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,MOL(ib,jb),'mol     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,RMOL(ib,jb),'rmol    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,REGIME(ib,jb),'regime  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,LH(ib,jb),'lh      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,tmn(ib,jb),'tmn     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,FLHC(ib,jb),'flhc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,FLQC(ib,jb),'flqc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,QGH(ib,jb),'qgh     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CK(ib,jb),'ck      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CKA(ib,jb),'cka     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,CDA(ib,jb),'cda     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,USTM(ib,jb),'ustm    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,QSFC(ib,jb),'qsfc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,T2(ib,jb),'t2      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,Q2(ib,jb),'q2      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,TH2(ib,jb),'th2     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,EMISS(ib,jb),'emiss   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,THC(ib,jb),'thc     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,ALBD(ib,jb),'albd    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,gsw(ib,jb),'gsw     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,glw(ib,jb),'glw     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,chklowq(ib,jb),'chklowq ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,capg(ib,jb),'capg    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,snowc(ib,jb),'snowc   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,fm(ib,jb),'fm      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,fh(ib,jb),'fh      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        do n=1,num_soil_layers
          if( n.lt.10 )then
            text1 = 'tslbX   '
            write(text1(5:5),171) n
171         format(i1.1)
          elseif( n.lt.100 )then
            text1 = 'tslbXX  '
            write(text1(5:6),172) n
172         format(i2.2)
          else
            stop 22122
          endif
          call writer(ni,nj,1,1,nx,ny,tslb(ib,jb,n),text1,             &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                      ncid,time_index,restart_format,restart_filetype, &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        enddo
      endif
      endif

      if(oceanmodel.eq.2)then
        call writer(ni,nj,1,1,nx,ny,tml(ib,jb),'tml     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,t0ml(ib,jb),'t0ml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,hml(ib,jb),'hml     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,h0ml(ib,jb),'h0ml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,huml(ib,jb),'huml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,hvml(ib,jb),'hvml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call writer(ni,nj,1,1,nx,ny,tmoml(ib,jb),'tmoml   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

!---------------------------------------------------------------
!  passive tracers:

      if(iptra.eq.1)then

        if(myid.eq.0)then
          if( restart_format.eq.1 )then
            write(50) npt
#ifdef NETCDF
          elseif( restart_format.eq.2 )then
            call disp_err( nf90_inq_varid(ncid,"npt",varid) , .true. )
            call disp_err( nf90_put_var(ncid,varid,npt,(/time_index/)) , .true. )
#endif
          endif
        endif
        do n=1,npt
          if( n.lt.10 )then
            text1 = 'ptX     '
            write(text1(3:3),161) n
161         format(i1.1)
          elseif( n.lt.100 )then
            text1 = 'ptXX    '
            write(text1(3:4),162) n
162         format(i2.2)
          else
            stop 11512
          endif
          call writer(ni,nj,1,nk,nx,ny,pta(ib,jb,1,n),text1,           &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                      ncid,time_index,restart_format,restart_filetype, &
                      dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        enddo
      else
        if(myid.eq.0)then
          nvar = 0
          if( restart_format.eq.1 )then
            write(50) nvar
#ifdef NETCDF
          elseif( restart_format.eq.2 )then
            call disp_err( nf90_inq_varid(ncid,"npt",varid) , .true. )
            call disp_err( nf90_put_var(ncid,varid,nvar,(/time_index/)) , .true. )
#endif
          endif
        endif
      endif

!---------------------------------------------------------------
!  parcels:

      if(iprcl.eq.1)then
        !-----------------
        ! with parcels:
        if(myid.eq.0)then
          if( restart_format.eq.1 )then
            write(50) nparcels
#ifdef NETCDF
          elseif( restart_format.eq.2 )then
            call disp_err( nf90_inq_varid(ncid,"numparcels",varid) , .true. )
            call disp_err( nf90_put_var(ncid,varid,nparcels,(/time_index/)) , .true. )
#endif
          endif
        endif
        ! only write position info:
        if(myid.eq.0)then
          DO np=1,nparcels
          DO n=1,3
            ploc(n,np)=pdata(n,np)
          ENDDO
          ENDDO
          if( restart_format.eq.1 )then
            write(50) ploc
#ifdef NETCDF
          elseif( restart_format.eq.2 )then
            call disp_err( nf90_inq_varid(ncid,"ploc",varid) , .true. )
            n = 3
            call disp_err( nf90_put_var(ncid,varid,ploc,(/1,1,time_index/),(/n,nparcels,1/)) , .true. )
#endif
          endif
        endif
      else
        !-----------------
        ! without parcels:
        if(myid.eq.0)then
          nvar = 0
          if( restart_format.eq.1 )then
            write(50) nvar
#ifdef NETCDF
          elseif( restart_format.eq.2 )then
            call disp_err( nf90_inq_varid(ncid,"numparcels",varid) , .true. )
            call disp_err( nf90_put_var(ncid,varid,nvar,(/time_index/)) , .true. )
#endif
          endif
        endif
        !-----------------
      endif

!---------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!---------------------------------------------------------------
!  open bc:

      if(irbc.eq.4)then
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
        if(myid.eq.0)then
          ndum = ny
        else
          ndum = 1
        endif
        allocate( dumy(ndum) )
        !----------------------
      if( wbc.eq.2 )then
        aname = 'radbcw'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in writerbcwe, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          call writerbcwe(radbcw,aname,ndum,dumy,ibw,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,restart_format,myid,k)
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              write(50) dumy
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_put_var(ncid,varid,dumy,(/1,k,time_index/),(/ny,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in writerbcwe, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
        enddo
      endif
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
      if( ebc.eq.2 )then
        aname = 'radbce'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in writerbcwe, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          call writerbcwe(radbce,aname,ndum,dumy,ibe,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,restart_format,myid,k)
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              write(50) dumy
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_put_var(ncid,varid,dumy,(/1,k,time_index/),(/ny,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in writerbcwe, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
        enddo
      endif
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
        deallocate( dumy )
        if(myid.eq.0)then
          ndum = nx
        else
          ndum = 1
        endif
        allocate( dumx(ndum) )
        !----------------------
      if( sbc.eq.2 )then
        aname = 'radbcs'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in writerbcsn, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          call writerbcsn(radbcs,aname,ndum,dumx,ibs,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,restart_format,myid,k)
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              write(50) dumx
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_put_var(ncid,varid,dumx,(/1,k,time_index/),(/nx,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in writerbcsn, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
        enddo
      endif
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
      if( nbc.eq.2 )then
        aname = 'radbcn'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in writerbcsn, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          call writerbcsn(radbcn,aname,ndum,dumx,ibn,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,restart_format,myid,k)
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              write(50) dumx
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_put_var(ncid,varid,dumx,(/1,k,time_index/),(/nx,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in writerbcsn, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
        enddo
      endif
        !----------------------
        deallocate( dumx )
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
      endif

!---------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!---------------------------------------------------------------
!  150820:  optional variables


    IF( restart_file_theta )THEN
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum1(i,j,k) = th0(i,j,k)+tha(i,j,k)
      enddo
      enddo
      enddo
      call writer(ni,nj,1,nk,nx,ny,dum1(ib,jb,1),'theta   ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_dbz )THEN
      call writer(ni,nj,1,nk,nx,ny,dbz(ib,jb,1),'dbz     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    !-----
    IF( restart_file_th0 )THEN
      call writer(ni,nj,1,nk,nx,ny,th0(ib,jb,1),'th0     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_prs0 )THEN
      call writer(ni,nj,1,nk,nx,ny,prs0(ib,jb,1),'prs0    ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_pi0 )THEN
      call writer(ni,nj,1,nk,nx,ny,pi0(ib,jb,1),'pi0     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_rho0 )THEN
      call writer(ni,nj,1,nk,nx,ny,rho0(ib,jb,1),'rho0    ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_qv0 )THEN
      call writer(ni,nj,1,nk,nx,ny,qv0(ib,jb,1),'qv0     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_u0 )THEN
      call writer(ni+1,nj,1,nk,nx+1,ny,u0(ib,jb,1),'u0      ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecu,52,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)
    ENDIF
    IF( restart_file_v0 )THEN
      call writer(ni,nj+1,1,nk,nx,ny+1,v0(ib,jb,1),'v0      ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecv,53,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)
    ENDIF
    !-----
    IF( restart_file_zs )THEN
      call writer(ni,nj,1,1,nx,ny,zs(ib,jb),'zs      ',            &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_zh )THEN
      call writer(ni,nj,1,nk,nx,ny,zh(ib,jb,1),'zhalf   ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF
    IF( restart_file_zf )THEN
      call writer(ni,nj,1,nk+1,nx,ny,zf(ib,jb,1),'zfull   ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecw,54,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF

    IF( restart_file_diags )THEN
      if( td_diss.gt.0 )                                                 &
      call writer(ni,nj,1,nk,nx,ny,tdiag(ib,jb,1,td_diss),'dissheat',    &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if( td_mptend.gt.0 )                                               &
      call writer(ni,nj,1,nk,nx,ny,tdiag(ib,jb,1,td_mptend),'mptend  ',  &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if( qd_vtc.gt.0 )                                                  &
      call writer(ni,nj,1,nk,nx,ny,qdiag(ib,jb,1,qd_vtc),'vtc     ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if( qd_vtr.gt.0 )                                                  &
      call writer(ni,nj,1,nk,nx,ny,qdiag(ib,jb,1,qd_vtr),'vtr     ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if( qd_vts.gt.0 )                                                  &
      call writer(ni,nj,1,nk,nx,ny,qdiag(ib,jb,1,qd_vts),'vts     ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if( qd_vtg.gt.0 )                                                  &
      call writer(ni,nj,1,nk,nx,ny,qdiag(ib,jb,1,qd_vtg),'vtg     ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      if( qd_vti.gt.0 )                                                  &
      call writer(ni,nj,1,nk,nx,ny,qdiag(ib,jb,1,qd_vti),'vti     ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,         &
                  ncid,time_index,restart_format,restart_filetype,       &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    ENDIF

!---------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!---------------------------------------------------------------

    IF( restart_format.eq.1 )THEN
      IF(myid.eq.0) close(unit=50)
      IF(myid.eq.nodemaster) close(unit=51)
      IF(myid.eq.nodemaster) close(unit=52)
      IF(myid.eq.nodemaster) close(unit=53)
      IF(myid.eq.nodemaster) close(unit=54)
#ifdef NETCDF
    ELSEIF( restart_format.eq.2 )THEN
      if( myid.eq.0 )then
        call disp_err( nf90_close(ncid) , .true. )
      endif
#endif
    ENDIF

#ifdef MPI
      if(timestats.ge.1)then
        ! this is needed for proper accounting of timing:
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
      endif
#endif

      return
      end subroutine write_restart


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine read_restart(nstep,nrec,prec,nwrite,nrst,num_soil_layers,         &
                              dt,dtlast,mtime,ndt,adt,acfl,dbldt,mass1,            &
                              stattim,taptim,rsttim,radtim,prcltim,                &
                              qbudget,asq,bsq,qname,                               &
                              xfref,yfref,zh,zf,sigma,sigmaf,zs,                   &
                              th0,prs0,pi0,rho0,qv0,u0,v0,                         &
                              rain,sws,svs,sps,srs,sgs,sus,shs,                    &
                              tsk,znt,ust,cd,ch,cq,u1,v1,s1,thflux,qvflux,         &
                              radbcw,radbce,radbcs,radbcn,                         &
                              rho,prs,ua,va,wa,ppi,tha,qa,tkea,                    &
                              swten,lwten,radsw,rnflx,radswnet,radlwin,rad2d,      &
                              effc,effi,effs,effr,effg,effis,                      &
                              lu_index,kpbl2d,psfc,u10,v10,s10,hfx,qfx,xland,      &
                              hpbl,wspd,psim,psih,gz1oz0,br,                       &
                              CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                       &
                              MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                    &
                              CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,       &
                              f2d,gsw,glw,chklowq,capg,snowc,fm,fh,tslb,           &
                              tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,               &
                              qpten,qtten,qvten,qcten,pta,pdata,ploc,ppx,dbz ,     &
                              ntdiag,nqdiag,tdiag,qdiag,                           &
                              dum1,dat1,dat2,dat3,reqt,restart_prcl)
#ifdef MPI
      use mpi
#endif
#ifdef NETCDF
      use netcdf
#endif
      implicit none

      !----------------------------------------------------------
      ! This subroutine organizes the reading of restart files
      !----------------------------------------------------------

      include 'input.incl'
      include 'constants.incl'
      include 'radcst.incl'

      integer, intent(inout) :: nstep,nrec,prec,nwrite,nrst
      integer, intent(in) :: num_soil_layers
      real, intent(inout) :: dt,dtlast
      integer, intent(inout) :: ndt
      double precision, intent(inout) :: adt,acfl,dbldt,mass1
      double precision, intent(inout) :: mtime,stattim,taptim,rsttim,radtim,prcltim
      double precision, intent(inout), dimension(nbudget) :: qbudget
      double precision, intent(inout), dimension(numq) :: asq,bsq
      character*3, intent(in), dimension(maxq) :: qname
      real, intent(in), dimension(-2:nx+4) :: xfref
      real, intent(in), dimension(-2:ny+4) :: yfref
      real, intent(in), dimension(kb:ke) :: sigma
      real, intent(in), dimension(kb:ke+1) :: sigmaf
      real, intent(in), dimension(ib:ie,jb:je) :: zs
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: th0,prs0,pi0,rho0,qv0
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,znt,ust,cd,ch,cq,u1,v1,s1,xland,psfc,thflux,qvflux
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: rho,prs
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: swten,lwten,effc,effi,effs,effr,effg,effis
      real, intent(inout), dimension(ni,nj) :: radsw,rnflx,radswnet,radlwin
      real, intent(inout), dimension(ni,nj,nrad2d) :: rad2d
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: lu_index
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: kpbl2d
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: u10,v10,s10,hfx,qfx, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,   &
                                      CK,CKA,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,fm,fh
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem) :: qpten,qtten,qvten,qcten
      real, intent(inout), dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, intent(inout), dimension(npvals,nparcels) :: pdata
      real, intent(inout), dimension(3,nparcels) :: ploc
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppx,dbz
      integer, intent(in) :: ntdiag,nqdiag
      real, intent(inout) , dimension(ibd:ied,jbd:jed,kbd:ked,ntdiag) :: tdiag
      real, intent(inout) , dimension(ibd:ied,jbd:jed,kbd:ked,nqdiag) :: qdiag
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1
      real, intent(inout), dimension(ni+1,nj+1) :: dat1
      real, intent(inout), dimension(d2i,d2j) :: dat2
      real, intent(inout), dimension(d3i,d3j,d3n) :: dat3
      integer, intent(inout), dimension(d3t) :: reqt
      logical, intent(inout) :: restart_prcl

      character*80 fname
      character*8 :: text1
      character*6 :: aname
      integer :: i,j,k,n,np,nvar,nread,reqs,orecs,orecu,orecv,orecw,ndum
      integer :: ncid,time_index,old_format
      double precision, dimension(nbudget,0:numprocs-1) :: sbudget
      double precision, dimension(numq,0:numprocs-1) :: csq,dsq
      real, dimension(:,:), allocatable :: pfoo
      real, dimension(:), allocatable :: dumx,dumy
#ifdef MPI
      integer :: proc,index,count,req1,req2,req3,reqp
#endif
#ifdef NETCDF
      integer :: varid,ncstatus
#endif

!-----------------------------------------------------------------------

  IF( restart_format.eq.1 )THEN
    ! unformatted direct-access (grads) format:

  IF( restart_filetype.eq.1 )THEN

    !------------------
    ! one restart file (per stagger type):
    IF(myid.eq.nodemaster)THEN
      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      fname(totlen+1:totlen+1+10) = '_rst_x.dat'

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Reading from restart file!'
      if(dowr) write(outfile,*) '  fname=',fname

      if( myid.eq.0 )  &
      open(unit=50,file=fname,form='unformatted',status='old',err=778)

      fname(totlen+1:totlen+1+10) = '_rst_s.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=51,file=fname,form='unformatted',access='direct',recl=4*nx*ny,status='old',err=778)
      orecs = 1

      fname(totlen+1:totlen+1+10) = '_rst_u.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=52,file=fname,form='unformatted',access='direct',recl=4*(nx+1)*ny,status='old',err=778)
      orecu = 1

      fname(totlen+1:totlen+1+10) = '_rst_v.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=53,file=fname,form='unformatted',access='direct',recl=4*nx*(ny+1),status='old',err=778)
      orecv = 1

      fname(totlen+1:totlen+1+10) = '_rst_w.dat'
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=54,file=fname,form='unformatted',access='direct',recl=4*nx*ny,status='old',err=778)
      orecw = 1

      if(dowr) write(outfile,*)
    ENDIF

  ELSEIF( restart_filetype.eq.2 )THEN

    !------------------
    ! one restart file (per restart time):
    IF(myid.eq.nodemaster)THEN
      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_x.dat'
      write(fname(totlen+ 6:totlen+11),101) rstnum
101   format(i6.6)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Reading from restart file!'
      if(dowr) write(outfile,*) '  fname=',fname

      if( myid.eq.0 )  &
      open(unit=50,file=fname,form='unformatted',status='old',err=778)

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_s.dat'
      write(fname(totlen+ 6:totlen+11),101) rstnum
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=51,file=fname,form='unformatted',access='direct',recl=4*nx*ny,status='old',err=778)
      orecs = 1

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_u.dat'
      write(fname(totlen+ 6:totlen+11),101) rstnum
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=52,file=fname,form='unformatted',access='direct',recl=4*(nx+1)*ny,status='old',err=778)
      orecu = 1

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_v.dat'
      write(fname(totlen+ 6:totlen+11),101) rstnum
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=53,file=fname,form='unformatted',access='direct',recl=4*nx*(ny+1),status='old',err=778)
      orecv = 1

      fname(totlen+1:totlen+1+17) = '_rst_XXXXXX_w.dat'
      write(fname(totlen+ 6:totlen+11),101) rstnum
      if(dowr) write(outfile,*) '  fname=',fname
      open(unit=54,file=fname,form='unformatted',access='direct',recl=4*nx*ny,status='old',err=778)
      orecw = 1

      if(dowr) write(outfile,*)
    ENDIF

  ELSEIF( restart_filetype.eq.3 )THEN

    !------------------
    ! one restart file per node (cm1r17 format):
    IF(myid.eq.nodemaster)THEN
      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      fname(totlen+1:totlen+1+22) = '_rst_XXXXXX_YYYYYY.dat'

      write(fname(totlen+ 6:totlen+11),102) mynode
      write(fname(totlen+13:totlen+18),102) rstnum
102   format(i6.6)

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  Reading from restart file!'
      if(dowr) write(outfile,*) '  fname=',fname
      if(dowr) write(outfile,*)

      open(unit=50,file=fname,form='unformatted',status='old')
    ENDIF
  ELSE
    stop 12389
  ENDIF

#ifdef NETCDF
  ELSEIF( restart_format.eq.2 )THEN
    ! netcdf format:

    if( myid.eq.0 )then

    IF(     restart_filetype.eq.1 )THEN
      string(totlen+1:totlen+22) = '_rst_XXXXXX.nc        '
      write(string(totlen+6:totlen+11),100) rstnum
!     string(totlen+1:totlen+22) = '_rst.nc               '
      time_index = rstnum
    ELSEIF( restart_filetype.eq.2 )THEN
      string(totlen+1:totlen+22) = '_rst_XXXXXX.nc        '
      write(string(totlen+6:totlen+11),100) rstnum
100   format(i6.6)
      time_index = 1
    ENDIF
      if(myid.eq.0) print *,'  string = ',string

      call disp_err( nf90_open(string,nf90_nowrite,ncid) , .true. )

    endif

#endif
  ELSE

    if( myid.eq.0 )then
      print *
      print *,'  unrecognized value for restart_format '
      print *
      print *,'      restart_format = ',restart_format
      print *
    endif
#ifdef MPI
    call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
    call stopcm1

  ENDIF

!---------------------------------------------------------------
! metadata:

  IF( restart_format.eq.1 )THEN
    IF(myid.eq.0)THEN
      ! only processor 0 has these variables:
      read(50) nstep
      read(50) nrec
      read(50) prec
      read(50) nwrite
      read(50) nrst
      read(50) ndt
      read(50) old_format
      read(50) dt
      read(50) dtlast
      read(50) cflmax
      read(50) mtime
      read(50) stattim
      read(50) taptim
      read(50) rsttim
      read(50) radtim
      read(50) prcltim
      read(50) adt
      read(50) acfl
      read(50) dbldt
      read(50) mass1
    ENDIF
#ifdef NETCDF
  ELSEIF( restart_format.eq.2 )THEN
    IF(myid.eq.0)THEN

      call disp_err( nf90_inq_varid(ncid,"nstep",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,nstep,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"nrec",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,nrec,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"prec",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,prec,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"nwrite",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,nwrite,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"nrst",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,nrst,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"ndt",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,ndt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"old_format",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,old_format,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"dt",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,dt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"dtlast",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,dtlast,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"cflmax",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,cflmax,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"mtime",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,mtime,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"stattim",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,stattim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"taptim",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,taptim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"rsttim",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,rsttim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"radtim",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,radtim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"prcltim",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,prcltim,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"adt",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,adt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"acfl",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,acfl,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"dbldt",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,dbldt,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,"mass1",varid) , .true. )
      call disp_err( nf90_get_var(ncid,varid,mass1,(/time_index/)) , .true. )

    ENDIF
#endif
  ENDIF

#ifdef MPI
      ! communicate to all other processors:
      call MPI_BCAST(nstep  ,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nrec   ,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prec   ,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nwrite ,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(nrst   ,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ndt    ,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(old_format,1,MPI_INTEGER         ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dt     ,1,MPI_REAL            ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dtlast ,1,MPI_REAL            ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(cflmax ,1,MPI_REAL            ,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(mtime  ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(stattim,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(taptim ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(rsttim ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(radtim ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(prcltim,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(adt    ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(acfl   ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(dbldt  ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(mass1  ,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)
#endif

!---------------------------------------------------------------
! budget variables:

    IF( myid.eq.0 )THEN

      IF( restart_format.eq.1 )THEN
        read(50) qbudget
        read(50) asq
        read(50) bsq
#ifdef NETCDF
      ELSEIF( restart_format.eq.2 )THEN
        call disp_err( nf90_inq_varid(ncid,"qbudget",varid) , .true. )
        call disp_err( nf90_get_var(ncid,varid,qbudget,(/1,time_index/),(/nbudget,1/)) , .true. )
        call disp_err( nf90_inq_varid(ncid,"asq",varid) , .true. )
        call disp_err( nf90_get_var(ncid,varid,asq,(/1,time_index/),(/numq,1/)) , .true. )
        call disp_err( nf90_inq_varid(ncid,"bsq",varid) , .true. )
        call disp_err( nf90_get_var(ncid,varid,bsq,(/1,time_index/),(/numq,1/)) , .true. )
#endif
      ENDIF

    ELSE

      qbudget = 0.0
      asq = 0.0
      bsq = 0.0

    ENDIF

!---------------------------------------------------------------
! standard 2D:

      n = 1
      call  readr(ni,nj,1,1,nx,ny,rain(ib,jb,n),'rain    ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sws(ib,jb,n),'sws     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,svs(ib,jb,n),'svs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sps(ib,jb,n),'sps     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,srs(ib,jb,n),'srs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sgs(ib,jb,n),'sgs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sus(ib,jb,n),'sus     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,shs(ib,jb,n),'shs     ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    if( nrain.eq.2 )then
      n = 2
      call  readr(ni,nj,1,1,nx,ny,rain(ib,jb,n),'rain2   ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sws(ib,jb,n),'sws2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,svs(ib,jb,n),'svs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sps(ib,jb,n),'sps2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,srs(ib,jb,n),'srs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sgs(ib,jb,n),'sgs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,sus(ib,jb,n),'sus2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,1,nx,ny,shs(ib,jb,n),'shs2    ',         &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif
      call  readr(ni,nj,1,1,nx,ny,tsk(ib,jb),'tsk     ',           &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)

!---------------------------------------------------------------
! standard 3D:

      call  readr(ni,nj,1,nk,nx,ny,rho(ib,jb,1),'rho     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,prs(ib,jb,1),'prs     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni+1,nj,1,nk,nx+1,ny,ua(ib,jb,1),'ua      ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecu,52,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iu,d2ju,d3iu,d3ju)
      call  readr(ni,nj+1,1,nk,nx,ny+1,va(ib,jb,1),'va      ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecv,53,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2iv,d2jv,d3iv,d3jv)
      call  readr(ni,nj,1,nk+1,nx,ny,wa(ib,jb,1),'wa      ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecw,54,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,ppi(ib,jb,1),'ppi     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,tha(ib,jb,1),'tha     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,ppx(ib,jb,1),'ppx     ',        &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    IF(imoist.eq.1)THEN
    do n=1,numq
      text1 = '        '
      write(text1(1:3),156) qname(n)
156   format(a3)
      call  readr(ni,nj,1,nk,nx,ny,qa(ib,jb,1,n),text1     ,       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    enddo
    ENDIF
    if(imoist.eq.1.and.eqtset.eq.2)then
      call  readr(ni,nj,1,nk,nx,ny,qpten(ib,jb,1),'qpten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,qtten(ib,jb,1),'qtten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,qvten(ib,jb,1),'qvten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      call  readr(ni,nj,1,nk,nx,ny,qcten(ib,jb,1),'qcten   ',      &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif
    if(iturb.eq.1)then
      call  readr(ni,nj,1,nk+1,nx,ny,tkea(ib,jb,1),'tkea    ',     &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecw,54,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
    endif

!---------------------------------------------------------------
!  radiation:

      if(radopt.eq.1)then
        call  readr(ni,nj,1,nk,nx,ny,lwten(ib,jb,1),'lwten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,nk,nx,ny,swten(ib,jb,1),'swten   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radsw   ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          radsw(i,j) = dum1(i,j,1)
        enddo
        enddo
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'rnflx   ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          rnflx(i,j) = dum1(i,j,1)
        enddo
        enddo
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radswnet',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          radswnet(i,j) = dum1(i,j,1)
        enddo
        enddo
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'radlwin ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          radlwin(i,j) = dum1(i,j,1)
        enddo
        enddo
        do n=1,nrad2d
        if( n.lt.10 )then
          text1 = 'radX    '
          write(text1(4:4),181) n
181       format(i1.1)
        elseif( n.lt.100 )then
          text1 = 'radXX   '
          write(text1(4:5),182) n
182       format(i2.2)
        elseif( n.lt.1000 )then
          text1 = 'radXXX  '
          write(text1(4:6),183) n
183       format(i3.3)
        else
          stop 11611
        endif
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),text1,             &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          rad2d(i,j,n) = dum1(i,j,1)
        enddo
        enddo
        enddo
      endif
      if( radopt.ge.1 .and. ptype.eq.5 )then
        call  readr(ni,nj,1,nk,nx,ny,effc(ib,jb,1),'effc    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,nk,nx,ny,effi(ib,jb,1),'effi    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,nk,nx,ny,effs(ib,jb,1),'effs    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,nk,nx,ny,effr(ib,jb,1),'effr    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,nk,nx,ny,effg(ib,jb,1),'effg    ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,nk,nx,ny,effis(ib,jb,1),'effis   ',      &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

!---------------------------------------------------------------
!  surface:
!     I don't know how many of these are really needed in restart
!     files, but let's include them all for now ... just to be safe

      if((oceanmodel.eq.2).or.(ipbl.eq.1).or.(sfcmodel.ge.1))then
        !---- (1) ----!
      if(sfcmodel.ge.1)then
        call  readr(ni,nj,1,1,nx,ny,ust(ib,jb),'ust     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,znt(ib,jb),'znt     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,cd(ib,jb),'cd      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,ch(ib,jb),'ch      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,cq(ib,jb),'cq      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,u1(ib,jb),'u1      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,v1(ib,jb),'v1      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,s1(ib,jb),'s1      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,u10(ib,jb),'u10     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,v10(ib,jb),'v10     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,s10(ib,jb),'s10     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,xland(ib,jb),'xland   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,thflux(ib,jb),'thflux  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,qvflux(ib,jb),'qvflux  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,psfc(ib,jb),'psfc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif
      if(sfcmodel.eq.2.or.sfcmodel.eq.3)then
        !---- (2) ----!
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'lu_index',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          lu_index(i,j) = nint(dum1(i,j,1))
        enddo
        enddo
        call  readr(ni,nj,1,1,nx,ny,dum1(ib,jb,1),'kpbl2d  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          kpbl2d(i,j) = nint(dum1(i,j,1))
        enddo
        enddo
        call  readr(ni,nj,1,1,nx,ny,hfx(ib,jb),'hfx     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,qfx(ib,jb),'qfx     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,hpbl(ib,jb),'hpbl    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,wspd(ib,jb),'wspd    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,psim(ib,jb),'psim    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,psih(ib,jb),'psih    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,gz1oz0(ib,jb),'gz1oz0  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,br(ib,jb),'br      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CHS(ib,jb),'chs     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CHS2(ib,jb),'chs2    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CQS2(ib,jb),'cqs2    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CPMM(ib,jb),'cpmm    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,ZOL(ib,jb),'zol     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,MAVAIL(ib,jb),'mavail  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,MOL(ib,jb),'mol     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,RMOL(ib,jb),'rmol    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,REGIME(ib,jb),'regime  ',        &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,LH(ib,jb),'lh      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,tmn(ib,jb),'tmn     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,FLHC(ib,jb),'flhc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,FLQC(ib,jb),'flqc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,QGH(ib,jb),'qgh     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CK(ib,jb),'ck      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CKA(ib,jb),'cka     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,CDA(ib,jb),'cda     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,USTM(ib,jb),'ustm    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,QSFC(ib,jb),'qsfc    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,T2(ib,jb),'t2      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,Q2(ib,jb),'q2      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,TH2(ib,jb),'th2     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,EMISS(ib,jb),'emiss   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,THC(ib,jb),'thc     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,ALBD(ib,jb),'albd    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,gsw(ib,jb),'gsw     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,glw(ib,jb),'glw     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,chklowq(ib,jb),'chklowq ',       &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,capg(ib,jb),'capg    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,snowc(ib,jb),'snowc   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,fm(ib,jb),'fm      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,fh(ib,jb),'fh      ',            &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        do n=1,num_soil_layers
          if( n.lt.10 )then
            text1 = 'tslbX   '
            write(text1(5:5),171) n
171         format(i1.1)
          elseif( n.lt.100 )then
            text1 = 'tslbXX  '
            write(text1(5:6),172) n
172         format(i2.2)
          else
            stop 22122
          endif
        call  readr(ni,nj,1,1,nx,ny,tslb(ib,jb,n),text1,             &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        enddo
      endif
      endif

      if(oceanmodel.eq.2)then
        call  readr(ni,nj,1,1,nx,ny,tml(ib,jb),'tml     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,t0ml(ib,jb),'t0ml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,hml(ib,jb),'hml     ',           &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,h0ml(ib,jb),'h0ml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,huml(ib,jb),'huml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,hvml(ib,jb),'hvml    ',          &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
        call  readr(ni,nj,1,1,nx,ny,tmoml(ib,jb),'tmoml   ',         &
                    ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                    ncid,time_index,restart_format,restart_filetype, &
                    dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      endif

!---------------------------------------------------------------
!  passive tracers:

      if( myid.eq.0 )then
        if( restart_format.eq.1 )then
          read(50) nvar
#ifdef NETCDF
        elseif( restart_format.eq.2 )then
          call disp_err( nf90_inq_varid(ncid,"npt",varid) , .true. )
          call disp_err( nf90_get_var(ncid,varid,nvar,(/time_index/)) , .true. )
          if( iptra.eq.0 ) nvar = 0
#endif
        endif
        print *,'  nvar_npt = ',nvar
      endif

#ifdef MPI
      call MPI_BCAST(nvar,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
#endif

      if( iptra.eq.1 .or. nvar.gt.0 )then
        if( nvar.gt.0 )then
          nread = 0
          if( iptra.eq.1 )then
            do n=1,min(nvar,npt)
              if( n.lt.10 )then
                text1 = 'ptX     '
                write(text1(3:3),161) n
161             format(i1.1)
              elseif( n.lt.100 )then
                text1 = 'ptXX    '
                write(text1(3:4),162) n
162             format(i2.2)
              else
                stop 11512
              endif
              call  readr(ni,nj,1,nk,nx,ny,pta(ib,jb,1,n),text1,           &
                          ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                          ncid,time_index,restart_format,restart_filetype, &
                          dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
              nread = nread+1
            enddo
          endif
          if( nread .lt. nvar )then
            ! need to read more data ....
            do n=nread+1,nvar
              if( n.lt.10 )then
                text1 = 'ptX     '
                write(text1(3:3),161) n
              elseif( n.lt.100 )then
                text1 = 'ptXX    '
                write(text1(3:4),162) n
              else
                stop 11513
              endif
              call  readr(ni,nj,1,nk,nx,ny,dum1(ib,jb,1),text1,            &
                          ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                          ncid,time_index,restart_format,restart_filetype, &
                          dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
            enddo
          endif
        else
          if( myid.eq.0 ) print *
          if( myid.eq.0 ) print *,'  Note:  no passive tracer data in the restart file '
          if( myid.eq.0 ) print *
        endif
      endif

!---------------------------------------------------------------
!  parcels:

      if( myid.eq.0 )then
        if( restart_format.eq.1 )then
          read(50) nvar
#ifdef NETCDF
        elseif( restart_format.eq.2 )then
          call disp_err( nf90_inq_varid(ncid,"numparcels",varid) , .true. )
          call disp_err( nf90_get_var(ncid,varid,nvar,(/time_index/)) , .true. )
          if( iprcl.eq.0 ) nvar = 0
#endif
        endif
        print *,'  nvar_parcels = ',nvar
      endif

#ifdef MPI
      call MPI_BCAST(nvar,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
#endif

      if( iprcl.eq.1 .or. nvar.gt.0 )then
        if( nvar.gt.0 )then
          ! only read position info:
          if( myid.eq.0 )then
            IF( nvar.eq.nparcels )THEN
              ! easy:  restart file matches current config
              if( restart_format.eq.1 )then
                read(50) ploc
#ifdef NETCDF
              elseif( restart_format.eq.2 )then
                call disp_err( nf90_inq_varid(ncid,"ploc",varid) , .true. )
                n = 3
                call disp_err( nf90_get_var(ncid,varid,ploc,(/1,1,time_index/),(/n,nparcels,1/)) , .true. )
#endif
              endif
            ELSE
              ! annoying:  restart file has different nparcels than current config
              IF( iprcl.eq.1 )THEN
                do np=1,nparcels
                do n=1,3
                  ploc(n,np) = pdata(n,np)
                enddo
                enddo
              ENDIF
              if( myid.eq.0 ) print *,'  start pfoo ' 
              allocate( pfoo(3,nvar) )
              if( restart_format.eq.1 )then
                read(50) pfoo
#ifdef NETCDF
              elseif( restart_format.eq.2 )then
                call disp_err( nf90_inq_varid(ncid,"ploc",varid) , .true. )
                n = 3
                call disp_err( nf90_get_var(ncid,varid,pfoo,(/1,1,time_index/),(/n,nvar,1/)) , .true. )
#endif
              endif
              IF( iprcl.eq.1 )THEN
                do np=1,min(nvar,nparcels)
                do n=1,3
                  ploc(n,np) = pfoo(n,np)
                enddo
                enddo
              ENDIF
              deallocate( pfoo )
              if( myid.eq.0 ) print *,'  end pfoo ' 
            ENDIF
          endif
          IF( iprcl.eq.1 )THEN
#ifdef MPI
            call MPI_BCAST(ploc,3*nparcels,MPI_REAL,0,MPI_COMM_WORLD,ierr)
#endif
            DO np=1,nparcels
            DO n=1,3
              pdata(n,np)=ploc(n,np)
            ENDDO
            ENDDO
            restart_prcl = .true.
          ENDIF
        else
          if( myid.eq.0 ) print *
          if( myid.eq.0 ) print *,'  Note:  no parcel data in the restart file '
          if( myid.eq.0 ) print *
          restart_prcl = .false.
        endif
      endif

!---------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!---------------------------------------------------------------
!  open bc:

      if(irbc.eq.4)then
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
        if(myid.eq.0)then
          ndum = ny
        else
          ndum = 1
        endif
        allocate( dumy(ndum) )
        !----------------------
      if( wbc.eq.2 )then
        aname = 'radbcw'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in readrbcwe, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              read(50) dumy
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_get_var(ncid,varid,dumy,(/1,k,time_index/),(/ny,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in readrbcwe, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
          call readrbcwe(radbcw,aname,ndum,dumy,ibw,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,restart_format,myid,k)
        enddo
      endif
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
      if( ebc.eq.2 )then
        aname = 'radbce'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in readrbcwe, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              read(50) dumy
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_get_var(ncid,varid,dumy,(/1,k,time_index/),(/ny,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in readrbcwe, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
          call readrbcwe(radbce,aname,ndum,dumy,ibe,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,restart_format,myid,k)
        enddo
      endif
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
        deallocate( dumy )
        if(myid.eq.0)then
          ndum = nx
        else
          ndum = 1
        endif
        allocate( dumx(ndum) )
        !----------------------
      if( sbc.eq.2 )then
        aname = 'radbcs'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in readrbcsn, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              read(50) dumx
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_get_var(ncid,varid,dumx,(/1,k,time_index/),(/nx,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in readrbcsn, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
          call readrbcsn(radbcs,aname,ndum,dumx,ibs,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,restart_format,myid,k)
        enddo
      endif
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
      if( nbc.eq.2 )then
        aname = 'radbcn'
#ifdef NETCDF
        if( restart_format.eq.2 .and. myid.eq.0 )then
          ncstatus = nf90_inq_varid(ncid,aname,varid)
          if(ncstatus.ne.nf90_noerr)then
            print *,'  Error1 in readrbcsn, aname = ',aname
            print *,nf90_strerror(ncstatus)
            call stopcm1
          endif
        endif
#endif
        do k=1,nk
          if( myid.eq.0 )then
            if( restart_format.eq.1 )then
              read(50) dumx
#ifdef NETCDF
            elseif( restart_format.eq.2 )then
              ncstatus = nf90_get_var(ncid,varid,dumx,(/1,k,time_index/),(/nx,1,1/))
              if(ncstatus.ne.nf90_noerr)then
                print *,'  Error2 in readrbcsn, aname = ',aname
                print *,nf90_strerror(ncstatus)
                call stopcm1
              endif
#endif
            endif
          endif
          call readrbcsn(radbcn,aname,ndum,dumx,ibn,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,restart_format,myid,k)
        enddo
      endif
        !----------------------
        deallocate( dumx )
        !----------------------
        !cccccccccccccccccccccc
        !----------------------
      endif

!---------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!---------------------------------------------------------------
!  151001:  use theta  (over-rides perturbation value that was read-in above)


    IF( restart_use_theta )THEN
      call  readr(ni,nj,1,nk,nx,ny,dum1(ib,jb,1),'theta   ',       &
                  ni,nj,ngxy,myid,numprocs,nodex,nodey,orecs,51,   &
                  ncid,time_index,restart_format,restart_filetype, &
                  dat1(1,1),dat2(1,1),dat3(1,1,1),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2is,d2js,d3is,d3js)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        tha(i,j,k) = dum1(i,j,k)-th0(i,j,k)
      enddo
      enddo
      enddo
    ENDIF

!---------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!---------------------------------------------------------------

    IF( restart_format.eq.1 )THEN
      IF(myid.eq.0) close(unit=50)
      IF(myid.eq.nodemaster) close(unit=51)
      IF(myid.eq.nodemaster) close(unit=52)
      IF(myid.eq.nodemaster) close(unit=53)
      IF(myid.eq.nodemaster) close(unit=54)
#ifdef NETCDF
    ELSEIF( restart_format.eq.2 )THEN
      if( myid.eq.0 )then
        call disp_err( nf90_close(ncid) , .true. )
      endif
#endif
    ENDIF

!---------

      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '  From restart file: '
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '   mtime   = ',mtime
      if(dowr) write(outfile,*) '   stattim = ',stattim
      if(dowr) write(outfile,*) '   taptim  = ',taptim
      if(dowr) write(outfile,*) '   rsttim  = ',rsttim
      if(dowr) write(outfile,*) '   radtim  = ',radtim
      if(dowr) write(outfile,*) '   prcltim = ',prcltim
      if(dowr) write(outfile,*)
      if(dowr) write(outfile,*) '   nstep   = ',nstep
      if(dowr) write(outfile,*) '   nrec    = ',nrec
      if(dowr) write(outfile,*) '   prec    = ',prec
      if(dowr) write(outfile,*) '   nwrite  = ',nwrite
      if(dowr) write(outfile,*) '   nrst    = ',nrst
      if(dowr) write(outfile,*)

!---------

      if( adapt_dt.eq.0 ) dt = dtl

      ! this is needed for stats files:
      if( output_format.eq.2 )then
        nrec=nrec-1
      else
        nrec=nrec-stat_out
      endif

      IF( output_format .ne. old_format )THEN
        nrec = 1
        nwrite = 1
        prec = 1
      ENDIF

!---------

#ifdef MPI
      if(timestats.ge.1)then
        ! this is needed for proper accounting of timing:
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
      endif
#endif

      return

778   print *,'  error opening restart file '
      print *,'    ... stopping cm1 ... '
      call stopcm1

      end subroutine read_restart


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine writerbcwe(radbc,aname,ndum,dumy,ibndy,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,restart_format,myid,k)
#ifdef MPI
      use mpi
#endif
      implicit none

      integer, intent(in) :: ndum,ibndy,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,k
      real, intent(in), dimension(jb:je,kb:ke) :: radbc
      character*6, intent(in) :: aname
      real, intent(inout), dimension(ndum) :: dumy
      integer, intent(in) :: restart_format,myid

      integer :: j,j1,j2
#ifdef MPI
      integer :: fooi,fooj,proc,reqs,ierr
#endif

#ifndef MPI
      do j=1,ny
        dumy(j) = radbc(j,k)
      enddo
#else
      IF(myid.ne.0)THEN
        if( ibndy.eq.1 )then
          call MPI_ISEND(radbc(1,k),nj,MPI_REAL,0,31,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        endif
      ELSE
        if( (aname.eq.'radbcw') .or. (aname.eq.'radbce' .and. nodex.eq.1) )then
          do j=1,nj
            dumy(j) = radbc(j,k)
          enddo
          j1 = 2
          j2 = nodey
        else
          j1 = 1
          j2 = nodey
        endif
        do j=j1,j2
          if( aname.eq.'radbcw' )then
            proc = (j-1)*nodex
          else
            proc = (j-1)*nodex + (nodex-1)
          endif
          fooj = proc / nodex + 1
          fooi = proc - (fooj-1)*nodex  + 1
          call MPI_IRECV(dumy((fooj-1)*nj+1),nj,MPI_REAL,proc,31,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        enddo
      ENDIF
#endif

      end subroutine writerbcwe


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine writerbcsn(radbc,aname,ndum,dumx,ibndy,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,restart_format,myid,k)
#ifdef MPI
      use mpi
#endif
      implicit none

      integer, intent(in) :: ndum,ibndy,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,k
      real, intent(in), dimension(ib:ie,kb:ke) :: radbc
      character*6, intent(in) :: aname
      real, intent(inout), dimension(ndum) :: dumx
      integer, intent(in) :: restart_format,myid

      integer :: i,i1,i2
#ifdef MPI
      integer :: fooi,fooj,proc,reqs,ierr
#endif

#ifndef MPI
      do i=1,nx
        dumx(i) = radbc(i,k)
      enddo
#else
      IF(myid.ne.0)THEN
        if( ibndy.eq.1 )then
          call MPI_ISEND(radbc(1,k),ni,MPI_REAL,0,32,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        endif
      ELSE
        if( (aname.eq.'radbcs') .or. (aname.eq.'radbcn' .and. nodey.eq.1) )then
          do i=1,ni
            dumx(i) = radbc(i,k)
          enddo
          i1 = 2
          i2 = nodex
        else
          i1 = 1
          i2 = nodex
        endif
        do i=i1,i2
          if( aname.eq.'radbcs' )then
            proc = (i-1)
          else
            proc = (i-1) + nodex*(nodey-1)
          endif
          fooj = proc / nodex + 1
          fooi = proc - (fooj-1)*nodex  + 1
          call MPI_IRECV(dumx((fooi-1)*ni+1),ni,MPI_REAL,proc,32,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        enddo
      ENDIF
#endif

      end subroutine writerbcsn


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine  readrbcwe(radbc,aname,ndum,dumy,ibndy,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,restart_format,myid,k)
#ifdef MPI
      use mpi
#endif
      implicit none

      integer, intent(in) :: ndum,ibndy,jb,je,kb,ke,ny,ni,nj,nk,nodex,nodey,k
      real, intent(inout), dimension(jb:je,kb:ke) :: radbc
      character*6, intent(in) :: aname
      real, intent(inout), dimension(ndum) :: dumy
      integer, intent(in) :: restart_format,myid

      integer :: j,j1,j2
#ifdef MPI
      integer :: fooi,fooj,proc,reqs,ierr
#endif

#ifndef MPI
      do j=1,ny
        radbc(j,k) = dumy(j)
      enddo
#else
      IF(myid.ne.0)THEN
        if( ibndy.eq.1 )then
          call MPI_IRECV(radbc(1,k),nj,MPI_REAL,0,33,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        endif
      ELSE
        if( (aname.eq.'radbcw') .or. (aname.eq.'radbce' .and. nodex.eq.1) )then
          do j=1,nj
            radbc(j,k) = dumy(j)
          enddo
          j1 = 2
          j2 = nodey
        else
          j1 = 1
          j2 = nodey
        endif
        do j=j1,j2
          if( aname.eq.'radbcw' )then
            proc = (j-1)*nodex
          else
            proc = (j-1)*nodex + (nodex-1)
          endif
          fooj = proc / nodex + 1
          fooi = proc - (fooj-1)*nodex  + 1
          call MPI_ISEND(dumy((fooj-1)*nj+1),nj,MPI_REAL,proc,33,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        enddo
      ENDIF
#endif

      end subroutine  readrbcwe


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine  readrbcsn(radbc,aname,ndum,dumx,ibndy,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,restart_format,myid,k)
#ifdef MPI
      use mpi
#endif
      implicit none

      integer, intent(in) :: ndum,ibndy,ib,ie,kb,ke,nx,ni,nj,nk,nodex,nodey,k
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbc
      character*6, intent(in) :: aname
      real, intent(inout), dimension(ndum) :: dumx
      integer, intent(in) :: restart_format,myid

      integer :: i,i1,i2
#ifdef MPI
      integer :: fooi,fooj,proc,reqs,ierr
#endif

#ifndef MPI
      do i=1,nx
        radbc(i,k) = dumx(i)
      enddo
#else
      IF(myid.ne.0)THEN
        if( ibndy.eq.1 )then
          call MPI_IRECV(radbc(1,k),ni,MPI_REAL,0,34,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        endif
      ELSE
        if( (aname.eq.'radbcs') .or. (aname.eq.'radbcn' .and. nodey.eq.1) )then
          do i=1,ni
            radbc(i,k) = dumx(i)
          enddo
          i1 = 2
          i2 = nodex
        else
          i1 = 1
          i2 = nodex
        endif
        do i=i1,i2
          if( aname.eq.'radbcs' )then
            proc = (i-1)
          else
            proc = (i-1) + nodex*(nodey-1)
          endif
          fooj = proc / nodex + 1
          fooi = proc - (fooj-1)*nodex  + 1
          call MPI_ISEND(dumx((fooi-1)*ni+1),ni,MPI_REAL,proc,34,MPI_COMM_WORLD,reqs,ierr)
          call MPI_WAIT(reqs,mpi_status_ignore,ierr)
        enddo
      ENDIF
#endif

      end subroutine  readrbcsn


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


    subroutine writer(numi,numj,numk1,numk2,nxr,nyr,var,aname,           &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orec,nfile,   &
                      ncid,time_index,restart_format,restart_filetype,   &
                      dat1,dat2,dat3,reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)
#ifdef MPI
    use mpi
#endif
#ifdef NETCDF
    use netcdf
#endif
    implicit none

    !-------------------------------------------------------------------
    ! This subroutine collects data (from other processors if this is a
    ! MPI run) and does the actual writing of restart files.
    !-------------------------------------------------------------------

    integer, intent(in) :: numi,numj,numk1,numk2,nxr,nyr
    integer, intent(in) :: ppnode,d3n,d3t,d2i,d2j,d3i,d3j
    real, intent(in   ), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy,numk1:numk2) :: var
    character*8, intent(in) :: aname
    integer, intent(in) :: ni,nj,ngxy,myid,numprocs,nodex,nodey
    integer, intent(inout) :: orec,ncid
    integer, intent(in) :: time_index,restart_format,restart_filetype
    real, intent(inout), dimension(numi,numj) :: dat1
    real, intent(inout), dimension(d2i,d2j) :: dat2
    real, intent(inout), dimension(d3i,d3j,0:d3n-1) :: dat3
    integer, intent(inout), dimension(d3t) :: reqt
    integer, intent(in) :: mynode,nodemaster,nodes,nfile

    integer :: i,j,k,msk
#ifdef MPI
    integer :: reqs,index,index2,n,nn,nnn,fooi,fooj,proc,ierr,ntot,n1,n2,tag
    logical :: recv1,recv2
#endif
#ifdef NETCDF
    integer :: varid,status
#endif

!-------------------------------------------------------------------------------

    rf1:  IF( restart_filetype.eq.1 .or. restart_filetype.eq.2 )THEN

    msk = 0

#ifdef MPI
    !----------------- MPI section -----------------!
    recv1 = .true.
    recv2 = .true.
    tag = 1
#endif

    kloop:  DO k=numk1,numk2

#ifndef MPI
      !-------------------- non-MPI section --------------------!
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,numj
      do i=1,numi
        dat2(i,j)=var(i,j,k)
      enddo
      enddo
#ifdef NETCDF
      if( restart_format.eq.2 )then
        status = nf90_inq_varid(ncid,aname,varid)
        if(status.ne.nf90_noerr)then
          print *,'  Error1 in writer, aname = ',aname
          print *,nf90_strerror(status)
          call stopcm1
        endif
      endif
#endif
#else
      iamnodemaster:  IF(myid.ne.nodemaster)THEN
        ! ordinary processor ... send data to nodemaster:
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          dat1(i,j)=var(i,j,k)
        enddo
        enddo
        call MPI_ISEND(dat1(1,1),numi*numj,MPI_REAL,nodemaster,tag,MPI_COMM_WORLD,reqs,ierr)
        call MPI_WAIT(reqs,MPI_STATUS_IGNORE,ierr)
        ! DONE, ordinary processors
      ELSE
        ! begin nodemaster section:
        if( recv1 )then
          ! start receives from all other processors on a node:
          do proc=myid+1,myid+(ppnode-1)
            call MPI_IRECV(dat3(1,1,proc),numi*numj,MPI_REAL,proc,tag,MPI_COMM_WORLD,reqt(proc-myid),ierr)
          enddo
        endif
        iammsk:  IF(myid.ne.msk)THEN
          ! nodemaster, not proc msk:
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,numj
          do i=1,numi
            dat3(i,j,myid)=var(i,j,k)
          enddo
          enddo
          ! wait for receives to finish:
          call mpi_waitall(ppnode-1,reqt(1:ppnode-1),MPI_STATUSES_IGNORE,ierr)
          ! send data to processor msk:
          call MPI_ISEND(dat3(1,1,myid),numi*numj*ppnode,MPI_REAL,msk,tag+1,MPI_COMM_WORLD,reqs,ierr)
          ! wait for send to finish:
          call MPI_WAIT(reqs,MPI_STATUS_IGNORE,ierr)
          recv1 = .true.
          ! DONE, nodemaster (not proc msk)
        ELSE
          ! proc msk:
          if( recv2 )then
            ! start receives from other nodemasters:
            do n = 1,(nodes-1)
              if( n.le.mynode )then
                proc = (n-1)*ppnode
              else
                proc = n*ppnode
              endif
              call MPI_IRECV(dat3(1,1,proc),numi*numj*ppnode,MPI_REAL,proc,tag+1,MPI_COMM_WORLD,reqt(ppnode-1+n),ierr)
            enddo
          endif
#ifdef NETCDF
          if( restart_format.eq.2 .and. k.eq.numk1 )then
            status = nf90_inq_varid(ncid,aname,varid)
            if(status.ne.nf90_noerr)then
              print *,'  Error1 in writer, aname = ',aname
              print *,nf90_strerror(status)
              call stopcm1
            endif
          endif
#endif
          ! my data:
          if( myid.eq.0 )then
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,numj
            do i=1,numi
              dat2(i,j)=var(i,j,k)
            enddo
            enddo
          else
            fooj = myid / nodex + 1
            fooi = myid - (fooj-1)*nodex  + 1
            fooi = (fooi-1)*ni
            fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,numj
            do i=1,numi
              dat2(fooi+i,fooj+j)=var(i,j,k)
            enddo
            enddo
          endif
          ! wait for data to arrive:
          ntot = ppnode-1 + nodes-1
          do nn=1,ntot
            call mpi_waitany(ntot,reqt(1:ntot),index,MPI_STATUS_IGNORE,ierr)
            if( index.le.(ppnode-1) )then
              ! data from ordinary procs on node:
              proc = myid+index
              fooj = proc / nodex + 1
              fooi = proc - (fooj-1)*nodex  + 1
              fooi = (fooi-1)*ni
              fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
              do j=1,numj
              do i=1,numi
                dat2(fooi+i,fooj+j) = dat3(i,j,proc)
              enddo
              enddo
            else
              ! data from other nodemasters:
              index2 = index-(ppnode-1)
              if( index2.le.mynode )then
                index2 = index2-1
              endif
              n1 = index2*ppnode
              n2 = (index2+1)*ppnode-1
              do nnn = n1,n2
                proc = nnn
                fooj = proc / nodex + 1
                fooi = proc - (fooj-1)*nodex  + 1
                fooi = (fooi-1)*ni
                fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
                do j=1,numj
                do i=1,numi
                  dat2(fooi+i,fooj+j) = dat3(i,j,proc)
                enddo
                enddo
              enddo
            endif
          enddo
          ! DONE, proc msk
          ! processor is ready to write.
          IF( k.lt.numk2 )THEN
            ! start receives for next level:
            do proc=myid+1,myid+(ppnode-1)
              call MPI_IRECV(dat3(1,1,proc),numi*numj,MPI_REAL,proc,tag+2,MPI_COMM_WORLD,reqt(proc-myid),ierr)
            enddo
            recv1 = .false.
!!!#ifdef NETCDF
!!!            IF( restart_format.eq.2 )THEN
              do n = 1,(nodes-1)
                proc = n*ppnode
                call MPI_IRECV(dat3(1,1,proc),numi*numj*ppnode,MPI_REAL,proc,tag+3,MPI_COMM_WORLD,reqt(ppnode-1+n),ierr)
              enddo
              recv2 = .false.
!!!            ENDIF
!!!#endif
          ENDIF
        ENDIF  iammsk
      ENDIF  iamnodemaster
#endif

        ! WRITE DATA:
        IF( myid.eq.msk )THEN
          !---   write data   ------------------!
          IF( restart_format.eq.1 )THEN
            write(nfile,rec=orec) ((dat2(i,j),i=1,nxr),j=1,nyr)
#ifdef NETCDF
          ELSEIF( restart_format.eq.2 )THEN
            ! ----- netcdf format -----
            if(numk1.eq.numk2)then
              status = nf90_put_var(ncid,varid,dat2,(/1,1,time_index/),(/nxr,nyr,1/))
            else
              status = nf90_put_var(ncid,varid,dat2,(/1,1,k,time_index/),(/nxr,nyr,1,1/))
            endif
            if(status.ne.nf90_noerr)then
              print *,'  Error2 in writer, aname = ',aname
              print *,nf90_strerror(status)
              call stopcm1
            endif
#endif
          ENDIF
        ENDIF

      !---  prepare for next level   -------!
      IF( restart_format.eq.1 )THEN
        orec = orec+1
!!!#ifdef MPI
!!!        msk = msk+ppnode
!!!        if( msk.ge.numprocs ) msk = msk-numprocs
!!!#endif
      ENDIF
#ifdef MPI
      tag = tag+2
#endif
      !---  done with this level   ---------!
    ENDDO  kloop

    ENDIF  rf1

!-------------------------------------------------------------------------------

#ifdef MPI
    rf2:  IF( restart_filetype.eq.3 )THEN

      call    writer2(numi,numj,numk1,numk2,nxr,nyr,var,aname,           &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orec,nfile,   &
                      ncid,time_index,restart_format,restart_filetype,   &
                      dat1(1,1),dat2(1,1),dat3(1,1,0),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)

    ENDIF  rf2
#endif

!-------------------------------------------------------------------------------
!ccccc  done  cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-------------------------------------------------------------------------------

#ifdef MPI
    ! helps with memory:
    call MPI_BARRIER (MPI_COMM_WORLD,ierr)
    !----------------- end MPI section -----------------!
#endif

    return
    end subroutine writer


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


    subroutine  readr(numi,numj,numk1,numk2,nxr,nyr,var,aname,           &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orec,nfile,   &
                      ncid,time_index,restart_format,restart_filetype,   &
                      dat1,dat2,dat3,reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)
#ifdef MPI
    use mpi
#endif
#ifdef NETCDF
    use netcdf
#endif
    implicit none

    !-------------------------------------------------------------------
    ! This subroutine reads restart files and then passes data 
    ! to other processors if this is a MPI run. 
    !-------------------------------------------------------------------

    integer, intent(in) :: numi,numj,numk1,numk2,nxr,nyr
    integer, intent(in) :: ppnode,d3n,d3t,d2i,d2j,d3i,d3j
    real, intent(inout), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy,numk1:numk2) :: var
    character*8, intent(in) :: aname
    integer, intent(in) :: ni,nj,ngxy,myid,numprocs,nodex,nodey
    integer, intent(inout) :: orec,ncid
    integer, intent(in) :: time_index,restart_format,restart_filetype
    real, intent(inout), dimension(numi,numj) :: dat1
    real, intent(inout), dimension(d2i,d2j) :: dat2
    real, intent(inout), dimension(d3i,d3j,0:d3n-1) :: dat3
    integer, intent(inout), dimension(d3t) :: reqt
    integer, intent(in) :: mynode,nodemaster,nodes,nfile

    integer :: i,j,k,msk
#ifdef MPI
    integer :: reqs,index,index2,n,nn,nnn,fooi,fooj,proc,ierr,ntot,n1,n2
    integer :: tag
#endif
#ifdef NETCDF
    integer :: varid,status
#endif

!-------------------------------------------------------------------------------

    rf1:  IF( restart_filetype.eq.1 .or. restart_filetype.eq.2 )THEN

    msk = 0

#ifdef MPI
    !----------------- MPI section -----------------!
    tag = 1
#endif
#ifdef NETCDF
    if( myid.eq.0 )then
      if( restart_format.eq.2 )then
        status = nf90_inq_varid(ncid,aname,varid)
        if(status.ne.nf90_noerr)then
          print *,'  Error1 in  readr, aname = ',aname
          print *,nf90_strerror(status)
          call stopcm1
        endif
      endif
    endif
#endif

    kloop:  DO k=numk1,numk2

#ifdef MPI
      IF(myid.ne.nodemaster)THEN
        ! ordinary processor ... recv data from nodemaster:
        call MPI_IRECV(dat1(1,1),numi*numj,MPI_REAL,nodemaster,tag,MPI_COMM_WORLD,reqs,ierr)
        call MPI_WAIT(reqs,MPI_STATUS_IGNORE,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          var(i,j,k)=dat1(i,j)
        enddo
        enddo
        ! DONE, ordinary processors
      ELSE
        ! begin nodemaster section:
        IF(myid.ne.msk)THEN
          ! nodemaster, not proc msk:
          ! get data from msk:
          call MPI_IRECV(dat3(1,1,myid),numi*numj*ppnode,MPI_REAL,msk,tag+1,MPI_COMM_WORLD,reqs,ierr)
          ! wait for data to arrive:
          call MPI_WAIT(reqs,MPI_STATUS_IGNORE,ierr)
          ! start sends to other processors on a node:
          do proc=myid+1,myid+(ppnode-1)
            call MPI_ISEND(dat3(1,1,proc),numi*numj,MPI_REAL,proc,tag,MPI_COMM_WORLD,reqt(proc-myid),ierr)
          enddo
          ! my data:
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,numj
          do i=1,numi
            var(i,j,k)=dat3(i,j,myid)
          enddo
          enddo
          ! wait for sends to finish:
          call mpi_waitall(ppnode-1,reqt(1:ppnode-1),MPI_STATUSES_IGNORE,ierr)
          ! DONE, nodemaster (not proc msk)
        ELSE
          ! proc msk:
          ! read data:
#endif

          IF( restart_format.eq.1 )THEN
            read(nfile,rec=orec) ((dat2(i,j),i=1,nxr),j=1,nyr)
#ifdef NETCDF
          ELSEIF( restart_format.eq.2 )THEN
            ! ----- netcdf format -----
            if(numk1.eq.numk2)then
              status = nf90_get_var(ncid,varid,dat2,(/1,1,time_index/),(/nxr,nyr,1/))
            else
              status = nf90_get_var(ncid,varid,dat2,(/1,1,k,time_index/),(/nxr,nyr,1,1/))
            endif
            if(status.ne.nf90_noerr)then
              print *,'  Error2 in  readr, aname = ',aname
              print *,nf90_strerror(status)
              call stopcm1
            endif
#endif
          ENDIF

#ifndef MPI
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,numj
          do i=1,numi
            var(i,j,k)=dat2(i,j)
          enddo
          enddo
#else
          ! send data:
          do nn=1,( nodes-1 )
              ! send data to other nodemasters:
              index2 = nn
              if( index2.le.mynode )then
                index2 = index2-1
              endif
              n1 = index2*ppnode
              n2 = (index2+1)*ppnode-1
              do nnn=n1,n2
                proc = nnn
                fooj = proc / nodex + 1
                fooi = proc - (fooj-1)*nodex  + 1
                fooi = (fooi-1)*ni
                fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
                do j=1,numj
                do i=1,numi
                  dat3(i,j,proc) = dat2(fooi+i,fooj+j)
                enddo
                enddo
              enddo
              proc = index2*ppnode
              call MPI_ISEND(dat3(1,1,proc),numi*numj*ppnode,MPI_REAL,proc,tag+1,MPI_COMM_WORLD,reqt(ppnode-1+nn),ierr)
          enddo
          do nn=1,( ppnode-1 )
              ! send data to ordinary procs on this node:
              proc = myid+nn
              fooj = proc / nodex + 1
              fooi = proc - (fooj-1)*nodex  + 1
              fooi = (fooi-1)*ni
              fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
              do j=1,numj
              do i=1,numi
                dat3(i,j,proc) = dat2(fooi+i,fooj+j)
              enddo
              enddo
              call MPI_ISEND(dat3(1,1,proc),numi*numj,MPI_REAL,proc,tag,MPI_COMM_WORLD,reqt(nn),ierr)
          enddo
          ! my data:
          if( myid.eq.0 )then
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,numj
            do i=1,numi
              var(i,j,k) = dat2(i,j)
            enddo
            enddo
          else
            fooj = myid / nodex + 1
            fooi = myid - (fooj-1)*nodex  + 1
            fooi = (fooi-1)*ni
            fooj = (fooj-1)*nj
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,numj
            do i=1,numi
              var(i,j,k) = dat2(fooi+i,fooj+j)
            enddo
            enddo
          endif
          ntot = ppnode-1 + nodes-1
          call mpi_waitall(ntot,reqt(1:ntot),MPI_STATUSES_IGNORE,ierr)
        ENDIF
      ENDIF
#endif
      !---  prepare for next level   -------!
      IF( restart_format.eq.1 )THEN
        orec = orec+1
!!!#ifdef MPI
!!!        msk = msk+ppnode
!!!        if( msk.ge.numprocs ) msk = msk-numprocs
!!!#endif
      ENDIF
#ifdef MPI
      tag = tag+2
#endif
      !---  done with this level   ---------!
    ENDDO  kloop

    ENDIF  rf1

!-------------------------------------------------------------------------------

#ifdef MPI
    rf2:  IF( restart_filetype.eq.3 )THEN

      call     readr2(numi,numj,numk1,numk2,nxr,nyr,var,aname,           &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orec,nfile,   &
                      ncid,time_index,restart_format,restart_filetype,   &
                      dat1(1,1),dat2(1,1),dat3(1,1,0),reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)

    ENDIF  rf2
#endif

!-------------------------------------------------------------------------------
!ccccc  done  cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-------------------------------------------------------------------------------

#ifdef MPI
    ! helps with memory:
    call MPI_BARRIER (MPI_COMM_WORLD,ierr)
    !----------------- end MPI section -----------------!
#endif

    return
    end subroutine  readr


#ifdef MPI
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


    ! cm1r17-format restart files !
    subroutine writer2(numi,numj,numk1,numk2,nxr,nyr,var,aname,          &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orec,nfile,   &
                      ncid,time_index,restart_format,restart_filetype,   &
                      dat1,dat2,dat3,reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)
    use mpi
    implicit none

    !-------------------------------------------------------------------
    ! This subroutine collects data (from other processors if this is a
    ! MPI run) and does the actual writing of restart files.
    !-------------------------------------------------------------------

    integer, intent(in) :: numi,numj,numk1,numk2,nxr,nyr
    integer, intent(in) :: ppnode,d3n,d3t,d2i,d2j,d3i,d3j
    real, intent(in   ), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy,numk1:numk2) :: var
    character*8, intent(in) :: aname
    integer, intent(in) :: ni,nj,ngxy,myid,numprocs,nodex,nodey
    integer, intent(inout) :: orec,ncid
    integer, intent(in) :: time_index,restart_format,restart_filetype
    real, intent(inout), dimension(numi,numj) :: dat1
    real, intent(inout), dimension(d3i*ppnode,d3j) :: dat2
    real, intent(inout), dimension(d3i,d3j,0:d3n-1) :: dat3
    integer, intent(inout), dimension(d3t) :: reqt
    integer, intent(in) :: mynode,nodemaster,nodes,nfile

    integer :: i,j,k,msk
    integer :: reqs,index,index2,n,nn,nnn,fooi,fooj,proc,ierr,ntot,n1,n2,tag
    logical :: recv1,recv2

    DO k=numk1,numk2
      IF(myid.ne.nodemaster)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          dat1(i,j) = var(i,j,k)
        enddo
        enddo
        call MPI_ISEND(dat1,numi*numj,MPI_REAL,nodemaster,k,MPI_COMM_WORLD,reqs,ierr)
        call MPI_WAIT(reqs,mpi_status_ignore,ierr)
      ELSE
        do proc=myid+1,myid+(ppnode-1)
          call MPI_IRECV(dat3(1,1,proc),numi*numj,MPI_REAL,proc,k,MPI_COMM_WORLD,reqt(proc-myid),ierr)
        enddo
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          dat2(i,j)=var(i,j,k)
        enddo
        enddo
        nn = 1
        do while( nn.le.(ppnode-1) )
          nn = nn + 1
          call mpi_waitany(ppnode-1,reqt(1:ppnode-1),index,MPI_STATUS_IGNORE,ierr)
          fooi = numi*index
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,numj
          do i=1,numi
            dat2(fooi+i,j)=dat3(i,j,nodemaster+index)
          enddo
          enddo
        enddo
        write(50) dat2
      ENDIF
    ENDDO

    return
    end subroutine writer2


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


    ! cm1r17-format restart files !
    subroutine  readr2(numi,numj,numk1,numk2,nxr,nyr,var,aname,          &
                      ni,nj,ngxy,myid,numprocs,nodex,nodey,orec,nfile,   &
                      ncid,time_index,restart_format,restart_filetype,   &
                      dat1,dat2,dat3,reqt,ppnode,d3n,d3t,mynode,nodemaster,nodes,d2i,d2j,d3i,d3j)
    use mpi
    implicit none

    !-------------------------------------------------------------------
    ! This subroutine reads restart files and then passes data 
    ! to other processors if this is a MPI run. 
    !-------------------------------------------------------------------

    integer, intent(in) :: numi,numj,numk1,numk2,nxr,nyr
    integer, intent(in) :: ppnode,d3n,d3t,d2i,d2j,d3i,d3j
    real, intent(inout), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy,numk1:numk2) :: var
    character*8, intent(in) :: aname
    integer, intent(in) :: ni,nj,ngxy,myid,numprocs,nodex,nodey
    integer, intent(inout) :: orec,ncid
    integer, intent(in) :: time_index,restart_format,restart_filetype
    real, intent(inout), dimension(numi,numj) :: dat1
    real, intent(inout), dimension(d3i*ppnode,d3j) :: dat2
    real, intent(inout), dimension(d3i,d3j,0:d3n-1) :: dat3
    integer, intent(inout), dimension(d3t) :: reqt
    integer, intent(in) :: mynode,nodemaster,nodes,nfile

    integer :: i,j,k,msk
    integer :: reqs,index,index2,n,nn,nnn,fooi,fooj,proc,ierr,ntot,n1,n2
    integer :: tag

    DO k=numk1,numk2
      IF(myid.ne.nodemaster)THEN
        call MPI_IRECV(dat1,numi*numj,MPI_REAL,nodemaster,k,MPI_COMM_WORLD,reqs,ierr)
        call MPI_WAIT(reqs,mpi_status_ignore,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          var(i,j,k) = dat1(i,j)
        enddo
        enddo
      ELSE
        read(50) dat2
        do proc=myid+1,myid+(ppnode-1)
          fooi = numi*(proc-myid)
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,numj
          do i=1,numi
            dat3(i,j,proc)=dat2(fooi+i,j)
          enddo
          enddo
          call MPI_ISEND(dat3(1,1,proc),numi*numj,MPI_REAL,proc,k,MPI_COMM_WORLD,reqt(proc-myid),ierr)
        enddo
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,numj
        do i=1,numi
          var(i,j,k)=dat2(i,j)
        enddo
        enddo
        call mpi_waitall(ppnode-1,reqt(1:ppnode-1),MPI_STATUSES_IGNORE,ierr)
      ENDIF
    ENDDO

    return
    end subroutine  readr2
#endif

END MODULE module_restart

writeout_nc.F   1587934804  1602  20    100644  167953    `

!-------------------------------------------------------------
!
!  This subroutine writes data in NetCDF files.
!
!  Code originally written by Daniel Kirshbaum
!  Code converted to netcdf4 (f90) by George Bryan, May 2013
!  Code last modified by George Bryan, 130910
!
!-------------------------------------------------------------


      subroutine netcdf_prelim(rtime,nwrite,ncid,time_index,qname,xh,xf,yh,yf, &
                               xfref,yfref,sigma,sigmaf,zs,zh,zf,        &
                               d2d,ds,du,dv,                             &
                               dumz,dumx,dumy)
#ifdef NETCDF
      use netcdf
#endif
      implicit none
      include 'input.incl'
      include 'constants.incl'

      real, intent(in) :: rtime
      integer, intent(in) :: nwrite
      integer, intent(inout) :: ncid,time_index
      character*3, dimension(maxq), intent(in) :: qname
      real, dimension(ib:ie),   intent(in) :: xh
      real, dimension(ib:ie+1), intent(in) :: xf
      real, dimension(jb:je),   intent(in) :: yh
      real, dimension(jb:je+1), intent(in) :: yf
      real, intent(in), dimension(-2:nx+4) :: xfref
      real, intent(in), dimension(-2:ny+4) :: yfref
      real, dimension(kb:ke)  , intent(in) :: sigma
      real, dimension(kb:ke+1), intent(in) :: sigmaf
      real, dimension(ib:ie,jb:je), intent(in) :: zs
      real, dimension(ib:ie,jb:je,kb:ke),   intent(in) :: zh
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: zf
      real, dimension(ni,nj) :: d2d
      real, dimension(ni,nj,nk) :: ds
      real, dimension(ni+1,nj,nk) :: du
      real, dimension(ni,nj+1,nk) :: dv
      real, intent(inout), dimension(nz+1) :: dumz
      real, intent(inout), dimension(nx+1) :: dumx
      real, intent(inout), dimension(ny+1) :: dumy

#ifdef NETCDF
      integer i,j,k,n,irec

      ! Users of GrADS might want to set coards to .true.
      logical, parameter :: coards = .false.

      integer :: cdfid    ! ID for the netCDF file to be created
      integer :: status,dimid,varid
      integer :: niid,njid,nkid,nip1id,njp1id,nkp1id,timeid,oneid,tfile,num_write
      character*8 chid

!-------------------------------------------------------------
! Declare and set integer values for the netCDF dimensions 
!-------------------------------------------------------------

      integer :: ival,jval,kval,ivalp1,jvalp1,kvalp1
      real :: actual_time

      logical :: allinfo

      integer, parameter :: shuffle       = 1
      integer, parameter :: deflate       = 1
      integer, parameter :: deflate_level = 2

      integer :: chkx,chky,chkxp1,chkyp1

      logical, parameter :: stop_on_error = .true.

!--------------------------------------------------------------
! Initializing some things
!--------------------------------------------------------------

    if(coards)then
      if(tapfrq.lt.60.0)then
        print *
        print *,'  Output frequency cannot be less than 60 s for coards format'
        print *
        call stopcm1
      endif
      actual_time = rtime/60.0
    else
      actual_time = rtime
    endif

!--------------------------------------------------------------
!  Write data to cdf file
!--------------------------------------------------------------

    IF(output_filetype.eq.1)THEN
      string(totlen+1:totlen+22) = '.nc                   '
    ELSEIF(output_filetype.eq.2)THEN
      string(totlen+1:totlen+22) = '_XXXXXX.nc            '
      write(string(totlen+2:totlen+7),100) nwrite
    ELSEIF(output_filetype.eq.3)THEN
      string(totlen+1:totlen+17) = '_XXXXXX_YYYYYY.nc     '
      write(string(totlen+ 2:totlen+ 7),100) myid
      write(string(totlen+ 9:totlen+14),100) nwrite
    ELSE
      if(dowr) write(outfile,*) '  for netcdf output, output_filetype must be either 1,2, or 3 '
      call stopcm1
    ENDIF

      if(myid.eq.0) print *,string

100   format(i6.6)

!--------------------------------------------------------------
!  Dimensions of data:

    IF( output_filetype.eq.1 .or. output_filetype.eq.2 )THEN
      ival = nx
      jval = ny
      chkx = nx
      chky = ny
      chkxp1 = nx+1
      chkyp1 = ny+1
    ELSEIF( output_filetype.eq.3 )THEN
      ival = ni
      jval = nj
      chkx = ni
      chky = nj
      chkxp1 = ni+1
      chkyp1 = nj+1
    ELSE
      print *,'  unrecognized value for output_filetype '
      call stopcm1
    ENDIF

    ivalp1 = ival+1
    jvalp1 = jval+1

    kval = min(maxk,nk)
    kvalp1 = min(maxk+1,nk+1)

!--------------------------------------------------------------
!  if this is the start of a file, then do this stuff:

    num_write = nwrite

    allinfo = .false.
    IF(num_write.eq.1) allinfo=.true.
    IF(output_filetype.ge.2)THEN
      allinfo=.true.
      num_write=1
    ENDIF

    IF( num_write.ne.1 )THEN
      ! cm1r18:  Try to open file.
      !          If error, set num_write to 1 and write all info.
      status = nf90_open(string,nf90_write,ncid)
      if( status.eq.nf90_noerr )then
        ! no error, file exists.  Get number of time levels in file:
        call disp_err( nf90_inq_dimid(ncid,'time',timeid) , .true. )
        call disp_err( nf90_inquire_dimension(ncid=ncid,dimid=timeid,len=tfile), .true. )
        if( (tfile+1).lt.num_write )then
          if(myid.eq.0) print *,'  tfile,num_write = ',tfile,num_write
          num_write = tfile+1
        endif
      else
        ! if error opening file, then write all info:
        if(myid.eq.0) print *,'  status = ',status
!!!        if(myid.eq.0) print *,nf90_strerror(status)
        allinfo = .true.
        num_write = 1
      endif
    ENDIF

    time_index = num_write

    ifallinfo: IF(allinfo)THEN
!!!      print *,'  allinfo ... '

!-----------------------------------------------------------------------
!  BEGIN NEW:

      if( myid.eq.0 ) print *,'  calling nf90_create '
#ifdef NCFPLUS
!--- works with netcdf 4.2, but not 4.0 (grumble)
!!     call disp_err( nf90_create(string,IOR(nf90_netcdf4, nf90_classic_model),ncid) , .true. )
       call disp_err( nf90_create(string,nf90_netcdf4,ncid) , .true. )
#else
      ! must do this for netcdf 4.0 (it seems) !
      call disp_err( nf90_create(path=string,cmode=0,ncid=ncid) , .true. )
#endif

      status = nf90_def_dim(ncid,'ni',ival,niid)
      status = nf90_def_dim(ncid,'nj',jval,njid)
      status = nf90_def_dim(ncid,'nk',kval,nkid)
      status = nf90_def_dim(ncid,'nip1',ivalp1,nip1id)
      status = nf90_def_dim(ncid,'njp1',jvalp1,njp1id)
      status = nf90_def_dim(ncid,'nkp1',kvalp1,nkp1id)
      status = nf90_def_dim(ncid,'time',nf90_unlimited,timeid)
      status = nf90_def_dim(ncid,'one',1,oneid)

    IF(icor.eq.1)THEN
      status = nf90_def_var(ncid,"f_cor",nf90_float,oneid,varid)
      status = nf90_put_att(ncid,varid,"long_name","Coriolis parameter")
      status = nf90_put_att(ncid,varid,"units","1/s")
    ENDIF

    if(.not.coards)then
      status = nf90_def_var(ncid,"ztop",nf90_float,oneid,varid)
      status = nf90_put_att(ncid,varid,"units","km")
    endif

    IF(coards)THEN

      status = nf90_def_var(ncid,"time",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","time since beginning of simulation")
      status = nf90_put_att(ncid,varid,"units","minutes since 2000-07-03 00:00:00")

      status = nf90_def_var(ncid,"ni",nf90_float,niid,varid)
      status = nf90_put_att(ncid,varid,"long_name","west-east location of scalar grid points")
      status = nf90_put_att(ncid,varid,"units","degree_east")

      status = nf90_def_var(ncid,"nip1",nf90_float,nip1id,varid)
      status = nf90_put_att(ncid,varid,"long_name","west-east location of staggered u grid points")
      status = nf90_put_att(ncid,varid,"units","degree_east")

      status = nf90_def_var(ncid,"nj",nf90_float,njid,varid)
      status = nf90_put_att(ncid,varid,"long_name","south-north location of scalar grid points")
      status = nf90_put_att(ncid,varid,"units","degree_north")

      status = nf90_def_var(ncid,"njp1",nf90_float,njp1id,varid)
      status = nf90_put_att(ncid,varid,"long_name","south-north location of staggered v grid points")
      status = nf90_put_att(ncid,varid,"units","degree_north")

      status = nf90_def_var(ncid,"nk",nf90_float,nkid,varid)
      status = nf90_put_att(ncid,varid,"long_name","nominal height of scalar grid points")
      status = nf90_put_att(ncid,varid,"units","km")

      status = nf90_def_var(ncid,"nkp1",nf90_float,nkp1id,varid)
      status = nf90_put_att(ncid,varid,"long_name","nominal height of staggered w grid points")
      status = nf90_put_att(ncid,varid,"units","km")

    ELSE

      status = nf90_def_var(ncid,"time",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","time since beginning of simulation")
      status = nf90_put_att(ncid,varid,"units","seconds since 2003-05-08 21:40:00")

      status = nf90_def_var(ncid,"xh",nf90_float,niid,varid)
      status = nf90_put_att(ncid,varid,"long_name","west-east location of scalar grid points")
      status = nf90_put_att(ncid,varid,"units","km")

      status = nf90_def_var(ncid,"xf",nf90_float,nip1id,varid)
      status = nf90_put_att(ncid,varid,"long_name","west-east location of staggered u grid points")
      status = nf90_put_att(ncid,varid,"units","km")

      status = nf90_def_var(ncid,"yh",nf90_float,njid,varid)
      status = nf90_put_att(ncid,varid,"long_name","south-north location of scalar grid points")
      status = nf90_put_att(ncid,varid,"units","km")

      status = nf90_def_var(ncid,"yf",nf90_float,njp1id,varid)
      status = nf90_put_att(ncid,varid,"long_name","south-north location of staggered v grid points")
      status = nf90_put_att(ncid,varid,"units","km")

      status = nf90_def_var(ncid,"z",nf90_float,nkid,varid)
      status = nf90_put_att(ncid,varid,"long_name","nominal height of scalar grid points")
      status = nf90_put_att(ncid,varid,"units","km")

      status = nf90_def_var(ncid,"zf",nf90_float,nkp1id,varid)
      status = nf90_put_att(ncid,varid,"long_name","nominal height of staggered w grid points")
      status = nf90_put_att(ncid,varid,"units","km")

    ENDIF

!--------------------------------------------------------
!  Just to be sure:

        status = nf90_inq_dimid(ncid,'time',timeid)
        status = nf90_inq_dimid(ncid,'ni',niid)
        status = nf90_inq_dimid(ncid,'nj',njid)
        status = nf90_inq_dimid(ncid,'nk',nkid)
        status = nf90_inq_dimid(ncid,'nip1',nip1id)
        status = nf90_inq_dimid(ncid,'njp1',njp1id)
        status = nf90_inq_dimid(ncid,'nkp1',nkp1id)

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!--- 2D vars:
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      if(output_rain.eq.1)then
        status = nf90_def_var(ncid,"rain",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","accumulated surface rainfall")
        status = nf90_put_att(ncid,varid,"units","cm")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_sws.eq.1) then
        status = nf90_def_var(ncid,"sws",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","max windspeed at lowest level")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_svs.eq.1) then
        status = nf90_def_var(ncid,"svs",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","max vert vorticity at lowest level")
        status = nf90_put_att(ncid,varid,"units","s-1")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_sps.eq.1) then
        status = nf90_def_var(ncid,"sps",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","min pressure at lowest level")
        status = nf90_put_att(ncid,varid,"units","Pa")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_srs.eq.1) then
        status = nf90_def_var(ncid,"srs",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","max surface rainwater")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_sgs.eq.1) then
        status = nf90_def_var(ncid,"sgs",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","max surface graupel/hail")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_sus.eq.1) then
        status = nf90_def_var(ncid,"sus",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","max w at 5 km AGL")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_shs.eq.1) then
        status = nf90_def_var(ncid,"shs",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","max integrated updraft helicity")
        status = nf90_put_att(ncid,varid,"units","m2/s2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      IF(nrain.eq.2)THEN
        if(output_rain.eq.1)then
          status = nf90_def_var(ncid,"rain2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","accumulated surface rainfall, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","cm")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_sws.eq.1) then
          status = nf90_def_var(ncid,"sws2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","max windspeed at lowest level, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_svs.eq.1) then
          status = nf90_def_var(ncid,"svs2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","max vorticity at lowest level, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","s-1")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_sps.eq.1) then
          status = nf90_def_var(ncid,"sps2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","min pressure at lowest level, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","Pa")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_srs.eq.1) then
          status = nf90_def_var(ncid,"srs2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","max surface rainwater, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_sgs.eq.1) then
          status = nf90_def_var(ncid,"sgs2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","max surface graupel/hail, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_sus.eq.1) then
          status = nf90_def_var(ncid,"sus2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","max w at 5 km AGL, translated with moving domain")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if(output_shs.eq.1) then
          status = nf90_def_var(ncid,"shs2",nf90_float,(/niid,njid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","translated max integrated updraft helicity")
          status = nf90_put_att(ncid,varid,"units","m2/s2")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
      ENDIF

      IF(output_uh.eq.1)THEN
        status = nf90_def_var(ncid,"uh",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","integrated updraft helicity")
        status = nf90_put_att(ncid,varid,"units","m2/s2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      ENDIF

      IF (output_coldpool.eq.1) THEN
        status = nf90_def_var(ncid,"cpc",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","cold pool intensity C")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        status = nf90_def_var(ncid,"cph",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","cold pool depth h")
        status = nf90_put_att(ncid,varid,"units","m AGL")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      ENDIF

      if (output_sfcflx.eq.1) then
        status = nf90_def_var(ncid,"thflux",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","surface potential temperature flux")
        status = nf90_put_att(ncid,varid,"units","K m s^{-1}")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"qvflux",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","surface water vapor flux")
        status = nf90_put_att(ncid,varid,"units","kg kg^{-1} m s^{-1}")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"tsk",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","soil/ocean temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_sfcparams.eq.1)then
        status = nf90_def_var(ncid,"cd",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","cd")
        status = nf90_put_att(ncid,varid,"units","nondimensional")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"ch",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","ch")
        status = nf90_put_att(ncid,varid,"units","nondimensional")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"cq",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","cq")
        status = nf90_put_att(ncid,varid,"units","nondimensional")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"tlh",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","horizontal turbulence lengthscale for iturb=3")
        status = nf90_put_att(ncid,varid,"units","m")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if (output_psfc.eq.1) then
        status = nf90_def_var(ncid,"psfc",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","surface pressure")
        status = nf90_put_att(ncid,varid,"units","Pa")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if (output_zs.eq.1) then
        status = nf90_def_var(ncid,"zs",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","terrain height")
        status = nf90_put_att(ncid,varid,"units","m")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      IF (output_dbz.eq.1) THEN
        status = nf90_def_var(ncid,"cref",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","composite reflectivity (dBZ)")
        status = nf90_put_att(ncid,varid,"units","dBZ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      ENDIF

      if(output_sfcparams.eq.1)then
        status = nf90_def_var(ncid,"xland",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","land/water flag (1=land,2=water)")
        status = nf90_put_att(ncid,varid,"units","integer flag")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"lu",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","land use index")
        status = nf90_put_att(ncid,varid,"units","integer flag")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"mavail",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","surface moisture availability")
        status = nf90_put_att(ncid,varid,"units","integer flag")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3.or.oceanmodel.eq.2))then
        status = nf90_def_var(ncid,"tmn",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","deep-layer soil temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"hfx",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","heat flux at surface")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"qfx",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","surface moisture flux")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"gsw",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","downward SW flux at surface")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"glw",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","downward LW flux at surface")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3))then
        status = nf90_def_var(ncid,"tslb1",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","soil temp, layer 1")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"tslb2",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","soil temp, layer 2")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"tslb3",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","soil temp, layer 3")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"tslb4",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","soil temp, layer 4")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"tslb5",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","soil temp, layer 5")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
        status = nf90_def_var(ncid,"tml",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","ocean mixed layer temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"hml",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","ocean mixed layer depth")
        status = nf90_put_att(ncid,varid,"units","m")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"huml",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","ocean mixed layer u vel.")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
#endif

        status = nf90_def_var(ncid,"hvml",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","ocean mixed layer v vel.")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_radten.eq.1)then
        status = nf90_def_var(ncid,"radsw",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","solar radiation at surface")
        status = nf90_put_att(ncid,varid,"units","w/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"rnflx",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","net radiation absorbed by surface")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"radswnet",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","net solar radiation")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"radlwin",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","incoming longwave radiation")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        ! MS add
        status = nf90_def_var(ncid,"olr",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","TOA net outgoing longwave radiation")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        status = nf90_def_var(ncid,"dsr",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","TOA net incoming solar radiation")
        status = nf90_put_att(ncid,varid,"units","W/m^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      IF(output_sfcdiags.eq.1)THEN
        status = nf90_def_var(ncid,"u10",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","diagnostic 10 m u wind")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"v10",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","diagnostic 10 m v wind")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"t2",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","diagnostic 2 m temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"q2",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","diagnostic 2 m mixing ratio")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"znt",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","roughness length")
        status = nf90_put_att(ncid,varid,"units","m")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"ust",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","friction velocity")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"hpbl",nf90_float,(/niid,njid,timeid/),varid)
      if(ipbl.eq.1)then
        status = nf90_put_att(ncid,varid,"long_name","PBL height (from PBL scheme)")
      else
        status = nf90_put_att(ncid,varid,"long_name","rough estimate of PBL height")
      endif
        status = nf90_put_att(ncid,varid,"units","m")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"zol",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","z/L (z over Monin-Obukhov length)")
        status = nf90_put_att(ncid,varid,"units","   ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"mol",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","T* (similarity theory)")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif


        status = nf90_def_var(ncid,"br",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","bulk Richardson number in surface layer")
        status = nf90_put_att(ncid,varid,"units","dimensionless")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"psim",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","similarity stability function for momentum")
        status = nf90_put_att(ncid,varid,"units","dimensionless")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"psih",nf90_float,(/niid,njid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","similarity stability function for heat")
        status = nf90_put_att(ncid,varid,"units","dimensionless")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!--- 3D vars:
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      if (output_zh.eq.1) then
        status = nf90_def_var(ncid,"zh",nf90_float,(/niid,njid,nkid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","height (above sea level) of scalar grid points")
        status = nf90_put_att(ncid,varid,"units","m")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_th.eq.1)then
        status = nf90_def_var(ncid,"th",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","potential temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_thpert.eq.1)then
        status = nf90_def_var(ncid,"thpert",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation potential temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_prs.eq.1)then
        status = nf90_def_var(ncid,"prs",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pressure")
        status = nf90_put_att(ncid,varid,"units","Pa")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_prspert.eq.1)then
        status = nf90_def_var(ncid,"prspert",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation pressure")
        status = nf90_put_att(ncid,varid,"units","Pa")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_pi.eq.1)then
        status = nf90_def_var(ncid,"pi",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","nondimensional pressure")
        status = nf90_put_att(ncid,varid,"units","dimensionless")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_pipert.eq.1)then
        status = nf90_def_var(ncid,"pipert",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation nondimensional pressure")
        status = nf90_put_att(ncid,varid,"units","dimensionless")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_rho.eq.1)then
        status = nf90_def_var(ncid,"rho",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","density of dry air")
        status = nf90_put_att(ncid,varid,"units","kg/m^3")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_rhopert.eq.1)then
        status = nf90_def_var(ncid,"rhopert",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation density of dry air")
        status = nf90_put_att(ncid,varid,"units","kg/m^3")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
    IF(iptra.eq.1)THEN
      do n=1,npt
        chid = 'pt      '
        if( n.le.9 )then
          write(chid(3:3),111) n
111       format(i1)
        else
          write(chid(3:4),141) n
141       format(i2)
        endif
        status = nf90_def_var(ncid,chid,nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","mixing ratio of passive tracer")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      enddo
    ENDIF
    IF(imoist.eq.1)THEN
      if(output_qv.eq.1)then
        status = nf90_def_var(ncid,"qv",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","water vapor mixing ratio")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_qvpert.eq.1)then
        status = nf90_def_var(ncid,"qvpert",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation water vapor mixing ratio")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
        if(output_q.eq.1)then
        do n=1,numq
          if(n.ne.nqv)then
            status = nf90_def_var(ncid,qname(n),nf90_float,(/niid,njid,nkid,timeid/),varid)
            if(idm.eq.1.and.n.ge.nnc1.and.n.le.nnc2)then
              status = nf90_put_att(ncid,varid,"long_name","number concentration")
              status = nf90_put_att(ncid,varid,"units","kg^{-1}")
            elseif(idm .eq. 1 .and. n.ge.nzl1 .and. n .le. nzl2)then
              status = nf90_put_att(ncid,varid,"long_name","reflectivity moment")
              status = nf90_put_att(ncid,varid,"units","Z m^{-3}kg^{-1}")
            elseif(idm .eq. 1 .and. n.ge.nvl1 .and. n .le. nvl2)then
              status = nf90_put_att(ncid,varid,"long_name","particle volume")
              status = nf90_put_att(ncid,varid,"units","m^{3}kg^{-1}")
            else
              status = nf90_put_att(ncid,varid,"long_name","mixing ratio")
              status = nf90_put_att(ncid,varid,"units","kg/kg")
            endif
#ifdef NCFPLUS
            call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
            call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
          endif
        enddo
      endif
      if(output_dbz.eq.1)then
        status = nf90_def_var(ncid,"dbz",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","reflectivity")
        status = nf90_put_att(ncid,varid,"units","dBZ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
    ENDIF

      if(output_buoyancy.eq.1)then
        status = nf90_def_var(ncid,"buoyancy",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","buoyancy")
        status = nf90_put_att(ncid,varid,"units","m s^-2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_uinterp.eq.1)then
        status = nf90_def_var(ncid,"uinterp",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","velocity in x-direction, interpolated to scalar points")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_vinterp.eq.1)then
        status = nf90_def_var(ncid,"vinterp",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","velocity in y-direction, interpolated to scalar points")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_winterp.eq.1)then
        status = nf90_def_var(ncid,"winterp",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","velocity in z-direction, interpolated to scalar points")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_vort.eq.1)then
        status = nf90_def_var(ncid,"xvort",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","horizontal vorticity (x)")
        status = nf90_put_att(ncid,varid,"units","s^-1")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"yvort",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","horizontal vorticity (y)")
        status = nf90_put_att(ncid,varid,"units","s^-1")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"zvort",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","vertical vorticity")
        status = nf90_put_att(ncid,varid,"units","s^-1")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_pv.eq.1)then
        status = nf90_def_var(ncid,"pv",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","potential vorticity")
        status = nf90_put_att(ncid,varid,"units","K m^2 kg^-1 s^-1")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if (output_basestate.eq.1) then

        status = nf90_def_var(ncid,"pi0",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","base-state nondimensional pressure")
        status = nf90_put_att(ncid,varid,"units","dimensionless")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"th0",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","base-state potential temperature")
        status = nf90_put_att(ncid,varid,"units","K")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"prs0",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","base-state pressure")
        status = nf90_put_att(ncid,varid,"units","Pa")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"qv0",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","base-state water vapor mixing ratio")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      endif

      if(output_pblten.eq.1)then
        status = nf90_def_var(ncid,"thpten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pbl tendency: theta")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
#endif

        status = nf90_def_var(ncid,"qvpten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pbl tendency: qv")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"qcpten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pbl tendency: qc")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"qipten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pbl tendency: qi")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"upten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pbl tendency: u")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"vpten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pbl tendency: v")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_radten.eq.1)then
        status = nf90_def_var(ncid,"swten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pot temp tendency, sw rad")
        status = nf90_put_att(ncid,varid,"units","    ")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

        status = nf90_def_var(ncid,"lwten",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","pot temp tendency, lw rad")
        status = nf90_put_att(ncid,varid,"units","K/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif


      IF( output_turbten.eq.1 )THEN
        status = nf90_def_var(ncid,"ftt",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","theta tendency: turbulence scheme")
        status = nf90_put_att(ncid,varid,"units","K/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        IF(imoist.eq.1)THEN
          status = nf90_def_var(ncid,"ftq",nf90_float,(/niid,njid,nkid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","qv tendency: turbulence scheme")
          status = nf90_put_att(ncid,varid,"units","kg/kg/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        ENDIF
      ENDIF

      IF( output_dissheat.eq.1 )THEN
        status = nf90_def_var(ncid,"dissheat",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","dissipative heating (potential temperature tendency)")
        status = nf90_put_att(ncid,varid,"units","K/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      ENDIF


      IF( output_mptend.eq.1 )THEN
        status = nf90_def_var(ncid,"mptend",nf90_float,(/niid,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","potential temperature tendency from microphysics scheme")
        status = nf90_put_att(ncid,varid,"units","K/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      ENDIF

      IF( output_fallvel.eq.1 )THEN
        if( qd_vtc.gt.0 )then
          status = nf90_def_var(ncid,"vtc",nf90_float,(/niid,njid,nkid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qc")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if( qd_vtr.gt.0 )then
          status = nf90_def_var(ncid,"vtr",nf90_float,(/niid,njid,nkid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qr")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if( qd_vts.gt.0 )then
          status = nf90_def_var(ncid,"vts",nf90_float,(/niid,njid,nkid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qs")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if( qd_vtg.gt.0 )then
          status = nf90_def_var(ncid,"vtg",nf90_float,(/niid,njid,nkid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qg")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
        if( qd_vti.gt.0 )then
          status = nf90_def_var(ncid,"vti",nf90_float,(/niid,njid,nkid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qi")
          status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
          call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
          call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        endif
      ENDIF

      if(output_u.eq.1)then
        status = nf90_def_var(ncid,"u",nf90_float,(/nip1id,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","velocity in x-direction")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_upert.eq.1)then
        status = nf90_def_var(ncid,"upert",nf90_float,(/nip1id,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation velocity in x-direction")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if (output_basestate.eq.1) then
        status = nf90_def_var(ncid,"u0",nf90_float,(/nip1id,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","base-state x-component of velocity")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_turbten.eq.1)then
        status = nf90_def_var(ncid,"ftu",nf90_float,(/nip1id,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","u tendency: turbulence scheme")
        status = nf90_put_att(ncid,varid,"units","m/s/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_impdiften.eq.1)then
        status = nf90_def_var(ncid,"fdu",nf90_float,(/nip1id,njid,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","u tendency: implicit diffusion")
        status = nf90_put_att(ncid,varid,"units","m/s/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_v.eq.1)then
        status = nf90_def_var(ncid,"v",nf90_float,(/niid,njp1id,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","velocity in y-direction")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_vpert.eq.1)then
        status = nf90_def_var(ncid,"vpert",nf90_float,(/niid,njp1id,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","perturbation velocity in y-direction")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if (output_basestate.eq.1) then
        status = nf90_def_var(ncid,"v0",nf90_float,(/niid,njp1id,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","base-state y-component of velocity")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_turbten.eq.1)then
        status = nf90_def_var(ncid,"ftv",nf90_float,(/niid,njp1id,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","v tendency: turbulence scheme")
        status = nf90_put_att(ncid,varid,"units","m/s/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_impdiften.eq.1)then
        status = nf90_def_var(ncid,"fdv",nf90_float,(/niid,njp1id,nkid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","v tendency: implicit diffusion")
        status = nf90_put_att(ncid,varid,"units","m/s/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

      if(output_w.eq.1)then
        status = nf90_def_var(ncid,"w",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","velocity in z-direction")
        status = nf90_put_att(ncid,varid,"units","m/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      IF((iturb.eq.1).and.(output_tke.eq.1))THEN
        status = nf90_def_var(ncid,"tke",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","subgrid turbulence kinetic energy")
        status = nf90_put_att(ncid,varid,"units","m^2/s^2")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      ENDIF
      IF(output_km.eq.1)THEN
        !----
        status = nf90_def_var(ncid,"kmh",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","eddy mixing coefficient for momentum in the horizontal direction")
        status = nf90_put_att(ncid,varid,"units","m^2/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        !----
        status = nf90_def_var(ncid,"kmv",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","eddy mixing coefficient for momentum in the vertical direction")
        status = nf90_put_att(ncid,varid,"units","m^2/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        !----
      ENDIF
      IF(output_kh.eq.1)THEN
        !----
        status = nf90_def_var(ncid,"khh",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","eddy mixing coefficient for scalars in the horizontal direction")
        status = nf90_put_att(ncid,varid,"units","m^2/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        !----
        status = nf90_def_var(ncid,"khv",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","eddy mixing coefficient for scalars in the vertical direction")
        status = nf90_put_att(ncid,varid,"units","m^2/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        !----
      ENDIF

      if(output_dissten.eq.1)then
        status = nf90_def_var(ncid,"dissten",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","dissipation rate")
        status = nf90_put_att(ncid,varid,"units","m^2/s^3")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_nm.eq.1)then
        status = nf90_def_var(ncid,"nm",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","squared Brunt-Vaisala freq")
        status = nf90_put_att(ncid,varid,"units","s^{-2}")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_def.eq.1)then
        status = nf90_def_var(ncid,"defv",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","vertical deformation")
        status = nf90_put_att(ncid,varid,"units","s^{-2}")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
        status = nf90_def_var(ncid,"defh",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","horizontal deformation")
        status = nf90_put_att(ncid,varid,"units","s^{-2}")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_turbten.eq.1)then
        status = nf90_def_var(ncid,"ftw",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","w tendency: turbulence scheme")
        status = nf90_put_att(ncid,varid,"units","m/s/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if(output_impdiften.eq.1)then
        status = nf90_def_var(ncid,"fdw",nf90_float,(/niid,njid,nkp1id,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","w tendency: implicit diffusion")
        status = nf90_put_att(ncid,varid,"units","m/s/s")
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif

!--------------------------------------------------

    if(coards)then
      status = nf90_put_att(ncid,NF90_GLOBAL,'Conventions','COARDS')
    endif
      status = nf90_put_att(ncid,NF90_GLOBAL,'x_units','km')
      status = nf90_put_att(ncid,NF90_GLOBAL,'x_label','x')
      status = nf90_put_att(ncid,NF90_GLOBAL,'y_units','km')
      status = nf90_put_att(ncid,NF90_GLOBAL,'y_label','y')
      status = nf90_put_att(ncid,NF90_GLOBAL,'z_units','km')
      status = nf90_put_att(ncid,NF90_GLOBAL,'z_label','z')

      status = nf90_enddef(ncid)

! ... end of defs
!--------------------------------------------------
! begin data ... initial time ...

    IF(icor.eq.1)THEN
      status = nf90_inq_varid(ncid,'f_cor',varid)
      status = nf90_put_var(ncid,varid,fcor)
    ENDIF

    if(.not.coards)then
      status = nf90_inq_varid(ncid,'ztop',varid)
      status = nf90_put_var(ncid,varid,0.001*ztop)
    endif

      if(coards)then
        status = nf90_inq_varid(ncid,'ni',varid)
      else
        status = nf90_inq_varid(ncid,'xh',varid)
      endif
      do i=1,nx
        dumx(i) = 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
      status = nf90_put_var(ncid,varid,dumx,(/1/),(/nx/))

      if(coards)then
        status = nf90_inq_varid(ncid,'nip1',varid)
      else
        status = nf90_inq_varid(ncid,'xf',varid)
      endif
      do i=1,nx+1
        dumx(i) = 0.001*xfref(i)
      enddo
      status = nf90_put_var(ncid,varid,dumx,(/1/),(/nx+1/))

      if(coards)then
        status = nf90_inq_varid(ncid,'nj',varid)
      else
        status = nf90_inq_varid(ncid,'yh',varid)
      endif
      do j=1,ny
        dumy(j) = 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
      status = nf90_put_var(ncid,varid,dumy,(/1/),(/ny/))

      if(coards)then
        status = nf90_inq_varid(ncid,'njp1',varid)
      else
        status = nf90_inq_varid(ncid,'yf',varid)
      endif
      do j=1,ny+1
        dumy(j) = 0.001*yfref(j)
      enddo
      status = nf90_put_var(ncid,varid,dumy,(/1/),(/ny+1/))

      if(coards)then
        status = nf90_inq_varid(ncid,'nk',varid)
      else
        status = nf90_inq_varid(ncid,'z',varid)
      endif
      if(terrain_flag)then
        do k=1,kval
          dumz(k) = 0.001*sigma(k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kval/))
      else
        do k=1,kval
          dumz(k) = 0.001*zh(1,1,k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kval/))
      endif

      if(coards)then
        status = nf90_inq_varid(ncid,'nkp1',varid)
      else
        status = nf90_inq_varid(ncid,'zf',varid)
      endif
      if(terrain_flag)then
        do k=1,kvalp1
          dumz(k) = 0.001*sigmaf(k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kvalp1/))
      else
        do k=1,kvalp1
          dumz(k) = 0.001*zf(1,1,k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kvalp1/))
      endif

      ! ... end if info at initial time only

!----------------------------------------------------------

    ENDIF ifallinfo

      call disp_err( nf90_inq_varid(ncid,'time',varid) , stop_on_error )
      call disp_err( nf90_put_var(ncid,varid,actual_time,(/time_index/)) , stop_on_error )

#endif

    return
    end subroutine netcdf_prelim


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef NETCDF


    ! cm1r18:  netcdf restart files
    subroutine restart_prelim(nrst,ncid,mtime,xfref,yfref,zh,zf,sigma,sigmaf,  &
                              qname,num_soil_layers,nrad2d,dumx,dumy,dumz)

    use netcdf
    use module_restart
    implicit none

    include 'input.incl'
    include 'constants.incl'

    integer, intent(in) :: nrst
    integer, intent(inout) :: ncid
    double precision, intent(in) :: mtime
    real, intent(in), dimension(-2:nx+4) :: xfref
    real, intent(in), dimension(-2:ny+4) :: yfref
    real, intent(in), dimension(ib:ie,jb:je,kb:ke)   :: zh
    real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
    real, intent(in), dimension(kb:ke)   :: sigma
    real, intent(in), dimension(kb:ke+1) :: sigmaf
    character*3, intent(in), dimension(maxq) :: qname
    integer, intent(in) :: num_soil_layers,nrad2d
    real, intent(inout), dimension(nx+1) :: dumx
    real, intent(inout), dimension(ny+1) :: dumy
    real, intent(inout), dimension(nz+1) :: dumz

    integer :: i,j,k,n
    integer :: ival,jval,kval,ivalp1,jvalp1,kvalp1
    integer :: chkx,chky,chkxp1,chkyp1
    integer :: time_index,status,varid
    real :: actual_time
    integer :: niid,njid,nkid,nip1id,njp1id,nkp1id,timeid
    integer :: nbudgetid,numqid,plocid,nparcelsid
    character*8 :: text1

    integer, parameter :: shuffle       = 1
    integer, parameter :: deflate       = 1
    integer, parameter :: deflate_level = 2

    chkx = nx
    chky = ny

    chkxp1 = nx+1
    chkyp1 = ny+1

    time_index = 1

    actual_time = mtime

    string(totlen+1:totlen+22) = '_rst_XXXXXX.nc        '
    write(string(totlen+6:totlen+11),100) nrst
100 format(i6.6)

    if(myid.eq.0) print *,'  string = ',string

!--------------------------------------------------------------
!  Dimensions of data:

    ival = nx
    jval = ny
    kval = nk

    ivalp1 = ival+1
    jvalp1 = jval+1
    kvalp1 = kval+1

!--------------------------------------------------------------
!  if this is the start of a file, then do this stuff:

#ifdef NCFPLUS

!--- works with netcdf 4.2, but not 4.0 (grumble)
      call disp_err( nf90_create(string,IOR(nf90_netcdf4, nf90_classic_model),ncid) , .true. )
      IF(myid.eq.0) print *,' USING COMPRESSED netCDF4 '
#else
      ! must do this for netcdf 4.0 (it seems) !
      call disp_err( nf90_create(path=string,cmode=0,ncid=ncid) , .true. )
	  
#endif

!-----------------------------------------------------------------------
!  BEGIN

      !------------------
      ! define dims:

      call disp_err( nf90_def_dim(ncid,'ni',ival,niid) , .true. )
      call disp_err( nf90_def_dim(ncid,'nj',jval,njid) , .true. )
      call disp_err( nf90_def_dim(ncid,'nk',kval,nkid) , .true. )
      call disp_err( nf90_def_dim(ncid,'nip1',ivalp1,nip1id) , .true. )
      call disp_err( nf90_def_dim(ncid,'njp1',jvalp1,njp1id) , .true. )
      call disp_err( nf90_def_dim(ncid,'nkp1',kvalp1,nkp1id) , .true. )
      call disp_err( nf90_def_dim(ncid,'time',1,timeid) , .true. )
      call disp_err( nf90_def_dim(ncid,'nbudget',nbudget,nbudgetid) , .true. )
      call disp_err( nf90_def_dim(ncid,'numq',numq,numqid) , .true. )
    if( iprcl.eq.1 )then
      n = 3
      call disp_err( nf90_def_dim(ncid,'nploc',n,plocid) , .true. )
      n = max( 1 , nparcels )
      call disp_err( nf90_def_dim(ncid,'nparcels',n,nparcelsid) , .true. )
    endif

      !------------------
      ! define vars:

      call disp_err( nf90_def_var(ncid,"time",nf90_float,timeid,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","time since beginning of simulation") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","seconds since 2003-05-08 21:40:00") , .true. )

      call disp_err( nf90_def_var(ncid,"xh",nf90_float,niid,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","west-east location of scalar grid points") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

      call disp_err( nf90_def_var(ncid,"xf",nf90_float,nip1id,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","west-east location of staggered u grid points") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

      call disp_err( nf90_def_var(ncid,"yh",nf90_float,njid,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","south-north location of scalar grid points") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

      call disp_err( nf90_def_var(ncid,"yf",nf90_float,njp1id,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","south-north location of staggered v grid points") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

      call disp_err( nf90_def_var(ncid,"zh",nf90_float,nkid,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","nominal height of scalar grid points") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

      call disp_err( nf90_def_var(ncid,"zf",nf90_float,nkp1id,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","nominal height of staggered w grid points") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

  !------------------
  ! vars:

      call disp_err( nf90_def_var(ncid,"nstep"   ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"nrec"    ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"prec"    ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"nwrite"  ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"nrst"    ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"ndt"     ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"old_format",nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"npt"     ,nf90_int,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"numparcels",nf90_int,varid) , .true. )

      call disp_err( nf90_def_var(ncid,"dt"      ,nf90_float,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","timestep") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","s") , .true. )

      call disp_err( nf90_def_var(ncid,"dtlast"  ,nf90_float,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","previous timestep") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","s") , .true. )

      call disp_err( nf90_def_var(ncid,"cflmax"  ,nf90_float,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max Courant number from previous timestep") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )

      call disp_err( nf90_def_var(ncid,"mtime"   ,nf90_double,varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","model time (i.e., time since beginning of simulation)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","s") , .true. )

      call disp_err( nf90_def_var(ncid,"stattim" ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"taptim"  ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"rsttim"  ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"radtim"  ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"prcltim" ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"adt"     ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"acfl"    ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"dbldt"   ,nf90_double,varid) , .true. )
      call disp_err( nf90_def_var(ncid,"mass1"   ,nf90_double,varid) , .true. )

      call disp_err( nf90_def_var(ncid,"qbudget" ,nf90_double,(/nbudgetid/),varid) , .true. )
      call disp_err( nf90_def_var(ncid,"asq"     ,nf90_double,(/numqid/),varid) , .true. )
      call disp_err( nf90_def_var(ncid,"bsq"     ,nf90_double,(/numqid/),varid) , .true. )

  !------------------
  ! 2d/3d vars:

      call disp_err( nf90_def_var(ncid,"rain"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","accumulated surface rainfall") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","cm") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sws"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max windspeed at lowest level") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"svs"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max vert vorticity at lowest level") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","s^(-1)") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sps"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","min pressure at lowest level") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","Pa") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"srs"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max surface rainwater") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sgs"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max surface graupel/hail") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sus"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max w at 5 km AGL") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"shs"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max integrated updraft helicity") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m2/s2") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

    if( nrain.eq.2 )then

      call disp_err( nf90_def_var(ncid,"rain2"   ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","accumulated surface rainfall (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","cm") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sws2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max windspeed at lowest level (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"svs2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max vert vorticity at lowest level (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","s^(-1)") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sps2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","min pressure at lowest level (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","Pa") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"srs2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max surface rainwater (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sgs2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max surface graupel/hail (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"sus2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max w at 5 km AGL (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"shs2"    ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","max integrated updraft helicity (translated)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m2/s2") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

    endif

      call disp_err( nf90_def_var(ncid,"tsk"     ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","soil/ocean temperature") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","K") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

! 3D VARS

      call disp_err( nf90_def_var(ncid,"rho"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","dry-air density") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/m^3") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"prs"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","pressure") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","Pa") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"ua"      ,nf90_float,(/nip1id,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","west-east velocity (at u points)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"va"      ,nf90_float,(/niid,njp1id,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","south-north velocity (at v points)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"wa"      ,nf90_float,(/niid,njid,nkp1id/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","vertical velocity (at w points)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"ppi"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","perturbation non-dimensional pressure") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"tha"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","perturbation potential temperature") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","K") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"ppx"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","change in nondimensional pressure used for forward-time-weighting on small steps") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

    IF( imoist.eq.1 )THEN
      do n=1,numq
        text1 = '        '
        write(text1(1:3),156) qname(n)
156     format(a3)
        call disp_err( nf90_def_var(ncid,text1     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
        if( n.eq.nqv )then
          call disp_err( nf90_put_att(ncid,varid,"long_name","water vapor mixing ratio") , .true. )
          call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
        elseif(idm.eq.1.and.n.ge.nnc1.and.n.le.nnc2)then
          call disp_err( nf90_put_att(ncid,varid,"long_name","number concentration") , .true. )
          call disp_err( nf90_put_att(ncid,varid,"units","kg^{-1}") , .true. )
        elseif(idm .eq. 1 .and. n.ge.nzl1 .and. n .le. nzl2)then
          call disp_err( nf90_put_att(ncid,varid,"long_name","reflectivity moment") , .true. )
          call disp_err( nf90_put_att(ncid,varid,"units","Z m^{-3}kg^{-1}") , .true. )
        elseif(idm .eq. 1 .and. n.ge.nvl1 .and. n .le. nvl2)then
          call disp_err( nf90_put_att(ncid,varid,"long_name","particle volume") , .true. )
          call disp_err( nf90_put_att(ncid,varid,"units","m^{3}kg^{-1}") , .true. )
        else
          call disp_err( nf90_put_att(ncid,varid,"long_name","mixing ratio") , .true. )
          call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
        endif
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      enddo
    ENDIF
    if(imoist.eq.1.and.eqtset.eq.2)then
      call disp_err( nf90_def_var(ncid,"qpten"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","ppi tendency from microphysics on previous timestep (related to h_diabatic in WRF)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","s^(-1)") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      !---
      call disp_err( nf90_def_var(ncid,"qtten"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","theta tendency from microphysics on previous timestep (related to h_diabatic in WRF)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","K/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      !---
      call disp_err( nf90_def_var(ncid,"qvten"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","qv tendency from microphysics on previous timestep (related to qv_diabatic in WRF)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      !---
      call disp_err( nf90_def_var(ncid,"qcten"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","qc tendency from microphysics on previous timestep (related to qc_diabatic in WRF)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    endif
    if(iturb.eq.1)then
      call disp_err( nf90_def_var(ncid,"tkea"    ,nf90_float,(/niid,njid,nkp1id/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","subgrid turbulence kinetic energy") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m^2/s^2") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    endif

    if( radopt.eq.1 )then

      call disp_err( nf90_def_var(ncid,"lwten"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"swten"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"radsw"   ,nf90_float,(/niid,njid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"rnflx"   ,nf90_float,(/niid,njid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
#ifdef NCFPLUS
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
      call disp_err( nf90_def_var(ncid,"radswnet",nf90_float,(/niid,njid/),varid) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"radlwin" ,nf90_float,(/niid,njid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      do n=1,nrad2d
        if( n.lt.10 )then
          text1 = 'radX    '
          write(text1(4:4),181) n
181       format(i1.1)
        elseif( n.lt.100 )then
          text1 = 'radXX   '
          write(text1(4:5),182) n
182       format(i2.2)
        elseif( n.lt.1000 )then
          text1 = 'radXXX  '
          write(text1(4:6),183) n
183       format(i3.3)
        else
          stop 11611
        endif
        call disp_err( nf90_def_var(ncid,text1     ,nf90_float,(/niid,njid/),varid) , .true. )
      enddo
     endif

    if( radopt.ge.1 .and. ptype.eq.5 )then

      call disp_err( nf90_def_var(ncid,"effc"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"effi"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"effs"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"effr"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"effg"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

      call disp_err( nf90_def_var(ncid,"effis"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif

    endif

    if((oceanmodel.eq.2).or.(ipbl.eq.1).or.(sfcmodel.ge.1))then
      if(sfcmodel.ge.1)then
        call disp_err( nf90_def_var(ncid,"ust"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","friction velocity") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"znt"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","roughness length") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )

        call disp_err( nf90_def_var(ncid,"cd"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","surface drag coefficient") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )

        call disp_err( nf90_def_var(ncid,"ch"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","surface exchange coefficient for sensible heat") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )

        call disp_err( nf90_def_var(ncid,"cq"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","surface exchange coefficient for moisture") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )

        call disp_err( nf90_def_var(ncid,"u1"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","u component of velocity at lowest model level") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"v1"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","v component of velocity at lowest model level") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"s1"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","horizontal windspeed at lowest model level") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"u10"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","u component of windspeed at z=10 m") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"v10"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","v component of windspeed at z=10 m") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"s10"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","horizontal windspeed at z=10 m") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )

        call disp_err( nf90_def_var(ncid,"xland"   ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","land/water flag (1=land,2=water)") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","integer flag") , .true. )

        call disp_err( nf90_def_var(ncid,"thflux"  ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","surface potential temperature flux") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","K m s^{-1}") , .true. )

        call disp_err( nf90_def_var(ncid,"qvflux"  ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","surface water vapor flux") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","kg kg^{-1} m s^{-1}") , .true. )

        call disp_err( nf90_def_var(ncid,"psfc"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","surface pressure") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","Pa") , .true. )
      endif
      if(sfcmodel.eq.2.or.sfcmodel.eq.3)then
        call disp_err( nf90_def_var(ncid,"lu_index",nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"kpbl2d"  ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"hfx"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"qfx"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"hpbl"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"wspd"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"psim"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"psih"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"gz1oz0"  ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"br"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"chs"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"chs2"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"cqs2"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"cpmm"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"zol"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"mavail"  ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"mol"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"rmol"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"regime"  ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"lh"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"tmn"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"flhc"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"flqc"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"qgh"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"ck"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"cka"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"cda"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"ustm"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"qsfc"    ,nf90_float,(/niid,njid/),varid) , .true. )

        call disp_err( nf90_def_var(ncid,"t2"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","temperature at z=2m") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","K") , .true. )

        call disp_err( nf90_def_var(ncid,"q2"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","water vapor mixing ratio at z=2m") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )

        call disp_err( nf90_def_var(ncid,"th2"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","potential temperature at z=2m") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","K") , .true. )

        call disp_err( nf90_def_var(ncid,"emiss"   ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"thc"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"albd"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"gsw"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"glw"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"chklowq" ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"capg"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"snowc"   ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"fm"      ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"fh"      ,nf90_float,(/niid,njid/),varid) , .true. )
        do n=1,num_soil_layers
          if( n.lt.10 )then
            text1 = 'tslbX   '
            write(text1(5:5),171) n
171         format(i1.1)
          elseif( n.lt.100 )then
            text1 = 'tslbXX  '
            write(text1(5:6),172) n
172         format(i2.2)
          else
            stop 22122
          endif
          call disp_err( nf90_def_var(ncid,text1     ,nf90_float,(/niid,njid/),varid) , .true. )
        enddo
      endif
      if(oceanmodel.eq.2)then
        call disp_err( nf90_def_var(ncid,"tml"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"t0ml"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"hml"     ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"h0ml"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"huml"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"hvml"    ,nf90_float,(/niid,njid/),varid) , .true. )
        call disp_err( nf90_def_var(ncid,"tmoml"   ,nf90_float,(/niid,njid/),varid) , .true. )
      endif
    endif

    if( iptra.eq.1 )then
      do n=1,npt
        if( n.le.9 )then
          text1 = 'ptX     '
          write(text1(3:3),161) n
161       format(i1.1)
        elseif( n.lt.100 )then
          text1 = 'ptXX    '
          write(text1(3:4),162) n
162       format(i2.2)
        else
          stop 11511
        endif
        call disp_err( nf90_def_var(ncid,text1,nf90_float,(/niid,njid,nkid/),varid) , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      enddo
    endif

    if( iprcl.eq.1 )then
      call disp_err( nf90_def_var(ncid,"ploc"    ,nf90_float,(/plocid,nparcelsid/),varid) , .true. )
    endif

    if(irbc.eq.4)then
      if( wbc.eq.2 )then
        call disp_err( nf90_def_var(ncid,"radbcw"  ,nf90_float,(/njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","estimated gravity wave phase speed on west boundary") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/ny,nz/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( ebc.eq.2 )then
        call disp_err( nf90_def_var(ncid,"radbce"  ,nf90_float,(/njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","estimated gravity wave phase speed on east boundary") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/ny,nz/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( sbc.eq.2 )then
        call disp_err( nf90_def_var(ncid,"radbcs"  ,nf90_float,(/niid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","estimated gravity wave phase speed on south boundary") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/nx,nz/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( nbc.eq.2 )then
        call disp_err( nf90_def_var(ncid,"radbcn"  ,nf90_float,(/niid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","estimated gravity wave phase speed on north boundary") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/nx,nz/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
    endif

  !------------------
  ! 150820:  optionals

    !-----
    IF( restart_file_theta )THEN
      call disp_err( nf90_def_var(ncid,"theta"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","potential temperature") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","K") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_dbz )THEN
      call disp_err( nf90_def_var(ncid,"dbz"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","reflectivity") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","dBZ") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    !-----
    IF( restart_file_th0 )THEN
      call disp_err( nf90_def_var(ncid,"th0"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state potential temperature") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","K") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_prs0 )THEN
      call disp_err( nf90_def_var(ncid,"prs0"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state pressure") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","Pa") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_pi0 )THEN
      call disp_err( nf90_def_var(ncid,"pi0"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state nondimensional pressure") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","nondimensional") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_rho0 )THEN
      call disp_err( nf90_def_var(ncid,"rho0"    ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state dry-air density") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/m^3") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_qv0 )THEN
      call disp_err( nf90_def_var(ncid,"qv0"     ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state water vapor mixing ratio") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","kg/kg") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_u0 )THEN
      call disp_err( nf90_def_var(ncid,"u0"      ,nf90_float,(/nip1id,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state x-component velocity") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkxp1,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_v0 )THEN
      call disp_err( nf90_def_var(ncid,"v0"      ,nf90_float,(/niid,njp1id,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","base-state y-component velocity") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chkyp1,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    !-----
    IF( restart_file_zs )THEN
      call disp_err( nf90_def_var(ncid,"zs"      ,nf90_float,(/niid,njid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","terrain height") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_zh )THEN
      call disp_err( nf90_def_var(ncid,"zhalf"   ,nf90_float,(/niid,njid,nkid/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","height of half (scalar) grid points (3d array)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
    IF( restart_file_zf )THEN
      call disp_err( nf90_def_var(ncid,"zfull"   ,nf90_float,(/niid,njid,nkp1id/),varid) , .true. )
      call disp_err( nf90_put_att(ncid,varid,"long_name","height of full (w) grid points (3d array)") , .true. )
      call disp_err( nf90_put_att(ncid,varid,"units","m") , .true. )
#ifdef NCFPLUS
      call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
      call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
    ENDIF
	
!-----
    IF( restart_file_diags )THEN
      if( td_diss.gt.0 )then
        call disp_err( nf90_def_var(ncid,"dissheat",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","dissipative heating (potential temperature tendency)") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","K/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( td_mptend.gt.0 )then
        call disp_err( nf90_def_var(ncid,"mptend",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","potential temperature tendency from microphysics scheme") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","K/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( qd_vtc.gt.0 )then
        call disp_err( nf90_def_var(ncid,"vtc",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qc") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( qd_vtr.gt.0 )then
        call disp_err( nf90_def_var(ncid,"vtr",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qr") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( qd_vts.gt.0 )then
        call disp_err( nf90_def_var(ncid,"vts",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qs") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( qd_vtg.gt.0 )then
        call disp_err( nf90_def_var(ncid,"vtg",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qg") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
      if( qd_vti.gt.0 )then
        call disp_err( nf90_def_var(ncid,"vti",nf90_float,(/niid,njid,nkid/),varid) , .true. )
        call disp_err( nf90_put_att(ncid,varid,"long_name","terminal fall velocity of qi") , .true. )
        call disp_err( nf90_put_att(ncid,varid,"units","m/s") , .true. )
#ifdef NCFPLUS
        call disp_err( NF90_DEF_VAR_CHUNKING(ncid,varid,NF90_CHUNKED,(/chkx,chky,1/)) , .true. )
        call disp_err( nf90_def_var_deflate(ncid,varid,shuffle,deflate,deflate_level) , .true. )
#endif
      endif
    ENDIF
    !-----

  !------------------
  ! end definitions:

  call disp_err( nf90_enddef(ncid) , .true. )

  !---------------------------------------------
  !ccccccccccccccccccccccccccccccccccccccccccccc
  !---------------------------------------------


      status = nf90_inq_varid(ncid,'xh',varid)
      do i=1,nx
        dumx(i) = 0.5*(xfref(i)+xfref(i+1))
      enddo
      status = nf90_put_var(ncid,varid,dumx,(/1/),(/nx/))


      status = nf90_inq_varid(ncid,'xf',varid)
      do i=1,nx+1
        dumx(i) = xfref(i)
      enddo
      status = nf90_put_var(ncid,varid,dumx,(/1/),(/nx+1/))


      status = nf90_inq_varid(ncid,'yh',varid)
      do j=1,ny
        dumy(j) = 0.5*(yfref(j)+yfref(j+1))
      enddo
      status = nf90_put_var(ncid,varid,dumy,(/1/),(/ny/))


      status = nf90_inq_varid(ncid,'yf',varid)
      do j=1,ny+1
        dumy(j) = yfref(j)
      enddo
      status = nf90_put_var(ncid,varid,dumy,(/1/),(/ny+1/))


      status = nf90_inq_varid(ncid,'zh',varid)
      if(terrain_flag)then
        do k=1,kval
          dumz(k) = sigma(k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kval/))
      else
        do k=1,kval
          dumz(k) = zh(1,1,k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kval/))
      endif


      status = nf90_inq_varid(ncid,'zf',varid)
      if(terrain_flag)then
        do k=1,kvalp1
          dumz(k) = sigmaf(k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kvalp1/))
      else
        do k=1,kvalp1
          dumz(k) = zf(1,1,k)
        enddo
        status = nf90_put_var(ncid,varid,dumz,(/1/),(/kvalp1/))
      endif


!  END
!-----------------------------------------------------------------------

      call disp_err( nf90_inq_varid(ncid,'time',varid) , .true. )
      call disp_err( nf90_put_var(ncid,varid,actual_time,(/time_index/)) , .true. )

      print *,'  leaving restart_prelim '

    return
    end subroutine restart_prelim


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine checkstatus(status)
      use netcdf
      implicit none

      integer :: status

      if(status.ne.nf90_noerr)then
        print *,'  Error ... '
        print *,nf90_strerror(status)
        call stopcm1
      endif

      return
      end subroutine checkstatus

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine write2d_nc(chid,ncid,time_index,ni,nj,d2d)
      use netcdf
      implicit none

      character*8, intent(in) :: chid
      integer, intent(in) :: ncid,time_index,ni,nj
      real, dimension(ni,nj), intent(in) :: d2d

      integer :: varid,status

!----------------------------------

      status = nf90_inq_varid(ncid,chid,varid)
      if(status.ne.nf90_noerr)then
        print *,'  Error1 in write2d_nc, chid = ',chid
        print *,nf90_strerror(status)
        call stopcm1
      endif

      status = nf90_put_var(ncid,varid,d2d,(/1,1,time_index/),(/ni,nj,1/))
      if(status.ne.nf90_noerr)then
        print *,'  Error2 in write2d_nc, chid = ',chid
        print *,nf90_strerror(status)
        call stopcm1
      endif

!----------------------------------

      return
      end subroutine write2d_nc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine write3d_nc(chid,k,ncid,time_index,ni,nj,ds)
      use netcdf
      implicit none

      character*8, intent(in) :: chid
      integer, intent(in) :: k,ncid,time_index,ni,nj
      real, dimension(ni,nj), intent(in) :: ds

      integer :: varid,status

!----------------------------------

      status = nf90_inq_varid(ncid,chid,varid)
      if(status.ne.nf90_noerr)then
        print *,'  Error1 in write3d_nc, chid = ',chid
        print *,'  status = ',status
        print *,nf90_strerror(status)
        call stopcm1
      endif

      status = nf90_put_var(ncid,varid,ds,(/1,1,k,time_index/),(/ni,nj,1,1/))
      if(status.ne.nf90_noerr)then
        print *,'  Error2 in write3d_nc, chid = ',chid
        print *,'  status = ',status
        print *,nf90_strerror(status)
        call stopcm1
      endif

!----------------------------------

      return
      end subroutine write3d_nc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine writestat_nc(nrec,rtime,nstat,rstat,qname,budname)
      use netcdf
      implicit none

      include 'input.incl'

      integer, intent(inout) :: nrec
      real,    intent(in)    :: rtime
      integer, intent(in)    :: nstat
      real, dimension(stat_out), intent(in) :: rstat
      character*3, dimension(maxq), intent(in) :: qname
      character*6, dimension(maxq), intent(in) :: budname

      integer :: n,ncid,status,dimid,varid,time_index,timeid,tfile
      integer :: xhid,yhid,zhid
      character*8  :: text1
      character*30 :: text2
      logical :: allinfo

    string(totlen+1:totlen+22) = '_stats.nc             '

    print *,string

    allinfo = .false.
    IF(nrec.eq.1) allinfo=.true.

    IF( nrec.ne.1 )THEN
      ! cm1r18:  Try to open file.
      !          If error, set nrec to 1 and write all info.
      status = nf90_open(string,nf90_write,ncid)
      if( status.eq.nf90_noerr )then
        ! no error, file exists.  Get number of time levels in file:
        call disp_err( nf90_inq_dimid(ncid,'time',timeid) , .true. )
        call disp_err( nf90_inquire_dimension(ncid=ncid,dimid=timeid,len=tfile), .true. )
        if( (tfile+1).lt.nrec )then
          if(myid.eq.0) print *,'  tfile,nrec = ',tfile,nrec
          nrec = tfile+1
        endif
      else
        ! if error opening file, then write all info:
        if(myid.eq.0) print *,'  status = ',status
!!!        if(myid.eq.0) print *,nf90_strerror(status)
        allinfo = .true.
        nrec = 1
      endif
    ENDIF

    if( myid.eq.0 ) print *,'  nrec = ',nrec


  allinfo2:  IF( allinfo )THEN
    ! Definitions/descriptions:

      if( myid.eq.0 ) print *,'  calling nf90_create '
#ifdef NCFPLUS
!--- works with netcdf 4.2, but not 4.0 (grumble)
      call disp_err( nf90_create(string,IOR(nf90_netcdf4, nf90_classic_model),ncid) , .true. )
#else
      ! must do this for netcdf 4.0 (it seems) !
      call disp_err( nf90_create(path=string,cmode=0,ncid=ncid) , .true. )
#endif

    status = nf90_def_dim(ncid,"xh",1,xhid)
    status = nf90_def_dim(ncid,"yh",1,yhid)
    status = nf90_def_dim(ncid,"zh",1,zhid)
    status = nf90_def_dim(ncid,"time",nf90_unlimited,timeid)

    status = nf90_def_var(ncid,"xh",nf90_float,(/xhid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","west-east location")
    status = nf90_put_att(ncid,varid,"units","degree_east")

    status = nf90_def_var(ncid,"yh",nf90_float,(/yhid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","south-north location")
    status = nf90_put_att(ncid,varid,"units","degree_north")

    status = nf90_def_var(ncid,"zh",nf90_float,(/zhid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","height")
    status = nf90_put_att(ncid,varid,"units","m")

    status = nf90_def_var(ncid,"time",nf90_float,(/timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","time")
    status = nf90_put_att(ncid,varid,"units","seconds")

    IF(adapt_dt.eq.1)THEN
      status = nf90_def_var(ncid,"dt",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","average timestep dt           ")
      status = nf90_put_att(ncid,varid,"units","seconds")
    ENDIF
    IF(stat_w.eq.1)THEN
      status = nf90_def_var(ncid,"wmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","maximum vertical velocity     ")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"wmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","minimum vertical velocity     ")
      status = nf90_put_att(ncid,varid,"units","m/s")
    ENDIF
    IF(stat_u.eq.1)THEN
      status = nf90_def_var(ncid,"umax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max E-W velocity              ")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"umin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min E-W velocity              ")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"sumax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max E-W velocity at lowest lvl")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"sumin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min E-W velocity at lowest lvl")
      status = nf90_put_att(ncid,varid,"units","m/s")
    ENDIF
    IF(stat_v.eq.1)THEN
      status = nf90_def_var(ncid,"vmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max N-S velocity              ")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"vmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min N-S velocity              ")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"svmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max N-S velocity at lowest lvl")
      status = nf90_put_att(ncid,varid,"units","m/s")
      status = nf90_def_var(ncid,"svmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min N-S velocity at lowest lvl")
      status = nf90_put_att(ncid,varid,"units","m/s")
    ENDIF
    IF(stat_rmw.eq.1)THEN
      status = nf90_def_var(ncid,"rmw",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","radius of maximum windspeed")
      status = nf90_put_att(ncid,varid,"units","m")
      status = nf90_def_var(ncid,"zmw",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","height (ASL) of maximum windspeed")
      status = nf90_put_att(ncid,varid,"units","m")
    ENDIF
    IF(stat_pipert.eq.1)THEN
      status = nf90_def_var(ncid,"ppimax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max pi pert.                  ")
      status = nf90_put_att(ncid,varid,"units","nondimensional")
      status = nf90_def_var(ncid,"ppimin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min pi pert.                  ")
      status = nf90_put_att(ncid,varid,"units","nondimensional")
    ENDIF
    IF(stat_prspert.eq.1)THEN
      status = nf90_def_var(ncid,"ppmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max pressure pert.            ")
      status = nf90_put_att(ncid,varid,"units","Pa")
      status = nf90_def_var(ncid,"ppmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min pressure pert.            ")
      status = nf90_put_att(ncid,varid,"units","Pa")
    ENDIF
    IF(stat_thpert.eq.1)THEN
      status = nf90_def_var(ncid,"thpmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max potential temp. pert.     ")
      status = nf90_put_att(ncid,varid,"units","K")
      status = nf90_def_var(ncid,"thpmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min potential temp. pert.     ")
      status = nf90_put_att(ncid,varid,"units","K")
      status = nf90_def_var(ncid,"sthpmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max pot temp pert lowest level")
      status = nf90_put_att(ncid,varid,"units","K")
      status = nf90_def_var(ncid,"sthpmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min pot temp pert lowest level")
      status = nf90_put_att(ncid,varid,"units","K")
    ENDIF
    IF(stat_q.eq.1)THEN
      do n=1,numq
        text1='max     '
        text2='max                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
156     format(a3)
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
        status = nf90_put_att(ncid,varid,"units","kg/kg")
        text1='min     '
        text2='min                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
        status = nf90_put_att(ncid,varid,"units","kg/kg")
      enddo
    ENDIF
    IF(stat_tke.eq.1)THEN
      status = nf90_def_var(ncid,"tkemax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max tke                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s^2")
      status = nf90_def_var(ncid,"tkemin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min tke                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s^2")
    ENDIF
    IF(stat_km.eq.1)THEN
      status = nf90_def_var(ncid,"kmhmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max kmh                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
      status = nf90_def_var(ncid,"kmhmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min kmh                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
      status = nf90_def_var(ncid,"kmvmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max kmv                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
      status = nf90_def_var(ncid,"kmvmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min kmv                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
    ENDIF
    IF(stat_kh.eq.1)THEN
      status = nf90_def_var(ncid,"khhmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max khh                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
      status = nf90_def_var(ncid,"khhmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min khh                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
      status = nf90_def_var(ncid,"khvmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max khv                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
      status = nf90_def_var(ncid,"khvmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min khv                       ")
      status = nf90_put_att(ncid,varid,"units","m^2/s")
    ENDIF
    IF(stat_div.eq.1)THEN
      status = nf90_def_var(ncid,"divmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max 3d divergence             ")
      status = nf90_def_var(ncid,"divmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min 3d divergence             ")
    ENDIF
    IF(stat_rh.eq.1)THEN
      status = nf90_def_var(ncid,"rhmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max relative humidity         ")
      status = nf90_def_var(ncid,"rhmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min relative humidity         ")
    ENDIF
    IF(stat_rhi.eq.1)THEN
      status = nf90_def_var(ncid,"rhimax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max relative humidity wrt ice ")
      status = nf90_def_var(ncid,"rhimin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min relative humidity wrt ice ")
    ENDIF
    IF(iptra.eq.1)then
      do n=1,npt
        text1='maxpt   '
        text2='max pt                        '
        if( n.le.9 )then
          write(text1(6:6),157) n
          write(text2(7:7),157) n
157       format(i1)
        else
          write(text1(6:7),167) n
          write(text2(7:8),167) n
167       format(i2)
        endif
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
        text1='minpt   '
        text2='min pt                        '
        if( n.le.9 )then
          write(text1(6:6),157) n
          write(text2(7:7),157) n
        else
          write(text1(6:7),167) n
          write(text2(7:8),167) n
        endif
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
      enddo
    endif
    IF(stat_the.eq.1)THEN
      status = nf90_def_var(ncid,"themax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max theta-e below 10 km       ")
      status = nf90_put_att(ncid,varid,"units","K")
      status = nf90_def_var(ncid,"themin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min theta-e below 10 km       ")
      status = nf90_put_att(ncid,varid,"units","K")
      status = nf90_def_var(ncid,"sthemax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max theta-e at lowest level   ")
      status = nf90_put_att(ncid,varid,"units","K")
      status = nf90_def_var(ncid,"sthemin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min theta-e at lowest level   ")
      status = nf90_put_att(ncid,varid,"units","K")
    ENDIF
    IF(stat_cloud.eq.1)THEN
      status = nf90_def_var(ncid,"qctop",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max cloud top height          ")
      status = nf90_put_att(ncid,varid,"units","m")
      status = nf90_def_var(ncid,"qcbot",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min cloud base height         ")
      status = nf90_put_att(ncid,varid,"units","m")
    ENDIF
    IF(stat_sfcprs.eq.1)THEN
      status = nf90_def_var(ncid,"sprsmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max pressure at lowest level  ")
      status = nf90_put_att(ncid,varid,"units","Pa")
      status = nf90_def_var(ncid,"sprsmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min pressure at lowest level  ")
      status = nf90_put_att(ncid,varid,"units","Pa")
      status = nf90_def_var(ncid,"psfcmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max surface pressure")
      status = nf90_put_att(ncid,varid,"units","Pa")
      status = nf90_def_var(ncid,"psfcmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min surface pressure")
      status = nf90_put_att(ncid,varid,"units","Pa")
    ENDIF
    IF(stat_wsp.eq.1)THEN
      status = nf90_def_var(ncid,"wspmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max wind speed                ")
      status = nf90_put_att(ncid,varid,"units","m/s")

      status = nf90_def_var(ncid,"wspmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min wind speed                ")
      status = nf90_put_att(ncid,varid,"units","m/s")

      status = nf90_def_var(ncid,"swspmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max wind speed at lowest level")
      status = nf90_put_att(ncid,varid,"units","m/s")

      status = nf90_def_var(ncid,"swspmin",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min wind speed at lowest level")
      status = nf90_put_att(ncid,varid,"units","m/s")

    IF(bbc.eq.3)THEN
      status = nf90_def_var(ncid,"wsp10max",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max 10 m wind speed           ")
      status = nf90_put_att(ncid,varid,"units","m/s")

      status = nf90_def_var(ncid,"wsp10min",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","min 10 m wind speed           ")
      status = nf90_put_att(ncid,varid,"units","m/s")
    ENDIF
    ENDIF
    IF(stat_cfl.eq.1)THEN
    IF(adapt_dt.eq.1)THEN
      status = nf90_def_var(ncid,"cflmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max Courant number (average)  ")
      status = nf90_put_att(ncid,varid,"units","nondimensional")
    ELSE
      status = nf90_def_var(ncid,"cflmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max Courant number            ")
      status = nf90_put_att(ncid,varid,"units","nondimensional")
    ENDIF
      status = nf90_def_var(ncid,"kshmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max horiz K stability factor  ")
      status = nf90_put_att(ncid,varid,"units","nondimensional")
      status = nf90_def_var(ncid,"ksvmax",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert K stability factor   ")
      status = nf90_put_att(ncid,varid,"units","nondimensional")
    ENDIF
    IF(stat_vort.eq.1)THEN
      status = nf90_def_var(ncid,"vortsfc",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert. vort. at lowest lvl ")
      status = nf90_put_att(ncid,varid,"units","1/s")
      status = nf90_def_var(ncid,"vort1km",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert. vort. at z = 1 km   ")
      status = nf90_put_att(ncid,varid,"units","1/s")
      status = nf90_def_var(ncid,"vort2km",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert. vort. at z = 2 km   ")
      status = nf90_put_att(ncid,varid,"units","1/s")
      status = nf90_def_var(ncid,"vort3km",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert. vort. at z = 3 km   ")
      status = nf90_put_att(ncid,varid,"units","1/s")
      status = nf90_def_var(ncid,"vort4km",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert. vort. at z = 4 km   ")
      status = nf90_put_att(ncid,varid,"units","1/s")
      status = nf90_def_var(ncid,"vort5km",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","max vert. vort. at z = 5 km   ")
      status = nf90_put_att(ncid,varid,"units","1/s")
    ENDIF
    IF(stat_tmass.eq.1)THEN
      status = nf90_def_var(ncid,"tmass",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total mass of (dry) air       ")
      status = nf90_put_att(ncid,varid,"units","kg")
    ENDIF
    IF(stat_tmois.eq.1)THEN
      status = nf90_def_var(ncid,"tmois",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total moisture                ")
      status = nf90_put_att(ncid,varid,"units","kg")
    ENDIF
    IF(stat_qmass.eq.1)THEN
      do n=1,numq
        IF( (n.eq.nqv) .or.                                 &
            (n.ge.nql1.and.n.le.nql2) .or.                  &
            (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
          text1='mass    '
          text2='total mass of                 '
          write(text1( 5: 7),156) qname(n)
          write(text2(15:17),156) qname(n)
          status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
          status = nf90_put_att(ncid,varid,"long_name",text2)
          status = nf90_put_att(ncid,varid,"units","kg")
        ENDIF
      enddo
    ENDIF
    IF(stat_tenerg.eq.1)THEN
      status = nf90_def_var(ncid,"ek",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total kinetic energy          ")
      status = nf90_def_var(ncid,"ei",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total internal energy         ")
      status = nf90_def_var(ncid,"ep",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total potential energy        ")
      status = nf90_def_var(ncid,"le",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total latent energy           ")
      status = nf90_def_var(ncid,"et",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total energy                  ")
    ENDIF
    IF(stat_mo.eq.1)THEN
      status = nf90_def_var(ncid,"tmu",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total E-W momentum            ")
      status = nf90_def_var(ncid,"tmv",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total N-S momentum            ")
      status = nf90_def_var(ncid,"tmw",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total vertical momentum       ")
    ENDIF
    IF(stat_tmf.eq.1)THEN
      status = nf90_def_var(ncid,"tmfu",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total upward mass flux        ")
      status = nf90_def_var(ncid,"tmfd",nf90_float,timeid,varid)
      status = nf90_put_att(ncid,varid,"long_name","total downward mass flux      ")
    ENDIF
    IF(stat_pcn.eq.1)THEN
      do n=1,nbudget
        text1='        '
        text2='                              '
        write(text1(1:6),158) budname(n)
        write(text2(1:6),158) budname(n)
158     format(a6)
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
      enddo
    ENDIF
    IF(stat_qsrc.eq.1)THEN
      do n=1,numq
        text1='as      '
        text2='artificial source of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
      enddo
      do n=1,numq
        text1='bs      '
        text2='bndry source/sink of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        status = nf90_def_var(ncid,text1,nf90_float,timeid,varid)
        status = nf90_put_att(ncid,varid,"long_name",text2)
      enddo
    ENDIF

    status = nf90_put_att(ncid, NF90_GLOBAL, 'Conventions','COARDS')

    status = nf90_enddef(ncid)

    status = nf90_put_var(ncid,1,0.0)
    status = nf90_put_var(ncid,2,0.0)
    status = nf90_put_var(ncid,3,0.0)

  ELSE

    ! open file:

    call disp_err( nf90_open(string,nf90_write,ncid), .true. )

  ENDIF  allinfo2

    ! Write data:

    time_index = nrec

    call disp_err( nf90_inq_varid(ncid,'time',timeid) , .true. )
    call disp_err( nf90_put_var(ncid,timeid,rtime,(/time_index/)) , .true. )

    DO n=1,nstat
      varid = timeid + n
      status = nf90_put_var(ncid,varid,rstat(n),(/time_index/))
    ENDDO

    ! close file

    call disp_err( nf90_close(ncid) , .true. )

    nrec = nrec + 1

    ! all done

      return
      end subroutine writestat_nc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine disp_err( status , stop_on_error )
      use netcdf
      implicit none

      integer, intent(in) :: status
      logical, intent(in) :: stop_on_error

      IF( status.ne.nf90_noerr )THEN
        IF( stop_on_error )THEN
          print *,'  netcdf status returned an error: ', status,' ... stopping program'
          print *
          print *,nf90_strerror(status)
          print *
          call stopcm1
        ENDIF
      ENDIF

      return
      end subroutine disp_err

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine writepdata_nc(prec,rtime,qname,pdata,pdata2)
      use netcdf
      implicit none

      include 'input.incl'

      integer, intent(inout) :: prec
      real, intent(in) :: rtime
      character*3, intent(in), dimension(maxq) :: qname
      real, intent(in), dimension(npvals,nparcels) :: pdata
      real, intent(inout), dimension(nparcels) :: pdata2

      integer :: ncid,status,dimid,varid,time_index,n,n2,np,timeid,tfile,xid
      integer :: npid,yhid,zhid
      character*8 text1
      character*30 text2
      logical :: allinfo

!-----------------------------------------------------------------------

    string(totlen+1:totlen+22) = '_pdata.nc             '

    allinfo = .false.
    IF(prec.eq.1) allinfo=.true.

    IF( prec.ne.1 )THEN
      ! cm1r18:  Try to open file.
      !          If error, set prec to 1 and write all info.
      status = nf90_open(string,nf90_write,ncid)
      if( status.eq.nf90_noerr )then
        ! no error, file exists.  Get number of time levels in file:
        call disp_err( nf90_inq_dimid(ncid,'time',timeid) , .true. )
        call disp_err( nf90_inquire_dimension(ncid=ncid,dimid=timeid,len=tfile), .true. )
        if( (tfile+1).lt.prec )then
          if(myid.eq.0) print *,'  tfile,prec = ',tfile,prec
          prec = tfile+1
        endif
      else
        ! if error opening file, then write all info:
        if(myid.eq.0) print *,'  status = ',status
!!!        if(myid.eq.0) print *,nf90_strerror(status)
        allinfo = .true.
        prec = 1
      endif
    ENDIF

    if( myid.eq.0 ) print *,'  pdata prec = ',prec


  allinfo3:  IF( allinfo )THEN
    ! Definitions/descriptions:

#ifdef NCFPLUS
!--- works with netcdf 4.2, but not 4.0 (grumble)
      call disp_err( nf90_create('cm1out_pdata.nc',IOR(nf90_netcdf4, nf90_classic_model),ncid) , .true. )
#else
      ! must do this for netcdf 4.0 (it seems) !
      call disp_err( nf90_create(path='cm1out_pdata.nc',cmode=0,ncid=ncid) , .true. )
#endif

    status = nf90_def_dim(ncid,"xh",nparcels,npid)
    status = nf90_def_dim(ncid,"yh",1,yhid)
    status = nf90_def_dim(ncid,"zh",1,zhid)
    status = nf90_def_dim(ncid,"time",nf90_unlimited,timeid)

    status = nf90_def_var(ncid,"xh",nf90_float,(/npid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","west-east location ... actually, really parcel ID number")
    status = nf90_put_att(ncid,varid,"units","degree_east")

    status = nf90_def_var(ncid,"yh",nf90_float,(/yhid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","south-north location")
    status = nf90_put_att(ncid,varid,"units","degree_north")

    status = nf90_def_var(ncid,"zh",nf90_float,(/zhid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","height")
    status = nf90_put_att(ncid,varid,"units","m")

    status = nf90_def_var(ncid,"time",nf90_float,(/timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","time")
    status = nf90_put_att(ncid,varid,"units","seconds")

!------------------------

    status = nf90_def_var(ncid,"x",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","x                             ")
    status = nf90_put_att(ncid,varid,"units","m")

    status = nf90_def_var(ncid,"y",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","y                             ")
    status = nf90_put_att(ncid,varid,"units","m")

    status = nf90_def_var(ncid,"z",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","z                             ")
    status = nf90_put_att(ncid,varid,"units","m")

    status = nf90_def_var(ncid,"u",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","u                             ")
    status = nf90_put_att(ncid,varid,"units","m/s")

    status = nf90_def_var(ncid,"v",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","v                             ")
    status = nf90_put_att(ncid,varid,"units","m/s")

    status = nf90_def_var(ncid,"w",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","w                             ")
    status = nf90_put_att(ncid,varid,"units","m/s")

  if(prth.ge.1)then
    status = nf90_def_var(ncid,"th",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","potential temperature         ")
    status = nf90_put_att(ncid,varid,"units","K")
  endif
  if(prt.ge.1)then
    status = nf90_def_var(ncid,"t",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","temperature")
    status = nf90_put_att(ncid,varid,"units","K")
  endif
  if(prprs.ge.1)then
    status = nf90_def_var(ncid,"prs",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","pressure                      ")
    status = nf90_put_att(ncid,varid,"units","Pa")
  endif

    if(prpt1.ge.1)then
      do n=1,npt
        text1='pt      '
        if(n.le.9)then
          write(text1(3:3),155) n
        else
          write(text1(3:4),154) n
        endif
154     format(i2.2)
155     format(i1.1)
        status = nf90_def_var(ncid,text1,nf90_float,(/npid,timeid/),varid)
        status = nf90_put_att(ncid,varid,"long_name","passive tracer conc.")
        status = nf90_put_att(ncid,varid,"units","kg/kg")
      enddo
    endif

  if(prqv.ge.1)then
    status = nf90_def_var(ncid,"qv",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","water vapor mixing ratio")
    status = nf90_put_att(ncid,varid,"units","kg/kg")
  endif

        if(prq1.ge.1)then
          n2 = nql2
          if( iice.eq.1 ) n2 = nqs2
          do n=nql1,n2
          text1='        '
          text2='                              '
          write(text1(1:3),156) qname(n)
          write(text2(1:3),156) qname(n)
156       format(a3)
          status = nf90_def_var(ncid,text1,nf90_float,(/npid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name",text2)
          enddo
        endif

        if(prnc1.ge.1)then
          do n=nnc1,nnc2
          text1='        '
          text2='                              '
          write(text1(1:3),156) qname(n)
          write(text2(1:3),156) qname(n)
          status = nf90_def_var(ncid,text1,nf90_float,(/npid,timeid/),varid)
          status = nf90_put_att(ncid,varid,"long_name",text2)
          enddo
        endif

  if(prkm.ge.1)then
    status = nf90_def_var(ncid,"kmh",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","turb. coef. for momentum (horiz)")
    status = nf90_put_att(ncid,varid,"units","m^2/s")
  endif
  if(prkm.ge.1)then
    status = nf90_def_var(ncid,"kmv",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","turb. coef. for momentum (vert)")
    status = nf90_put_att(ncid,varid,"units","m^2/s")
  endif
  if(prkh.ge.1)then
    status = nf90_def_var(ncid,"khh",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","turb. coef. for scalar (horiz)")
    status = nf90_put_att(ncid,varid,"units","m^2/s")
  endif
  if(prkh.ge.1)then
    status = nf90_def_var(ncid,"khv",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","turb. coef. for scalar (vert)")
    status = nf90_put_att(ncid,varid,"units","m^2/s")
  endif

  if(prtke.ge.1)then
    status = nf90_def_var(ncid,"tke",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","subgrid turbulence kinetic energy")
    status = nf90_put_att(ncid,varid,"units","m^2/s^2")
  endif

  if(prdbz.ge.1)then
    status = nf90_def_var(ncid,"dbz",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","reflectivity")
    status = nf90_put_att(ncid,varid,"units","dbz")
  endif
  if(prb.ge.1)then
    status = nf90_def_var(ncid,"b",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","buoyancy")
    status = nf90_put_att(ncid,varid,"units","m/s^2")
  endif
  if(prvpg.ge.1)then
    status = nf90_def_var(ncid,"vpg",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","vertical perturbation pressure gradient")
    status = nf90_put_att(ncid,varid,"units","m/s^2")
  endif
  if(przv.ge.1)then
    status = nf90_def_var(ncid,"zv",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","vertical vorticity")
    status = nf90_put_att(ncid,varid,"units","s^-1")
  endif
  if(prrho.ge.1)then
    status = nf90_def_var(ncid,"rho",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","dry-air density")
    status = nf90_put_att(ncid,varid,"units","kg/m^3")
  endif
  if(prqsl.ge.1)then
    status = nf90_def_var(ncid,"qsl",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","saturation mixing ratio wrt liquid")
    status = nf90_put_att(ncid,varid,"units","kg/kg")
  endif
  if(prqsi.ge.1)then
    status = nf90_def_var(ncid,"qsi",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","saturation mixing ratio wrt ice")
    status = nf90_put_att(ncid,varid,"units","kg/kg")
  endif
  if(prznt.ge.1)then
    status = nf90_def_var(ncid,"znt",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","sfc roughness length")
    status = nf90_put_att(ncid,varid,"units","m")
  endif
  if(prust.ge.1)then
    status = nf90_def_var(ncid,"ust",nf90_float,(/npid,timeid/),varid)
    status = nf90_put_att(ncid,varid,"long_name","sfc friction velocity")
    status = nf90_put_att(ncid,varid,"units","m/s")
  endif

!------------------------

    status = nf90_put_att(ncid, NF90_GLOBAL, 'Conventions','COARDS')

    status = nf90_enddef(ncid)

  do np=1,nparcels
    status = nf90_put_var(ncid,npid,float(np),(/np/))
  enddo
    status = nf90_put_var(ncid,yhid,0.0)
    status = nf90_put_var(ncid,zhid,0.0)

!------------------------

  ENDIF  allinfo3

      ! Write data:

      time_index = prec

      call disp_err( nf90_inq_varid(ncid,'time',timeid) , .true. )
      call disp_err( nf90_put_var(ncid,timeid,rtime,(/time_index/)) , .true. )

      call disp_err( nf90_inq_varid(ncid,'x',xid) , .true. )

      DO n=1,npvals
        varid = (xid-1) + n
        do np=1,nparcels
          pdata2(np) = pdata(n,np)
        enddo
        call disp_err( nf90_put_var(ncid,varid,pdata2,(/1,time_index/),(/nparcels,1/)) , .true. )
      ENDDO

      ! close file

      call disp_err( nf90_close(ncid) , .true. )

      prec = prec + 1

      ! all done

      return
      end subroutine writepdata_nc
#endif

writeout_hdf5.F 1587424407  1602  20    100644  112838    `
! HDF5 output written by Leigh Orf <leigh.orf@cmich.edu>
!
! In namelist.input, you can choose which of the 2D and 3D variables are written.
!
! Three output options are available, set in namelist.input:
! output_format = 3 uses scale-offset lossy compression followed by gzip compression. (smallest files)
! output_format = 4 uses gzip compression (level 1) on floating point data and is lossless.
! output_format = 5 uses no compression whatsoever, just floating point (largest files)
!
! These compression options apply to 3D data. See comments in subroutine
! writefloat_hdf_unlimited for how to to add gzip compression to
! unlimited dimension arrays in parcel and stats hdf5 files. For more
! information on compression, please refer to the HDF5 user's guide.
!
!
! The modular nature of HDF5 makes it so that you do not need to worry
! about how the data was compressed when you read it - filters are
! activated automatically and your data appears as 32 bit floating point
! data regardless of the compression choice.
!
! Note that with the scaleoffset filter, you need to a scaling parameter
! which is related to absolute magnitude of your data. The values I have
! chosen work fine for me, but you may wish to tweak them. See hdf5
! docs.
!
! I have written this code to work with MPI only. If you wish to run
! with hdf5 output on a single core, you still need to compile with
! MPI and run with 1 MPI process.
!
! Each MPI rank is matched to one hdf5 file for history data. A
! directory is created which houses all of the hdf5 files at a given
! model dump time. Software has been developed to simplify dealing with
! this format where model domain is split amongst many files. Conversion
! code to create netcdf or vis5d format has also been created and is
! available. If you are interested in exploring additional compression
! options and/or conversion code contact Leigh Orf <leigh.orf@cmich.edu>
! or post to the cm1 CM1 google group.
!
! All hdf5 datasets now contain description and units attributes. New
! code has been added which writes both parcel (trajectory) data to hdf5
! format, as well as statistics data. Both are stored in a single file
! with an unlimited dimension in time, growing as the model progresses.
! This is similar to the netcdf code, which I used as a guide.
!
! Leigh Orf 1/11/11

!--------------------------------------------------------------------------------------------MARK


subroutine writeout_mult_hdf5(model_time,qname,rds,sigma,rdsf,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf,    &
                pi0,prs0,rho0,th0,qv0,u0,v0,                        &
                zs,gz,rgz,rgzu,rgzv,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cd,ch,cq,dum1,dum2,dum3,dum4, &
                t11,t12,rho,prs,dbz,ua,dumu,va,dumv,wa,dumw,ppi,tha,        &
                qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,  &
                dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
#ifdef HDFOUT
      use HDF5
#endif
#ifdef MPI
      use mpi
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real :: model_time
      character*3, dimension(maxq) :: qname
      real, dimension(kb:ke) :: rds,sigma
      real, dimension(kb:ke+1) :: rdsf,sigmaf
      real, dimension(ib:ie)   :: xh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je)   :: yh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,zh,pi0,prs0,rho0,th0,qv0
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,zf
      real, dimension(ib:ie,jb:je) :: zs
      real, dimension(itb:ite,jtb:jte) :: gz,rgz,rgzu,rgzv
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,cd,ch,cq
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,t11,t12,rho,prs,dbz
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,dumu
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,dumv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,dumw
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      integer, intent(in) :: num_soil_layers
      integer, dimension(ibl:iel,jbl:jel), intent(in) :: lu_index
      real, dimension(ib:ie,jb:je), intent(in) :: tsk,xland
      real, dimension(ibl:iel,jbl:jel), intent(in) :: mavail,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw
      real, dimension(ibl:iel,jbl:jel,num_soil_layers), intent(in) :: tslb
      real, dimension(ni,nj), intent(in) :: radsw,rnflx,radswnet,radlwin
      real, dimension(ibl:iel,jbl:jel), intent(in) :: u10,v10,t2,q2,hpbl,zol,mol,br
      real, dimension(ib:ie,jb:je), intent(in) :: znt,ust
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: dissten
      real, dimension(ibb:ieb,jbb:jeb,kbb:keb), intent(in) :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, dimension(ibr:ier,jbr:jer,kbr:ker), intent(in) :: swten,lwten


#ifdef HDFOUT
      real, dimension(ni,nj,nk) :: ds
      real, dimension(ni,nj) :: ds2
      real, dimension(1:nk) :: zhcol,zfcol,u0col,v0col,th0col,pi0col,rho0col,pres0col,qv0col
      real, dimension(1:ni) :: xfcol,xhcol
      real, dimension(1:nj) :: yfcol,yhcol

      integer i,j,k,n
      character(len=120)  description
      character(len=20)   units
      character(len=20)   varname
      character(len=160)  filename
      character(LEN=20) :: qvarname
      character(len=8) chid
      character(len=4) cid
      character(len=5) ctime

      character(len=100) filedir
      character(len=109) dircmd

      integer ierror
      integer(HID_T) :: file_id,dset_id,dspace_id
      integer(HID_T) :: grid_group_id, mesh_group_id, basestate_group_id, twod_group_id, threed_group_id,threed_basestate_group_id
      character(LEN=4),  parameter :: grid_group_name = 'grid'
      character(LEN=4),  parameter :: mesh_group_name = 'mesh'
      character(LEN=9),  parameter :: basestate_group_name = 'basestate'
      character(LEN=12),  parameter :: threed_basestate_group_name = '3d_basestate'
      character(LEN=2),  parameter :: twod_group_name = '2d'
      character(LEN=2),  parameter :: threed_group_name = '3d'
      integer sd_id, sds_id, status, dim_id, data_type
      integer ix,iy
      integer rank
      integer(HSIZE_T), DIMENSION(3) :: dims
      integer itime,lt,flag
      integer x0,x1,y0,y1; ! bounding box for each MPI rank within total domain

      if (len_trim(output_path) .eq. 0) then
            if(dowr) write(outfile,*) 'empty output_path'
            if(dowr) write(outfile,*) 'defaulting to current working directory'
            output_path='.'
      endif
      write(ctime,102)int(model_time)
      write(cid,103)myid
102   format(i5.5)
103   format(i4.4)
      filedir = trim(output_path)//'/'//trim(output_basename)//'.'//ctime//'.cdir/'
      dircmd = 'mkdir -p '// trim(filedir)
      if (myid.eq.0) call system(dircmd)
#ifdef MPI
      call MPI_BARRIER (MPI_COMM_WORLD,ierr) ! TODO: create directory structure ahead of time
#endif
      filename = trim(filedir)//trim(output_basename)//'.'//ctime//'_'//cid//'.cm1hdf5'
      if(dowr) write(outfile,*) 'myid,filename=',myid,'   ',trim(filename)

      call h5open_f (ierror)
      call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror)

! Let's create some groups for organizational purposes

      call h5gcreate_f(file_id,grid_group_name,grid_group_id,ierror)      
      call h5gcreate_f(file_id,mesh_group_name,mesh_group_id,ierror)      
      call h5gcreate_f(file_id,basestate_group_name,basestate_group_id,ierror)      
      call h5gcreate_f(file_id,threed_basestate_group_name,threed_basestate_group_id,ierror)      
      call h5gcreate_f(file_id,twod_group_name,twod_group_id,ierror)      
      call h5gcreate_f(file_id,threed_group_name,threed_group_id,ierror)      

      x0 = (myi-1)*ni;
      x1 = myi*ni-1;
      y0 = (myj-1)*nj;
      y1 = myj*nj-1;

      varname='time'
      description='model time'
      units='seconds'
      call h5_write_float(file_id,varname,description,units,model_time)

      varname='dx'
      description='grid spacing in the x direction. If E/W grid stretching, this should be somehwat representative'
      units='meters'
      call h5_write_float(mesh_group_id,varname,description,units,dx)

      varname='dy'
      description='grid spacing in the y direction. If N/S grid stretching, this should be somehwat representative'
      units='meters'
      call h5_write_float(mesh_group_id,varname,description,units,dy)

      varname='x0'
      description='index of westmost point of 3d field in this hdf5 file with respect to full model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,x0)

      varname='x1'
      description='index of eastmost point of 3d field in this hdf5 file with respect to full model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,x1)

      varname='y0'
      description='index of southmost point of 3d field in this hdf5 file with respect to full model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,y0)

      varname='y1'
      description='index of northmost point of 3d field in this hdf5 file with respect to full model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,y1)

      varname='myi'
      description='east/west index of hdf5 file in 2d decomposition. (1 < myi <= nodex)'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,myi)

      varname='myj'
      description='north/south index of hdf5 file in 2d decomposition. (1 < myj <= nodej)'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,myj)

      varname='ni'
      description='number of gridpoints in east/west direction in this hdf5 file for 2d and 3d data'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,ni)

      varname='nj'
      description='number of gridpoints in north/south direction in this hdf5 file for 2d and 3d data'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,nj)

      varname='nodex'
      description='number of hdf5 files spanning the full east/west extent of the model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,nodex)

      varname='nodey'
      description='number of hdf5 files spanning the full north/south extent of the model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,nodey)

      varname='nx'
      description='number of gridpoints spanning the east/west direction of full the model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,nx)

      varname='ny'
      description='number of gridpoints spanning the north/south direction of full the model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,ny)

      varname='nz'
      description='number of gridpoints spanning the vertical extent of the full the model domain'
      units='index'
      call h5_write_int  (grid_group_id,varname,description,units,nz)


! ORF 1/11/11

! Always write out 1D vertical base state column varables. Full 3D
! base state variables are written below if output_basestate.eq.1 for
! you folks who run with terrain. If you have terrain then ignore the
! following 1D basestate variables (i.e., x0col(k) )

! In other words, if you run with terrain and want base state
! variables, set output_basesteate.eq.1 and use vars in group
! /3d_basestate. If you do not run with terrain (flat bottom), you can
! set output_basestate.eq.0 and use vars in /basestate since all base
! state variables will be horizontlaly homogeneous. 1D vars save space
! over 3D vars. Of course nothing is stopping you from writing full 3D
! basestate even if you are not running with terrain!

      do k=1,nk
          zhcol(k)=zh(1,1,k)
          zfcol(k)=zf(1,1,k)
          u0col(k) = u0(1,1,k)
          v0col(k) = v0(1,1,k)
          th0col(k) = th0(1,1,k)
          pi0col(k) = pi0(1,1,k)
          rho0col(k) = rho0(1,1,k)
          pres0col(k) = p00*(pi0(1,1,k))**cpdrd
          qv0col(k) = qv0(1,1,k)
      enddo

      do j = 1,nj
          yfcol(j) = yf(j)
          yhcol(j) = yh(j)
      enddo

      do i = 1,ni
          xfcol(i) = xf(i)
          xhcol(i) = xh(i)
      enddo

      varname='zh'
      description='Height above ground of scalar points (model uses Arakawa C grid)'
      units='meters'
      call h5_write_1d_float(mesh_group_id,varname,description,units,zhcol,nk)

      varname='zf'
      description='Height above ground of W points (model uses Arakawa C grid)'
      units='meters'
      call h5_write_1d_float(mesh_group_id,varname,description,units,zfcol,nk)

      varname='yh'
      description='N/S location of scalar points (model uses Arakawa C grid)'
      units='meters'
      call h5_write_1d_float(mesh_group_id,varname,description,units,yhcol,nj)

      varname='yf'
      description='N/S location of V points (model uses Arakawa C grid)'
      units='meters'
      call h5_write_1d_float(mesh_group_id,varname,description,units,yfcol,nj)

      varname='xh'
      description='E/W location of scalar points (model uses Arakawa C grid)'
      units='meters'
      call h5_write_1d_float(mesh_group_id,varname,description,units,xhcol,ni)

      varname='xf'
      description='E/W location of U points (model uses Arakawa C grid)'
      units='meters'
      call h5_write_1d_float(mesh_group_id,varname,description,units,xfcol,ni)

      varname='u0'
      description='U (E/W wind) base state, (i.e., from sounding)'
      units='m/s'
      call h5_write_1d_float(basestate_group_id,varname,description,units,u0col,nk)

      varname='v0'
      description='V (N/S wind) base state, (i.e., from sounding)'
      units='m/s'
      call h5_write_1d_float(basestate_group_id,varname,description,units,v0col,nk)

      varname='th0'
      description='Potential temperature base state, (i.e., from sounding)'
      units='K'
      call h5_write_1d_float(basestate_group_id,varname,description,units,th0col,nk)

      varname='pi0'
      description='Dimensionless pressure (Exner function) base state, (i.e., from sounding)'
      units='dimensionless'
      call h5_write_1d_float(basestate_group_id,varname,description,units,pi0col,nk)

      varname='pres0'
      description='Pressure base state, (i.e., from sounding)'
      units='Pa'
      call h5_write_1d_float(basestate_group_id,varname,description,units,pres0col,nk)

      varname='rh0'
      description='Density base state, (i.e., from sounding)'
      units='kg/m^3'
      call h5_write_1d_float(basestate_group_id,varname,description,units,rho0col,nk)

      call h5gclose_f(grid_group_id,ierror)
      call h5gclose_f(mesh_group_id,ierror)
      call h5gclose_f(basestate_group_id,ierror)

! terrain

     if (output_zs.eq.1.and.terrain_flag) then
       do j=1,nj
       do i=1,ni
         ds2(i,j)=zs(i,j)
       enddo
       enddo

       varname='zs'
       description='terrain height'
       units='meters'
       call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

      endif

     if (output_zh.eq.1.and.terrain_flag) then
       do k=1,nk
       do j=1,nj
       do i=1,ni
         ds(i,j,k)=zh(i,j,k)
       enddo
       enddo
       enddo

       varname='zh'
       description='height (above ground) of scalar grid points'
       units='meters'
       call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,ds,ni,nj,nk)

     endif
            
! ORF 1/11/11 Following netcdf example, allow option for output of 3D
! base state. 1D basestate variables in /basestate group are always
! written but are not useful for folks running with terrain who require
! the 3D basestate.

     if (output_basestate.eq.1) then

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=pi0(i,j,k)
          enddo
          enddo
          enddo

          varname='pi0'
          description = '3D base state nondimensional pressure (Exner function)'
          units = 'dimensionless'
          call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=th0(i,j,k)
          enddo
          enddo
          enddo

          varname='th0'
          description = '3D base state potential temperature'
          units = 'K'
          call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=prs0(i,j,k)
          enddo
          enddo
          enddo

          varname='p0'
          description = '3D base state pressure'
          units = 'Pa'
          call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qv0(i,j,k)
          enddo
          enddo
          enddo

          varname='qv0'
          description = '3D base state water vapor mixing ratio'
          units = 'kg/kg'
          call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni+1
            dumu(i,j,k)=u0(i,j,k)
          enddo
          enddo
          enddo

          varname='u0'
          description = '3D base state x component of velocity on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,dumu,ni+1,nj,nk)

          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            dumv(i,j,k)=v0(i,j,k)
          enddo
          enddo
          enddo

          varname='v0'
          description = '3D base state y component of velocity on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_basestate_group_id,varname,description,units,3,dumv,ni,nj+1,nk)

      endif !output_basestate.eq.1

      if(output_rain.eq.1) then
          do j=1,nj
          do i=1,ni
            ds2(i,j)=rain(i,j,1)
          enddo
          enddo
          varname='sfcrain'
          description='accumulated surface rainfall'
          units='cm'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
          if (nrain.eq.2) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=rain(i,j,2)
              enddo
              enddo
              varname='sfcrain_trans'
              description='accumulated surface rainfall, translated with moving domain'
              units='cm'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
          endif
      endif

      if(output_sws.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=sws(i,j,1)
           enddo
           enddo
           varname='maxsws'
           description='maximum windspeed at lowest level'
           units='m/s'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_sws.eq.1

      if(output_svs.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=svs(i,j,1)
           enddo
           enddo
           varname='maxsvs'
           description='maximum vertical vorticity at lowest level'
           units='s^{-1}'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_svs.eq.1

      if(output_sps.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=sps(i,j,1)
           enddo
           enddo
           varname='maxsps'
           description='minimum pressure at lowest level'
           units='Pa'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_sps.eq.1

      if(output_srs.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=srs(i,j,1)
           enddo
           enddo
           varname='maxsrs'
           description='maximum surface rainwater mixing ratio'
           units='kg/kg'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_srs.eq.1

      if(output_sgs.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=sgs(i,j,1)
           enddo
           enddo
           varname='maxsgs'
           description='maximum surface graupel/hail mixing ratio'
           units='kg/kg'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_sgs.eq.1

      if(output_sus.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=sus(i,j,1)
           enddo
           enddo
           varname='maxsus'
           description='maximum updraft velocity'
           units='m/s'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_sus.eq.1

      if(output_shs.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=shs(i,j,1)
           enddo
           enddo
           varname='maxshs'
           description='maximum integrated updraft helicity'
           units='m^2/s^2'
           call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_shs.eq.1

      if (nrain.eq.2) then
         if(output_rain.eq.1) then
            do j=1,nj
            do i=1,ni
              ds2(i,j)=rain(i,j,2)
            enddo
            enddo
            varname='maxrain_trans'
            description='accumulated surface rainfall, translated with moving domain'
            units='cm'
            call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
          endif

          if(output_sws.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=sws(i,j,2)
              enddo
              enddo
              varname='maxsws_trans'
              description='maximum windspeed at lowest level, translated with moving domain'
              units='m/s'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_sws.eq.1

          if(output_svs.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=svs(i,j,2)
              enddo
              enddo
              varname='maxsvs_trans'
              description='maximum vertical vorticity at lowest level, translated with moving domain'
              units='s^{-1}'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_svs.eq.1

          if(output_sps.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=sps(i,j,2)
              enddo
              enddo
              varname='maxsps_trans'
              description='minimum pressure at lowest level, translated with moving domain'
              units='Pa'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_sps.eq.1

          if(output_srs.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=srs(i,j,2)
              enddo
              enddo
              varname='maxsrs_trans'
              description='maximum surface rainwater mixing ratio, translated with moving domain'
              units='kg/kg'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_srs.eq.1

          if(output_sgs.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=sgs(i,j,2)
              enddo
              enddo
              varname='maxsgs_trans'
              description='maximum surface graupel/hail mixing ratio, translated with moving domain'
              units='kg/kg'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_sgs.eq.1

          if(output_sus.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=sus(i,j,2)
              enddo
              enddo
              varname='maxsus_trans'
              description='maximum updraft velocity, translated with moving domain'
              units='m/s'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_sus.eq.1

          if(output_shs.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=shs(i,j,2)
              enddo
              enddo
              varname='maxshs_trans'
              description='maximum integrated updraft helicity, translated with moving domain'
              units='m^2/s^2'
              call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
           endif !output_shs.eq.1
      endif !nrain.eq.2

! Composite reflectivity

      if(output_dbz.eq.1)then
          call calccref(dum1(ib,jb,1),dbz)
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,1)
          enddo
          enddo
          varname='cref'
          description='composite reflectivity'
          units='dbZ'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif

! Cold pool C and H (RKW)

      if(output_coldpool.eq.1) then
          call calccpch(zh,zf,th0,qv0,dum1(ib,jb,1),dum1(ib,jb,2),tha,qa)
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,1)
          enddo
          enddo
          varname='cpc'
          description='cold pool intensity C'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,2)
          enddo
          enddo
          varname='cph'
          description='cold pool depth h'
          units='meters'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif !output_coldpool.eq.1

! Surface fluxes

      if(output_sfcflx.eq.1) then
          do j=1,nj
          do i=1,ni
            ds2(i,j)=thflux(i,j)
          enddo
          enddo
          varname='thflux'
          description='surface potential temperature flux'
          units='K m s^{-1}'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
        
          do j=1,nj
          do i=1,ni
            ds2(i,j)=qvflux(i,j)
          enddo
          enddo

          varname='qvflux'
          description='surface water vapor flux'
          units='kg/kg m s^{-1}'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tsk(i,j)
          enddo
          enddo

          varname='tsk'
          description='soil/ocean temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

      endif !output_sfcflx.eq.1

      if(output_sfcparams.eq.1) then

          do j=1,nj
            do i=1,ni
             ds2(i,j)=cd(i,j)
            enddo
          enddo

          varname='cd'
          description='cd' !ORF WTF IS THIS?
          units='nondimensional'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=ch(i,j)
          enddo
          enddo

          varname='ch'
          description='ch' !ORF WTF IS THIS?
          units='nondimensional'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=cq(i,j)
          enddo
          enddo

          varname='cq'
          description='cq' !ORF WTF IS THIS?
          units='nondimensional'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=xland(i,j)
          enddo
          enddo

          varname='xland'
          description='land/water flag (1=land, 2=water)'
          units='integer flag'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=lu_index(i,j)
          enddo
          enddo

          varname='lu'
          description='land usage index'
          units='integer flag'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=mavail(i,j)
          enddo
          enddo

          varname='mavail'
          description='surface moisture availability'
          units='integer flag'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

      endif !output_sfcparams.eq.1

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3.or.oceanmodel.eq.2))then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tmn(i,j)
          enddo
          enddo
          varname='tmn'
          description='deep-layer soil temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=hfx(i,j)
          enddo
          enddo
          varname='hfx'
          description='heat flux at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=qfx(i,j)
          enddo
          enddo
          varname='qfx'
          description='surface moisture flux'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=gsw(i,j)
          enddo
          enddo
          varname='gsw'
          description='downward SW flux at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=glw(i,j)
          enddo
          enddo
          varname='glw'
          description='downward LW flux at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.sfcmodel.eq.3))then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,1)
          enddo
          enddo
          varname='tslb1'
          description='soil temp, layer 1'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,2)
          enddo
          enddo
          varname='tslb2'
          description='soil temp, layer 2'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,3)
          enddo
          enddo
          varname='tslb3'
          description='soil temp, layer 3'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,4)
          enddo
          enddo
          varname='tslb4'
          description='soil temp, layer 4'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,5)
          enddo
          enddo
          varname='tslb5'
          description='soil temp, layer 5'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tml(i,j)
          enddo
          enddo
          varname='tml'
          description='ocean mixed layer temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=hml(i,j)
          enddo
          enddo
          varname='hml'
          description='ocean mixed layer depth'
          units='meters'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=huml(i,j)
          enddo
          enddo
          varname='huml'
          description='ocean mixed layer u velocity'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=hvml(i,j)
          enddo
          enddo
          varname='hvml'
          description='ocean mixed layer v velocity'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif

      if(output_radten.eq.1)then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=radsw(i,j)
          enddo
          enddo
          varname='radsw'
          description='solar radiation at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=rnflx(i,j)
          enddo
          enddo
          varname='rnflx'
          description='net radiation absorbed by surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=radswnet(i,j)
          enddo
          enddo
          varname='radswnet'
          description='net solar radiation'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=radlwin(i,j)
          enddo
          enddo
          varname='radlwin'
          description='incoming longwave radiation'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif

      if(output_sfcdiags.eq.1)then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=u10(i,j)
          enddo
          enddo
          varname='ul0'
          description='diagnostic 10m u wind'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=v10(i,j)
          enddo
          enddo
          varname='vl0'
          description='diagnostic 10m v wind'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=t2(i,j)
          enddo
          enddo
          varname='t2'
          description='diagnostic 2m temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=q2(i,j)
          enddo
          enddo
          varname='q2'
          description='diagnostic 2m water vapor mixing ratio'
          units='kg/kg'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=znt(i,j)
          enddo
          enddo
          varname='znt'
          description='roughness length'
          units='m'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=ust(i,j)
          enddo
          enddo
          varname='ust'
          description='u* in similarity theory'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          if(ipbl.eq.1)then
                description='PBL height (from PBL scheme)'
          else
                description='rough estimate of PBL height'
          endif
          do j=1,nj
          do i=1,ni
            ds2(i,j)=hpbl(i,j)
          enddo
          enddo
          varname='hpbl'
          units='meters'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=zol(i,j)
          enddo
          enddo
          varname='zol'
          description='z/L (z over Monin-Obukhov length)'
          units='dimensionless'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=mol(i,j)
          enddo
          enddo
          varname='mol'
          description='T* (similarity theory)'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=br(i,j)
          enddo
          enddo
          varname='br'
          description='bulk Richardson number in surface layer'
          units='dimensionless'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)
      endif

! begin 3d group

      if(output_th  .eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=th0(i,j,k)+tha(i,j,k)
          enddo
          enddo
          enddo
          varname='th'
          description = 'Potential temperature'
          units = 'K'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif

      if(output_thpert .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=tha(i,j,k)
          enddo
          enddo
          enddo
          varname='thpert'
          description = 'Perturbation potential temperature'
          units = 'K'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif

      if(output_prs    .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=prs(i,j,k)
          enddo
          enddo
          enddo
          varname='p'
          description = 'Pressure'
          units = 'Pa'
          call h5_write_3d_float(threed_group_id,varname,description,units,1,ds,ni,nj,nk)
      endif

      if(output_prspert.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=prs(i,j,k)-p00*(pi0(i,j,k)**cpdrd)
          enddo
          enddo
          enddo
          varname="ppert"
          description = 'Perturbation pressure'
          units = 'Pa'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif
      if(output_pi.eq.1)then  
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
          enddo
          enddo
          enddo
          varname = "pi"
          description = 'Nondimensional pressure (Exner function)'
          units = 'dimensionless'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)
      endif
      if(output_pipert .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=ppi(i,j,k)
          enddo
          enddo
          enddo
          varname='pipert'
          description = 'Nondimensional pressure (Exner function) perturbation'
          units = 'dimensionless'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)
      endif

      if(output_rho    .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=rho(i,j,k)
          enddo
          enddo
          enddo
          varname = "rho"
          description = 'Density'
          units = 'kg/m^3'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif
      if(output_rhopert.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=rho(i,j,k)-rho0(i,j,k)
          enddo
          enddo
          enddo
          varname="rhopert"
          description = 'Density perturbation'
          units = 'kg/m^3'
          call h5_write_3d_float(threed_group_id,varname,description,units,4,ds,ni,nj,nk)
      endif
      if(iturb.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=tkea(i,j,k)
          enddo
          enddo
          enddo
          varname="tke"
          description = 'Subgrid turbulence kinetic energy'
          units = 'J/kg'
          call h5_write_3d_float(threed_group_id,varname,description,units,4,ds,ni,nj,nk)
      endif

      if(iturb.ge.1)then

          if(output_km  .eq.1) then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=kmh(i,j,k)
              enddo
              enddo
              enddo

              varname='kmh'
              description = 'Eddy mixing coefficient for momentum in the horizontal direction'
              units = 'm^2/s'
              call h5_write_3d_float(threed_group_id,varname,description,units,4,ds,ni,nj,nk)

              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=kmv(i,j,k)
              enddo
              enddo
              enddo
              varname='kmv'
              description = 'Eddy mixing coefficient for momentum in the vertical direction'
              units = 'm^2/s'
              call h5_write_3d_float(threed_group_id,varname,description,units,4,ds,ni,nj,nk)
          endif

         if(output_kh  .eq.1) then
           do k=1,nk
           do j=1,nj
           do i=1,ni
             ds(i,j,k)=khh(i,j,k)
           enddo
           enddo
           enddo
           varname='khh'
           description = 'Eddy mixing coefficient for scalars in the horizontal direction'
           units = 'm^2/s'
           call h5_write_3d_float(threed_group_id,varname,description,units,4,ds,ni,nj,nk)

           do k=1,nk
           do j=1,nj
           do i=1,ni
             ds(i,j,k)=khv(i,j,k)
           enddo
           enddo
           enddo
           varname='khv'
           description = 'Eddy mixing coefficient for scalars in the vertical direction'
           units = 'm^2/s'
           call h5_write_3d_float(threed_group_id,varname,description,units,4,ds,ni,nj,nk)
         endif
      endif !iturb .ge. 1

      if(imoist.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qa(i,j,k,nqv)
          enddo
          enddo
          enddo
          varname='qv'
          description = 'Water vapor mixing ratio'
          units = 'kg/kg                         '
          if(output_qv .eq. 1)    call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)
          if(output_qvpert.eq.1)then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=qa(i,j,k,nqv)-qv0(i,j,k)
              enddo
              enddo
              enddo
              varname="qvpert"
              description = 'Perturbation water vapor mixing ratio'
              units = 'kg/kg                         '
              call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)
          endif

          if(output_q.eq.1)then
              do n=1,numq
                  if(n.ne.nqv)then
                      do k=1,nk
                      do j=1,nj
                      do i=1,ni
                        ds(i,j,k)=qa(i,j,k,n)
                      enddo
                      enddo
                      enddo
                      qvarname='                    '
                      write(qvarname(1:3),156) qname(n)
156                   Format(a3)
                      if(idm.eq.1.and.n.ge.nnc1.and.n.le.nnc2)then
                           description = 'Number concentration'
                           units = 'kg^{-1}'
                      elseif(idm.eq.1.and.n.ge.nvl1.and.n.le.nvl2)then
                           description = 'particle volume'
                           units = 'm^{3}kg^{-1}'
                      elseif(idm.eq.1.and.n.ge.nzl1.and.n.le.nzl2)then
                           description = 'reflectivity moment'
                           units = 'Z m^{-3}kg^{-1}'
                      else
                           description = 'Hydrometeor mixing ratio'
                           units = 'kg/kg'
                      endif
                      call h5_write_3d_float(threed_group_id,qvarname,description,units,6,ds,ni,nj,nk)
                  endif
              enddo
          endif !output_q .eq.1
          if(output_dbz.eq.1) then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=dbz(i,j,k)
              enddo
              enddo
              enddo
              varname="dbz"
              description = 'Reflectivity'
              units = 'dBZ'
              call h5_write_3d_float(threed_group_id,varname,description,units,2,ds,ni,nj,nk)
          endif

      endif !imoist.eq.1

      if(output_uinterp.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
          enddo
          enddo
          enddo
          varname="uinterp"
          description = 'velocity in x-direction, interpolated to scalar points'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif
      if(output_vinterp.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
          enddo
          enddo
          enddo
          varname="vinterp"
          description = 'velocity in y-direction, interpolated to scalar points'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif
      if(output_winterp.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
          enddo
          enddo
          enddo
          varname='winterp'
          description = 'velocity in z direction, interpolated to scalar points'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,ds,ni,nj,nk)
      endif


      if(iptra.eq.1)then
          do n=1,npt
            do k=1,nk
            do j=1,nj
            do i=1,ni
              ds(i,j,k)=pta(i,j,k,n)
            enddo
            enddo
            enddo

            chid = 'pt      '
            write(chid(3:4),111) n
111         format(i2.2)

            varname=chid
            description='mixing ratio of passive tracer'
            units='kg/kg'
            call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)
          enddo
      endif


      if(output_pblten.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=thpten(i,j,k)
          enddo
          enddo
          enddo

          varname='thpten'
          description='pbl tendency: theta'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qvpten(i,j,k)
          enddo
          enddo
          enddo

          varname='qvpten'
          description='pbl tendency: qv'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qcpten(i,j,k)
          enddo
          enddo
          enddo

          varname='qcpten'
          description='pbl tendency: qc'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qipten(i,j,k)
          enddo
          enddo
          enddo

          varname='qipten'
          description='pbl tendency: qi'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=upten(i,j,k)
          enddo
          enddo
          enddo

          varname='upten'
          description='pbl tendency: u'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=vpten(i,j,k)
          enddo
          enddo
          enddo

          varname='vpten'
          description='pbl tendency: v'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

      endif !output_pblten.eq.1

      if(output_uh.eq.1) then

        ! get height AGL:
          if( terrain_flag )then
            do k=1,nk+1
            do j=1,nj
            do i=1,ni
              dum3(i,j,k) = zh(i,j,k)-zs(i,j)
              dumw(i,j,k) = zf(i,j,k)-zs(i,j)
            enddo
            enddo
            enddo
          else
            do k=1,nk+1
            do j=1,nj
            do i=1,ni
              dum3(i,j,k) = zh(i,j,k)
              dumw(i,j,k) = zf(i,j,k)
            enddo
            enddo
            enddo
          endif
          call calcuh(uf,vf,dum3,dumw,ua,va,wa,dum1(ib,jb,1),dum2,t11,t12, &
                      zs,rgzu,rgzv,rds,sigma,rdsf,sigmaf)
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,1)
          enddo
          enddo

          varname='uh'
          description='integrated updraft helicity'
          units='m^2/s^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,ni,nj)

      endif!output_uh.eq.1

      if(output_vort.eq.1)then
#endif
!              cm1r18 ... needs to be updated
#ifdef HDFOUT

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dum1(i,j,k)
          enddo
          enddo
          enddo

          varname='xvort'
          description='horizontal vorticity (x), usually called xi'
          units='s^{-1}'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dum2(i,j,k)
          enddo
          enddo
          enddo

          varname='yvort'
          description='horizontal vorticity (y), usually called eta'
          units='s^{-1}'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dum3(i,j,k)
          enddo
          enddo
          enddo

          varname='zvort'
          description='vertical vorticity (zeta)'
          units='s^{-1}'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

      endif !output_vort.eq.1

      if(output_dissten.eq.1) then

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dissten(i,j,k)
          enddo
          enddo
          enddo

          varname='dissten'
          description='dissipative heating tendency'
          units='K/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,6,ds,ni,nj,nk)

       endif


!--------------------------------------------------------------
!  writeout data on u-points

! Note velocity data is staggered and requires 1 extra point

       if(output_u    .eq.1) then
           do k=1,nk
           do j=1,nj
           do i=1,ni+1
             dumu(i,j,k)=ua(i,j,k)
           enddo
           enddo
           enddo
           varname='u'
           description = 'velocity in x direction on native Arakawa C grid'
           units = 'm/s'
           call h5_write_3d_float(threed_group_id,varname,description,units,3,dumu(1:ni+1,1:nj,1:nk),ni+1,nj,nk)
       endif


      if(output_upert.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni+1
            dumu(i,j,k)=ua(i,j,k)-u0(i,j,k)
          enddo
          enddo
          enddo
          varname='upert'
          description = 'perturbation velocity in x direction on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,dumu(1:ni+1,1:nj,1:nk),ni+1,nj,nk)
      endif

!--------------------------------------------------------------
!  writeout data on v-points

      if(output_v    .eq.1) then
          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            dumv(i,j,k)=va(i,j,k)
          enddo
          enddo
          enddo
          varname='v'
          description = 'velocity in y direction on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,dumv(1:ni,1:nj+1,1:nk),ni,nj+1,nk)
      endif


      if(output_vpert.eq.1)then
          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            dumv(i,j,k)=va(i,j,k)-v0(i,j,k)
          enddo
          enddo
          enddo
          varname='vpert'
          description = 'perturbation velocity in y direction on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,dumv(1:ni,1:nj+1,1:nk),ni,nj+1,nk)
      endif

!--------------------------------------------------------------
!  writeout data on w-points

      if(output_w    .eq.1) then
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dumw(i,j,k)=wa(i,j,k)
          enddo
          enddo
          enddo
          varname='w'
          description = 'velocity in z direction on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,3,dumw(1:ni,1:nj,1:nk+1),ni,nj,nk+1)
      endif

!--------------------------------------------------------------

      if(dowr) write(outfile,*) 'Done Writing Data to File: ',trim(filename)
! NOTE if compiler says undefined symbol here, try flush_ (IBM)
!     call flush(outfile)

! close everything
      call h5gclose_f(twod_group_id,ierror)
      call h5gclose_f(threed_group_id,ierror)
      call h5fclose_f(file_id,ierror)
      call h5close_f(ierror)

#ifdef MPI
!     call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif

      return
      end

!--------------------------------------------------------------------------------------------MARK

! Have messed around with chunking. For 60x60x80 (per hdf file),
! 60x60x20 chunking works well. I think with small datasets you really
! don't gain much with chunking. Chunking horizontally (e.g., 30x30x20)
! leads to a penalty with small files. You may wish to experiment
! with chunking if you are interested in saving space and are using
! compression, or wish to increase file access and write performance
! (see hdf5 docs).

! Also note that scale_factor is passed to this routine, you may wish
! to change this value if you find that you are seeing compression
! artifacts or you are getting too much (or too little) compression. The
! value I am passing is the one I chose based upon the expected range of
! the data and the level of nrecision I wanted.

      subroutine h5_write_3d_float(file_id,varname,description,units,scale_factor,fl_array_3d,numi,numj,numk)
      use HDF5

      implicit none
      include 'input.incl'
      character*120  description
      character*20  units
      integer(HSIZE_T), DIMENSION(3) :: dims,chunkdims
      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer(HSIZE_T) level
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id,desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer :: scale_type, scale_factor
      integer :: options_mask, pix_per_block
      integer :: rank,numi,numj,numk,ierror
      character(LEN=20) :: varname
      real, dimension(numi,numj,numk) :: fl_array_3d
      integer, dimension(2) :: szip_filter_values
      integer :: gzip_compression_level
      integer(size_t) :: n0,n1,n2

      gzip_compression_level = 1 ! Bump this up if you want more compression

      rank=3
      dims(1)=numi
      dims(2)=numj
      dims(3)=numk
      strdims(1)=1
      level=20
      chunkdims(1) = dims(1) ! do not make this smaller or file gets much(?) larger
      chunkdims(2) = dims(2) ! do not make this smaller or file gets much(?) larger
      chunkdims(3) = min(level,dims(3)) ! Tried a few values, 20 worked nicely

! ORF 1/5/11 add description and units attributes

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

!     call h5tcopy_f(H5T_IEEE_F32LE,datatype_id,ierror)
      call h5screate_simple_f(rank,dims,dspace_id,ierror)
      call h5pcreate_f(H5P_DATASET_CREATE_F,chunk_id,ierror)
      call h5pset_chunk_f(chunk_id,rank,chunkdims,ierror)

! sometimes shuffling first makes compression more efficient
!     call h5pset_shuffle_f (chunk_id,ierror)

      if (output_format.eq.3) call h5pset_scaleoffset_f (chunk_id,0,scale_factor,ierror)
      if (output_format.eq.3.or.output_format.eq.4)call h5pset_deflate_f (chunk_id,gzip_compression_level,ierror)

!     call h5dcreate_f(file_id,trim(varname),datatype_id,dspace_id,dset_id,ierror,chunk_id)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,dspace_id,dset_id,ierror,chunk_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,description,strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,units,strdims,ierror)

!     call h5dwrite_f(dset_id,datatype_id,fl_array_3d,dims,ierror)
      call h5dwrite_f(dset_id,H5T_NATIVE_REAL,fl_array_3d,dims,ierror,H5S_ALL_F,H5S_ALL_F,H5P_DEFAULT_F)

      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
!     call H5tclose_f (datatype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (dspace_id,ierror)
      call H5pclose_f (chunk_id,ierror)

      return
      end

!--------------------------------------------------------------------------------------------MARK
      subroutine h5_write_float (file_id,varname,description,units,value)
      use HDF5
      implicit none
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      real value
      integer rank,ierror
      integer(HSIZE_T), DIMENSION(1) :: dims
      integer(HID_T) :: file_id,dset_id,dspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id

      rank=1
      strdims(1)=1
      dims(1)=1

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      call h5screate_simple_f(rank,dims,dspace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,dspace_id,dset_id,ierror)
      call h5dwrite_f(dset_id,H5T_NATIVE_REAL,value,dims,ierror,H5S_ALL_F,H5S_ALL_F,H5P_DEFAULT_F)

      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)


      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (dspace_id,ierror)
      return
      end
!--------------------------------------------------------------------------------------------MARK
      subroutine h5_write_int (file_id,varname,description,units,value)
      use HDF5
      implicit none
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      integer value
      integer rank,ierror
      integer(HSIZE_T), DIMENSION(1) :: dims
      integer(HID_T) :: file_id,dset_id,dspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id

      rank=1
      strdims(1)=1
      dims(1)=1

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      call h5screate_simple_f(rank,dims,dspace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_INTEGER,dspace_id,dset_id,ierror)
      call h5dwrite_f(dset_id,H5T_NATIVE_INTEGER,value,dims,ierror,H5S_ALL_F,H5S_ALL_F,H5P_DEFAULT_F)

      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)


      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (dspace_id,ierror)
      return
      end
!--------------------------------------------------------------------------------------------MARK
      subroutine h5_write_1d_float (file_id,varname,description,units,fl_array_1d,numk)
      use HDF5
      implicit none
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      real value
      integer rank,numk,ierror
      real, dimension(1:numk) :: fl_array_1d
      integer(HSIZE_T), DIMENSION(1) :: dims
      integer(HID_T) :: file_id,dset_id,dspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id

      rank=1
      strdims(1)=1
      dims(1)=numk

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      call h5screate_simple_f(rank,dims,dspace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,dspace_id,dset_id,ierror)
      call h5dwrite_f(dset_id,H5T_NATIVE_REAL,fl_array_1d,dims,ierror,H5S_ALL_F,H5S_ALL_F,H5P_DEFAULT_F)

      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)


      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (dspace_id,ierror)
      return
      end
!--------------------------------------------------------------------------------------------MARK

      subroutine h5_write_2d_float(file_id,varname,description,units,fl_array_2d,numi,numj)
      use HDF5

      implicit none
      character(LEN=20) :: varname
      character*20  units
      character*120  description
      integer(HSIZE_T), DIMENSION(2) :: dims
      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id,desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer :: rank,numi,numj,ierror
      real, dimension(numi,numj) :: fl_array_2d

      rank=2
      dims(1)=numi
      dims(2)=numj
      strdims(1)=1

! ORF TODO: Add chunking and gzip as we do in the other 2d write code with
! unlimited

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

!     call h5tcopy_f(H5T_IEEE_F32LE,datatype_id,ierror)
      call h5screate_simple_f(rank,dims,dspace_id,ierror)
      call h5pcreate_f(H5P_DATASET_CREATE_F,chunk_id,ierror)

!     call h5dcreate_f(file_id,trim(varname),datatype_id,dspace_id,dset_id,ierror,chunk_id)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,dspace_id,dset_id,ierror,chunk_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,description,strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,units,strdims,ierror)

!     call h5dwrite_f(dset_id,datatype_id,fl_array_2d,dims,ierror)
      call h5dwrite_f(dset_id,H5T_NATIVE_REAL,fl_array_2d,dims,ierror,H5S_ALL_F,H5S_ALL_F,H5P_DEFAULT_F)

      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
!     call H5tclose_f (datatype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (dspace_id,ierror)
      call H5pclose_f (chunk_id,ierror)

      return
      end

!--------------------------------------------------------------------------------------------MARK

! Fields along parcels are hardwired in parcel.F. If you add more fields, change
! here accordingly.

subroutine writepdata_hdf5(nrec,rtime,pdata)

      use HDF5
      implicit none
      include 'input.incl'

      character*160 filename
      integer :: nrec
      real :: rtime
      real, dimension(npvals,nparcels) :: pdata
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id
      integer(HID_T) :: desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: parcel_group_id,memoryspace,filespace,time_id
      integer(HSIZE_T), dimension(2) :: maxdims,chunkdims,currentdims,singledims,offset
      integer(HSIZE_T), dimension(1) :: maxtimedims,timechunkdims,timecurrentdims,timesingledims,timeoffset
      integer(HID_T) :: timechunk_id,timememoryspace,timefilespace,timedset_id
      character(len=6), parameter :: parcel_group_name="parcel"
      character(len=120), parameter :: timedesc="model time"
      character(len=20), parameter :: timevar="time",timeunits="s"
      integer :: i,ierror
      integer :: rank,nvals

      character(len=20), parameter :: varname(16) = (/character(len=20) :: &
      'x', &
      'y', &
      'z', &
      'u', &
      'v', &
      'w', &
      'th', &
      'prs', &
      'b', &
      'qv', &
      'qc', &
      'qr', &
      'qi', &
      'qs', &
      'qg', &
      'kh'/)

      character(len=120), parameter :: vardesc(16) = (/character(len=120) :: &
      'x position of parcel', &
      'y position of parcel', &
      'z position of parcel', &
      'u component of wind', &
      'v component of wind', &
      'w component of wind', &
      'potential temperature', &
      'pressure', &
      'buoyancy', &
      'water vapor mixing ratio', &
      'cloud water mixing ratio', &
      'rain water mixing ratio', &
      'mixing ratio of ice particles', &
      'mixing ratio snow', &
      'mixing ratio graupel/hail', &
      'turbulence coefficient for scalars'/)

      character(len=20), parameter :: varunits(16) = (/character(len=20) :: &
      'm','m','m', &
      'm/s','m/s','m/s', &
      'K', &
      'Pa', &
      'm/s^2', &
      'kg/kg','kg/kg','kg/kg', &
      'kg/kg','kg/kg','kg/kg', &
      'm^2/s'/)

      call h5open_f (ierror)

      maxdims(1) = nparcels
      maxdims(2) = H5S_UNLIMITED_F
      currentdims(1)=nparcels
      currentdims(2)=1
      singledims(1)=nparcels
      singledims(2)=1
      chunkdims(1) =nparcels
      chunkdims(2) = 1
      offset(1) = 0
      offset(2) = 0

      maxtimedims(1) = H5S_UNLIMITED_F
      timechunkdims(1) = 100
      timecurrentdims(1)=1
      timesingledims(1)=1
      timeoffset(1)=0

      timeoffset(1)=nrec-1
      timecurrentdims(1)=nrec
      offset(2) = nrec-1
      currentdims(2) = nrec

      filename = trim(output_basename)//'_pdata.hdf5'
      if(nrec.eq.1) then 
             call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror)
             call h5gcreate_f(file_id,parcel_group_name,parcel_group_id,ierror)      
      else
!            print *,'myid = ',myid,' nrec= ',nrec,' filename = ',trim(filename)
             call h5fopen_f(trim(filename),H5F_ACC_RDWR_F, file_id,ierror)
             call h5gopen_f(file_id,parcel_group_name,parcel_group_id,ierror)
      endif

      rank=1
      nvals=1
      call writefloat_hdf_unlimited(rank,nvals,nrec,parcel_group_id,timevar,timedesc,timeunits,time_id,timefilespace, &
            timememoryspace,timedset_id,timechunk_id,timechunkdims,maxtimedims,timecurrentdims,timesingledims,timeoffset,rtime)

      rank=2
      nvals=nparcels
      do i=1,16
            call writefloat_hdf_unlimited(rank,nvals,nrec,parcel_group_id,varname(i),vardesc(i), &
                  varunits(i),dspace_id,filespace,memoryspace,dset_id,chunk_id, &
                  chunkdims,maxdims,currentdims,singledims,offset,pdata(i,:))
            enddo

      nrec = nrec + 1
      call h5close_f (ierror)

      return
      end 


!--------------------------------------------------------------------------------------------MARK
! ORF 1/11/11
! Following routine works on data with an unlimited dimension,
! i.e., for creating and appending variables in parcel or stats hdf5 files

subroutine writefloat_hdf_unlimited(rank,nvals,irec,file_id,varname,vardesc,varunits,dspace_id, &
      filespace,memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,floatval)

      use HDF5
      implicit none
      include 'input.incl'

      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id
      integer(HID_T) :: desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: parcel_group_id,memoryspace,filespace
      integer rank,nvals
      integer(HSIZE_T),dimension(rank) :: chunkdims,maxdims,currentdims,singledims,offset
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(HSIZE_T), DIMENSION(1) :: strdims = (/1/)
      real, dimension(nvals) :: floatval
      character(len=20) ::  varname
      character(len=120) :: vardesc
      character(len=20) :: varunits
      integer irec,ierror
      integer(SIZE_T) :: stringlen

!     print *, 'myid: ',myid,'irec: ',irec, varname
      if (irec.eq.1) then

            call h5screate_simple_f(rank, singledims, dspace_id, ierror, maxdims)
            call h5screate_simple_f(rank, singledims, memoryspace, ierror, singledims)
            call h5pcreate_f(H5P_DATASET_CREATE_F,chunk_id,ierror)
            call h5pset_chunk_f(chunk_id,rank,chunkdims,ierror)
! This is an example of how you would add gzip compression to unlimited dimension arrays for parcel and stats hdf5 files
!           if (output_format.eq.3.or.output_format.eq.4)call h5pset_deflate_f (chunk_id,1,ierror)

            call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,dspace_id,dset_id,ierror,chunk_id)
            call h5dset_extent_f(dset_id,currentdims,ierror)
            call h5dget_space_f(dset_id,filespace,ierror)
            call h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,singledims,ierror)
            call h5dwrite_f(dset_id,H5T_NATIVE_REAL,floatval,singledims,ierror,memoryspace,filespace,H5P_DEFAULT_F)
            call h5sclose_f(memoryspace,ierror)
            call h5sclose_f(filespace,ierror)
            call h5sclose_f(dspace_id,ierror)
            call H5pclose_f(chunk_id,ierror)

            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            stringlen = len_trim(vardesc)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            call h5screate_simple_f(1,adims,aspace_id,ierror)
            call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,vardesc,strdims,ierror)
            call H5aclose_f (desc_id,ierror)
            call H5sclose_f (aspace_id,ierror)
            call H5tclose_f (desctype_id,ierror)

            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            stringlen = len_trim(varunits)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            call h5screate_simple_f(1,adims,aspace_id,ierror)
            call h5acreate_f(dset_id,"units",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,varunits,strdims,ierror)
            call H5aclose_f (desc_id,ierror)
            call H5sclose_f (aspace_id,ierror)
            call H5tclose_f (desctype_id,ierror)

            call h5dclose_f(dset_id,ierror)
      else
!           print *,'myid = ',myid,' irec= ',irec,' varname = ',varname
            call h5dopen_f(file_id,trim(varname),dset_id,ierror)
            call h5dset_extent_f(dset_id,currentdims,ierror)
            call h5dget_space_f(dset_id,filespace,ierror)
            call h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,singledims,ierror)
            call h5screate_simple_f(rank, singledims, memoryspace, ierror, singledims)
            call h5dwrite_f(dset_id,H5T_NATIVE_REAL,floatval,singledims,ierror,memoryspace,filespace,H5P_DEFAULT_F)
            call h5sclose_f(memoryspace,ierror)
            call h5sclose_f(filespace,ierror)
            call h5dclose_f(dset_id,ierror)
      endif
      return
end 


!--------------------------------------------------------------------------------------------MARK
subroutine writestat_hdf5(nrec,rtime,nstat,rstat,qname,budname)

      use HDF5
      implicit none
      include 'input.incl'

      integer, intent(inout) :: nrec
      real,    intent(in)    :: rtime
      integer, intent(in)    :: nstat
      real, dimension(stat_out), intent(in) :: rstat
      character*3, dimension(maxq), intent(in) :: qname
      character*6, dimension(maxq), intent(in) :: budname

      character*160 filename
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id
      integer(HID_T) :: desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: stats_group_id,memoryspace,filespace,var_id
      integer(HSIZE_T), dimension(1) :: maxdims,chunkdims,currentdims,singledims,offset
      character(len=6), parameter :: stats_group_name="stats"
      integer :: i,n,ierror
      integer :: rank,nvals
      character(len=20) :: varname
      character(len=20) :: units
      character(len=120)::  description
      character(len=8) :: text1
      character(len=30) :: text2

      call h5open_f (ierror)

      maxdims(1) = H5S_UNLIMITED_F
      chunkdims(1) = 100
      currentdims(1)=1
      singledims(1)=1
      offset(1)=0

      rank=1
      nvals=1

!     print *,'nrec = ',nrec
!     print *,'rtime = ',rtime

      filename = trim(output_basename)//'_stats.hdf5'
      if(nrec.eq.1) then 
             call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror)
             call h5gcreate_f(file_id,stats_group_name,stats_group_id,ierror)      
      else
!            print *,'myid = ',myid,' nrec= ',nrec,' filename = ',trim(filename)
             call h5fopen_f(trim(filename),H5F_ACC_RDWR_F, file_id,ierror)
             call h5gopen_f(file_id,stats_group_name,stats_group_id,ierror)
      endif

      offset(1)=nrec-1
      currentdims(1)=nrec

      varname='time'
      description='model time'
      units='s'
      call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
            memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rtime)
 
      i=0
      if(adapt_dt.eq.1) then
            i=i+1
            varname='dt'
            description='average timestep (this simulation used adaptive timestepping)'
            units='s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_w.eq.1) then
            i=i+1
            varname='wmax'
            description='maximum vertical velocity'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='wmin'
            description='minimum vertical velocity'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_u.eq.1) then
            i=i+1
            varname='umax'
            description='maximum E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='umin'
            description='minimum E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sumax'
            description='maximum surface E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sumin'
            description='minimum surface E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_v.eq.1) then
            i=i+1
            varname='vmax'
            description='maximum N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='vmin'
            description='minimum N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='svmax'
            description='maximum surface N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='svmin'
            description='minimum surface N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_rmw.eq.1) then
            i=i+1
            varname='rmw'
            description='radius of maximum windspeed'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='zmw'
            description='height of maximum windspeed'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_pipert.eq.1) then
            i=i+1
            varname='ppimax'
            description='maximum pi perturbation'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ppimin'
            description='minimum pi perturbation'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif

      if(stat_prspert.eq.1) then
            i=i+1
            varname='ppmax'
            description='maximum pressure perturbation'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ppmin'
            description='minimum pressure perturbation'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_thpert.eq.1) then
            i=i+1
            varname='thpmax'
            description='maximum potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='thpmin'
            description='minimum potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthpmax'
            description='maximum surface potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthpmin'
            description='minimum surface potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_q.eq.1) then
            do n=1,numq
                  text1='max     '
                  text2='max                           '
                  write(text1(4:6),156) qname(n)
                  write(text2(5:7),156) qname(n)
156 format(a3)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
                  text1='min     '
                  text2='min                           '
                  write(text1(4:6),156) qname(n)
                  write(text2(5:7),156) qname(n)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif

      if(stat_tke.eq.1) then
            i=i+1
            varname='tkemax'
            description='maximum turbulent kinetic energy'
            units='m^2/s^2'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tkemin'
            description='minimum turbulent kinetic energy'
            units='m^2/s^2'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_km.eq.1) then
            i=i+1
            varname='kmhmax'
            description='maximum horizontal eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='kmhmin'
            description='minimum horizontal eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='kmvmax'
            description='maximum vertical eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='kmvmin'
            description='minimum vertical eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_kh.eq.1) then
            i=i+1
            varname='khhmax'
            description='maximum horizontal eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='khhmin'
            description='minimum horizontal eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='khvmax'
            description='maximum vertical eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='khvmin'
            description='minimum vertical eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_div.eq.1) then
            i=i+1
            varname='divmax'
            description='maximum 3D divergence'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='divmin'
            description='minimum 3D divergence'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_rh.eq.1) then
            i=i+1
            varname='rhmax'
            description='maximum relative humidity'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='rhmin'
            description='minimum relative humidity'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_rhi.eq.1) then
            i=i+1
            varname='rhimax'
            description='maximum relative humidity wrt ice'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='rhimin'
            description='minimum relative humidity wrt ice'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if (iptra.eq.1) then
            do n=1,npt
                  text1='maxpt   '
                  text2='max pt                        '
                  write(text1(6:6),157) n
                  write(text2(7:7),157) n
157 format(i1)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
                  text1='minpt   '
                  text2='min pt                        '
                  write(text1(6:6),157) n
                  write(text2(7:7),157) n
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif
 
      if(stat_the.eq.1) then
            i=i+1
            varname='themax'
            description='maximum theta-e below 10 km'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='themin'
            description='minimum theta-e below 10 km'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthemax'
            description='maximum surface theta-e'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthemin'
            description='minimum surface theta-e'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_cloud.eq.1) then
            i=i+1
            varname='qctop'
            description='maximum cloud top height'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='qcbot'
            description='minimum cloud base height'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_sfcprs.eq.1) then
            i=i+1
            varname='sprsmax'
            description='maximum pressure lowest model level'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sprsmin'
            description='minumum pressure lowest model level'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='psfcmax'
            description='maximum surface pressure'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='psfcmin'
            description='minumum surface pressure'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_wsp.eq.1) then
            i=i+1
            varname='wspmax'
            description='maximum wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='wspmin'
            description='minumum wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='swspmax'
            description='maximum surface wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='swspmin'
            description='minumum surface wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            if(bbc.eq.3)then
                  i=i+1
                  varname='wsp10max'
                  description='maximum 10 m wind speed'
                  units='m/s'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
                  i=i+1
                  varname='wsp10min'
                  description='minimum 10 m wind speed'
                  units='m/s'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            endif
      endif
 
      if(stat_cfl.eq.1) then
            if(adapt_dt.eq.1) then
                  i=i+1
                  varname='cflmax'
                  description='maximum Courant number (average - model ran with adaptive time stepping)'
                  units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            else
                  i=i+1
                  varname='cflmax'
                  description='maximum Courant number'
                  units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            endif
 
            i=i+1
            varname='kshmax'
            description='maximum horizontal K stability factor'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='ksvmax'
            description='maximum vertical K stability factor'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if (stat_vort.eq.1) then
            i=i+1
            varname='vortsfc'
            description='maximum surface vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort1km'
            description='maximum 1 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort2km'
            description='maximum 2 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort3km'
            description='maximum 3 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort4km'
            description='maximum 4 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort5km'
            description='maximum 5 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_tmass.eq.1) then
            i=i+1
            varname='tmass'
            description='total mass of dry air'
            units='kg'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
      if(stat_tmois.eq.1) then
            i=i+1
            varname='tmois'
            description='total mass of water vapor in air (doublecheck)'
            units='kg'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
! Note, tmois seems to be same as massqv 
      if(stat_qmass.eq.1)then
            do n=1,numq
                  if( (n.eq.nqv) .or.                                 &
                      (n.ge.nql1.and.n.le.nql2) .or.                  &
                      (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )then
                            text1='mass    '
                            text2='total mass of                 '
                            write(text1( 5: 7),156) qname(n)
                            write(text2(15:17),156) qname(n)
 
                            i=i+1
                            varname=text1
                            description=text2
                            units='kg'
                            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
                   endif
             enddo
       endif
 
      if(stat_tenerg.eq.1) then
            i=i+1
            varname='ek'
            description='total kinetic energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ei'
            description='total internal energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ep'
            description='total potential energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='le'
            description='total latent energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='et'
            description='total energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_mo.eq.1) then
            i=i+1
            varname='tmu'
            description='total E-W momentum '
            units='kg m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tmv'
            description='total N-S momentum '
            units='kg m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tmw'
            description='total vertical momentum '
            units='kg m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_tmf.eq.1) then
            i=i+1
            varname='tmfu'
            description='total upward mass flux'
            units='kg/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tmfd'
            description='total downward mass flux'
            units='kg/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
      if(stat_pcn.eq.1)then
            do n=1,nbudget
                  text1='        '
                  text2='                              '
                  write(text1(1:6),158) budname(n)
                  write(text2(1:6),158) budname(n)
158 format(a6)
                  i=i+1
                  varname=text1
                  description=trim(text2)//' (microphysics water budget in qbudget array - try `grep qbudget solve.F`)'
                  units='kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif
 
      IF(stat_qsrc.eq.1)THEN
            do n=1,numq
                  text1='as      '
                  text2='artificial source of          '
                  write(text1( 3: 5),156) qname(n)
                  write(text2(22:24),156) qname(n)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
            do n=1,numq
                  text1='bs      '
                  text2='bndry source/sink of          '
                  write(text1( 3: 5),156) qname(n)
                  write(text2(22:24),156) qname(n)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif

! Note: i should now equal stat_out (see procXXXXX.out file) or something is wrong
      if (i .ne. stat_out) then
            print *, 'Number of stats written in writestat_hdf5: ',i 
            print *, 'Number of stats caculated in param: ',stat_out
            print *, 'These two must be equal, something is wrong, likely in writestat_hdf5'
            call h5close_f (ierror)
            call stopcm1
      endif

      nrec = nrec + 1
      call h5close_f (ierror)
#endif
! above endif matches #ifdef HDFOUT
      return
      end 
raddata3d.F     1587424407  1602  20    100644  206056    `
!
!##################################################################
!##################################################################
!######                                                      ######
!######                BLOCK DATA RADDATA                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!
  BLOCK DATA raddata
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Initialize pre-calculated look-up tables used in radiation
!  computation.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  03/15/1996
!
!  Combined all files of look-up tables used in radiation computation
!  into this file. Different tables are identified by different
!  COMMON block names.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: i, j, ip, iw
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "h2o.tran3", which define pre-computed tables used for h2o (bands
!  1, 2, and 7 only) transmittance calculations.
!
!-----------------------------------------------------------------------
!
!  integer nx,no,nc,nh,nt
!  parameter (nx=26,no=21,nc=24,nh=31,nt=7)
!
!-----------------------------------------------------------------------
!
! h2o.tran3

  REAL :: h11(26,31,7),h12(26,31,7),h13(26,31,7)
  REAL :: h21(26,31,7),h22(26,31,7),h23(26,31,7)
  REAL :: h71(26,31,7),h72(26,31,7),h73(26,31,7)

  COMMON /radtab001/ h11,h12,h13,h21,h22,h23,h71,h72,h73

  DATA ((h11(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.6160E-04,  0.9815E-04,  0.1474E-03,  0.2092E-03,  0.2823E-03,   &
      0.3662E-03,  0.4615E-03,  0.5710E-03,  0.6998E-03,  0.8554E-03,   &
      0.1049E-02,  0.1295E-02,  0.1612E-02,  0.2021E-02,  0.2548E-02,   &
      0.3230E-02,  0.4123E-02,  0.5306E-02,  0.6887E-02,  0.9021E-02,   &
      0.1193E-01,  0.1590E-01,  0.2135E-01,  0.2885E-01,  0.3914E-01,   &
      0.5317E-01,  0.7223E-01,  0.9800E-01,  0.1326E+00,  0.1783E+00,   &
      0.2373E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.2021E-06, -0.3628E-06, -0.5891E-06, -0.8735E-06, -0.1204E-05,  &
      -0.1579E-05, -0.2002E-05, -0.2494E-05, -0.3093E-05, -0.3852E-05,  &
      -0.4835E-05, -0.6082E-05, -0.7591E-05, -0.9332E-05, -0.1128E-04,  &
      -0.1347E-04, -0.1596E-04, -0.1890E-04, -0.2241E-04, -0.2672E-04,  &
      -0.3208E-04, -0.3884E-04, -0.4747E-04, -0.5854E-04, -0.7272E-04,  &
      -0.9092E-04, -0.1146E-03, -0.1458E-03, -0.1877E-03, -0.2435E-03,  &
      -0.3159E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.5907E-09,  0.8541E-09,  0.1095E-08,  0.1272E-08,  0.1297E-08,   &
      0.1105E-08,  0.6788E-09, -0.5585E-10, -0.1147E-08, -0.2746E-08,   &
      -0.5001E-08, -0.7715E-08, -0.1037E-07, -0.1227E-07, -0.1287E-07,  &
      -0.1175E-07, -0.8517E-08, -0.2920E-08,  0.4786E-08,  0.1407E-07,  &
      0.2476E-07,  0.3781E-07,  0.5633E-07,  0.8578E-07,  0.1322E-06,   &
      0.2013E-06,  0.3006E-06,  0.4409E-06,  0.6343E-06,  0.8896E-06,   &
      0.1216E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.6166E-04,  0.9828E-04,  0.1477E-03,  0.2097E-03,  0.2833E-03,   &
      0.3680E-03,  0.4648E-03,  0.5768E-03,  0.7101E-03,  0.8736E-03,   &
      0.1080E-02,  0.1348E-02,  0.1700E-02,  0.2162E-02,  0.2767E-02,   &
      0.3563E-02,  0.4621E-02,  0.6039E-02,  0.7953E-02,  0.1056E-01,   &
      0.1412E-01,  0.1901E-01,  0.2574E-01,  0.3498E-01,  0.4763E-01,   &
      0.6484E-01,  0.8815E-01,  0.1196E+00,  0.1614E+00,  0.2157E+00,   &
      0.2844E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.2017E-06, -0.3620E-06, -0.5878E-06, -0.8713E-06, -0.1201E-05,  &
      -0.1572E-05, -0.1991E-05, -0.2476E-05, -0.3063E-05, -0.3808E-05,  &
      -0.4776E-05, -0.6011E-05, -0.7516E-05, -0.9272E-05, -0.1127E-04,  &
      -0.1355E-04, -0.1620E-04, -0.1936E-04, -0.2321E-04, -0.2797E-04,  &
      -0.3399E-04, -0.4171E-04, -0.5172E-04, -0.6471E-04, -0.8150E-04,  &
      -0.1034E-03, -0.1321E-03, -0.1705E-03, -0.2217E-03, -0.2889E-03,  &
      -0.3726E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.5894E-09,  0.8519E-09,  0.1092E-08,  0.1267E-08,  0.1289E-08,   &
      0.1093E-08,  0.6601E-09, -0.7831E-10, -0.1167E-08, -0.2732E-08,   &
      -0.4864E-08, -0.7334E-08, -0.9581E-08, -0.1097E-07, -0.1094E-07,  &
      -0.8999E-08, -0.4669E-08,  0.2391E-08,  0.1215E-07,  0.2424E-07,  &
      0.3877E-07,  0.5711E-07,  0.8295E-07,  0.1218E-06,  0.1793E-06,   &
      0.2621E-06,  0.3812E-06,  0.5508E-06,  0.7824E-06,  0.1085E-05,   &
      0.1462E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.6175E-04,  0.9849E-04,  0.1481E-03,  0.2106E-03,  0.2849E-03,   &
      0.3708E-03,  0.4698E-03,  0.5857E-03,  0.7257E-03,  0.9006E-03,   &
      0.1126E-02,  0.1425E-02,  0.1823E-02,  0.2353E-02,  0.3059E-02,   &
      0.4002E-02,  0.5270E-02,  0.6984E-02,  0.9316E-02,  0.1251E-01,   &
      0.1689E-01,  0.2292E-01,  0.3123E-01,  0.4262E-01,  0.5814E-01,   &
      0.7921E-01,  0.1077E+00,  0.1458E+00,  0.1957E+00,  0.2595E+00,   &
      0.3380E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.2011E-06, -0.3609E-06, -0.5859E-06, -0.8680E-06, -0.1195E-05,  &
      -0.1563E-05, -0.1975E-05, -0.2450E-05, -0.3024E-05, -0.3755E-05,  &
      -0.4711E-05, -0.5941E-05, -0.7455E-05, -0.9248E-05, -0.1132E-04,  &
      -0.1373E-04, -0.1659E-04, -0.2004E-04, -0.2431E-04, -0.2966E-04,  &
      -0.3653E-04, -0.4549E-04, -0.5724E-04, -0.7259E-04, -0.9265E-04,  &
      -0.1191E-03, -0.1543E-03, -0.2013E-03, -0.2633E-03, -0.3421E-03,  &
      -0.4350E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.5872E-09,  0.8484E-09,  0.1087E-08,  0.1259E-08,  0.1279E-08,   &
      0.1077E-08,  0.6413E-09, -0.9334E-10, -0.1161E-08, -0.2644E-08,   &
      -0.4588E-08, -0.6709E-08, -0.8474E-08, -0.9263E-08, -0.8489E-08,  &
      -0.5553E-08,  0.1203E-09,  0.9035E-08,  0.2135E-07,  0.3689E-07,  &
      0.5610E-07,  0.8097E-07,  0.1155E-06,  0.1649E-06,  0.2350E-06,   &
      0.3353E-06,  0.4806E-06,  0.6858E-06,  0.9617E-06,  0.1315E-05,   &
      0.1741E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.6189E-04,  0.9882E-04,  0.1488E-03,  0.2119E-03,  0.2873E-03,   &
      0.3752E-03,  0.4776E-03,  0.5993E-03,  0.7490E-03,  0.9403E-03,   &
      0.1192E-02,  0.1531E-02,  0.1990E-02,  0.2610E-02,  0.3446E-02,   &
      0.4576E-02,  0.6109E-02,  0.8196E-02,  0.1105E-01,  0.1498E-01,   &
      0.2039E-01,  0.2785E-01,  0.3809E-01,  0.5209E-01,  0.7112E-01,   &
      0.9688E-01,  0.1315E+00,  0.1773E+00,  0.2363E+00,  0.3100E+00,   &
      0.3976E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.2001E-06, -0.3592E-06, -0.5829E-06, -0.8631E-06, -0.1187E-05,  &
      -0.1549E-05, -0.1953E-05, -0.2415E-05, -0.2975E-05, -0.3694E-05,  &
      -0.4645E-05, -0.5882E-05, -0.7425E-05, -0.9279E-05, -0.1147E-04,  &
      -0.1406E-04, -0.1717E-04, -0.2100E-04, -0.2580E-04, -0.3191E-04,  &
      -0.3989E-04, -0.5042E-04, -0.6432E-04, -0.8261E-04, -0.1068E-03,  &
      -0.1389E-03, -0.1820E-03, -0.2391E-03, -0.3127E-03, -0.4021E-03,  &
      -0.5002E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.5838E-09,  0.8426E-09,  0.1081E-08,  0.1249E-08,  0.1267E-08,   &
      0.1062E-08,  0.6313E-09, -0.8241E-10, -0.1094E-08, -0.2436E-08,   &
      -0.4100E-08, -0.5786E-08, -0.6992E-08, -0.7083E-08, -0.5405E-08,  &
      -0.1259E-08,  0.6099E-08,  0.1732E-07,  0.3276E-07,  0.5256E-07,  &
      0.7756E-07,  0.1103E-06,  0.1547E-06,  0.2159E-06,  0.3016E-06,   &
      0.4251E-06,  0.6033E-06,  0.8499E-06,  0.1175E-05,  0.1579E-05,   &
      0.2044E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.6211E-04,  0.9932E-04,  0.1499E-03,  0.2140E-03,  0.2911E-03,   &
      0.3820E-03,  0.4895E-03,  0.6196E-03,  0.7834E-03,  0.9973E-03,   &
      0.1285E-02,  0.1678E-02,  0.2216E-02,  0.2951E-02,  0.3953E-02,   &
      0.5319E-02,  0.7186E-02,  0.9743E-02,  0.1326E-01,  0.1811E-01,   &
      0.2479E-01,  0.3400E-01,  0.4662E-01,  0.6379E-01,  0.8708E-01,   &
      0.1185E+00,  0.1603E+00,  0.2147E+00,  0.2835E+00,  0.3667E+00,   &
      0.4620E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.1987E-06, -0.3565E-06, -0.5784E-06, -0.8557E-06, -0.1175E-05,  &
      -0.1530E-05, -0.1923E-05, -0.2372E-05, -0.2919E-05, -0.3631E-05,  &
      -0.4587E-05, -0.5848E-05, -0.7442E-05, -0.9391E-05, -0.1173E-04,  &
      -0.1455E-04, -0.1801E-04, -0.2232E-04, -0.2779E-04, -0.3489E-04,  &
      -0.4428E-04, -0.5678E-04, -0.7333E-04, -0.9530E-04, -0.1246E-03,  &
      -0.1639E-03, -0.2164E-03, -0.2848E-03, -0.3697E-03, -0.4665E-03,  &
      -0.5646E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.5785E-09,  0.8338E-09,  0.1071E-08,  0.1239E-08,  0.1256E-08,   &
      0.1057E-08,  0.6480E-09, -0.1793E-10, -0.9278E-09, -0.2051E-08,   &
      -0.3337E-08, -0.4514E-08, -0.5067E-08, -0.4328E-08, -0.1545E-08,  &
      0.4100E-08,  0.1354E-07,  0.2762E-07,  0.4690E-07,  0.7190E-07,   &
      0.1040E-06,  0.1459E-06,  0.2014E-06,  0.2764E-06,  0.3824E-06,   &
      0.5359E-06,  0.7532E-06,  0.1047E-05,  0.1424E-05,  0.1873E-05,   &
      0.2356E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.6246E-04,  0.1001E-03,  0.1515E-03,  0.2171E-03,  0.2970E-03,   &
      0.3924E-03,  0.5072E-03,  0.6495E-03,  0.8329E-03,  0.1078E-02,   &
      0.1413E-02,  0.1876E-02,  0.2516E-02,  0.3399E-02,  0.4612E-02,   &
      0.6276E-02,  0.8562E-02,  0.1171E-01,  0.1605E-01,  0.2205E-01,   &
      0.3032E-01,  0.4167E-01,  0.5717E-01,  0.7821E-01,  0.1067E+00,   &
      0.1447E+00,  0.1948E+00,  0.2586E+00,  0.3372E+00,  0.4290E+00,   &
      0.5295E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.1964E-06, -0.3526E-06, -0.5717E-06, -0.8451E-06, -0.1158E-05,  &
      -0.1504E-05, -0.1886E-05, -0.2322E-05, -0.2861E-05, -0.3576E-05,  &
      -0.4552E-05, -0.5856E-05, -0.7529E-05, -0.9609E-05, -0.1216E-04,  &
      -0.1528E-04, -0.1916E-04, -0.2408E-04, -0.3043E-04, -0.3880E-04,  &
      -0.4997E-04, -0.6488E-04, -0.8474E-04, -0.1113E-03, -0.1471E-03,  &
      -0.1950E-03, -0.2583E-03, -0.3384E-03, -0.4326E-03, -0.5319E-03,  &
      -0.6244E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.5713E-09,  0.8263E-09,  0.1060E-08,  0.1226E-08,  0.1252E-08,   &
      0.1076E-08,  0.7149E-09,  0.1379E-09, -0.6043E-09, -0.1417E-08,   &
      -0.2241E-08, -0.2830E-08, -0.2627E-08, -0.8950E-09,  0.3231E-08,  &
      0.1075E-07,  0.2278E-07,  0.4037E-07,  0.6439E-07,  0.9576E-07,   &
      0.1363E-06,  0.1886E-06,  0.2567E-06,  0.3494E-06,  0.4821E-06,   &
      0.6719E-06,  0.9343E-06,  0.1280E-05,  0.1705E-05,  0.2184E-05,   &
      0.2651E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.6299E-04,  0.1013E-03,  0.1541E-03,  0.2220E-03,  0.3058E-03,   &
      0.4078E-03,  0.5334E-03,  0.6928E-03,  0.9032E-03,  0.1190E-02,   &
      0.1587E-02,  0.2140E-02,  0.2912E-02,  0.3982E-02,  0.5460E-02,   &
      0.7500E-02,  0.1031E-01,  0.1420E-01,  0.1958E-01,  0.2700E-01,   &
      0.3721E-01,  0.5118E-01,  0.7019E-01,  0.9593E-01,  0.1305E+00,   &
      0.1763E+00,  0.2354E+00,  0.3091E+00,  0.3969E+00,  0.4952E+00,   &
      0.5978E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.1932E-06, -0.3467E-06, -0.5623E-06, -0.8306E-06, -0.1136E-05,  &
      -0.1472E-05, -0.1842E-05, -0.2269E-05, -0.2807E-05, -0.3539E-05,  &
      -0.4553E-05, -0.5925E-05, -0.7710E-05, -0.9968E-05, -0.1278E-04,  &
      -0.1629E-04, -0.2073E-04, -0.2644E-04, -0.3392E-04, -0.4390E-04,  &
      -0.5727E-04, -0.7516E-04, -0.9916E-04, -0.1315E-03, -0.1752E-03,  &
      -0.2333E-03, -0.3082E-03, -0.3988E-03, -0.4982E-03, -0.5947E-03,  &
      -0.6764E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.5612E-09,  0.8116E-09,  0.1048E-08,  0.1222E-08,  0.1270E-08,   &
      0.1141E-08,  0.8732E-09,  0.4336E-09, -0.6548E-10, -0.4774E-09,   &
      -0.7556E-09, -0.6577E-09,  0.4377E-09,  0.3359E-08,  0.9159E-08,  &
      0.1901E-07,  0.3422E-07,  0.5616E-07,  0.8598E-07,  0.1251E-06,   &
      0.1752E-06,  0.2392E-06,  0.3228E-06,  0.4389E-06,  0.6049E-06,   &
      0.8370E-06,  0.1150E-05,  0.1547E-05,  0.2012E-05,  0.2493E-05,   &
      0.2913E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.6378E-04,  0.1032E-03,  0.1579E-03,  0.2293E-03,  0.3190E-03,   &
      0.4305E-03,  0.5712E-03,  0.7541E-03,  0.1001E-02,  0.1342E-02,   &
      0.1819E-02,  0.2489E-02,  0.3427E-02,  0.4734E-02,  0.6548E-02,   &
      0.9059E-02,  0.1254E-01,  0.1735E-01,  0.2401E-01,  0.3318E-01,   &
      0.4577E-01,  0.6292E-01,  0.8620E-01,  0.1176E+00,  0.1594E+00,   &
      0.2139E+00,  0.2827E+00,  0.3660E+00,  0.4614E+00,  0.5634E+00,   &
      0.6649E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.1885E-06, -0.3385E-06, -0.5493E-06, -0.8114E-06, -0.1109E-05,  &
      -0.1436E-05, -0.1796E-05, -0.2219E-05, -0.2770E-05, -0.3535E-05,  &
      -0.4609E-05, -0.6077E-05, -0.8016E-05, -0.1051E-04, -0.1367E-04,  &
      -0.1768E-04, -0.2283E-04, -0.2955E-04, -0.3849E-04, -0.5046E-04,  &
      -0.6653E-04, -0.8813E-04, -0.1173E-03, -0.1569E-03, -0.2100E-03,  &
      -0.2794E-03, -0.3656E-03, -0.4637E-03, -0.5629E-03, -0.6512E-03,  &
      -0.7167E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.5477E-09,  0.8000E-09,  0.1039E-08,  0.1234E-08,  0.1331E-08,   &
      0.1295E-08,  0.1160E-08,  0.9178E-09,  0.7535E-09,  0.8301E-09,   &
      0.1184E-08,  0.2082E-08,  0.4253E-08,  0.8646E-08,  0.1650E-07,   &
      0.2920E-07,  0.4834E-07,  0.7564E-07,  0.1125E-06,  0.1606E-06,   &
      0.2216E-06,  0.2992E-06,  0.4031E-06,  0.5493E-06,  0.7549E-06,   &
      0.1035E-05,  0.1400E-05,  0.1843E-05,  0.2327E-05,  0.2774E-05,   &
      0.3143E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.6495E-04,  0.1059E-03,  0.1635E-03,  0.2400E-03,  0.3381E-03,   &
      0.4631E-03,  0.6246E-03,  0.8394E-03,  0.1134E-02,  0.1546E-02,   &
      0.2126E-02,  0.2944E-02,  0.4093E-02,  0.5699E-02,  0.7934E-02,   &
      0.1104E-01,  0.1535E-01,  0.2131E-01,  0.2956E-01,  0.4089E-01,   &
      0.5636E-01,  0.7739E-01,  0.1058E+00,  0.1439E+00,  0.1939E+00,   &
      0.2578E+00,  0.3364E+00,  0.4283E+00,  0.5290E+00,  0.6314E+00,   &
      0.7292E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.1822E-06, -0.3274E-06, -0.5325E-06, -0.7881E-06, -0.1079E-05,  &
      -0.1398E-05, -0.1754E-05, -0.2184E-05, -0.2763E-05, -0.3581E-05,  &
      -0.4739E-05, -0.6341E-05, -0.8484E-05, -0.1128E-04, -0.1490E-04,  &
      -0.1955E-04, -0.2561E-04, -0.3364E-04, -0.4438E-04, -0.5881E-04,  &
      -0.7822E-04, -0.1045E-03, -0.1401E-03, -0.1884E-03, -0.2523E-03,  &
      -0.3335E-03, -0.4289E-03, -0.5296E-03, -0.6231E-03, -0.6980E-03,  &
      -0.7406E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.5334E-09,  0.7859E-09,  0.1043E-08,  0.1279E-08,  0.1460E-08,   &
      0.1560E-08,  0.1618E-08,  0.1657E-08,  0.1912E-08,  0.2569E-08,   &
      0.3654E-08,  0.5509E-08,  0.8964E-08,  0.1518E-07,  0.2560E-07,   &
      0.4178E-07,  0.6574E-07,  0.9958E-07,  0.1449E-06,  0.2031E-06,   &
      0.2766E-06,  0.3718E-06,  0.5022E-06,  0.6849E-06,  0.9360E-06,   &
      0.1268E-05,  0.1683E-05,  0.2157E-05,  0.2625E-05,  0.3020E-05,   &
      0.3364E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.6661E-04,  0.1098E-03,  0.1716E-03,  0.2554E-03,  0.3653E-03,   &
      0.5088E-03,  0.6986E-03,  0.9557E-03,  0.1313E-02,  0.1816E-02,   &
      0.2527E-02,  0.3532E-02,  0.4947E-02,  0.6929E-02,  0.9694E-02,   &
      0.1354E-01,  0.1888E-01,  0.2628E-01,  0.3647E-01,  0.5043E-01,   &
      0.6941E-01,  0.9514E-01,  0.1297E+00,  0.1755E+00,  0.2347E+00,   &
      0.3084E+00,  0.3962E+00,  0.4947E+00,  0.5974E+00,  0.6973E+00,   &
      0.7898E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.1742E-06, -0.3134E-06, -0.5121E-06, -0.7619E-06, -0.1048E-05,  &
      -0.1364E-05, -0.1725E-05, -0.2177E-05, -0.2801E-05, -0.3694E-05,  &
      -0.4969E-05, -0.6748E-05, -0.9161E-05, -0.1236E-04, -0.1655E-04,  &
      -0.2203E-04, -0.2927E-04, -0.3894E-04, -0.5192E-04, -0.6936E-04,  &
      -0.9294E-04, -0.1250E-03, -0.1686E-03, -0.2271E-03, -0.3027E-03,  &
      -0.3944E-03, -0.4951E-03, -0.5928E-03, -0.6755E-03, -0.7309E-03,  &
      -0.7417E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.5179E-09,  0.7789E-09,  0.1071E-08,  0.1382E-08,  0.1690E-08,   &
      0.1979E-08,  0.2297E-08,  0.2704E-08,  0.3466E-08,  0.4794E-08,   &
      0.6746E-08,  0.9739E-08,  0.1481E-07,  0.2331E-07,  0.3679E-07,   &
      0.5726E-07,  0.8716E-07,  0.1289E-06,  0.1837E-06,  0.2534E-06,   &
      0.3424E-06,  0.4609E-06,  0.6245E-06,  0.8495E-06,  0.1151E-05,   &
      0.1536E-05,  0.1991E-05,  0.2468E-05,  0.2891E-05,  0.3245E-05,   &
      0.3580E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.6888E-04,  0.1151E-03,  0.1828E-03,  0.2766E-03,  0.4028E-03,   &
      0.5713E-03,  0.7987E-03,  0.1111E-02,  0.1548E-02,  0.2167E-02,   &
      0.3044E-02,  0.4285E-02,  0.6035E-02,  0.8490E-02,  0.1192E-01,   &
      0.1670E-01,  0.2333E-01,  0.3249E-01,  0.4506E-01,  0.6220E-01,   &
      0.8546E-01,  0.1168E+00,  0.1587E+00,  0.2131E+00,  0.2820E+00,   &
      0.3653E+00,  0.4609E+00,  0.5630E+00,  0.6645E+00,  0.7599E+00,   &
      0.8458E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.1647E-06, -0.2974E-06, -0.4900E-06, -0.7358E-06, -0.1022E-05,  &
      -0.1344E-05, -0.1721E-05, -0.2212E-05, -0.2901E-05, -0.3896E-05,  &
      -0.5327E-05, -0.7342E-05, -0.1011E-04, -0.1382E-04, -0.1875E-04,  &
      -0.2530E-04, -0.3403E-04, -0.4573E-04, -0.6145E-04, -0.8264E-04,  &
      -0.1114E-03, -0.1507E-03, -0.2039E-03, -0.2737E-03, -0.3607E-03,  &
      -0.4599E-03, -0.5604E-03, -0.6497E-03, -0.7161E-03, -0.7443E-03,  &
      -0.7133E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.5073E-09,  0.7906E-09,  0.1134E-08,  0.1560E-08,  0.2046E-08,   &
      0.2589E-08,  0.3254E-08,  0.4107E-08,  0.5481E-08,  0.7602E-08,   &
      0.1059E-07,  0.1501E-07,  0.2210E-07,  0.3334E-07,  0.5055E-07,   &
      0.7629E-07,  0.1134E-06,  0.1642E-06,  0.2298E-06,  0.3133E-06,   &
      0.4225E-06,  0.5709E-06,  0.7739E-06,  0.1047E-05,  0.1401E-05,   &
      0.1833E-05,  0.2308E-05,  0.2753E-05,  0.3125E-05,  0.3467E-05,   &
      0.3748E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.7179E-04,  0.1221E-03,  0.1975E-03,  0.3049E-03,  0.4529E-03,   &
      0.6547E-03,  0.9312E-03,  0.1315E-02,  0.1855E-02,  0.2620E-02,   &
      0.3705E-02,  0.5243E-02,  0.7414E-02,  0.1046E-01,  0.1472E-01,   &
      0.2065E-01,  0.2888E-01,  0.4019E-01,  0.5566E-01,  0.7668E-01,   &
      0.1051E+00,  0.1432E+00,  0.1932E+00,  0.2571E+00,  0.3358E+00,   &
      0.4278E+00,  0.5285E+00,  0.6310E+00,  0.7289E+00,  0.8184E+00,   &
      0.8954E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.1548E-06, -0.2808E-06, -0.4683E-06, -0.7142E-06, -0.1008E-05,  &
      -0.1347E-05, -0.1758E-05, -0.2306E-05, -0.3083E-05, -0.4214E-05,  &
      -0.5851E-05, -0.8175E-05, -0.1140E-04, -0.1577E-04, -0.2166E-04,  &
      -0.2955E-04, -0.4014E-04, -0.5434E-04, -0.7343E-04, -0.9931E-04,  &
      -0.1346E-03, -0.1826E-03, -0.2467E-03, -0.3283E-03, -0.4246E-03,  &
      -0.5264E-03, -0.6211E-03, -0.6970E-03, -0.7402E-03, -0.7316E-03,  &
      -0.6486E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.5078E-09,  0.8244E-09,  0.1255E-08,  0.1826E-08,  0.2550E-08,   &
      0.3438E-08,  0.4532E-08,  0.5949E-08,  0.8041E-08,  0.1110E-07,   &
      0.1534E-07,  0.2157E-07,  0.3116E-07,  0.4570E-07,  0.6747E-07,   &
      0.9961E-07,  0.1451E-06,  0.2061E-06,  0.2843E-06,  0.3855E-06,   &
      0.5213E-06,  0.7060E-06,  0.9544E-06,  0.1280E-05,  0.1684E-05,   &
      0.2148E-05,  0.2609E-05,  0.3002E-05,  0.3349E-05,  0.3670E-05,   &
      0.3780E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.7529E-04,  0.1306E-03,  0.2160E-03,  0.3410E-03,  0.5175E-03,   &
      0.7626E-03,  0.1103E-02,  0.1577E-02,  0.2246E-02,  0.3196E-02,   &
      0.4544E-02,  0.6455E-02,  0.9152E-02,  0.1294E-01,  0.1823E-01,   &
      0.2560E-01,  0.3577E-01,  0.4971E-01,  0.6870E-01,  0.9443E-01,   &
      0.1290E+00,  0.1748E+00,  0.2340E+00,  0.3078E+00,  0.3956E+00,   &
      0.4942E+00,  0.5969E+00,  0.6970E+00,  0.7896E+00,  0.8714E+00,   &
      0.9364E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.1461E-06, -0.2663E-06, -0.4512E-06, -0.7027E-06, -0.1014E-05,  &
      -0.1387E-05, -0.1851E-05, -0.2478E-05, -0.3373E-05, -0.4682E-05,  &
      -0.6588E-05, -0.9311E-05, -0.1311E-04, -0.1834E-04, -0.2544E-04,  &
      -0.3502E-04, -0.4789E-04, -0.6515E-04, -0.8846E-04, -0.1202E-03,  &
      -0.1635E-03, -0.2217E-03, -0.2975E-03, -0.3897E-03, -0.4913E-03,  &
      -0.5902E-03, -0.6740E-03, -0.7302E-03, -0.7415E-03, -0.6858E-03,  &
      -0.5447E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.5236E-09,  0.8873E-09,  0.1426E-08,  0.2193E-08,  0.3230E-08,   &
      0.4555E-08,  0.6200E-08,  0.8298E-08,  0.1126E-07,  0.1544E-07,   &
      0.2130E-07,  0.2978E-07,  0.4239E-07,  0.6096E-07,  0.8829E-07,   &
      0.1280E-06,  0.1830E-06,  0.2555E-06,  0.3493E-06,  0.4740E-06,   &
      0.6431E-06,  0.8701E-06,  0.1169E-05,  0.1547E-05,  0.1992E-05,   &
      0.2460E-05,  0.2877E-05,  0.3230E-05,  0.3569E-05,  0.3782E-05,   &
      0.3591E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.7911E-04,  0.1403E-03,  0.2378E-03,  0.3847E-03,  0.5973E-03,   &
      0.8978E-03,  0.1319E-02,  0.1909E-02,  0.2741E-02,  0.3923E-02,   &
      0.5600E-02,  0.7977E-02,  0.1133E-01,  0.1604E-01,  0.2262E-01,   &
      0.3174E-01,  0.4429E-01,  0.6143E-01,  0.8469E-01,  0.1161E+00,   &
      0.1579E+00,  0.2124E+00,  0.2813E+00,  0.3647E+00,  0.4603E+00,   &
      0.5625E+00,  0.6641E+00,  0.7596E+00,  0.8456E+00,  0.9170E+00,   &
      0.9670E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.1402E-06, -0.2569E-06, -0.4428E-06, -0.7076E-06, -0.1051E-05,  &
      -0.1478E-05, -0.2019E-05, -0.2752E-05, -0.3802E-05, -0.5343E-05,  &
      -0.7594E-05, -0.1082E-04, -0.1536E-04, -0.2166E-04, -0.3028E-04,  &
      -0.4195E-04, -0.5761E-04, -0.7867E-04, -0.1072E-03, -0.1462E-03,  &
      -0.1990E-03, -0.2687E-03, -0.3559E-03, -0.4558E-03, -0.5572E-03,  &
      -0.6476E-03, -0.7150E-03, -0.7439E-03, -0.7133E-03, -0.6015E-03,  &
      -0.4089E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.5531E-09,  0.9757E-09,  0.1644E-08,  0.2650E-08,  0.4074E-08,   &
      0.5957E-08,  0.8314E-08,  0.1128E-07,  0.1528E-07,  0.2087E-07,   &
      0.2874E-07,  0.4002E-07,  0.5631E-07,  0.7981E-07,  0.1139E-06,   &
      0.1621E-06,  0.2275E-06,  0.3136E-06,  0.4280E-06,  0.5829E-06,   &
      0.7917E-06,  0.1067E-05,  0.1419E-05,  0.1844E-05,  0.2310E-05,   &
      0.2747E-05,  0.3113E-05,  0.3455E-05,  0.3739E-05,  0.3715E-05,   &
      0.3125E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.8292E-04,  0.1503E-03,  0.2614E-03,  0.4345E-03,  0.6915E-03,   &
      0.1061E-02,  0.1584E-02,  0.2320E-02,  0.3359E-02,  0.4831E-02,   &
      0.6920E-02,  0.9877E-02,  0.1405E-01,  0.1990E-01,  0.2805E-01,   &
      0.3933E-01,  0.5477E-01,  0.7579E-01,  0.1042E+00,  0.1423E+00,   &
      0.1924E+00,  0.2564E+00,  0.3351E+00,  0.4271E+00,  0.5280E+00,   &
      0.6306E+00,  0.7286E+00,  0.8182E+00,  0.8952E+00,  0.9530E+00,   &
      0.9864E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.1378E-06, -0.2542E-06, -0.4461E-06, -0.7333E-06, -0.1125E-05,  &
      -0.1630E-05, -0.2281E-05, -0.3159E-05, -0.4410E-05, -0.6246E-05,  &
      -0.8933E-05, -0.1280E-04, -0.1826E-04, -0.2589E-04, -0.3639E-04,  &
      -0.5059E-04, -0.6970E-04, -0.9552E-04, -0.1307E-03, -0.1784E-03,  &
      -0.2422E-03, -0.3237E-03, -0.4203E-03, -0.5227E-03, -0.6184E-03,  &
      -0.6953E-03, -0.7395E-03, -0.7315E-03, -0.6487E-03, -0.4799E-03,  &
      -0.2625E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.5891E-09,  0.1074E-08,  0.1885E-08,  0.3167E-08,  0.5051E-08,   &
      0.7631E-08,  0.1092E-07,  0.1500E-07,  0.2032E-07,  0.2769E-07,   &
      0.3810E-07,  0.5279E-07,  0.7361E-07,  0.1032E-06,  0.1450E-06,   &
      0.2026E-06,  0.2798E-06,  0.3832E-06,  0.5242E-06,  0.7159E-06,   &
      0.9706E-06,  0.1299E-05,  0.1701E-05,  0.2159E-05,  0.2612E-05,   &
      0.2998E-05,  0.3341E-05,  0.3661E-05,  0.3775E-05,  0.3393E-05,   &
      0.2384E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.8637E-04,  0.1598E-03,  0.2853E-03,  0.4876E-03,  0.7970E-03,   &
      0.1251E-02,  0.1901E-02,  0.2820E-02,  0.4118E-02,  0.5955E-02,   &
      0.8557E-02,  0.1224E-01,  0.1742E-01,  0.2467E-01,  0.3476E-01,   &
      0.4864E-01,  0.6759E-01,  0.9332E-01,  0.1280E+00,  0.1738E+00,   &
      0.2330E+00,  0.3069E+00,  0.3949E+00,  0.4935E+00,  0.5964E+00,   &
      0.6965E+00,  0.7893E+00,  0.8713E+00,  0.9363E+00,  0.9780E+00,   &
      0.9961E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.1383E-06, -0.2577E-06, -0.4608E-06, -0.7793E-06, -0.1237E-05,  &
      -0.1850E-05, -0.2652E-05, -0.3728E-05, -0.5244E-05, -0.7451E-05,  &
      -0.1067E-04, -0.1532E-04, -0.2193E-04, -0.3119E-04, -0.4395E-04,  &
      -0.6126E-04, -0.8466E-04, -0.1164E-03, -0.1596E-03, -0.2177E-03,  &
      -0.2933E-03, -0.3855E-03, -0.4874E-03, -0.5870E-03, -0.6718E-03,  &
      -0.7290E-03, -0.7411E-03, -0.6859E-03, -0.5450E-03, -0.3353E-03,  &
      -0.1363E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.6217E-09,  0.1165E-08,  0.2116E-08,  0.3685E-08,  0.6101E-08,   &
      0.9523E-08,  0.1400E-07,  0.1959E-07,  0.2668E-07,  0.3629E-07,   &
      0.4982E-07,  0.6876E-07,  0.9523E-07,  0.1321E-06,  0.1825E-06,   &
      0.2505E-06,  0.3420E-06,  0.4677E-06,  0.6416E-06,  0.8760E-06,   &
      0.1183E-05,  0.1565E-05,  0.2010E-05,  0.2472E-05,  0.2882E-05,   &
      0.3229E-05,  0.3564E-05,  0.3777E-05,  0.3589E-05,  0.2786E-05,   &
      0.1487E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.8925E-04,  0.1682E-03,  0.3074E-03,  0.5403E-03,  0.9085E-03,   &
      0.1463E-02,  0.2268E-02,  0.3416E-02,  0.5040E-02,  0.7333E-02,   &
      0.1057E-01,  0.1515E-01,  0.2157E-01,  0.3055E-01,  0.4297E-01,   &
      0.6001E-01,  0.8323E-01,  0.1146E+00,  0.1565E+00,  0.2111E+00,   &
      0.2801E+00,  0.3636E+00,  0.4594E+00,  0.5618E+00,  0.6636E+00,   &
      0.7592E+00,  0.8454E+00,  0.9169E+00,  0.9669E+00,  0.9923E+00,   &
      0.9995E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.1405E-06, -0.2649E-06, -0.4829E-06, -0.8398E-06, -0.1379E-05,  &
      -0.2132E-05, -0.3138E-05, -0.4487E-05, -0.6353E-05, -0.9026E-05,  &
      -0.1290E-04, -0.1851E-04, -0.2650E-04, -0.3772E-04, -0.5319E-04,  &
      -0.7431E-04, -0.1031E-03, -0.1422E-03, -0.1951E-03, -0.2648E-03,  &
      -0.3519E-03, -0.4518E-03, -0.5537E-03, -0.6449E-03, -0.7133E-03,  &
      -0.7432E-03, -0.7133E-03, -0.6018E-03, -0.4092E-03, -0.1951E-03,  &
      -0.5345E-04/
  DATA ((h13(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.6457E-09,  0.1235E-08,  0.2303E-08,  0.4149E-08,  0.7120E-08,   &
      0.1152E-07,  0.1749E-07,  0.2508E-07,  0.3462E-07,  0.4718E-07,   &
      0.6452E-07,  0.8874E-07,  0.1222E-06,  0.1675E-06,  0.2276E-06,   &
      0.3076E-06,  0.4174E-06,  0.5714E-06,  0.7837E-06,  0.1067E-05,   &
      0.1428E-05,  0.1859E-05,  0.2327E-05,  0.2760E-05,  0.3122E-05,   &
      0.3458E-05,  0.3739E-05,  0.3715E-05,  0.3126E-05,  0.1942E-05,   &
      0.6977E-06/
  DATA ((h11(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.9151E-04,  0.1750E-03,  0.3265E-03,  0.5891E-03,  0.1020E-02,   &
      0.1688E-02,  0.2679E-02,  0.4109E-02,  0.6138E-02,  0.9002E-02,   &
      0.1304E-01,  0.1871E-01,  0.2667E-01,  0.3773E-01,  0.5299E-01,   &
      0.7386E-01,  0.1022E+00,  0.1403E+00,  0.1905E+00,  0.2546E+00,   &
      0.3335E+00,  0.4258E+00,  0.5269E+00,  0.6297E+00,  0.7280E+00,   &
      0.8178E+00,  0.8950E+00,  0.9529E+00,  0.9864E+00,  0.9983E+00,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.1431E-06, -0.2731E-06, -0.5072E-06, -0.9057E-06, -0.1537E-05,  &
      -0.2460E-05, -0.3733E-05, -0.5449E-05, -0.7786E-05, -0.1106E-04,  &
      -0.1574E-04, -0.2249E-04, -0.3212E-04, -0.4564E-04, -0.6438E-04,  &
      -0.9019E-04, -0.1256E-03, -0.1737E-03, -0.2378E-03, -0.3196E-03,  &
      -0.4163E-03, -0.5191E-03, -0.6154E-03, -0.6931E-03, -0.7384E-03,  &
      -0.7313E-03, -0.6492E-03, -0.4805E-03, -0.2629E-03, -0.8897E-04,  &
      -0.1432E-04/
  DATA ((h13(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.6607E-09,  0.1282E-08,  0.2441E-08,  0.4522E-08,  0.8027E-08,   &
      0.1348E-07,  0.2122E-07,  0.3139E-07,  0.4435E-07,  0.6095E-07,   &
      0.8319E-07,  0.1139E-06,  0.1557E-06,  0.2107E-06,  0.2819E-06,   &
      0.3773E-06,  0.5107E-06,  0.6982E-06,  0.9542E-06,  0.1290E-05,   &
      0.1703E-05,  0.2170E-05,  0.2628E-05,  0.3013E-05,  0.3352E-05,   &
      0.3669E-05,  0.3780E-05,  0.3397E-05,  0.2386E-05,  0.1062E-05,   &
      0.2216E-06/
  DATA ((h11(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.9320E-04,  0.1803E-03,  0.3422E-03,  0.6317E-03,  0.1124E-02,   &
      0.1915E-02,  0.3121E-02,  0.4890E-02,  0.7421E-02,  0.1100E-01,   &
      0.1602E-01,  0.2306E-01,  0.3288E-01,  0.4647E-01,  0.6515E-01,   &
      0.9066E-01,  0.1252E+00,  0.1710E+00,  0.2304E+00,  0.3045E+00,   &
      0.3928E+00,  0.4918E+00,  0.5951E+00,  0.6956E+00,  0.7887E+00,   &
      0.8709E+00,  0.9361E+00,  0.9780E+00,  0.9961E+00,  0.9999E+00,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.1454E-06, -0.2805E-06, -0.5296E-06, -0.9685E-06, -0.1695E-05,  &
      -0.2812E-05, -0.4412E-05, -0.6606E-05, -0.9573E-05, -0.1363E-04,  &
      -0.1932E-04, -0.2743E-04, -0.3897E-04, -0.5520E-04, -0.7787E-04,  &
      -0.1094E-03, -0.1529E-03, -0.2117E-03, -0.2880E-03, -0.3809E-03,  &
      -0.4834E-03, -0.5836E-03, -0.6692E-03, -0.7275E-03, -0.7408E-03,  &
      -0.6865E-03, -0.5459E-03, -0.3360E-03, -0.1365E-03, -0.2935E-04,  &
      -0.2173E-05/
  DATA ((h13(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.6693E-09,  0.1312E-08,  0.2538E-08,  0.4802E-08,  0.8778E-08,   &
      0.1528E-07,  0.2501E-07,  0.3836E-07,  0.5578E-07,  0.7806E-07,   &
      0.1069E-06,  0.1456E-06,  0.1970E-06,  0.2631E-06,  0.3485E-06,   &
      0.4642E-06,  0.6268E-06,  0.8526E-06,  0.1157E-05,  0.1545E-05,   &
      0.2002E-05,  0.2478E-05,  0.2897E-05,  0.3245E-05,  0.3578E-05,   &
      0.3789E-05,  0.3598E-05,  0.2792E-05,  0.1489E-05,  0.4160E-06,   &
      0.3843E-07/
  DATA ((h11(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.9443E-04,  0.1843E-03,  0.3545E-03,  0.6669E-03,  0.1217E-02,   &
      0.2133E-02,  0.3577E-02,  0.5742E-02,  0.8880E-02,  0.1333E-01,   &
      0.1958E-01,  0.2830E-01,  0.4039E-01,  0.5705E-01,  0.7988E-01,   &
      0.1110E+00,  0.1526E+00,  0.2072E+00,  0.2764E+00,  0.3604E+00,   &
      0.4567E+00,  0.5597E+00,  0.6620E+00,  0.7581E+00,  0.8447E+00,   &
      0.9165E+00,  0.9668E+00,  0.9923E+00,  0.9995E+00,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.1472E-06, -0.2866E-06, -0.5485E-06, -0.1024E-05, -0.1842E-05,  &
      -0.3160E-05, -0.5136E-05, -0.7922E-05, -0.1171E-04, -0.1682E-04,  &
      -0.2381E-04, -0.3355E-04, -0.4729E-04, -0.6673E-04, -0.9417E-04,  &
      -0.1327E-03, -0.1858E-03, -0.2564E-03, -0.3449E-03, -0.4463E-03,  &
      -0.5495E-03, -0.6420E-03, -0.7116E-03, -0.7427E-03, -0.7139E-03,  &
      -0.6031E-03, -0.4104E-03, -0.1957E-03, -0.5358E-04, -0.6176E-05,  &
      -0.1347E-06/
  DATA ((h13(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.6750E-09,  0.1332E-08,  0.2602E-08,  0.5003E-08,  0.9367E-08,   &
      0.1684E-07,  0.2863E-07,  0.4566E-07,  0.6865E-07,  0.9861E-07,   &
      0.1368E-06,  0.1856E-06,  0.2479E-06,  0.3274E-06,  0.4315E-06,   &
      0.5739E-06,  0.7710E-06,  0.1040E-05,  0.1394E-05,  0.1829E-05,   &
      0.2309E-05,  0.2759E-05,  0.3131E-05,  0.3472E-05,  0.3755E-05,   &
      0.3730E-05,  0.3138E-05,  0.1948E-05,  0.6994E-06,  0.1022E-06,   &
      0.2459E-08/
  DATA ((h11(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.9530E-04,  0.1872E-03,  0.3638E-03,  0.6949E-03,  0.1295E-02,   &
      0.2330E-02,  0.4022E-02,  0.6633E-02,  0.1049E-01,  0.1601E-01,   &
      0.2378E-01,  0.3456E-01,  0.4941E-01,  0.6980E-01,  0.9765E-01,   &
      0.1353E+00,  0.1852E+00,  0.2494E+00,  0.3287E+00,  0.4216E+00,   &
      0.5234E+00,  0.6272E+00,  0.7261E+00,  0.8166E+00,  0.8943E+00,   &
      0.9526E+00,  0.9863E+00,  0.9983E+00,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.1487E-06, -0.2912E-06, -0.5636E-06, -0.1069E-05, -0.1969E-05,  &
      -0.3483E-05, -0.5858E-05, -0.9334E-05, -0.1416E-04, -0.2067E-04,  &
      -0.2936E-04, -0.4113E-04, -0.5750E-04, -0.8072E-04, -0.1139E-03,  &
      -0.1606E-03, -0.2246E-03, -0.3076E-03, -0.4067E-03, -0.5121E-03,  &
      -0.6110E-03, -0.6909E-03, -0.7378E-03, -0.7321E-03, -0.6509E-03,  &
      -0.4825E-03, -0.2641E-03, -0.8936E-04, -0.1436E-04, -0.5966E-06,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.6777E-09,  0.1344E-08,  0.2643E-08,  0.5138E-08,  0.9798E-08,   &
      0.1809E-07,  0.3185E-07,  0.5285E-07,  0.8249E-07,  0.1222E-06,   &
      0.1730E-06,  0.2351E-06,  0.3111E-06,  0.4078E-06,  0.5366E-06,   &
      0.7117E-06,  0.9495E-06,  0.1266E-05,  0.1667E-05,  0.2132E-05,   &
      0.2600E-05,  0.3001E-05,  0.3354E-05,  0.3679E-05,  0.3796E-05,   &
      0.3414E-05,  0.2399E-05,  0.1067E-05,  0.2222E-06,  0.1075E-07,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.9589E-04,  0.1893E-03,  0.3706E-03,  0.7162E-03,  0.1357E-02,   &
      0.2500E-02,  0.4434E-02,  0.7523E-02,  0.1220E-01,  0.1900E-01,   &
      0.2860E-01,  0.4190E-01,  0.6015E-01,  0.8508E-01,  0.1189E+00,   &
      0.1643E+00,  0.2233E+00,  0.2976E+00,  0.3865E+00,  0.4865E+00,   &
      0.5909E+00,  0.6925E+00,  0.7866E+00,  0.8696E+00,  0.9355E+00,   &
      0.9778E+00,  0.9961E+00,  0.9999E+00,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.1496E-06, -0.2947E-06, -0.5749E-06, -0.1105E-05, -0.2074E-05,  &
      -0.3763E-05, -0.6531E-05, -0.1076E-04, -0.1682E-04, -0.2509E-04,  &
      -0.3605E-04, -0.5049E-04, -0.7012E-04, -0.9787E-04, -0.1378E-03,  &
      -0.1939E-03, -0.2695E-03, -0.3641E-03, -0.4703E-03, -0.5750E-03,  &
      -0.6648E-03, -0.7264E-03, -0.7419E-03, -0.6889E-03, -0.5488E-03,  &
      -0.3382E-03, -0.1375E-03, -0.2951E-04, -0.2174E-05,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.6798E-09,  0.1350E-08,  0.2667E-08,  0.5226E-08,  0.1010E-07,   &
      0.1903E-07,  0.3455E-07,  0.5951E-07,  0.9658E-07,  0.1479E-06,   &
      0.2146E-06,  0.2951E-06,  0.3903E-06,  0.5101E-06,  0.6693E-06,   &
      0.8830E-06,  0.1168E-05,  0.1532E-05,  0.1968E-05,  0.2435E-05,   &
      0.2859E-05,  0.3222E-05,  0.3572E-05,  0.3797E-05,  0.3615E-05,   &
      0.2811E-05,  0.1500E-05,  0.4185E-06,  0.3850E-07,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.9629E-04,  0.1907E-03,  0.3755E-03,  0.7321E-03,  0.1406E-02,   &
      0.2639E-02,  0.4796E-02,  0.8368E-02,  0.1394E-01,  0.2221E-01,   &
      0.3400E-01,  0.5037E-01,  0.7279E-01,  0.1033E+00,  0.1442E+00,   &
      0.1983E+00,  0.2673E+00,  0.3516E+00,  0.4489E+00,  0.5533E+00,   &
      0.6572E+00,  0.7547E+00,  0.8425E+00,  0.9153E+00,  0.9663E+00,   &
      0.9922E+00,  0.9995E+00,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.1503E-06, -0.2971E-06, -0.5832E-06, -0.1131E-05, -0.2154E-05,  &
      -0.3992E-05, -0.7122E-05, -0.1211E-04, -0.1954E-04, -0.2995E-04,  &
      -0.4380E-04, -0.6183E-04, -0.8577E-04, -0.1191E-03, -0.1668E-03,  &
      -0.2333E-03, -0.3203E-03, -0.4237E-03, -0.5324E-03, -0.6318E-03,  &
      -0.7075E-03, -0.7429E-03, -0.7168E-03, -0.6071E-03, -0.4139E-03,  &
      -0.1976E-03, -0.5410E-04, -0.6215E-05, -0.1343E-06,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.6809E-09,  0.1356E-08,  0.2683E-08,  0.5287E-08,  0.1030E-07,   &
      0.1971E-07,  0.3665E-07,  0.6528E-07,  0.1100E-06,  0.1744E-06,   &
      0.2599E-06,  0.3650E-06,  0.4887E-06,  0.6398E-06,  0.8358E-06,   &
      0.1095E-05,  0.1429E-05,  0.1836E-05,  0.2286E-05,  0.2716E-05,   &
      0.3088E-05,  0.3444E-05,  0.3748E-05,  0.3740E-05,  0.3157E-05,   &
      0.1966E-05,  0.7064E-06,  0.1030E-06,  0.2456E-08,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.9655E-04,  0.1917E-03,  0.3789E-03,  0.7436E-03,  0.1442E-02,   &
      0.2748E-02,  0.5100E-02,  0.9128E-02,  0.1563E-01,  0.2553E-01,   &
      0.3987E-01,  0.5994E-01,  0.8746E-01,  0.1246E+00,  0.1739E+00,   &
      0.2376E+00,  0.3170E+00,  0.4107E+00,  0.5141E+00,  0.6198E+00,   &
      0.7208E+00,  0.8130E+00,  0.8923E+00,  0.9517E+00,  0.9860E+00,   &
      0.9983E+00,  0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.1508E-06, -0.2989E-06, -0.5892E-06, -0.1151E-05, -0.2216E-05,  &
      -0.4175E-05, -0.7619E-05, -0.1333E-04, -0.2217E-04, -0.3497E-04,  &
      -0.5238E-04, -0.7513E-04, -0.1049E-03, -0.1455E-03, -0.2021E-03,  &
      -0.2790E-03, -0.3757E-03, -0.4839E-03, -0.5902E-03, -0.6794E-03,  &
      -0.7344E-03, -0.7341E-03, -0.6557E-03, -0.4874E-03, -0.2674E-03,  &
      -0.9059E-04, -0.1455E-04, -0.5986E-06,  0.0000E+00,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.6812E-09,  0.1356E-08,  0.2693E-08,  0.5328E-08,  0.1045E-07,   &
      0.2021E-07,  0.3826E-07,  0.6994E-07,  0.1218E-06,  0.1997E-06,   &
      0.3069E-06,  0.4428E-06,  0.6064E-06,  0.8015E-06,  0.1043E-05,   &
      0.1351E-05,  0.1733E-05,  0.2168E-05,  0.2598E-05,  0.2968E-05,   &
      0.3316E-05,  0.3662E-05,  0.3801E-05,  0.3433E-05,  0.2422E-05,   &
      0.1081E-05,  0.2256E-06,  0.1082E-07,  0.0000E+00,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.9672E-04,  0.1923E-03,  0.3813E-03,  0.7518E-03,  0.1469E-02,   &
      0.2832E-02,  0.5343E-02,  0.9779E-02,  0.1719E-01,  0.2882E-01,   &
      0.4606E-01,  0.7051E-01,  0.1042E+00,  0.1493E+00,  0.2081E+00,   &
      0.2824E+00,  0.3720E+00,  0.4736E+00,  0.5803E+00,  0.6844E+00,   &
      0.7810E+00,  0.8663E+00,  0.9339E+00,  0.9772E+00,  0.9960E+00,   &
      0.9999E+00,  0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.1511E-06, -0.3001E-06, -0.5934E-06, -0.1166E-05, -0.2263E-05,  &
      -0.4319E-05, -0.8028E-05, -0.1438E-04, -0.2460E-04, -0.3991E-04,  &
      -0.6138E-04, -0.9005E-04, -0.1278E-03, -0.1778E-03, -0.2447E-03,  &
      -0.3313E-03, -0.4342E-03, -0.5424E-03, -0.6416E-03, -0.7146E-03,  &
      -0.7399E-03, -0.6932E-03, -0.5551E-03, -0.3432E-03, -0.1398E-03,  &
      -0.3010E-04, -0.2229E-05,  0.0000E+00,  0.0000E+00,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.6815E-09,  0.1358E-08,  0.2698E-08,  0.5355E-08,  0.1054E-07,   &
      0.2056E-07,  0.3942E-07,  0.7349E-07,  0.1315E-06,  0.2226E-06,   &
      0.3537E-06,  0.5266E-06,  0.7407E-06,  0.9958E-06,  0.1296E-05,   &
      0.1657E-05,  0.2077E-05,  0.2512E-05,  0.2893E-05,  0.3216E-05,   &
      0.3562E-05,  0.3811E-05,  0.3644E-05,  0.2841E-05,  0.1524E-05,   &
      0.4276E-06,  0.3960E-07,  0.0000E+00,  0.0000E+00,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.9682E-04,  0.1928E-03,  0.3829E-03,  0.7576E-03,  0.1489E-02,   &
      0.2894E-02,  0.5533E-02,  0.1031E-01,  0.1856E-01,  0.3195E-01,   &
      0.5237E-01,  0.8187E-01,  0.1227E+00,  0.1771E+00,  0.2468E+00,   &
      0.3321E+00,  0.4312E+00,  0.5384E+00,  0.6455E+00,  0.7463E+00,   &
      0.8372E+00,  0.9126E+00,  0.9652E+00,  0.9919E+00,  0.9994E+00,   &
      0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.1513E-06, -0.3009E-06, -0.5966E-06, -0.1176E-05, -0.2299E-05,  &
      -0.4430E-05, -0.8352E-05, -0.1526E-04, -0.2674E-04, -0.4454E-04,  &
      -0.7042E-04, -0.1062E-03, -0.1540E-03, -0.2163E-03, -0.2951E-03,  &
      -0.3899E-03, -0.4948E-03, -0.5983E-03, -0.6846E-03, -0.7332E-03,  &
      -0.7182E-03, -0.6142E-03, -0.4209E-03, -0.2014E-03, -0.5530E-04,  &
      -0.6418E-05, -0.1439E-06,  0.0000E+00,  0.0000E+00,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.6817E-09,  0.1359E-08,  0.2702E-08,  0.5374E-08,  0.1061E-07,   &
      0.2079E-07,  0.4022E-07,  0.7610E-07,  0.1392E-06,  0.2428E-06,   &
      0.3992E-06,  0.6149E-06,  0.8893E-06,  0.1220E-05,  0.1599E-05,   &
      0.2015E-05,  0.2453E-05,  0.2853E-05,  0.3173E-05,  0.3488E-05,   &
      0.3792E-05,  0.3800E-05,  0.3210E-05,  0.2002E-05,  0.7234E-06,   &
      0.1068E-06,  0.2646E-08,  0.0000E+00,  0.0000E+00,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.3920E-05,  0.7617E-05,  0.1455E-04,  0.2706E-04,  0.4855E-04,   &
      0.8315E-04,  0.1349E-03,  0.2063E-03,  0.2984E-03,  0.4109E-03,   &
      0.5422E-03,  0.6896E-03,  0.8537E-03,  0.1041E-02,  0.1262E-02,   &
      0.1534E-02,  0.1870E-02,  0.2286E-02,  0.2803E-02,  0.3444E-02,   &
      0.4242E-02,  0.5244E-02,  0.6511E-02,  0.8138E-02,  0.1027E-01,   &
      0.1312E-01,  0.1697E-01,  0.2222E-01,  0.2941E-01,  0.3923E-01,   &
      0.5258E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.5622E-07, -0.1071E-06, -0.1983E-06, -0.3533E-06, -0.5991E-06,  &
      -0.9592E-06, -0.1444E-05, -0.2049E-05, -0.2764E-05, -0.3577E-05,  &
      -0.4469E-05, -0.5467E-05, -0.6654E-05, -0.8137E-05, -0.1002E-04,  &
      -0.1237E-04, -0.1528E-04, -0.1884E-04, -0.2310E-04, -0.2809E-04,  &
      -0.3396E-04, -0.4098E-04, -0.4960E-04, -0.6058E-04, -0.7506E-04,  &
      -0.9451E-04, -0.1207E-03, -0.1558E-03, -0.2026E-03, -0.2648E-03,  &
      -0.3468E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.2195E-09, -0.4031E-09, -0.7043E-09, -0.1153E-08, -0.1737E-08,  &
      -0.2395E-08, -0.3020E-08, -0.3549E-08, -0.4034E-08, -0.4421E-08,  &
      -0.4736E-08, -0.5681E-08, -0.8289E-08, -0.1287E-07, -0.1873E-07,  &
      -0.2523E-07, -0.3223E-07, -0.3902E-07, -0.4409E-07, -0.4699E-07,  &
      -0.4782E-07, -0.4705E-07, -0.4657E-07, -0.4885E-07, -0.5550E-07,  &
      -0.6619E-07, -0.7656E-07, -0.8027E-07, -0.7261E-07, -0.4983E-07,  &
      -0.1101E-07/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.3920E-05,  0.7617E-05,  0.1455E-04,  0.2706E-04,  0.4856E-04,   &
      0.8318E-04,  0.1349E-03,  0.2065E-03,  0.2986E-03,  0.4114E-03,   &
      0.5431E-03,  0.6912E-03,  0.8566E-03,  0.1046E-02,  0.1272E-02,   &
      0.1552E-02,  0.1902E-02,  0.2342E-02,  0.2899E-02,  0.3605E-02,   &
      0.4501E-02,  0.5648E-02,  0.7129E-02,  0.9063E-02,  0.1163E-01,   &
      0.1509E-01,  0.1980E-01,  0.2626E-01,  0.3510E-01,  0.4717E-01,   &
      0.6351E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.5622E-07, -0.1071E-06, -0.1983E-06, -0.3534E-06, -0.5992E-06,  &
      -0.9594E-06, -0.1445E-05, -0.2050E-05, -0.2766E-05, -0.3580E-05,  &
      -0.4476E-05, -0.5479E-05, -0.6677E-05, -0.8179E-05, -0.1009E-04,  &
      -0.1251E-04, -0.1553E-04, -0.1928E-04, -0.2384E-04, -0.2930E-04,  &
      -0.3588E-04, -0.4393E-04, -0.5403E-04, -0.6714E-04, -0.8458E-04,  &
      -0.1082E-03, -0.1400E-03, -0.1829E-03, -0.2401E-03, -0.3157E-03,  &
      -0.4147E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.2195E-09, -0.4032E-09, -0.7046E-09, -0.1153E-08, -0.1738E-08,  &
      -0.2395E-08, -0.3021E-08, -0.3550E-08, -0.4035E-08, -0.4423E-08,  &
      -0.4740E-08, -0.5692E-08, -0.8314E-08, -0.1292E-07, -0.1882E-07,  &
      -0.2536E-07, -0.3242E-07, -0.3927E-07, -0.4449E-07, -0.4767E-07,  &
      -0.4889E-07, -0.4857E-07, -0.4860E-07, -0.5132E-07, -0.5847E-07,  &
      -0.6968E-07, -0.8037E-07, -0.8400E-07, -0.7521E-07, -0.4830E-07,  &
      -0.7562E-09/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.3920E-05,  0.7617E-05,  0.1455E-04,  0.2707E-04,  0.4858E-04,   &
      0.8322E-04,  0.1350E-03,  0.2066E-03,  0.2990E-03,  0.4122E-03,   &
      0.5444E-03,  0.6937E-03,  0.8611E-03,  0.1054E-02,  0.1287E-02,   &
      0.1579E-02,  0.1949E-02,  0.2424E-02,  0.3037E-02,  0.3829E-02,   &
      0.4854E-02,  0.6190E-02,  0.7942E-02,  0.1026E-01,  0.1338E-01,   &
      0.1761E-01,  0.2340E-01,  0.3134E-01,  0.4223E-01,  0.5703E-01,   &
      0.7694E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.5622E-07, -0.1071E-06, -0.1983E-06, -0.3535E-06, -0.5994E-06,  &
      -0.9599E-06, -0.1446E-05, -0.2052E-05, -0.2769E-05, -0.3586E-05,  &
      -0.4487E-05, -0.5499E-05, -0.6712E-05, -0.8244E-05, -0.1021E-04,  &
      -0.1272E-04, -0.1591E-04, -0.1992E-04, -0.2489E-04, -0.3097E-04,  &
      -0.3845E-04, -0.4782E-04, -0.5982E-04, -0.7558E-04, -0.9674E-04,  &
      -0.1254E-03, -0.1644E-03, -0.2167E-03, -0.2863E-03, -0.3777E-03,  &
      -0.4959E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.2196E-09, -0.4033E-09, -0.7048E-09, -0.1154E-08, -0.1739E-08,  &
      -0.2396E-08, -0.3022E-08, -0.3551E-08, -0.4036E-08, -0.4425E-08,  &
      -0.4746E-08, -0.5710E-08, -0.8354E-08, -0.1300E-07, -0.1894E-07,  &
      -0.2554E-07, -0.3265E-07, -0.3958E-07, -0.4502E-07, -0.4859E-07,  &
      -0.5030E-07, -0.5053E-07, -0.5104E-07, -0.5427E-07, -0.6204E-07,  &
      -0.7388E-07, -0.8477E-07, -0.8760E-07, -0.7545E-07, -0.4099E-07,  &
      0.2046E-07/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.3919E-05,  0.7618E-05,  0.1455E-04,  0.2708E-04,  0.4860E-04,   &
      0.8327E-04,  0.1352E-03,  0.2070E-03,  0.2997E-03,  0.4134E-03,   &
      0.5466E-03,  0.6976E-03,  0.8682E-03,  0.1067E-02,  0.1310E-02,   &
      0.1619E-02,  0.2020E-02,  0.2543E-02,  0.3232E-02,  0.4136E-02,   &
      0.5328E-02,  0.6906E-02,  0.9004E-02,  0.1182E-01,  0.1562E-01,   &
      0.2081E-01,  0.2794E-01,  0.3773E-01,  0.5111E-01,  0.6919E-01,   &
      0.9329E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.5623E-07, -0.1071E-06, -0.1984E-06, -0.3536E-06, -0.5997E-06,  &
      -0.9606E-06, -0.1447E-05, -0.2055E-05, -0.2775E-05, -0.3596E-05,  &
      -0.4504E-05, -0.5529E-05, -0.6768E-05, -0.8345E-05, -0.1039E-04,  &
      -0.1304E-04, -0.1645E-04, -0.2082E-04, -0.2633E-04, -0.3322E-04,  &
      -0.4187E-04, -0.5292E-04, -0.6730E-04, -0.8640E-04, -0.1122E-03,  &
      -0.1472E-03, -0.1948E-03, -0.2585E-03, -0.3428E-03, -0.4523E-03,  &
      -0.5915E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.2196E-09, -0.4034E-09, -0.7050E-09, -0.1154E-08, -0.1740E-08,  &
      -0.2398E-08, -0.3024E-08, -0.3552E-08, -0.4037E-08, -0.4428E-08,  &
      -0.4756E-08, -0.5741E-08, -0.8418E-08, -0.1310E-07, -0.1910E-07,  &
      -0.2575E-07, -0.3293E-07, -0.3998E-07, -0.4572E-07, -0.4980E-07,  &
      -0.5211E-07, -0.5287E-07, -0.5390E-07, -0.5782E-07, -0.6650E-07,  &
      -0.7892E-07, -0.8940E-07, -0.8980E-07, -0.7119E-07, -0.2452E-07,  &
      0.5823E-07/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.3919E-05,  0.7618E-05,  0.1455E-04,  0.2709E-04,  0.4863E-04,   &
      0.8337E-04,  0.1354E-03,  0.2075E-03,  0.3007E-03,  0.4152E-03,   &
      0.5500E-03,  0.7038E-03,  0.8793E-03,  0.1086E-02,  0.1345E-02,   &
      0.1680E-02,  0.2123E-02,  0.2712E-02,  0.3500E-02,  0.4552E-02,   &
      0.5958E-02,  0.7844E-02,  0.1038E-01,  0.1381E-01,  0.1847E-01,   &
      0.2487E-01,  0.3366E-01,  0.4572E-01,  0.6209E-01,  0.8406E-01,   &
      0.1130E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.5623E-07, -0.1071E-06, -0.1985E-06, -0.3538E-06, -0.6002E-06,  &
      -0.9618E-06, -0.1450E-05, -0.2059E-05, -0.2783E-05, -0.3611E-05,  &
      -0.4531E-05, -0.5577E-05, -0.6855E-05, -0.8499E-05, -0.1066E-04,  &
      -0.1351E-04, -0.1723E-04, -0.2207E-04, -0.2829E-04, -0.3621E-04,  &
      -0.4636E-04, -0.5954E-04, -0.7690E-04, -0.1002E-03, -0.1317E-03,  &
      -0.1746E-03, -0.2326E-03, -0.3099E-03, -0.4111E-03, -0.5407E-03,  &
      -0.7020E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.2197E-09, -0.4037E-09, -0.7054E-09, -0.1155E-08, -0.1741E-08,  &
      -0.2401E-08, -0.3027E-08, -0.3553E-08, -0.4039E-08, -0.4431E-08,  &
      -0.4775E-08, -0.5784E-08, -0.8506E-08, -0.1326E-07, -0.1931E-07,  &
      -0.2600E-07, -0.3324E-07, -0.4048E-07, -0.4666E-07, -0.5137E-07,  &
      -0.5428E-07, -0.5558E-07, -0.5730E-07, -0.6228E-07, -0.7197E-07,  &
      -0.8455E-07, -0.9347E-07, -0.8867E-07, -0.5945E-07,  0.5512E-08,  &
      0.1209E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.3919E-05,  0.7619E-05,  0.1456E-04,  0.2710E-04,  0.4868E-04,   &
      0.8351E-04,  0.1357E-03,  0.2082E-03,  0.3022E-03,  0.4181E-03,   &
      0.5554E-03,  0.7134E-03,  0.8963E-03,  0.1117E-02,  0.1397E-02,   &
      0.1770E-02,  0.2270E-02,  0.2947E-02,  0.3865E-02,  0.5107E-02,   &
      0.6787E-02,  0.9062E-02,  0.1215E-01,  0.1634E-01,  0.2209E-01,   &
      0.2999E-01,  0.4083E-01,  0.5563E-01,  0.7559E-01,  0.1021E+00,   &
      0.1364E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.5624E-07, -0.1072E-06, -0.1986E-06, -0.3541E-06, -0.6010E-06,  &
      -0.9636E-06, -0.1453E-05, -0.2067E-05, -0.2796E-05, -0.3634E-05,  &
      -0.4572E-05, -0.5652E-05, -0.6987E-05, -0.8733E-05, -0.1107E-04,  &
      -0.1418E-04, -0.1832E-04, -0.2378E-04, -0.3092E-04, -0.4017E-04,  &
      -0.5221E-04, -0.6806E-04, -0.8916E-04, -0.1176E-03, -0.1562E-03,  &
      -0.2087E-03, -0.2793E-03, -0.3724E-03, -0.4928E-03, -0.6440E-03,  &
      -0.8270E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.2198E-09, -0.4040E-09, -0.7061E-09, -0.1156E-08, -0.1744E-08,  &
      -0.2405E-08, -0.3032E-08, -0.3556E-08, -0.4040E-08, -0.4444E-08,  &
      -0.4800E-08, -0.5848E-08, -0.8640E-08, -0.1346E-07, -0.1957E-07,  &
      -0.2627E-07, -0.3357E-07, -0.4114E-07, -0.4793E-07, -0.5330E-07,  &
      -0.5676E-07, -0.5873E-07, -0.6152E-07, -0.6783E-07, -0.7834E-07,  &
      -0.9023E-07, -0.9530E-07, -0.8162E-07, -0.3634E-07,  0.5638E-07,  &
      0.2189E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.3919E-05,  0.7620E-05,  0.1457E-04,  0.2713E-04,  0.4877E-04,   &
      0.8374E-04,  0.1363E-03,  0.2095E-03,  0.3047E-03,  0.4227E-03,   &
      0.5637E-03,  0.7282E-03,  0.9224E-03,  0.1162E-02,  0.1475E-02,   &
      0.1898E-02,  0.2475E-02,  0.3267E-02,  0.4354E-02,  0.5839E-02,   &
      0.7866E-02,  0.1063E-01,  0.1440E-01,  0.1957E-01,  0.2666E-01,   &
      0.3641E-01,  0.4975E-01,  0.6784E-01,  0.9201E-01,  0.1236E+00,   &
      0.1639E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.5626E-07, -0.1072E-06, -0.1987E-06, -0.3545E-06, -0.6022E-06,  &
      -0.9665E-06, -0.1460E-05, -0.2078E-05, -0.2817E-05, -0.3671E-05,  &
      -0.4637E-05, -0.5767E-05, -0.7188E-05, -0.9080E-05, -0.1165E-04,  &
      -0.1513E-04, -0.1981E-04, -0.2609E-04, -0.3441E-04, -0.4534E-04,  &
      -0.5978E-04, -0.7897E-04, -0.1047E-03, -0.1396E-03, -0.1870E-03,  &
      -0.2510E-03, -0.3363E-03, -0.4475E-03, -0.5888E-03, -0.7621E-03,  &
      -0.9647E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.2200E-09, -0.4045E-09, -0.7071E-09, -0.1159E-08, -0.1748E-08,  &
      -0.2411E-08, -0.3040E-08, -0.3561E-08, -0.4046E-08, -0.4455E-08,  &
      -0.4839E-08, -0.5941E-08, -0.8815E-08, -0.1371E-07, -0.1983E-07,  &
      -0.2652E-07, -0.3400E-07, -0.4207E-07, -0.4955E-07, -0.5554E-07,  &
      -0.5966E-07, -0.6261E-07, -0.6688E-07, -0.7454E-07, -0.8521E-07,  &
      -0.9470E-07, -0.9275E-07, -0.6525E-07,  0.3686E-08,  0.1371E-06,  &
      0.3623E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.3919E-05,  0.7622E-05,  0.1458E-04,  0.2717E-04,  0.4890E-04,   &
      0.8410E-04,  0.1372E-03,  0.2114E-03,  0.3085E-03,  0.4298E-03,   &
      0.5765E-03,  0.7508E-03,  0.9618E-03,  0.1229E-02,  0.1586E-02,   &
      0.2077E-02,  0.2757E-02,  0.3697E-02,  0.5000E-02,  0.6794E-02,   &
      0.9260E-02,  0.1264E-01,  0.1728E-01,  0.2365E-01,  0.3242E-01,   &
      0.4444E-01,  0.6080E-01,  0.8278E-01,  0.1118E+00,  0.1491E+00,   &
      0.1956E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.5628E-07, -0.1073E-06, -0.1990E-06, -0.3553E-06, -0.6042E-06,  &
      -0.9710E-06, -0.1469E-05, -0.2096E-05, -0.2849E-05, -0.3728E-05,  &
      -0.4738E-05, -0.5942E-05, -0.7490E-05, -0.9586E-05, -0.1247E-04,  &
      -0.1644E-04, -0.2184E-04, -0.2916E-04, -0.3898E-04, -0.5205E-04,  &
      -0.6948E-04, -0.9285E-04, -0.1244E-03, -0.1672E-03, -0.2251E-03,  &
      -0.3028E-03, -0.4051E-03, -0.5365E-03, -0.6998E-03, -0.8940E-03,  &
      -0.1112E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.2204E-09, -0.4052E-09, -0.7088E-09, -0.1162E-08, -0.1755E-08,  &
      -0.2422E-08, -0.3053E-08, -0.3572E-08, -0.4052E-08, -0.4474E-08,  &
      -0.4898E-08, -0.6082E-08, -0.9046E-08, -0.1400E-07, -0.2009E-07,  &
      -0.2683E-07, -0.3463E-07, -0.4334E-07, -0.5153E-07, -0.5811E-07,  &
      -0.6305E-07, -0.6749E-07, -0.7346E-07, -0.8208E-07, -0.9173E-07,  &
      -0.9603E-07, -0.8264E-07, -0.3505E-07,  0.6878E-07,  0.2586E-06,  &
      0.5530E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.3919E-05,  0.7625E-05,  0.1459E-04,  0.2723E-04,  0.4910E-04,   &
      0.8465E-04,  0.1385E-03,  0.2143E-03,  0.3143E-03,  0.4407E-03,   &
      0.5960E-03,  0.7850E-03,  0.1020E-02,  0.1326E-02,  0.1744E-02,   &
      0.2324E-02,  0.3135E-02,  0.4267E-02,  0.5845E-02,  0.8031E-02,   &
      0.1105E-01,  0.1520E-01,  0.2093E-01,  0.2880E-01,  0.3962E-01,   &
      0.5440E-01,  0.7435E-01,  0.1009E+00,  0.1353E+00,  0.1787E+00,   &
      0.2317E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.5630E-07, -0.1074E-06, -0.1994E-06, -0.3564E-06, -0.6072E-06,  &
      -0.9779E-06, -0.1484E-05, -0.2124E-05, -0.2900E-05, -0.3817E-05,  &
      -0.4891E-05, -0.6205E-05, -0.7931E-05, -0.1031E-04, -0.1362E-04,  &
      -0.1821E-04, -0.2454E-04, -0.3320E-04, -0.4493E-04, -0.6068E-04,  &
      -0.8186E-04, -0.1104E-03, -0.1491E-03, -0.2016E-03, -0.2722E-03,  &
      -0.3658E-03, -0.4873E-03, -0.6404E-03, -0.8253E-03, -0.1037E-02,  &
      -0.1267E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.2207E-09, -0.4061E-09, -0.7117E-09, -0.1169E-08, -0.1767E-08,  &
      -0.2439E-08, -0.3074E-08, -0.3588E-08, -0.4062E-08, -0.4510E-08,  &
      -0.4983E-08, -0.6261E-08, -0.9324E-08, -0.1430E-07, -0.2036E-07,  &
      -0.2725E-07, -0.3561E-07, -0.4505E-07, -0.5384E-07, -0.6111E-07,  &
      -0.6731E-07, -0.7355E-07, -0.8112E-07, -0.8978E-07, -0.9616E-07,  &
      -0.9157E-07, -0.6114E-07,  0.1622E-07,  0.1694E-06,  0.4277E-06,  &
      0.7751E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.3919E-05,  0.7629E-05,  0.1462E-04,  0.2733E-04,  0.4940E-04,   &
      0.8549E-04,  0.1406E-03,  0.2188E-03,  0.3232E-03,  0.4572E-03,   &
      0.6253E-03,  0.8354E-03,  0.1105E-02,  0.1464E-02,  0.1960E-02,   &
      0.2657E-02,  0.3637E-02,  0.5014E-02,  0.6942E-02,  0.9622E-02,   &
      0.1333E-01,  0.1846E-01,  0.2553E-01,  0.3526E-01,  0.4859E-01,   &
      0.6667E-01,  0.9084E-01,  0.1225E+00,  0.1629E+00,  0.2127E+00,   &
      0.2721E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.5636E-07, -0.1076E-06, -0.2000E-06, -0.3582E-06, -0.6119E-06,  &
      -0.9888E-06, -0.1507E-05, -0.2168E-05, -0.2978E-05, -0.3952E-05,  &
      -0.5122E-05, -0.6592E-05, -0.8565E-05, -0.1132E-04, -0.1518E-04,  &
      -0.2060E-04, -0.2811E-04, -0.3848E-04, -0.5261E-04, -0.7173E-04,  &
      -0.9758E-04, -0.1326E-03, -0.1801E-03, -0.2442E-03, -0.3296E-03,  &
      -0.4415E-03, -0.5840E-03, -0.7591E-03, -0.9636E-03, -0.1189E-02,  &
      -0.1427E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.2214E-09, -0.4080E-09, -0.7156E-09, -0.1178E-08, -0.1784E-08,  &
      -0.2466E-08, -0.3105E-08, -0.3617E-08, -0.4087E-08, -0.4563E-08,  &
      -0.5110E-08, -0.6492E-08, -0.9643E-08, -0.1461E-07, -0.2069E-07,  &
      -0.2796E-07, -0.3702E-07, -0.4717E-07, -0.5662E-07, -0.6484E-07,  &
      -0.7271E-07, -0.8079E-07, -0.8928E-07, -0.9634E-07, -0.9625E-07,  &
      -0.7776E-07, -0.2242E-07,  0.9745E-07,  0.3152E-06,  0.6388E-06,  &
      0.9992E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.3919E-05,  0.7639E-05,  0.1466E-04,  0.2748E-04,  0.4986E-04,   &
      0.8675E-04,  0.1437E-03,  0.2255E-03,  0.3365E-03,  0.4816E-03,   &
      0.6682E-03,  0.9082E-03,  0.1224E-02,  0.1653E-02,  0.2253E-02,   &
      0.3099E-02,  0.4296E-02,  0.5984E-02,  0.8352E-02,  0.1165E-01,   &
      0.1623E-01,  0.2257E-01,  0.3132E-01,  0.4333E-01,  0.5968E-01,   &
      0.8166E-01,  0.1107E+00,  0.1481E+00,  0.1947E+00,  0.2509E+00,   &
      0.3170E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.5645E-07, -0.1079E-06, -0.2009E-06, -0.3610E-06, -0.6190E-06,  &
      -0.1005E-05, -0.1541E-05, -0.2235E-05, -0.3096E-05, -0.4155E-05,  &
      -0.5463E-05, -0.7150E-05, -0.9453E-05, -0.1269E-04, -0.1728E-04,  &
      -0.2375E-04, -0.3279E-04, -0.4531E-04, -0.6246E-04, -0.8579E-04,  &
      -0.1175E-03, -0.1604E-03, -0.2186E-03, -0.2964E-03, -0.3990E-03,  &
      -0.5311E-03, -0.6957E-03, -0.8916E-03, -0.1112E-02, -0.1346E-02,  &
      -0.1590E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.2225E-09, -0.4104E-09, -0.7217E-09, -0.1192E-08, -0.1811E-08,  &
      -0.2509E-08, -0.3155E-08, -0.3668E-08, -0.4138E-08, -0.4650E-08,  &
      -0.5296E-08, -0.6785E-08, -0.9991E-08, -0.1494E-07, -0.2122E-07,  &
      -0.2911E-07, -0.3895E-07, -0.4979E-07, -0.6002E-07, -0.6964E-07,  &
      -0.7935E-07, -0.8887E-07, -0.9699E-07, -0.9967E-07, -0.8883E-07,  &
      -0.4988E-07,  0.4156E-07,  0.2197E-06,  0.5081E-06,  0.8667E-06,  &
      0.1212E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.3920E-05,  0.7649E-05,  0.1472E-04,  0.2768E-04,  0.5051E-04,   &
      0.8856E-04,  0.1481E-03,  0.2352E-03,  0.3557E-03,  0.5169E-03,   &
      0.7295E-03,  0.1010E-02,  0.1388E-02,  0.1909E-02,  0.2640E-02,   &
      0.3678E-02,  0.5151E-02,  0.7231E-02,  0.1015E-01,  0.1423E-01,   &
      0.1990E-01,  0.2775E-01,  0.3856E-01,  0.5333E-01,  0.7328E-01,   &
      0.9980E-01,  0.1343E+00,  0.1778E+00,  0.2308E+00,  0.2936E+00,   &
      0.3667E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.5658E-07, -0.1083E-06, -0.2023E-06, -0.3650E-06, -0.6295E-06,  &
      -0.1030E-05, -0.1593E-05, -0.2334E-05, -0.3273E-05, -0.4455E-05,  &
      -0.5955E-05, -0.7935E-05, -0.1067E-04, -0.1455E-04, -0.2007E-04,  &
      -0.2788E-04, -0.3885E-04, -0.5409E-04, -0.7503E-04, -0.1036E-03,  &
      -0.1425E-03, -0.1951E-03, -0.2660E-03, -0.3598E-03, -0.4817E-03,  &
      -0.6355E-03, -0.8218E-03, -0.1035E-02, -0.1267E-02, -0.1508E-02,  &
      -0.1755E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.2241E-09, -0.4142E-09, -0.7312E-09, -0.1214E-08, -0.1854E-08,  &
      -0.2578E-08, -0.3250E-08, -0.3765E-08, -0.4238E-08, -0.4809E-08,  &
      -0.5553E-08, -0.7132E-08, -0.1035E-07, -0.1538E-07, -0.2211E-07,  &
      -0.3079E-07, -0.4142E-07, -0.5303E-07, -0.6437E-07, -0.7566E-07,  &
      -0.8703E-07, -0.9700E-07, -0.1025E-06, -0.9718E-07, -0.6973E-07,  &
      -0.5265E-09,  0.1413E-06,  0.3895E-06,  0.7321E-06,  0.1085E-05,  &
      0.1449E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.3920E-05,  0.7668E-05,  0.1480E-04,  0.2798E-04,  0.5143E-04,   &
      0.9106E-04,  0.1542E-03,  0.2488E-03,  0.3827E-03,  0.5661E-03,   &
      0.8143E-03,  0.1150E-02,  0.1608E-02,  0.2246E-02,  0.3147E-02,   &
      0.4428E-02,  0.6248E-02,  0.8823E-02,  0.1244E-01,  0.1750E-01,   &
      0.2452E-01,  0.3424E-01,  0.4756E-01,  0.6564E-01,  0.8981E-01,   &
      0.1215E+00,  0.1619E+00,  0.2118E+00,  0.2713E+00,  0.3409E+00,   &
      0.4215E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.5677E-07, -0.1090E-06, -0.2043E-06, -0.3709E-06, -0.6448E-06,  &
      -0.1066E-05, -0.1669E-05, -0.2480E-05, -0.3532E-05, -0.4887E-05,  &
      -0.6650E-05, -0.9017E-05, -0.1232E-04, -0.1701E-04, -0.2372E-04,  &
      -0.3325E-04, -0.4664E-04, -0.6528E-04, -0.9095E-04, -0.1260E-03,  &
      -0.1737E-03, -0.2381E-03, -0.3238E-03, -0.4359E-03, -0.5789E-03,  &
      -0.7549E-03, -0.9607E-03, -0.1188E-02, -0.1427E-02, -0.1674E-02,  &
      -0.1914E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.2262E-09, -0.4191E-09, -0.7441E-09, -0.1244E-08, -0.1916E-08,  &
      -0.2687E-08, -0.3407E-08, -0.3947E-08, -0.4432E-08, -0.5059E-08,  &
      -0.5896E-08, -0.7538E-08, -0.1079E-07, -0.1606E-07, -0.2346E-07,  &
      -0.3305E-07, -0.4459E-07, -0.5720E-07, -0.6999E-07, -0.8300E-07,  &
      -0.9536E-07, -0.1039E-06, -0.1036E-06, -0.8526E-07, -0.3316E-07,  &
      0.7909E-07,  0.2865E-06,  0.6013E-06,  0.9580E-06,  0.1303E-05,   &
      0.1792E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.3923E-05,  0.7691E-05,  0.1491E-04,  0.2836E-04,  0.5261E-04,   &
      0.9432E-04,  0.1623E-03,  0.2667E-03,  0.4187E-03,  0.6323E-03,   &
      0.9278E-03,  0.1334E-02,  0.1897E-02,  0.2685E-02,  0.3800E-02,   &
      0.5388E-02,  0.7646E-02,  0.1084E-01,  0.1533E-01,  0.2160E-01,   &
      0.3031E-01,  0.4231E-01,  0.5866E-01,  0.8064E-01,  0.1097E+00,   &
      0.1471E+00,  0.1938E+00,  0.2501E+00,  0.3163E+00,  0.3932E+00,   &
      0.4810E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.5703E-07, -0.1098E-06, -0.2071E-06, -0.3788E-06, -0.6657E-06,  &
      -0.1116E-05, -0.1776E-05, -0.2687E-05, -0.3898E-05, -0.5493E-05,  &
      -0.7607E-05, -0.1048E-04, -0.1450E-04, -0.2024E-04, -0.2845E-04,  &
      -0.4014E-04, -0.5658E-04, -0.7947E-04, -0.1110E-03, -0.1541E-03,  &
      -0.2125E-03, -0.2907E-03, -0.3936E-03, -0.5261E-03, -0.6912E-03,  &
      -0.8880E-03, -0.1109E-02, -0.1346E-02, -0.1591E-02, -0.1837E-02,  &
      -0.2054E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.2288E-09, -0.4265E-09, -0.7627E-09, -0.1289E-08, -0.2011E-08,  &
      -0.2861E-08, -0.3673E-08, -0.4288E-08, -0.4812E-08, -0.5475E-08,  &
      -0.6365E-08, -0.8052E-08, -0.1142E-07, -0.1711E-07, -0.2533E-07,  &
      -0.3597E-07, -0.4862E-07, -0.6259E-07, -0.7708E-07, -0.9150E-07,  &
      -0.1035E-06, -0.1079E-06, -0.9742E-07, -0.5928E-07,  0.2892E-07,  &
      0.1998E-06,  0.4789E-06,  0.8298E-06,  0.1172E-05,  0.1583E-05,   &
      0.2329E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.3928E-05,  0.7724E-05,  0.1504E-04,  0.2883E-04,  0.5403E-04,   &
      0.9826E-04,  0.1722E-03,  0.2891E-03,  0.4644E-03,  0.7172E-03,   &
      0.1074E-02,  0.1572E-02,  0.2267E-02,  0.3245E-02,  0.4632E-02,   &
      0.6606E-02,  0.9411E-02,  0.1338E-01,  0.1896E-01,  0.2674E-01,   &
      0.3751E-01,  0.5227E-01,  0.7222E-01,  0.9875E-01,  0.1332E+00,   &
      0.1768E+00,  0.2299E+00,  0.2927E+00,  0.3660E+00,  0.4504E+00,   &
      0.5444E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.5736E-07, -0.1109E-06, -0.2106E-06, -0.3890E-06, -0.6928E-06,  &
      -0.1181E-05, -0.1917E-05, -0.2965E-05, -0.4396E-05, -0.6315E-05,  &
      -0.8891E-05, -0.1242E-04, -0.1736E-04, -0.2442E-04, -0.3454E-04,  &
      -0.4892E-04, -0.6916E-04, -0.9735E-04, -0.1362E-03, -0.1891E-03,  &
      -0.2602E-03, -0.3545E-03, -0.4768E-03, -0.6310E-03, -0.8179E-03,  &
      -0.1032E-02, -0.1265E-02, -0.1508E-02, -0.1757E-02, -0.1989E-02,  &
      -0.2159E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.2321E-09, -0.4350E-09, -0.7861E-09, -0.1347E-08, -0.2144E-08,  &
      -0.3120E-08, -0.4107E-08, -0.4892E-08, -0.5511E-08, -0.6164E-08,  &
      -0.7054E-08, -0.8811E-08, -0.1240E-07, -0.1862E-07, -0.2773E-07,  &
      -0.3957E-07, -0.5371E-07, -0.6939E-07, -0.8564E-07, -0.1006E-06,  &
      -0.1100E-06, -0.1066E-06, -0.8018E-07, -0.1228E-07,  0.1263E-06,  &
      0.3678E-06,  0.7022E-06,  0.1049E-05,  0.1411E-05,  0.2015E-05,   &
      0.3099E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.2064E-05,  0.4104E-05,  0.8141E-05,  0.1607E-04,  0.3145E-04,   &
      0.6080E-04,  0.1153E-03,  0.2129E-03,  0.3802E-03,  0.6538E-03,   &
      0.1078E-02,  0.1699E-02,  0.2576E-02,  0.3805E-02,  0.5540E-02,   &
      0.8004E-02,  0.1149E-01,  0.1640E-01,  0.2329E-01,  0.3290E-01,   &
      0.4622E-01,  0.6441E-01,  0.8888E-01,  0.1210E+00,  0.1622E+00,   &
      0.2132E+00,  0.2745E+00,  0.3470E+00,  0.4317E+00,  0.5286E+00,   &
      0.6335E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.3122E-07, -0.6175E-07, -0.1214E-06, -0.2361E-06, -0.4518E-06,  &
      -0.8438E-06, -0.1524E-05, -0.2643E-05, -0.4380E-05, -0.6922E-05,  &
      -0.1042E-04, -0.1504E-04, -0.2125E-04, -0.2987E-04, -0.4200E-04,  &
      -0.5923E-04, -0.8383E-04, -0.1186E-03, -0.1670E-03, -0.2328E-03,  &
      -0.3204E-03, -0.4347E-03, -0.5802E-03, -0.7595E-03, -0.9703E-03,  &
      -0.1205E-02, -0.1457E-02, -0.1720E-02, -0.1980E-02, -0.2191E-02,  &
      -0.2290E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.1376E-09, -0.2699E-09, -0.5220E-09, -0.9897E-09, -0.1819E-08,  &
      -0.3186E-08, -0.5224E-08, -0.7896E-08, -0.1090E-07, -0.1349E-07,  &
      -0.1443E-07, -0.1374E-07, -0.1386E-07, -0.1673E-07, -0.2237E-07,  &
      -0.3248E-07, -0.5050E-07, -0.7743E-07, -0.1097E-06, -0.1369E-06,  &
      -0.1463E-06, -0.1268E-06, -0.6424E-07,  0.5941E-07,  0.2742E-06,  &
      0.5924E-06,  0.9445E-06,  0.1286E-05,  0.1819E-05,  0.2867E-05,   &
      0.4527E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.2452E-05,  0.4881E-05,  0.9693E-05,  0.1918E-04,  0.3768E-04,   &
      0.7322E-04,  0.1399E-03,  0.2607E-03,  0.4694E-03,  0.8102E-03,   &
      0.1334E-02,  0.2098E-02,  0.3180E-02,  0.4710E-02,  0.6879E-02,   &
      0.9952E-02,  0.1429E-01,  0.2038E-01,  0.2894E-01,  0.4085E-01,   &
      0.5722E-01,  0.7939E-01,  0.1088E+00,  0.1468E+00,  0.1945E+00,   &
      0.2524E+00,  0.3210E+00,  0.4017E+00,  0.4948E+00,  0.5978E+00,   &
      0.7040E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.3547E-07, -0.7029E-07, -0.1386E-06, -0.2709E-06, -0.5218E-06,  &
      -0.9840E-06, -0.1799E-05, -0.3156E-05, -0.5272E-05, -0.8357E-05,  &
      -0.1260E-04, -0.1827E-04, -0.2598E-04, -0.3667E-04, -0.5169E-04,  &
      -0.7312E-04, -0.1037E-03, -0.1467E-03, -0.2060E-03, -0.2857E-03,  &
      -0.3907E-03, -0.5257E-03, -0.6940E-03, -0.8954E-03, -0.1124E-02,  &
      -0.1371E-02, -0.1632E-02, -0.1897E-02, -0.2131E-02, -0.2275E-02,  &
      -0.2265E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.1482E-09, -0.2910E-09, -0.5667E-09, -0.1081E-08, -0.2005E-08,  &
      -0.3554E-08, -0.5902E-08, -0.8925E-08, -0.1209E-07, -0.1448E-07,  &
      -0.1536E-07, -0.1565E-07, -0.1763E-07, -0.2088E-07, -0.2564E-07,  &
      -0.3635E-07, -0.5791E-07, -0.8907E-07, -0.1213E-06, -0.1418E-06,  &
      -0.1397E-06, -0.1000E-06, -0.4427E-08,  0.1713E-06,  0.4536E-06,  &
      0.8086E-06,  0.1153E-05,  0.1588E-05,  0.2437E-05,  0.3905E-05,   &
      0.5874E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.2878E-05,  0.5733E-05,  0.1140E-04,  0.2258E-04,  0.4446E-04,   &
      0.8668E-04,  0.1664E-03,  0.3120E-03,  0.5656E-03,  0.9812E-03,   &
      0.1621E-02,  0.2559E-02,  0.3902E-02,  0.5812E-02,  0.8522E-02,   &
      0.1235E-01,  0.1773E-01,  0.2530E-01,  0.3590E-01,  0.5058E-01,   &
      0.7059E-01,  0.9736E-01,  0.1323E+00,  0.1767E+00,  0.2312E+00,   &
      0.2962E+00,  0.3728E+00,  0.4619E+00,  0.5623E+00,  0.6685E+00,   &
      0.7716E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.4064E-07, -0.8066E-07, -0.1593E-06, -0.3124E-06, -0.6049E-06,  &
      -0.1148E-05, -0.2118E-05, -0.3751E-05, -0.6314E-05, -0.1006E-04,  &
      -0.1526E-04, -0.2232E-04, -0.3196E-04, -0.4525E-04, -0.6394E-04,  &
      -0.9058E-04, -0.1284E-03, -0.1812E-03, -0.2533E-03, -0.3493E-03,  &
      -0.4740E-03, -0.6315E-03, -0.8228E-03, -0.1044E-02, -0.1286E-02,  &
      -0.1544E-02, -0.1810E-02, -0.2061E-02, -0.2243E-02, -0.2291E-02,  &
      -0.2152E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.1630E-09, -0.3213E-09, -0.6266E-09, -0.1201E-08, -0.2248E-08,  &
      -0.4030E-08, -0.6770E-08, -0.1033E-07, -0.1392E-07, -0.1640E-07,  &
      -0.1768E-07, -0.1932E-07, -0.2229E-07, -0.2508E-07, -0.2940E-07,  &
      -0.4200E-07, -0.6717E-07, -0.1002E-06, -0.1286E-06, -0.1402E-06,  &
      -0.1216E-06, -0.5487E-07,  0.8418E-07,  0.3246E-06,  0.6610E-06,  &
      0.1013E-05,  0.1394E-05,  0.2073E-05,  0.3337E-05,  0.5175E-05,   &
      0.7255E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.3282E-05,  0.6539E-05,  0.1300E-04,  0.2578E-04,  0.5085E-04,   &
      0.9936E-04,  0.1914E-03,  0.3608E-03,  0.6586E-03,  0.1153E-02,   &
      0.1924E-02,  0.3074E-02,  0.4742E-02,  0.7126E-02,  0.1051E-01,   &
      0.1526E-01,  0.2195E-01,  0.3133E-01,  0.4441E-01,  0.6238E-01,   &
      0.8664E-01,  0.1186E+00,  0.1597E+00,  0.2108E+00,  0.2723E+00,   &
      0.3450E+00,  0.4300E+00,  0.5272E+00,  0.6324E+00,  0.7378E+00,   &
      0.8330E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.4629E-07, -0.9195E-07, -0.1819E-06, -0.3572E-06, -0.6936E-06,  &
      -0.1323E-05, -0.2456E-05, -0.4385E-05, -0.7453E-05, -0.1200E-04,  &
      -0.1843E-04, -0.2731E-04, -0.3943E-04, -0.5606E-04, -0.7936E-04,  &
      -0.1123E-03, -0.1588E-03, -0.2231E-03, -0.3101E-03, -0.4247E-03,  &
      -0.5713E-03, -0.7522E-03, -0.9651E-03, -0.1202E-02, -0.1456E-02,  &
      -0.1721E-02, -0.1983E-02, -0.2196E-02, -0.2296E-02, -0.2224E-02,  &
      -0.1952E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.1827E-09, -0.3607E-09, -0.7057E-09, -0.1359E-08, -0.2552E-08,  &
      -0.4615E-08, -0.7854E-08, -0.1218E-07, -0.1670E-07, -0.2008E-07,  &
      -0.2241E-07, -0.2516E-07, -0.2796E-07, -0.3015E-07, -0.3506E-07,  &
      -0.4958E-07, -0.7627E-07, -0.1070E-06, -0.1289E-06, -0.1286E-06,  &
      -0.8843E-07,  0.1492E-07,  0.2118E-06,  0.5155E-06,  0.8665E-06,  &
      0.1220E-05,  0.1765E-05,  0.2825E-05,  0.4498E-05,  0.6563E-05,   &
      0.8422E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.3608E-05,  0.7189E-05,  0.1430E-04,  0.2837E-04,  0.5601E-04,   &
      0.1097E-03,  0.2120E-03,  0.4017E-03,  0.7396E-03,  0.1311E-02,   &
      0.2226E-02,  0.3624E-02,  0.5685E-02,  0.8652E-02,  0.1286E-01,   &
      0.1878E-01,  0.2709E-01,  0.3868E-01,  0.5471E-01,  0.7654E-01,   &
      0.1057E+00,  0.1435E+00,  0.1912E+00,  0.2492E+00,  0.3181E+00,   &
      0.3990E+00,  0.4926E+00,  0.5960E+00,  0.7027E+00,  0.8027E+00,   &
      0.8852E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.5164E-07, -0.1026E-06, -0.2031E-06, -0.3994E-06, -0.7771E-06,  &
      -0.1488E-05, -0.2776E-05, -0.5001E-05, -0.8610E-05, -0.1411E-04,  &
      -0.2209E-04, -0.3328E-04, -0.4860E-04, -0.6954E-04, -0.9861E-04,  &
      -0.1393E-03, -0.1961E-03, -0.2738E-03, -0.3778E-03, -0.5132E-03,  &
      -0.6831E-03, -0.8868E-03, -0.1118E-02, -0.1368E-02, -0.1632E-02,  &
      -0.1899E-02, -0.2136E-02, -0.2282E-02, -0.2273E-02, -0.2067E-02,  &
      -0.1679E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.2058E-09, -0.4066E-09, -0.7967E-09, -0.1539E-08, -0.2904E-08,  &
      -0.5293E-08, -0.9116E-08, -0.1447E-07, -0.2058E-07, -0.2608E-07,  &
      -0.3053E-07, -0.3418E-07, -0.3619E-07, -0.3766E-07, -0.4313E-07,  &
      -0.5817E-07, -0.8299E-07, -0.1072E-06, -0.1195E-06, -0.1031E-06,  &
      -0.3275E-07,  0.1215E-06,  0.3835E-06,  0.7220E-06,  0.1062E-05,  &
      0.1504E-05,  0.2367E-05,  0.3854E-05,  0.5842E-05,  0.7875E-05,   &
      0.9082E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.3827E-05,  0.7626E-05,  0.1518E-04,  0.3013E-04,  0.5955E-04,   &
      0.1169E-03,  0.2268E-03,  0.4325E-03,  0.8046E-03,  0.1449E-02,   &
      0.2512E-02,  0.4185E-02,  0.6707E-02,  0.1038E-01,  0.1561E-01,   &
      0.2298E-01,  0.3328E-01,  0.4754E-01,  0.6708E-01,  0.9340E-01,   &
      0.1280E+00,  0.1722E+00,  0.2267E+00,  0.2918E+00,  0.3688E+00,   &
      0.4584E+00,  0.5594E+00,  0.6662E+00,  0.7700E+00,  0.8597E+00,   &
      0.9266E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.5584E-07, -0.1110E-06, -0.2198E-06, -0.4329E-06, -0.8444E-06,  &
      -0.1623E-05, -0.3049E-05, -0.5551E-05, -0.9714E-05, -0.1627E-04,  &
      -0.2609E-04, -0.4015E-04, -0.5955E-04, -0.8603E-04, -0.1223E-03,  &
      -0.1724E-03, -0.2413E-03, -0.3346E-03, -0.4578E-03, -0.6155E-03,  &
      -0.8087E-03, -0.1033E-02, -0.1279E-02, -0.1540E-02, -0.1811E-02,  &
      -0.2065E-02, -0.2251E-02, -0.2301E-02, -0.2163E-02, -0.1828E-02,  &
      -0.1365E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.2274E-09, -0.4498E-09, -0.8814E-09, -0.1708E-08, -0.3247E-08,  &
      -0.5972E-08, -0.1045E-07, -0.1707E-07, -0.2545E-07, -0.3440E-07,  &
      -0.4259E-07, -0.4822E-07, -0.5004E-07, -0.5061E-07, -0.5485E-07,  &
      -0.6687E-07, -0.8483E-07, -0.9896E-07, -0.9646E-07, -0.5557E-07,  &
      0.5765E-07,  0.2752E-06,  0.5870E-06,  0.9188E-06,  0.1291E-05,   &
      0.1971E-05,  0.3251E-05,  0.5115E-05,  0.7221E-05,  0.8825E-05,   &
      0.9032E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.3938E-05,  0.7849E-05,  0.1563E-04,  0.3105E-04,  0.6149E-04,   &
      0.1210E-03,  0.2361E-03,  0.4537E-03,  0.8543E-03,  0.1565E-02,   &
      0.2774E-02,  0.4739E-02,  0.7781E-02,  0.1229E-01,  0.1877E-01,   &
      0.2791E-01,  0.4064E-01,  0.5812E-01,  0.8180E-01,  0.1132E+00,   &
      0.1539E+00,  0.2047E+00,  0.2662E+00,  0.3391E+00,  0.4247E+00,   &
      0.5226E+00,  0.6287E+00,  0.7351E+00,  0.8311E+00,  0.9066E+00,   &
      0.9569E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.5833E-07, -0.1160E-06, -0.2300E-06, -0.4540E-06, -0.8885E-06,  &
      -0.1718E-05, -0.3256E-05, -0.6010E-05, -0.1072E-04, -0.1838E-04,  &
      -0.3026E-04, -0.4772E-04, -0.7223E-04, -0.1057E-03, -0.1512E-03,  &
      -0.2128E-03, -0.2961E-03, -0.4070E-03, -0.5514E-03, -0.7320E-03,  &
      -0.9467E-03, -0.1187E-02, -0.1446E-02, -0.1717E-02, -0.1985E-02,  &
      -0.2203E-02, -0.2307E-02, -0.2237E-02, -0.1965E-02, -0.1532E-02,  &
      -0.1044E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.2426E-09, -0.4805E-09, -0.9447E-09, -0.1841E-08, -0.3519E-08,  &
      -0.6565E-08, -0.1172E-07, -0.1979E-07, -0.3095E-07, -0.4443E-07,  &
      -0.5821E-07, -0.6868E-07, -0.7282E-07, -0.7208E-07, -0.7176E-07,  &
      -0.7562E-07, -0.8110E-07, -0.7934E-07, -0.5365E-07,  0.2483E-07,  &
      0.1959E-06,  0.4731E-06,  0.7954E-06,  0.1123E-05,  0.1652E-05,   &
      0.2711E-05,  0.4402E-05,  0.6498E-05,  0.8392E-05,  0.9154E-05,   &
      0.8261E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.3973E-05,  0.7921E-05,  0.1578E-04,  0.3139E-04,  0.6229E-04,   &
      0.1231E-03,  0.2414E-03,  0.4680E-03,  0.8923E-03,  0.1663E-02,   &
      0.3011E-02,  0.5268E-02,  0.8869E-02,  0.1434E-01,  0.2230E-01,   &
      0.3359E-01,  0.4924E-01,  0.7057E-01,  0.9908E-01,  0.1363E+00,   &
      0.1834E+00,  0.2411E+00,  0.3100E+00,  0.3913E+00,  0.4856E+00,   &
      0.5901E+00,  0.6981E+00,  0.7994E+00,  0.8832E+00,  0.9424E+00,   &
      0.9773E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.5929E-07, -0.1180E-06, -0.2344E-06, -0.4638E-06, -0.9118E-06,  &
      -0.1775E-05, -0.3401E-05, -0.6375E-05, -0.1160E-04, -0.2039E-04,  &
      -0.3444E-04, -0.5575E-04, -0.8641E-04, -0.1287E-03, -0.1856E-03,  &
      -0.2615E-03, -0.3618E-03, -0.4928E-03, -0.6594E-03, -0.8621E-03,  &
      -0.1095E-02, -0.1349E-02, -0.1618E-02, -0.1894E-02, -0.2140E-02,  &
      -0.2293E-02, -0.2290E-02, -0.2085E-02, -0.1696E-02, -0.1212E-02,  &
      -0.7506E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.2496E-09, -0.4954E-09, -0.9780E-09, -0.1915E-08, -0.3697E-08,  &
      -0.6991E-08, -0.1279E-07, -0.2231E-07, -0.3653E-07, -0.5541E-07,  &
      -0.7688E-07, -0.9614E-07, -0.1069E-06, -0.1065E-06, -0.9866E-07,  &
      -0.8740E-07, -0.7192E-07, -0.4304E-07,  0.1982E-07,  0.1525E-06,  &
      0.3873E-06,  0.6947E-06,  0.1000E-05,  0.1409E-05,  0.2253E-05,   &
      0.3739E-05,  0.5744E-05,  0.7812E-05,  0.9067E-05,  0.8746E-05,   &
      0.6940E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.3978E-05,  0.7933E-05,  0.1581E-04,  0.3149E-04,  0.6260E-04,   &
      0.1240E-03,  0.2445E-03,  0.4777E-03,  0.9213E-03,  0.1743E-02,   &
      0.3217E-02,  0.5756E-02,  0.9929E-02,  0.1644E-01,  0.2612E-01,   &
      0.3995E-01,  0.5910E-01,  0.8497E-01,  0.1190E+00,  0.1626E+00,   &
      0.2165E+00,  0.2813E+00,  0.3583E+00,  0.4485E+00,  0.5505E+00,   &
      0.6590E+00,  0.7646E+00,  0.8562E+00,  0.9245E+00,  0.9676E+00,   &
      0.9897E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.5950E-07, -0.1185E-06, -0.2358E-06, -0.4678E-06, -0.9235E-06,  &
      -0.1810E-05, -0.3503E-05, -0.6664E-05, -0.1236E-04, -0.2223E-04,  &
      -0.3849E-04, -0.6396E-04, -0.1017E-03, -0.1545E-03, -0.2257E-03,  &
      -0.3192E-03, -0.4399E-03, -0.5933E-03, -0.7824E-03, -0.1005E-02,  &
      -0.1251E-02, -0.1516E-02, -0.1794E-02, -0.2060E-02, -0.2257E-02,  &
      -0.2318E-02, -0.2186E-02, -0.1853E-02, -0.1386E-02, -0.9021E-03,  &
      -0.5050E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.2515E-09, -0.5001E-09, -0.9904E-09, -0.1951E-08, -0.3800E-08,  &
      -0.7288E-08, -0.1362E-07, -0.2452E-07, -0.4184E-07, -0.6663E-07,  &
      -0.9770E-07, -0.1299E-06, -0.1533E-06, -0.1584E-06, -0.1425E-06,  &
      -0.1093E-06, -0.5972E-07,  0.1426E-07,  0.1347E-06,  0.3364E-06,  &
      0.6209E-06,  0.9169E-06,  0.1243E-05,  0.1883E-05,  0.3145E-05,   &
      0.5011E-05,  0.7136E-05,  0.8785E-05,  0.9048E-05,  0.7686E-05,   &
      0.5368E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.3978E-05,  0.7934E-05,  0.1582E-04,  0.3153E-04,  0.6275E-04,   &
      0.1246E-03,  0.2466E-03,  0.4847E-03,  0.9432E-03,  0.1808E-02,   &
      0.3392E-02,  0.6189E-02,  0.1092E-01,  0.1852E-01,  0.3009E-01,   &
      0.4683E-01,  0.7008E-01,  0.1012E+00,  0.1416E+00,  0.1920E+00,   &
      0.2531E+00,  0.3258E+00,  0.4115E+00,  0.5102E+00,  0.6180E+00,   &
      0.7267E+00,  0.8252E+00,  0.9030E+00,  0.9550E+00,  0.9838E+00,   &
      0.9965E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.5953E-07, -0.1187E-06, -0.2363E-06, -0.4697E-06, -0.9304E-06,  &
      -0.1833E-05, -0.3578E-05, -0.6889E-05, -0.1299E-04, -0.2384E-04,  &
      -0.4227E-04, -0.7201E-04, -0.1174E-03, -0.1825E-03, -0.2710E-03,  &
      -0.3861E-03, -0.5313E-03, -0.7095E-03, -0.9203E-03, -0.1158E-02,  &
      -0.1417E-02, -0.1691E-02, -0.1968E-02, -0.2200E-02, -0.2320E-02,  &
      -0.2263E-02, -0.1998E-02, -0.1563E-02, -0.1068E-02, -0.6300E-03,  &
      -0.3174E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.2520E-09, -0.5016E-09, -0.9963E-09, -0.1971E-08, -0.3867E-08,  &
      -0.7500E-08, -0.1427E-07, -0.2634E-07, -0.4656E-07, -0.7753E-07,  &
      -0.1196E-06, -0.1683E-06, -0.2113E-06, -0.2309E-06, -0.2119E-06,  &
      -0.1518E-06, -0.5200E-07,  0.9274E-07,  0.2973E-06,  0.5714E-06,  &
      0.8687E-06,  0.1152E-05,  0.1621E-05,  0.2634E-05,  0.4310E-05,   &
      0.6418E-05,  0.8347E-05,  0.9162E-05,  0.8319E-05,  0.6209E-05,   &
      0.3844E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.3976E-05,  0.7932E-05,  0.1582E-04,  0.3154E-04,  0.6284E-04,   &
      0.1250E-03,  0.2479E-03,  0.4896E-03,  0.9592E-03,  0.1857E-02,   &
      0.3532E-02,  0.6558E-02,  0.1181E-01,  0.2048E-01,  0.3402E-01,   &
      0.5399E-01,  0.8188E-01,  0.1190E+00,  0.1664E+00,  0.2243E+00,   &
      0.2933E+00,  0.3747E+00,  0.4695E+00,  0.5755E+00,  0.6858E+00,   &
      0.7903E+00,  0.8773E+00,  0.9391E+00,  0.9758E+00,  0.9934E+00,   &
      0.9996E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.5954E-07, -0.1187E-06, -0.2366E-06, -0.4709E-06, -0.9349E-06,  &
      -0.1849E-05, -0.3632E-05, -0.7058E-05, -0.1350E-04, -0.2521E-04,  &
      -0.4564E-04, -0.7958E-04, -0.1329E-03, -0.2114E-03, -0.3200E-03,  &
      -0.4611E-03, -0.6353E-03, -0.8409E-03, -0.1072E-02, -0.1324E-02,  &
      -0.1592E-02, -0.1871E-02, -0.2127E-02, -0.2297E-02, -0.2312E-02,  &
      -0.2123E-02, -0.1738E-02, -0.1247E-02, -0.7744E-03, -0.4117E-03,  &
      -0.1850E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.2522E-09, -0.5025E-09, -0.9997E-09, -0.1983E-08, -0.3912E-08,  &
      -0.7650E-08, -0.1474E-07, -0.2777E-07, -0.5055E-07, -0.8745E-07,  &
      -0.1414E-06, -0.2095E-06, -0.2790E-06, -0.3241E-06, -0.3135E-06,  &
      -0.2269E-06, -0.5896E-07,  0.1875E-06,  0.4996E-06,  0.8299E-06,  &
      0.1115E-05,  0.1467E-05,  0.2236E-05,  0.3672E-05,  0.5668E-05,   &
      0.7772E-05,  0.9094E-05,  0.8827E-05,  0.7041E-05,  0.4638E-05,   &
      0.2539E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.1342E-04,  0.2640E-04,  0.5137E-04,  0.9829E-04,  0.1832E-03,   &
      0.3284E-03,  0.5585E-03,  0.8907E-03,  0.1327E-02,  0.1856E-02,   &
      0.2461E-02,  0.3138E-02,  0.3898E-02,  0.4766E-02,  0.5783E-02,   &
      0.7007E-02,  0.8521E-02,  0.1041E-01,  0.1278E-01,  0.1570E-01,   &
      0.1928E-01,  0.2361E-01,  0.2884E-01,  0.3520E-01,  0.4305E-01,   &
      0.5286E-01,  0.6531E-01,  0.8127E-01,  0.1019E+00,  0.1287E+00,   &
      0.1632E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.5685E-08, -0.1331E-07, -0.3249E-07, -0.8137E-07, -0.2048E-06,  &
      -0.4973E-06, -0.1118E-05, -0.2246E-05, -0.3982E-05, -0.6290E-05,  &
      -0.9040E-05, -0.1215E-04, -0.1567E-04, -0.1970E-04, -0.2449E-04,  &
      -0.3046E-04, -0.3798E-04, -0.4725E-04, -0.5831E-04, -0.7123E-04,  &
      -0.8605E-04, -0.1028E-03, -0.1212E-03, -0.1413E-03, -0.1635E-03,  &
      -0.1884E-03, -0.2160E-03, -0.2461E-03, -0.2778E-03, -0.3098E-03,  &
      -0.3411E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.2169E-10,  0.5237E-10,  0.1296E-09,  0.3204E-09,  0.7665E-09,   &
      0.1691E-08,  0.3222E-08,  0.5110E-08,  0.6779E-08,  0.7681E-08,   &
      0.7378E-08,  0.5836E-08,  0.3191E-08, -0.1491E-08, -0.1022E-07,   &
      -0.2359E-07, -0.3957E-07, -0.5553E-07, -0.6927E-07, -0.7849E-07,  &
      -0.8139E-07, -0.7853E-07, -0.7368E-07, -0.7220E-07, -0.7780E-07,  &
      -0.9091E-07, -0.1038E-06, -0.9929E-07, -0.5422E-07,  0.5379E-07,  &
      0.2350E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.1342E-04,  0.2640E-04,  0.5137E-04,  0.9829E-04,  0.1832E-03,   &
      0.3284E-03,  0.5586E-03,  0.8908E-03,  0.1327E-02,  0.1856E-02,   &
      0.2462E-02,  0.3140E-02,  0.3902E-02,  0.4774E-02,  0.5797E-02,   &
      0.7033E-02,  0.8570E-02,  0.1050E-01,  0.1294E-01,  0.1599E-01,   &
      0.1979E-01,  0.2448E-01,  0.3024E-01,  0.3738E-01,  0.4633E-01,   &
      0.5766E-01,  0.7218E-01,  0.9096E-01,  0.1154E+00,  0.1471E+00,   &
      0.1880E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.5684E-08, -0.1331E-07, -0.3248E-07, -0.8133E-07, -0.2047E-06,  &
      -0.4971E-06, -0.1117E-05, -0.2245E-05, -0.3981E-05, -0.6287E-05,  &
      -0.9035E-05, -0.1215E-04, -0.1565E-04, -0.1967E-04, -0.2444E-04,  &
      -0.3036E-04, -0.3780E-04, -0.4694E-04, -0.5779E-04, -0.7042E-04,  &
      -0.8491E-04, -0.1013E-03, -0.1196E-03, -0.1399E-03, -0.1625E-03,  &
      -0.1879E-03, -0.2163E-03, -0.2474E-03, -0.2803E-03, -0.3140E-03,  &
      -0.3478E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.2168E-10,  0.5242E-10,  0.1295E-09,  0.3201E-09,  0.7662E-09,   &
      0.1690E-08,  0.3220E-08,  0.5106E-08,  0.6776E-08,  0.7673E-08,   &
      0.7362E-08,  0.5808E-08,  0.3138E-08, -0.1595E-08, -0.1041E-07,   &
      -0.2390E-07, -0.4010E-07, -0.5636E-07, -0.7045E-07, -0.7972E-07,  &
      -0.8178E-07, -0.7677E-07, -0.6876E-07, -0.6381E-07, -0.6583E-07,  &
      -0.7486E-07, -0.8229E-07, -0.7017E-07, -0.1497E-07,  0.1051E-06,  &
      0.2990E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.1342E-04,  0.2640E-04,  0.5137E-04,  0.9830E-04,  0.1832E-03,   &
      0.3285E-03,  0.5587E-03,  0.8911E-03,  0.1328E-02,  0.1857E-02,   &
      0.2465E-02,  0.3144E-02,  0.3909E-02,  0.4787E-02,  0.5820E-02,   &
      0.7075E-02,  0.8646E-02,  0.1064E-01,  0.1319E-01,  0.1643E-01,   &
      0.2053E-01,  0.2569E-01,  0.3215E-01,  0.4028E-01,  0.5059E-01,   &
      0.6380E-01,  0.8088E-01,  0.1031E+00,  0.1321E+00,  0.1698E+00,   &
      0.2179E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.5682E-08, -0.1330E-07, -0.3247E-07, -0.8129E-07, -0.2046E-06,  &
      -0.4968E-06, -0.1117E-05, -0.2244E-05, -0.3978E-05, -0.6283E-05,  &
      -0.9027E-05, -0.1213E-04, -0.1563E-04, -0.1963E-04, -0.2436E-04,  &
      -0.3021E-04, -0.3754E-04, -0.4649E-04, -0.5709E-04, -0.6940E-04,  &
      -0.8359E-04, -0.9986E-04, -0.1182E-03, -0.1388E-03, -0.1620E-03,  &
      -0.1882E-03, -0.2175E-03, -0.2498E-03, -0.2843E-03, -0.3203E-03,  &
      -0.3573E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.2167E-10,  0.5238E-10,  0.1294E-09,  0.3198E-09,  0.7656E-09,   &
      0.1688E-08,  0.3217E-08,  0.5104E-08,  0.6767E-08,  0.7661E-08,   &
      0.7337E-08,  0.5764E-08,  0.3051E-08, -0.1752E-08, -0.1068E-07,   &
      -0.2436E-07, -0.4081E-07, -0.5740E-07, -0.7165E-07, -0.8046E-07,  &
      -0.8082E-07, -0.7289E-07, -0.6141E-07, -0.5294E-07, -0.5134E-07,  &
      -0.5552E-07, -0.5609E-07, -0.3464E-07,  0.3275E-07,  0.1669E-06,  &
      0.3745E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.1342E-04,  0.2640E-04,  0.5138E-04,  0.9830E-04,  0.1832E-03,   &
      0.3286E-03,  0.5589E-03,  0.8915E-03,  0.1329E-02,  0.1859E-02,   &
      0.2468E-02,  0.3150E-02,  0.3920E-02,  0.4806E-02,  0.5855E-02,   &
      0.7140E-02,  0.8763E-02,  0.1085E-01,  0.1356E-01,  0.1707E-01,   &
      0.2158E-01,  0.2736E-01,  0.3471E-01,  0.4407E-01,  0.5608E-01,   &
      0.7161E-01,  0.9184E-01,  0.1183E+00,  0.1528E+00,  0.1973E+00,   &
      0.2537E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.5680E-08, -0.1329E-07, -0.3243E-07, -0.8121E-07, -0.2044E-06,  &
      -0.4963E-06, -0.1115E-05, -0.2242E-05, -0.3974E-05, -0.6276E-05,  &
      -0.9015E-05, -0.1211E-04, -0.1559E-04, -0.1956E-04, -0.2423E-04,  &
      -0.2999E-04, -0.3716E-04, -0.4588E-04, -0.5618E-04, -0.6818E-04,  &
      -0.8218E-04, -0.9847E-04, -0.1171E-03, -0.1382E-03, -0.1621E-03,  &
      -0.1892E-03, -0.2197E-03, -0.2535E-03, -0.2902E-03, -0.3293E-03,  &
      -0.3700E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.2166E-10,  0.5229E-10,  0.1294E-09,  0.3193E-09,  0.7644E-09,   &
      0.1686E-08,  0.3213E-08,  0.5092E-08,  0.6753E-08,  0.7640E-08,   &
      0.7302E-08,  0.5696E-08,  0.2917E-08, -0.1984E-08, -0.1108E-07,   &
      -0.2497E-07, -0.4171E-07, -0.5849E-07, -0.7254E-07, -0.8017E-07,  &
      -0.7802E-07, -0.6662E-07, -0.5153E-07, -0.3961E-07, -0.3387E-07,  &
      -0.3219E-07, -0.2426E-07,  0.8700E-08,  0.9027E-07,  0.2400E-06,  &
      0.4623E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.1342E-04,  0.2640E-04,  0.5138E-04,  0.9832E-04,  0.1833E-03,   &
      0.3287E-03,  0.5591E-03,  0.8922E-03,  0.1330E-02,  0.1862E-02,   &
      0.2473E-02,  0.3159E-02,  0.3937E-02,  0.4837E-02,  0.5911E-02,   &
      0.7240E-02,  0.8943E-02,  0.1117E-01,  0.1411E-01,  0.1798E-01,   &
      0.2304E-01,  0.2961E-01,  0.3807E-01,  0.4896E-01,  0.6308E-01,   &
      0.8148E-01,  0.1056E+00,  0.1371E+00,  0.1780E+00,  0.2303E+00,   &
      0.2958E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.5675E-08, -0.1328E-07, -0.3239E-07, -0.8110E-07, -0.2040E-06,  &
      -0.4954E-06, -0.1114E-05, -0.2238E-05, -0.3968E-05, -0.6265E-05,  &
      -0.8996E-05, -0.1208E-04, -0.1553E-04, -0.1945E-04, -0.2404E-04,  &
      -0.2966E-04, -0.3663E-04, -0.4508E-04, -0.5508E-04, -0.6686E-04,  &
      -0.8082E-04, -0.9732E-04, -0.1165E-03, -0.1382E-03, -0.1630E-03,  &
      -0.1913E-03, -0.2234E-03, -0.2593E-03, -0.2989E-03, -0.3417E-03,  &
      -0.3857E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.2163E-10,  0.5209E-10,  0.1291E-09,  0.3186E-09,  0.7626E-09,   &
      0.1682E-08,  0.3203E-08,  0.5078E-08,  0.6730E-08,  0.7606E-08,   &
      0.7246E-08,  0.5592E-08,  0.2735E-08, -0.2325E-08, -0.1162E-07,   &
      -0.2576E-07, -0.4268E-07, -0.5938E-07, -0.7262E-07, -0.7827E-07,  &
      -0.7297E-07, -0.5786E-07, -0.3930E-07, -0.2373E-07, -0.1295E-07,  &
      -0.3728E-08,  0.1465E-07,  0.6114E-07,  0.1590E-06,  0.3257E-06,  &
      0.5622E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.1342E-04,  0.2640E-04,  0.5139E-04,  0.9834E-04,  0.1833E-03,   &
      0.3288E-03,  0.5596E-03,  0.8932E-03,  0.1332E-02,  0.1866E-02,   &
      0.2481E-02,  0.3174E-02,  0.3963E-02,  0.4885E-02,  0.5997E-02,   &
      0.7394E-02,  0.9215E-02,  0.1164E-01,  0.1489E-01,  0.1924E-01,   &
      0.2501E-01,  0.3258E-01,  0.4243E-01,  0.5523E-01,  0.7195E-01,   &
      0.9387E-01,  0.1226E+00,  0.1601E+00,  0.2084E+00,  0.2695E+00,   &
      0.3446E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.5671E-08, -0.1326E-07, -0.3234E-07, -0.8091E-07, -0.2035E-06,  &
      -0.4941E-06, -0.1111E-05, -0.2232E-05, -0.3958E-05, -0.6247E-05,  &
      -0.8966E-05, -0.1202E-04, -0.1544E-04, -0.1929E-04, -0.2377E-04,  &
      -0.2921E-04, -0.3593E-04, -0.4409E-04, -0.5385E-04, -0.6555E-04,  &
      -0.7965E-04, -0.9656E-04, -0.1163E-03, -0.1390E-03, -0.1649E-03,  &
      -0.1947E-03, -0.2288E-03, -0.2675E-03, -0.3109E-03, -0.3575E-03,  &
      -0.4039E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.2155E-10,  0.5188E-10,  0.1288E-09,  0.3175E-09,  0.7599E-09,   &
      0.1675E-08,  0.3190E-08,  0.5059E-08,  0.6699E-08,  0.7551E-08,   &
      0.7154E-08,  0.5435E-08,  0.2452E-08, -0.2802E-08, -0.1235E-07,   &
      -0.2668E-07, -0.4353E-07, -0.5962E-07, -0.7134E-07, -0.7435E-07,  &
      -0.6551E-07, -0.4676E-07, -0.2475E-07, -0.4876E-08,  0.1235E-07,  &
      0.3092E-07,  0.6192E-07,  0.1243E-06,  0.2400E-06,  0.4247E-06,   &
      0.6755E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.1342E-04,  0.2640E-04,  0.5139E-04,  0.9837E-04,  0.1834E-03,   &
      0.3291E-03,  0.5603E-03,  0.8949E-03,  0.1336E-02,  0.1873E-02,   &
      0.2494E-02,  0.3198E-02,  0.4005E-02,  0.4960E-02,  0.6130E-02,   &
      0.7628E-02,  0.9618E-02,  0.1232E-01,  0.1599E-01,  0.2097E-01,   &
      0.2764E-01,  0.3646E-01,  0.4803E-01,  0.6319E-01,  0.8312E-01,   &
      0.1093E+00,  0.1436E+00,  0.1881E+00,  0.2448E+00,  0.3153E+00,   &
      0.4001E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.5665E-08, -0.1322E-07, -0.3224E-07, -0.8063E-07, -0.2027E-06,  &
      -0.4921E-06, -0.1106E-05, -0.2223E-05, -0.3942E-05, -0.6220E-05,  &
      -0.8920E-05, -0.1194E-04, -0.1530E-04, -0.1905E-04, -0.2337E-04,  &
      -0.2860E-04, -0.3505E-04, -0.4296E-04, -0.5259E-04, -0.6439E-04,  &
      -0.7884E-04, -0.9635E-04, -0.1170E-03, -0.1407E-03, -0.1681E-03,  &
      -0.1998E-03, -0.2366E-03, -0.2790E-03, -0.3265E-03, -0.3763E-03,  &
      -0.4235E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.2157E-10,  0.5178E-10,  0.1283E-09,  0.3162E-09,  0.7558E-09,   &
      0.1665E-08,  0.3169E-08,  0.5027E-08,  0.6645E-08,  0.7472E-08,   &
      0.7017E-08,  0.5212E-08,  0.2059E-08, -0.3443E-08, -0.1321E-07,   &
      -0.2754E-07, -0.4389E-07, -0.5869E-07, -0.6825E-07, -0.6819E-07,  &
      -0.5570E-07, -0.3343E-07, -0.7592E-08,  0.1778E-07,  0.4322E-07,  &
      0.7330E-07,  0.1190E-06,  0.1993E-06,  0.3348E-06,  0.5376E-06,   &
      0.8030E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.1342E-04,  0.2641E-04,  0.5141E-04,  0.9842E-04,  0.1836E-03,   &
      0.3295E-03,  0.5614E-03,  0.8975E-03,  0.1341E-02,  0.1884E-02,   &
      0.2514E-02,  0.3234E-02,  0.4071E-02,  0.5075E-02,  0.6332E-02,   &
      0.7976E-02,  0.1021E-01,  0.1328E-01,  0.1751E-01,  0.2329E-01,   &
      0.3109E-01,  0.4146E-01,  0.5517E-01,  0.7325E-01,  0.9710E-01,   &
      0.1284E+00,  0.1693E+00,  0.2217E+00,  0.2876E+00,  0.3679E+00,   &
      0.4616E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.5652E-08, -0.1318E-07, -0.3210E-07, -0.8018E-07, -0.2014E-06,  &
      -0.4888E-06, -0.1099E-05, -0.2210E-05, -0.3918E-05, -0.6179E-05,  &
      -0.8849E-05, -0.1182E-04, -0.1509E-04, -0.1871E-04, -0.2284E-04,  &
      -0.2782E-04, -0.3403E-04, -0.4177E-04, -0.5145E-04, -0.6354E-04,  &
      -0.7853E-04, -0.9681E-04, -0.1185E-03, -0.1437E-03, -0.1729E-03,  &
      -0.2072E-03, -0.2475E-03, -0.2942E-03, -0.3457E-03, -0.3973E-03,  &
      -0.4434E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.2153E-10,  0.5151E-10,  0.1273E-09,  0.3136E-09,  0.7488E-09,   &
      0.1649E-08,  0.3142E-08,  0.4980E-08,  0.6559E-08,  0.7346E-08,   &
      0.6813E-08,  0.4884E-08,  0.1533E-08, -0.4209E-08, -0.1409E-07,   &
      -0.2801E-07, -0.4320E-07, -0.5614E-07, -0.6312E-07, -0.5976E-07,  &
      -0.4369E-07, -0.1775E-07,  0.1280E-07,  0.4534E-07,  0.8106E-07,  &
      0.1246E-06,  0.1874E-06,  0.2873E-06,  0.4433E-06,  0.6651E-06,   &
      0.9477E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.1342E-04,  0.2641E-04,  0.5143E-04,  0.9849E-04,  0.1838E-03,   &
      0.3302E-03,  0.5631E-03,  0.9016E-03,  0.1350E-02,  0.1901E-02,   &
      0.2546E-02,  0.3292E-02,  0.4171E-02,  0.5250E-02,  0.6634E-02,   &
      0.8486E-02,  0.1104E-01,  0.1460E-01,  0.1955E-01,  0.2635E-01,   &
      0.3555E-01,  0.4786E-01,  0.6421E-01,  0.8588E-01,  0.1145E+00,   &
      0.1519E+00,  0.2003E+00,  0.2615E+00,  0.3372E+00,  0.4269E+00,   &
      0.5281E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.5629E-08, -0.1310E-07, -0.3186E-07, -0.7948E-07, -0.1995E-06,  &
      -0.4837E-06, -0.1088E-05, -0.2188E-05, -0.3880E-05, -0.6115E-05,  &
      -0.8743E-05, -0.1165E-04, -0.1480E-04, -0.1824E-04, -0.2216E-04,  &
      -0.2691E-04, -0.3293E-04, -0.4067E-04, -0.5057E-04, -0.6314E-04,  &
      -0.7885E-04, -0.9813E-04, -0.1212E-03, -0.1482E-03, -0.1799E-03,  &
      -0.2175E-03, -0.2622E-03, -0.3135E-03, -0.3678E-03, -0.4193E-03,  &
      -0.4627E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.2121E-10,  0.5076E-10,  0.1257E-09,  0.3091E-09,  0.7379E-09,   &
      0.1623E-08,  0.3097E-08,  0.4904E-08,  0.6453E-08,  0.7168E-08,   &
      0.6534E-08,  0.4458E-08,  0.8932E-09, -0.5026E-08, -0.1469E-07,   &
      -0.2765E-07, -0.4103E-07, -0.5169E-07, -0.5585E-07, -0.4913E-07,  &
      -0.2954E-07,  0.6372E-09,  0.3738E-07,  0.7896E-07,  0.1272E-06,  &
      0.1867E-06,  0.2682E-06,  0.3895E-06,  0.5672E-06,  0.8091E-06,   &
      0.1114E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.1343E-04,  0.2642E-04,  0.5147E-04,  0.9861E-04,  0.1842E-03,   &
      0.3312E-03,  0.5658E-03,  0.9080E-03,  0.1364E-02,  0.1928E-02,   &
      0.2595E-02,  0.3379E-02,  0.4325E-02,  0.5513E-02,  0.7077E-02,   &
      0.9215E-02,  0.1220E-01,  0.1640E-01,  0.2226E-01,  0.3032E-01,   &
      0.4127E-01,  0.5598E-01,  0.7559E-01,  0.1016E+00,  0.1359E+00,   &
      0.1804E+00,  0.2372E+00,  0.3081E+00,  0.3935E+00,  0.4916E+00,   &
      0.5975E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.5597E-08, -0.1300E-07, -0.3148E-07, -0.7838E-07, -0.1964E-06,  &
      -0.4759E-06, -0.1071E-05, -0.2155E-05, -0.3822E-05, -0.6019E-05,  &
      -0.8586E-05, -0.1139E-04, -0.1439E-04, -0.1764E-04, -0.2134E-04,  &
      -0.2591E-04, -0.3188E-04, -0.3978E-04, -0.5011E-04, -0.6334E-04,  &
      -0.7998E-04, -0.1006E-03, -0.1253E-03, -0.1547E-03, -0.1895E-03,  &
      -0.2315E-03, -0.2811E-03, -0.3363E-03, -0.3917E-03, -0.4413E-03,  &
      -0.4809E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.2109E-10,  0.5017E-10,  0.1235E-09,  0.3021E-09,  0.7217E-09,   &
      0.1585E-08,  0.3028E-08,  0.4796E-08,  0.6285E-08,  0.6910E-08,   &
      0.6178E-08,  0.3945E-08,  0.2436E-09, -0.5632E-08, -0.1464E-07,   &
      -0.2596E-07, -0.3707E-07, -0.4527E-07, -0.4651E-07, -0.3644E-07,  &
      -0.1296E-07,  0.2250E-07,  0.6722E-07,  0.1202E-06,  0.1831E-06,  &
      0.2605E-06,  0.3627E-06,  0.5062E-06,  0.7064E-06,  0.9725E-06,   &
      0.1304E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.1343E-04,  0.2644E-04,  0.5152E-04,  0.9878E-04,  0.1847E-03,   &
      0.3328E-03,  0.5701E-03,  0.9179E-03,  0.1385E-02,  0.1969E-02,   &
      0.2671E-02,  0.3513E-02,  0.4554E-02,  0.5900E-02,  0.7713E-02,   &
      0.1023E-01,  0.1379E-01,  0.1879E-01,  0.2578E-01,  0.3542E-01,   &
      0.4854E-01,  0.6622E-01,  0.8983E-01,  0.1211E+00,  0.1619E+00,   &
      0.2145E+00,  0.2807E+00,  0.3614E+00,  0.4559E+00,  0.5603E+00,   &
      0.6675E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.5538E-08, -0.1280E-07, -0.3089E-07, -0.7667E-07, -0.1917E-06,  &
      -0.4642E-06, -0.1045E-05, -0.2106E-05, -0.3736E-05, -0.5878E-05,  &
      -0.8363E-05, -0.1104E-04, -0.1387E-04, -0.1692E-04, -0.2044E-04,  &
      -0.2493E-04, -0.3101E-04, -0.3926E-04, -0.5020E-04, -0.6429E-04,  &
      -0.8213E-04, -0.1044E-03, -0.1314E-03, -0.1637E-03, -0.2027E-03,  &
      -0.2498E-03, -0.3042E-03, -0.3617E-03, -0.4163E-03, -0.4625E-03,  &
      -0.4969E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.2067E-10,  0.4903E-10,  0.1200E-09,  0.2917E-09,  0.6965E-09,   &
      0.1532E-08,  0.2925E-08,  0.4632E-08,  0.6054E-08,  0.6590E-08,   &
      0.5746E-08,  0.3436E-08, -0.2251E-09, -0.5703E-08, -0.1344E-07,   &
      -0.2256E-07, -0.3120E-07, -0.3690E-07, -0.3520E-07, -0.2164E-07,  &
      0.6510E-08,  0.4895E-07,  0.1037E-06,  0.1702E-06,  0.2502E-06,   &
      0.3472E-06,  0.4710E-06,  0.6379E-06,  0.8633E-06,  0.1159E-05,   &
      0.1514E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.1344E-04,  0.2647E-04,  0.5161E-04,  0.9906E-04,  0.1856E-03,   &
      0.3353E-03,  0.5765E-03,  0.9331E-03,  0.1417E-02,  0.2032E-02,   &
      0.2785E-02,  0.3712E-02,  0.4892E-02,  0.6456E-02,  0.8604E-02,   &
      0.1162E-01,  0.1590E-01,  0.2192E-01,  0.3033E-01,  0.4193E-01,   &
      0.5774E-01,  0.7906E-01,  0.1075E+00,  0.1449E+00,  0.1934E+00,   &
      0.2549E+00,  0.3309E+00,  0.4213E+00,  0.5232E+00,  0.6308E+00,   &
      0.7348E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.5476E-08, -0.1257E-07, -0.3008E-07, -0.7418E-07, -0.1848E-06,  &
      -0.4468E-06, -0.1006E-05, -0.2032E-05, -0.3611E-05, -0.5679E-05,  &
      -0.8058E-05, -0.1059E-04, -0.1324E-04, -0.1612E-04, -0.1956E-04,  &
      -0.2411E-04, -0.3046E-04, -0.3925E-04, -0.5098E-04, -0.6619E-04,  &
      -0.8562E-04, -0.1100E-03, -0.1399E-03, -0.1761E-03, -0.2202E-03,  &
      -0.2726E-03, -0.3306E-03, -0.3885E-03, -0.4404E-03, -0.4820E-03,  &
      -0.5082E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.2041E-10,  0.4771E-10,  0.1149E-09,  0.2782E-09,  0.6614E-09,   &
      0.1451E-08,  0.2778E-08,  0.4401E-08,  0.5736E-08,  0.6189E-08,   &
      0.5315E-08,  0.3087E-08, -0.2518E-09, -0.4806E-08, -0.1071E-07,   &
      -0.1731E-07, -0.2346E-07, -0.2659E-07, -0.2184E-07, -0.4261E-08,  &
      0.2975E-07,  0.8112E-07,  0.1484E-06,  0.2308E-06,  0.3296E-06,   &
      0.4475E-06,  0.5942E-06,  0.7859E-06,  0.1041E-05,  0.1369E-05,   &
      0.1726E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.1345E-04,  0.2650E-04,  0.5173E-04,  0.9947E-04,  0.1868E-03,   &
      0.3389E-03,  0.5861E-03,  0.9559E-03,  0.1466E-02,  0.2125E-02,   &
      0.2955E-02,  0.4004E-02,  0.5376E-02,  0.7235E-02,  0.9824E-02,   &
      0.1348E-01,  0.1866E-01,  0.2596E-01,  0.3613E-01,  0.5016E-01,   &
      0.6929E-01,  0.9504E-01,  0.1292E+00,  0.1738E+00,  0.2309E+00,   &
      0.3021E+00,  0.3880E+00,  0.4868E+00,  0.5936E+00,  0.7003E+00,   &
      0.7964E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.5362E-08, -0.1223E-07, -0.2895E-07, -0.7071E-07, -0.1748E-06,  &
      -0.4219E-06, -0.9516E-06, -0.1928E-05, -0.3436E-05, -0.5409E-05,  &
      -0.7666E-05, -0.1005E-04, -0.1254E-04, -0.1533E-04, -0.1880E-04,  &
      -0.2358E-04, -0.3038E-04, -0.3988E-04, -0.5264E-04, -0.6934E-04,  &
      -0.9083E-04, -0.1179E-03, -0.1515E-03, -0.1927E-03, -0.2424E-03,  &
      -0.2994E-03, -0.3591E-03, -0.4155E-03, -0.4634E-03, -0.4982E-03,  &
      -0.5096E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.1976E-10,  0.4551E-10,  0.1086E-09,  0.2601E-09,  0.6126E-09,   &
      0.1345E-08,  0.2583E-08,  0.4112E-08,  0.5365E-08,  0.5796E-08,   &
      0.5031E-08,  0.3182E-08,  0.5970E-09, -0.2547E-08, -0.6172E-08,   &
      -0.1017E-07, -0.1388E-07, -0.1430E-07, -0.6118E-08,  0.1624E-07,  &
      0.5791E-07,  0.1205E-06,  0.2025E-06,  0.3032E-06,  0.4225E-06,   &
      0.5619E-06,  0.7322E-06,  0.9528E-06,  0.1243E-05,  0.1592E-05,   &
      0.1904E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.1346E-04,  0.2655E-04,  0.5192E-04,  0.1001E-03,  0.1887E-03,   &
      0.3442E-03,  0.6001E-03,  0.9892E-03,  0.1536E-02,  0.2262E-02,   &
      0.3200E-02,  0.4420E-02,  0.6053E-02,  0.8300E-02,  0.1146E-01,   &
      0.1592E-01,  0.2224E-01,  0.3112E-01,  0.4348E-01,  0.6051E-01,   &
      0.8369E-01,  0.1147E+00,  0.1556E+00,  0.2084E+00,  0.2749E+00,   &
      0.3561E+00,  0.4511E+00,  0.5562E+00,  0.6644E+00,  0.7655E+00,   &
      0.8499E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.5210E-08, -0.1172E-07, -0.2731E-07, -0.6598E-07, -0.1615E-06,  &
      -0.3880E-06, -0.8769E-06, -0.1787E-05, -0.3204E-05, -0.5066E-05,  &
      -0.7197E-05, -0.9451E-05, -0.1185E-04, -0.1465E-04, -0.1831E-04,  &
      -0.2346E-04, -0.3088E-04, -0.4132E-04, -0.5545E-04, -0.7410E-04,  &
      -0.9820E-04, -0.1288E-03, -0.1670E-03, -0.2140E-03, -0.2692E-03,  &
      -0.3293E-03, -0.3886E-03, -0.4417E-03, -0.4840E-03, -0.5073E-03,  &
      -0.4944E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.1880E-10,  0.4271E-10,  0.9966E-10,  0.2352E-09,  0.5497E-09,   &
      0.1205E-08,  0.2334E-08,  0.3765E-08,  0.4993E-08,  0.5532E-08,   &
      0.5148E-08,  0.4055E-08,  0.2650E-08,  0.1326E-08,  0.2019E-09,   &
      -0.1124E-08, -0.2234E-08,  0.2827E-09,  0.1247E-07,  0.4102E-07,  &
      0.9228E-07,  0.1682E-06,  0.2676E-06,  0.3885E-06,  0.5286E-06,   &
      0.6904E-06,  0.8871E-06,  0.1142E-05,  0.1466E-05,  0.1800E-05,   &
      0.2004E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.1348E-04,  0.2663E-04,  0.5216E-04,  0.1009E-03,  0.1912E-03,   &
      0.3515E-03,  0.6196E-03,  0.1036E-02,  0.1637E-02,  0.2456E-02,   &
      0.3544E-02,  0.4996E-02,  0.6973E-02,  0.9722E-02,  0.1360E-01,   &
      0.1908E-01,  0.2681E-01,  0.3766E-01,  0.5272E-01,  0.7343E-01,   &
      0.1015E+00,  0.1388E+00,  0.1874E+00,  0.2492E+00,  0.3257E+00,   &
      0.4165E+00,  0.5191E+00,  0.6275E+00,  0.7324E+00,  0.8235E+00,   &
      0.8939E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.5045E-08, -0.1113E-07, -0.2540E-07, -0.6008E-07, -0.1449E-06,  &
      -0.3457E-06, -0.7826E-06, -0.1609E-05, -0.2920E-05, -0.4665E-05,  &
      -0.6691E-05, -0.8868E-05, -0.1127E-04, -0.1422E-04, -0.1820E-04,  &
      -0.2389E-04, -0.3213E-04, -0.4380E-04, -0.5975E-04, -0.8092E-04,  &
      -0.1083E-03, -0.1433E-03, -0.1873E-03, -0.2402E-03, -0.2997E-03,  &
      -0.3607E-03, -0.4178E-03, -0.4662E-03, -0.4994E-03, -0.5028E-03,  &
      -0.4563E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.1804E-10,  0.3983E-10,  0.9045E-10,  0.2080E-09,  0.4786E-09,   &
      0.1046E-08,  0.2052E-08,  0.3413E-08,  0.4704E-08,  0.5565E-08,   &
      0.5887E-08,  0.5981E-08,  0.6202E-08,  0.6998E-08,  0.8493E-08,   &
      0.1002E-07,  0.1184E-07,  0.1780E-07,  0.3483E-07,  0.7122E-07,   &
      0.1341E-06,  0.2259E-06,  0.3446E-06,  0.4866E-06,  0.6486E-06,   &
      0.8343E-06,  0.1063E-05,  0.1356E-05,  0.1690E-05,  0.1951E-05,   &
      0.2005E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.1351E-04,  0.2672E-04,  0.5247E-04,  0.1019E-03,  0.1944E-03,   &
      0.3609E-03,  0.6451E-03,  0.1098E-02,  0.1772E-02,  0.2718E-02,   &
      0.4009E-02,  0.5767E-02,  0.8190E-02,  0.1158E-01,  0.1636E-01,   &
      0.2311E-01,  0.3260E-01,  0.4586E-01,  0.6425E-01,  0.8940E-01,   &
      0.1232E+00,  0.1678E+00,  0.2251E+00,  0.2967E+00,  0.3831E+00,   &
      0.4825E+00,  0.5901E+00,  0.6976E+00,  0.7946E+00,  0.8725E+00,   &
      0.9285E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.4850E-08, -0.1045E-07, -0.2334E-07, -0.5367E-07, -0.1265E-06,  &
      -0.2980E-06, -0.6750E-06, -0.1406E-05, -0.2601E-05, -0.4239E-05,  &
      -0.6201E-05, -0.8389E-05, -0.1091E-04, -0.1413E-04, -0.1859E-04,  &
      -0.2500E-04, -0.3432E-04, -0.4761E-04, -0.6595E-04, -0.9030E-04,  &
      -0.1219E-03, -0.1624E-03, -0.2126E-03, -0.2708E-03, -0.3327E-03,  &
      -0.3926E-03, -0.4458E-03, -0.4871E-03, -0.5045E-03, -0.4777E-03,  &
      -0.3954E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.1717E-10,  0.3723E-10,  0.8093E-10,  0.1817E-09,  0.4100E-09,   &
      0.8932E-09,  0.1791E-08,  0.3126E-08,  0.4634E-08,  0.6095E-08,   &
      0.7497E-08,  0.9170E-08,  0.1136E-07,  0.1453E-07,  0.1892E-07,   &
      0.2369E-07,  0.2909E-07,  0.3922E-07,  0.6232E-07,  0.1083E-06,   &
      0.1847E-06,  0.2943E-06,  0.4336E-06,  0.5970E-06,  0.7815E-06,   &
      0.9959E-06,  0.1263E-05,  0.1583E-05,  0.1880E-05,  0.2009E-05,   &
      0.1914E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.1353E-04,  0.2681E-04,  0.5283E-04,  0.1031E-03,  0.1981E-03,   &
      0.3721E-03,  0.6761E-03,  0.1176E-02,  0.1943E-02,  0.3055E-02,   &
      0.4612E-02,  0.6766E-02,  0.9760E-02,  0.1396E-01,  0.1986E-01,   &
      0.2818E-01,  0.3984E-01,  0.5609E-01,  0.7850E-01,  0.1090E+00,   &
      0.1495E+00,  0.2023E+00,  0.2691E+00,  0.3508E+00,  0.4465E+00,   &
      0.5524E+00,  0.6613E+00,  0.7633E+00,  0.8485E+00,  0.9119E+00,   &
      0.9543E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.4673E-08, -0.9862E-08, -0.2135E-07, -0.4753E-07, -0.1087E-06,  &
      -0.2512E-06, -0.5671E-06, -0.1199E-05, -0.2281E-05, -0.3842E-05,  &
      -0.5804E-05, -0.8110E-05, -0.1088E-04, -0.1452E-04, -0.1961E-04,  &
      -0.2696E-04, -0.3768E-04, -0.5311E-04, -0.7444E-04, -0.1028E-03,  &
      -0.1397E-03, -0.1865E-03, -0.2427E-03, -0.3047E-03, -0.3667E-03,  &
      -0.4237E-03, -0.4712E-03, -0.5003E-03, -0.4921E-03, -0.4286E-03,  &
      -0.3188E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.1653E-10,  0.3436E-10,  0.7431E-10,  0.1605E-09,  0.3548E-09,   &
      0.7723E-09,  0.1595E-08,  0.2966E-08,  0.4849E-08,  0.7169E-08,   &
      0.1003E-07,  0.1366E-07,  0.1825E-07,  0.2419E-07,  0.3186E-07,   &
      0.4068E-07,  0.5064E-07,  0.6618E-07,  0.9684E-07,  0.1536E-06,   &
      0.2450E-06,  0.3730E-06,  0.5328E-06,  0.7184E-06,  0.9291E-06,   &
      0.1180E-05,  0.1484E-05,  0.1798E-05,  0.1992E-05,  0.1968E-05,   &
      0.1736E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.1356E-04,  0.2691E-04,  0.5318E-04,  0.1043E-03,  0.2020E-03,   &
      0.3841E-03,  0.7100E-03,  0.1263E-02,  0.2144E-02,  0.3464E-02,   &
      0.5359E-02,  0.8019E-02,  0.1174E-01,  0.1694E-01,  0.2426E-01,   &
      0.3451E-01,  0.4883E-01,  0.6870E-01,  0.9593E-01,  0.1326E+00,   &
      0.1809E+00,  0.2428E+00,  0.3196E+00,  0.4112E+00,  0.5147E+00,   &
      0.6239E+00,  0.7297E+00,  0.8217E+00,  0.8928E+00,  0.9421E+00,   &
      0.9726E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.4532E-08, -0.9395E-08, -0.1978E-07, -0.4272E-07, -0.9442E-07,  &
      -0.2124E-06, -0.4747E-06, -0.1017E-05, -0.2003E-05, -0.3524E-05,  &
      -0.5567E-05, -0.8108E-05, -0.1127E-04, -0.1547E-04, -0.2138E-04,  &
      -0.2996E-04, -0.4251E-04, -0.6059E-04, -0.8563E-04, -0.1190E-03,  &
      -0.1623E-03, -0.2156E-03, -0.2767E-03, -0.3403E-03, -0.4006E-03,  &
      -0.4530E-03, -0.4912E-03, -0.4995E-03, -0.4563E-03, -0.3592E-03,  &
      -0.2383E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.1593E-10,  0.3276E-10,  0.6896E-10,  0.1476E-09,  0.3190E-09,   &
      0.6944E-09,  0.1474E-08,  0.2935E-08,  0.5300E-08,  0.8697E-08,   &
      0.1336E-07,  0.1946E-07,  0.2707E-07,  0.3637E-07,  0.4800E-07,   &
      0.6187E-07,  0.7806E-07,  0.1008E-06,  0.1404E-06,  0.2089E-06,   &
      0.3153E-06,  0.4613E-06,  0.6416E-06,  0.8506E-06,  0.1095E-05,   &
      0.1387E-05,  0.1708E-05,  0.1956E-05,  0.2003E-05,  0.1836E-05,   &
      0.1483E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.1358E-04,  0.2700E-04,  0.5350E-04,  0.1054E-03,  0.2057E-03,   &
      0.3955E-03,  0.7434E-03,  0.1353E-02,  0.2361E-02,  0.3928E-02,   &
      0.6237E-02,  0.9531E-02,  0.1416E-01,  0.2063E-01,  0.2968E-01,   &
      0.4233E-01,  0.5990E-01,  0.8412E-01,  0.1170E+00,  0.1608E+00,   &
      0.2177E+00,  0.2894E+00,  0.3764E+00,  0.4768E+00,  0.5855E+00,   &
      0.6941E+00,  0.7921E+00,  0.8710E+00,  0.9276E+00,  0.9641E+00,   &
      0.9846E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.4448E-08, -0.9085E-08, -0.1877E-07, -0.3946E-07, -0.8472E-07,  &
      -0.1852E-06, -0.4074E-06, -0.8791E-06, -0.1789E-05, -0.3314E-05,  &
      -0.5521E-05, -0.8425E-05, -0.1215E-04, -0.1711E-04, -0.2407E-04,  &
      -0.3421E-04, -0.4905E-04, -0.7032E-04, -0.9985E-04, -0.1394E-03,  &
      -0.1897E-03, -0.2491E-03, -0.3132E-03, -0.3763E-03, -0.4332E-03,  &
      -0.4786E-03, -0.5005E-03, -0.4775E-03, -0.3970E-03, -0.2794E-03,  &
      -0.1652E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.1566E-10,  0.3219E-10,  0.6635E-10,  0.1400E-09,  0.2999E-09,   &
      0.6513E-09,  0.1406E-08,  0.2953E-08,  0.5789E-08,  0.1037E-07,   &
      0.1709E-07,  0.2623E-07,  0.3777E-07,  0.5159E-07,  0.6823E-07,   &
      0.8864E-07,  0.1134E-06,  0.1461E-06,  0.1960E-06,  0.2761E-06,   &
      0.3962E-06,  0.5583E-06,  0.7580E-06,  0.9957E-06,  0.1282E-05,   &
      0.1607E-05,  0.1898E-05,  0.2020E-05,  0.1919E-05,  0.1623E-05,   &
      0.1171E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.1360E-04,  0.2707E-04,  0.5375E-04,  0.1063E-03,  0.2087E-03,   &
      0.4052E-03,  0.7731E-03,  0.1437E-02,  0.2575E-02,  0.4414E-02,   &
      0.7212E-02,  0.1128E-01,  0.1704E-01,  0.2509E-01,  0.3631E-01,   &
      0.5188E-01,  0.7338E-01,  0.1028E+00,  0.1422E+00,  0.1940E+00,   &
      0.2603E+00,  0.3422E+00,  0.4387E+00,  0.5459E+00,  0.6563E+00,   &
      0.7597E+00,  0.8461E+00,  0.9105E+00,  0.9536E+00,  0.9791E+00,   &
      0.9920E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.4403E-08, -0.8896E-08, -0.1818E-07, -0.3751E-07, -0.7880E-07,  &
      -0.1683E-06, -0.3640E-06, -0.7852E-06, -0.1640E-05, -0.3191E-05,  &
      -0.5634E-05, -0.9046E-05, -0.1355E-04, -0.1953E-04, -0.2786E-04,  &
      -0.3995E-04, -0.5752E-04, -0.8256E-04, -0.1174E-03, -0.1638E-03,  &
      -0.2211E-03, -0.2854E-03, -0.3507E-03, -0.4116E-03, -0.4633E-03,  &
      -0.4966E-03, -0.4921E-03, -0.4309E-03, -0.3215E-03, -0.2016E-03,  &
      -0.1061E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.1551E-10,  0.3147E-10,  0.6419E-10,  0.1356E-09,  0.2860E-09,   &
      0.6178E-09,  0.1353E-08,  0.2934E-08,  0.6095E-08,  0.1174E-07,   &
      0.2067E-07,  0.3346E-07,  0.5014E-07,  0.7024E-07,  0.9377E-07,   &
      0.1226E-06,  0.1592E-06,  0.2056E-06,  0.2678E-06,  0.3584E-06,   &
      0.4892E-06,  0.6651E-06,  0.8859E-06,  0.1160E-05,  0.1488E-05,   &
      0.1814E-05,  0.2010E-05,  0.1984E-05,  0.1748E-05,  0.1338E-05,   &
      0.8445E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.1361E-04,  0.2711E-04,  0.5393E-04,  0.1070E-03,  0.2110E-03,   &
      0.4129E-03,  0.7973E-03,  0.1508E-02,  0.2769E-02,  0.4886E-02,   &
      0.8229E-02,  0.1322E-01,  0.2037E-01,  0.3038E-01,  0.4427E-01,   &
      0.6342E-01,  0.8963E-01,  0.1250E+00,  0.1720E+00,  0.2327E+00,   &
      0.3089E+00,  0.4007E+00,  0.5052E+00,  0.6163E+00,  0.7241E+00,   &
      0.8179E+00,  0.8905E+00,  0.9408E+00,  0.9720E+00,  0.9887E+00,   &
      0.9961E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.4379E-08, -0.8801E-08, -0.1782E-07, -0.3642E-07, -0.7536E-07,  &
      -0.1581E-06, -0.3366E-06, -0.7227E-06, -0.1532E-05, -0.3106E-05,  &
      -0.5810E-05, -0.9862E-05, -0.1540E-04, -0.2279E-04, -0.3292E-04,  &
      -0.4738E-04, -0.6817E-04, -0.9765E-04, -0.1384E-03, -0.1918E-03,  &
      -0.2551E-03, -0.3226E-03, -0.3876E-03, -0.4452E-03, -0.4883E-03,  &
      -0.5005E-03, -0.4598E-03, -0.3633E-03, -0.2416E-03, -0.1349E-03,  &
      -0.6278E-04/
  DATA ((h73(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.1542E-10,  0.3111E-10,  0.6345E-10,  0.1310E-09,  0.2742E-09,   &
      0.5902E-09,  0.1289E-08,  0.2826E-08,  0.6103E-08,  0.1250E-07,   &
      0.2355E-07,  0.4041E-07,  0.6347E-07,  0.9217E-07,  0.1256E-06,   &
      0.1658E-06,  0.2175E-06,  0.2824E-06,  0.3607E-06,  0.4614E-06,   &
      0.6004E-06,  0.7880E-06,  0.1034E-05,  0.1349E-05,  0.1698E-05,   &
      0.1965E-05,  0.2021E-05,  0.1857E-05,  0.1500E-05,  0.1015E-05,   &
      0.5467E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.1362E-04,  0.2714E-04,  0.5405E-04,  0.1074E-03,  0.2127E-03,   &
      0.4187E-03,  0.8159E-03,  0.1565E-02,  0.2933E-02,  0.5314E-02,   &
      0.9222E-02,  0.1525E-01,  0.2406E-01,  0.3649E-01,  0.5367E-01,   &
      0.7717E-01,  0.1090E+00,  0.1514E+00,  0.2067E+00,  0.2770E+00,   &
      0.3633E+00,  0.4640E+00,  0.5742E+00,  0.6853E+00,  0.7859E+00,   &
      0.8670E+00,  0.9253E+00,  0.9629E+00,  0.9842E+00,  0.9942E+00,   &
      0.9983E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.4366E-08, -0.8749E-08, -0.1761E-07, -0.3578E-07, -0.7322E-07,  &
      -0.1517E-06, -0.3189E-06, -0.6785E-06, -0.1446E-05, -0.3014E-05,  &
      -0.5933E-05, -0.1069E-04, -0.1755E-04, -0.2683E-04, -0.3936E-04,  &
      -0.5675E-04, -0.8137E-04, -0.1160E-03, -0.1630E-03, -0.2223E-03,  &
      -0.2899E-03, -0.3589E-03, -0.4230E-03, -0.4755E-03, -0.5031E-03,  &
      -0.4834E-03, -0.4036E-03, -0.2849E-03, -0.1687E-03, -0.8356E-04,  &
      -0.3388E-04/
  DATA ((h73(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.1536E-10,  0.3086E-10,  0.6248E-10,  0.1288E-09,  0.2664E-09,   &
      0.5637E-09,  0.1222E-08,  0.2680E-08,  0.5899E-08,  0.1262E-07,   &
      0.2527E-07,  0.4621E-07,  0.7678E-07,  0.1165E-06,  0.1640E-06,   &
      0.2199E-06,  0.2904E-06,  0.3783E-06,  0.4787E-06,  0.5925E-06,   &
      0.7377E-06,  0.9389E-06,  0.1216E-05,  0.1560E-05,  0.1879E-05,   &
      0.2025E-05,  0.1940E-05,  0.1650E-05,  0.1194E-05,  0.6981E-06,   &
      0.3103E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.1362E-04,  0.2716E-04,  0.5413E-04,  0.1077E-03,  0.2139E-03,   &
      0.4228E-03,  0.8295E-03,  0.1609E-02,  0.3063E-02,  0.5676E-02,   &
      0.1013E-01,  0.1726E-01,  0.2799E-01,  0.4332E-01,  0.6452E-01,   &
      0.9328E-01,  0.1317E+00,  0.1820E+00,  0.2467E+00,  0.3270E+00,   &
      0.4228E+00,  0.5308E+00,  0.6434E+00,  0.7499E+00,  0.8395E+00,   &
      0.9065E+00,  0.9515E+00,  0.9782E+00,  0.9916E+00,  0.9973E+00,   &
      0.9993E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.4359E-08, -0.8720E-08, -0.1749E-07, -0.3527E-07, -0.7175E-07,  &
      -0.1473E-06, -0.3062E-06, -0.6451E-06, -0.1372E-05, -0.2902E-05,  &
      -0.5936E-05, -0.1133E-04, -0.1971E-04, -0.3143E-04, -0.4715E-04,  &
      -0.6833E-04, -0.9759E-04, -0.1379E-03, -0.1907E-03, -0.2542E-03,  &
      -0.3239E-03, -0.3935E-03, -0.4559E-03, -0.4991E-03, -0.5009E-03,  &
      -0.4414E-03, -0.3306E-03, -0.2077E-03, -0.1093E-03, -0.4754E-04,  &
      -0.1642E-04/
  DATA ((h73(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.1531E-10,  0.3070E-10,  0.6184E-10,  0.1257E-09,  0.2578E-09,   &
      0.5451E-09,  0.1159E-08,  0.2526E-08,  0.5585E-08,  0.1225E-07,   &
      0.2576E-07,  0.5017E-07,  0.8855E-07,  0.1417E-06,  0.2078E-06,   &
      0.2858E-06,  0.3802E-06,  0.4946E-06,  0.6226E-06,  0.7572E-06,   &
      0.9137E-06,  0.1133E-05,  0.1438E-05,  0.1772E-05,  0.1994E-05,   &
      0.1994E-05,  0.1779E-05,  0.1375E-05,  0.8711E-06,  0.4273E-06,   &
      0.1539E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.1362E-04,  0.2717E-04,  0.5417E-04,  0.1079E-03,  0.2146E-03,   &
      0.4256E-03,  0.8393E-03,  0.1641E-02,  0.3163E-02,  0.5968E-02,   &
      0.1092E-01,  0.1915E-01,  0.3195E-01,  0.5066E-01,  0.7669E-01,   &
      0.1117E+00,  0.1578E+00,  0.2173E+00,  0.2919E+00,  0.3824E+00,   &
      0.4867E+00,  0.5992E+00,  0.7100E+00,  0.8076E+00,  0.8838E+00,   &
      0.9370E+00,  0.9702E+00,  0.9880E+00,  0.9959E+00,  0.9988E+00,   &
      0.9998E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.4354E-08, -0.8703E-08, -0.1742E-07, -0.3499E-07, -0.7074E-07,  &
      -0.1441E-06, -0.2971E-06, -0.6195E-06, -0.1309E-05, -0.2780E-05,  &
      -0.5823E-05, -0.1165E-04, -0.2152E-04, -0.3616E-04, -0.5604E-04,  &
      -0.8230E-04, -0.1173E-03, -0.1635E-03, -0.2211E-03, -0.2868E-03,  &
      -0.3567E-03, -0.4260E-03, -0.4844E-03, -0.5097E-03, -0.4750E-03,  &
      -0.3779E-03, -0.2522E-03, -0.1409E-03, -0.6540E-04, -0.2449E-04,  &
      -0.6948E-05/
  DATA ((h73(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.1529E-10,  0.3060E-10,  0.6142E-10,  0.1241E-09,  0.2535E-09,   &
      0.5259E-09,  0.1107E-08,  0.2383E-08,  0.5243E-08,  0.1161E-07,   &
      0.2523E-07,  0.5188E-07,  0.9757E-07,  0.1657E-06,  0.2553E-06,   &
      0.3629E-06,  0.4878E-06,  0.6323E-06,  0.7923E-06,  0.9575E-06,   &
      0.1139E-05,  0.1381E-05,  0.1687E-05,  0.1952E-05,  0.2029E-05,   &
      0.1890E-05,  0.1552E-05,  0.1062E-05,  0.5728E-06,  0.2280E-06,   &
      0.6762E-07/
  DATA ((h71(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.1363E-04,  0.2718E-04,  0.5420E-04,  0.1080E-03,  0.2151E-03,   &
      0.4275E-03,  0.8461E-03,  0.1664E-02,  0.3237E-02,  0.6195E-02,   &
      0.1156E-01,  0.2080E-01,  0.3573E-01,  0.5818E-01,  0.8981E-01,   &
      0.1323E+00,  0.1874E+00,  0.2570E+00,  0.3423E+00,  0.4425E+00,   &
      0.5534E+00,  0.6669E+00,  0.7714E+00,  0.8568E+00,  0.9191E+00,   &
      0.9597E+00,  0.9828E+00,  0.9938E+00,  0.9981E+00,  0.9996E+00,   &
      0.1000E+01/
  DATA ((h72(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.4352E-08, -0.8693E-08, -0.1738E-07, -0.3483E-07, -0.7006E-07,  &
      -0.1423E-06, -0.2905E-06, -0.6008E-06, -0.1258E-05, -0.2663E-05,  &
      -0.5638E-05, -0.1165E-04, -0.2270E-04, -0.4044E-04, -0.6554E-04,  &
      -0.9855E-04, -0.1407E-03, -0.1928E-03, -0.2534E-03, -0.3197E-03,  &
      -0.3890E-03, -0.4563E-03, -0.5040E-03, -0.4998E-03, -0.4249E-03,  &
      -0.3025E-03, -0.1794E-03, -0.8860E-04, -0.3575E-04, -0.1122E-04,  &
      -0.2506E-05/
  DATA ((h73(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.1527E-10,  0.3053E-10,  0.6115E-10,  0.1230E-09,  0.2492E-09,   &
      0.5149E-09,  0.1068E-08,  0.2268E-08,  0.4932E-08,  0.1089E-07,   &
      0.2408E-07,  0.5156E-07,  0.1028E-06,  0.1859E-06,  0.3028E-06,   &
      0.4476E-06,  0.6124E-06,  0.7932E-06,  0.9879E-06,  0.1194E-05,   &
      0.1417E-05,  0.1673E-05,  0.1929E-05,  0.2064E-05,  0.1997E-05,   &
      0.1725E-05,  0.1267E-05,  0.7464E-06,  0.3312E-06,  0.1066E-06,   &
      0.2718E-07/
  DATA ((h71(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.1363E-04,  0.2719E-04,  0.5422E-04,  0.1081E-03,  0.2154E-03,   &
      0.4287E-03,  0.8506E-03,  0.1680E-02,  0.3291E-02,  0.6364E-02,   &
      0.1206E-01,  0.2218E-01,  0.3912E-01,  0.6544E-01,  0.1033E+00,   &
      0.1544E+00,  0.2198E+00,  0.3008E+00,  0.3970E+00,  0.5060E+00,   &
      0.6209E+00,  0.7311E+00,  0.8254E+00,  0.8972E+00,  0.9462E+00,   &
      0.9757E+00,  0.9907E+00,  0.9970E+00,  0.9992E+00,  0.9999E+00,   &
      0.1000E+01/
  DATA ((h72(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.4351E-08, -0.8688E-08, -0.1736E-07, -0.3473E-07, -0.6966E-07,  &
      -0.1405E-06, -0.2857E-06, -0.5867E-06, -0.1218E-05, -0.2563E-05,  &
      -0.5435E-05, -0.1144E-04, -0.2321E-04, -0.4379E-04, -0.7487E-04,  &
      -0.1163E-03, -0.1670E-03, -0.2250E-03, -0.2876E-03, -0.3535E-03,  &
      -0.4215E-03, -0.4826E-03, -0.5082E-03, -0.4649E-03, -0.3564E-03,  &
      -0.2264E-03, -0.1188E-03, -0.5128E-04, -0.1758E-04, -0.4431E-05,  &
      -0.7275E-06/
  DATA ((h73(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.1525E-10,  0.3048E-10,  0.6097E-10,  0.1223E-09,  0.2466E-09,   &
      0.5021E-09,  0.1032E-08,  0.2195E-08,  0.4688E-08,  0.1027E-07,   &
      0.2279E-07,  0.4999E-07,  0.1046E-06,  0.2009E-06,  0.3460E-06,   &
      0.5335E-06,  0.7478E-06,  0.9767E-06,  0.1216E-05,  0.1469E-05,   &
      0.1735E-05,  0.1977E-05,  0.2121E-05,  0.2103E-05,  0.1902E-05,   &
      0.1495E-05,  0.9541E-06,  0.4681E-06,  0.1672E-06,  0.4496E-07,   &
      0.9859E-08/
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "co2.tran3", which define pre-computed tables used for co2 (band
!  3) transmittance calculations.
!
!-----------------------------------------------------------------------
!
! co2.tran3

  REAL :: c1(26,24,7),c2(26,24,7),c3(26,24,7)

  COMMON /radtab002/ c1,c2,c3

  DATA ((c1(ip,iw,1),iw=1,24),ip= 1, 1)/                                &
      0.1444E-03,  0.2378E-03,  0.3644E-03,  0.5245E-03,  0.7311E-03,   &
      0.1015E-02,  0.1416E-02,  0.1975E-02,  0.2715E-02,  0.3651E-02,   &
      0.4813E-02,  0.6264E-02,  0.8084E-02,  0.1037E-01,  0.1327E-01,   &
      0.1693E-01,  0.2155E-01,  0.2734E-01,  0.3453E-01,  0.4337E-01,   &
      0.5414E-01,  0.6726E-01,  0.8335E-01,  0.1032E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 1, 1)/                                &
      -0.2878E-06, -0.6295E-06, -0.1270E-05, -0.2323E-05, -0.3910E-05,  &
      -0.6235E-05, -0.9527E-05, -0.1391E-04, -0.1947E-04, -0.2652E-04,  &
      -0.3568E-04, -0.4777E-04, -0.6363E-04, -0.8414E-04, -0.1102E-03,  &
      -0.1425E-03, -0.1822E-03, -0.2301E-03, -0.2869E-03, -0.3534E-03,  &
      -0.4305E-03, -0.5188E-03, -0.6173E-03, -0.7229E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 1, 1)/                                &
      -0.2369E-09, -0.5453E-09, -0.1434E-08, -0.3513E-08, -0.7277E-08,  &
      -0.1283E-07, -0.1983E-07, -0.2838E-07, -0.4075E-07, -0.6115E-07,  &
      -0.9201E-07, -0.1325E-06, -0.1844E-06, -0.2534E-06, -0.3430E-06,  &
      -0.4550E-06, -0.5896E-06, -0.7434E-06, -0.9121E-06, -0.1096E-05,  &
      -0.1298E-05, -0.1508E-05, -0.1689E-05, -0.1773E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 2, 2)/                                &
      0.1444E-03,  0.2379E-03,  0.3646E-03,  0.5250E-03,  0.7320E-03,   &
      0.1016E-02,  0.1419E-02,  0.1981E-02,  0.2726E-02,  0.3669E-02,   &
      0.4847E-02,  0.6325E-02,  0.8193E-02,  0.1056E-01,  0.1358E-01,   &
      0.1742E-01,  0.2228E-01,  0.2843E-01,  0.3611E-01,  0.4561E-01,   &
      0.5730E-01,  0.7169E-01,  0.8952E-01,  0.1117E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 2, 2)/                                &
      -0.2875E-06, -0.6289E-06, -0.1269E-05, -0.2321E-05, -0.3907E-05,  &
      -0.6229E-05, -0.9516E-05, -0.1389E-04, -0.1944E-04, -0.2646E-04,  &
      -0.3559E-04, -0.4762E-04, -0.6340E-04, -0.8384E-04, -0.1098E-03,  &
      -0.1423E-03, -0.1824E-03, -0.2309E-03, -0.2887E-03, -0.3566E-03,  &
      -0.4355E-03, -0.5260E-03, -0.6274E-03, -0.7367E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 2, 2)/                                &
      -0.2382E-09, -0.5476E-09, -0.1437E-08, -0.3520E-08, -0.7291E-08,  &
      -0.1286E-07, -0.1989E-07, -0.2849E-07, -0.4093E-07, -0.6144E-07,  &
      -0.9241E-07, -0.1330E-06, -0.1852E-06, -0.2542E-06, -0.3435E-06,  &
      -0.4549E-06, -0.5891E-06, -0.7427E-06, -0.9114E-06, -0.1096E-05,  &
      -0.1298E-05, -0.1509E-05, -0.1689E-05, -0.1772E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 3, 3)/                                &
      0.1445E-03,  0.2381E-03,  0.3650E-03,  0.5258E-03,  0.7335E-03,   &
      0.1019E-02,  0.1424E-02,  0.1990E-02,  0.2742E-02,  0.3698E-02,   &
      0.4899E-02,  0.6418E-02,  0.8353E-02,  0.1083E-01,  0.1401E-01,   &
      0.1807E-01,  0.2326E-01,  0.2985E-01,  0.3814E-01,  0.4849E-01,   &
      0.6134E-01,  0.7733E-01,  0.9732E-01,  0.1223E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 3, 3)/                                &
      -0.2871E-06, -0.6279E-06, -0.1267E-05, -0.2318E-05, -0.3901E-05,  &
      -0.6219E-05, -0.9500E-05, -0.1386E-04, -0.1939E-04, -0.2639E-04,  &
      -0.3547E-04, -0.4743E-04, -0.6313E-04, -0.8354E-04, -0.1096E-03,  &
      -0.1425E-03, -0.1831E-03, -0.2325E-03, -0.2916E-03, -0.3613E-03,  &
      -0.4425E-03, -0.5361E-03, -0.6412E-03, -0.7550E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 3, 3)/                                &
      -0.2404E-09, -0.5516E-09, -0.1443E-08, -0.3531E-08, -0.7310E-08,  &
      -0.1290E-07, -0.1997E-07, -0.2865E-07, -0.4121E-07, -0.6185E-07,  &
      -0.9295E-07, -0.1337E-06, -0.1860E-06, -0.2549E-06, -0.3438E-06,  &
      -0.4547E-06, -0.5888E-06, -0.7424E-06, -0.9114E-06, -0.1097E-05,  &
      -0.1300E-05, -0.1511E-05, -0.1691E-05, -0.1771E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 4, 4)/                                &
      0.1446E-03,  0.2383E-03,  0.3656E-03,  0.5270E-03,  0.7358E-03,   &
      0.1023E-02,  0.1432E-02,  0.2003E-02,  0.2766E-02,  0.3743E-02,   &
      0.4979E-02,  0.6557E-02,  0.8587E-02,  0.1121E-01,  0.1459E-01,   &
      0.1895E-01,  0.2455E-01,  0.3170E-01,  0.4076E-01,  0.5217E-01,   &
      0.6649E-01,  0.8448E-01,  0.1071E+00,  0.1353E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 4, 4)/                                &
      -0.2865E-06, -0.6264E-06, -0.1264E-05, -0.2313E-05, -0.3892E-05,  &
      -0.6204E-05, -0.9474E-05, -0.1382E-04, -0.1932E-04, -0.2628E-04,  &
      -0.3530E-04, -0.4720E-04, -0.6286E-04, -0.8333E-04, -0.1097E-03,  &
      -0.1430E-03, -0.1845E-03, -0.2352E-03, -0.2960E-03, -0.3681E-03,  &
      -0.4523E-03, -0.5496E-03, -0.6595E-03, -0.7790E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 4, 4)/                                &
      -0.2433E-09, -0.5580E-09, -0.1454E-08, -0.3550E-08, -0.7345E-08,  &
      -0.1296E-07, -0.2010E-07, -0.2889E-07, -0.4159E-07, -0.6239E-07,  &
      -0.9360E-07, -0.1345E-06, -0.1867E-06, -0.2554E-06, -0.3439E-06,  &
      -0.4548E-06, -0.5890E-06, -0.7429E-06, -0.9127E-06, -0.1099E-05,  &
      -0.1304E-05, -0.1516E-05, -0.1693E-05, -0.1770E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 5, 5)/                                &
      0.1448E-03,  0.2387E-03,  0.3666E-03,  0.5290E-03,  0.7394E-03,   &
      0.1030E-02,  0.1444E-02,  0.2025E-02,  0.2805E-02,  0.3811E-02,   &
      0.5099E-02,  0.6761E-02,  0.8919E-02,  0.1173E-01,  0.1538E-01,   &
      0.2011E-01,  0.2622E-01,  0.3408E-01,  0.4412E-01,  0.5686E-01,   &
      0.7302E-01,  0.9346E-01,  0.1192E+00,  0.1512E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 5, 5)/                                &
      -0.2854E-06, -0.6241E-06, -0.1260E-05, -0.2305E-05, -0.3878E-05,  &
      -0.6181E-05, -0.9435E-05, -0.1375E-04, -0.1922E-04, -0.2613E-04,  &
      -0.3510E-04, -0.4696E-04, -0.6265E-04, -0.8334E-04, -0.1102E-03,  &
      -0.1443E-03, -0.1870E-03, -0.2393E-03, -0.3025E-03, -0.3775E-03,  &
      -0.4656E-03, -0.5678E-03, -0.6835E-03, -0.8098E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 5, 5)/                                &
      -0.2485E-09, -0.5672E-09, -0.1468E-08, -0.3577E-08, -0.7395E-08,  &
      -0.1306E-07, -0.2029E-07, -0.2923E-07, -0.4213E-07, -0.6307E-07,  &
      -0.9429E-07, -0.1351E-06, -0.1872E-06, -0.2557E-06, -0.3442E-06,  &
      -0.4553E-06, -0.5899E-06, -0.7447E-06, -0.9163E-06, -0.1105E-05,  &
      -0.1311E-05, -0.1522E-05, -0.1697E-05, -0.1766E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 6, 6)/                                &
      0.1450E-03,  0.2394E-03,  0.3680E-03,  0.5320E-03,  0.7452E-03,   &
      0.1040E-02,  0.1462E-02,  0.2058E-02,  0.2863E-02,  0.3914E-02,   &
      0.5275E-02,  0.7051E-02,  0.9378E-02,  0.1243E-01,  0.1641E-01,   &
      0.2162E-01,  0.2838E-01,  0.3713E-01,  0.4839E-01,  0.6282E-01,   &
      0.8125E-01,  0.1046E+00,  0.1340E+00,  0.1702E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 6, 6)/                                &
      -0.2837E-06, -0.6203E-06, -0.1252E-05, -0.2292E-05, -0.3857E-05,  &
      -0.6146E-05, -0.9377E-05, -0.1366E-04, -0.1909E-04, -0.2596E-04,  &
      -0.3489E-04, -0.4676E-04, -0.6263E-04, -0.8372E-04, -0.1113E-03,  &
      -0.1465E-03, -0.1908E-03, -0.2454E-03, -0.3115E-03, -0.3903E-03,  &
      -0.4833E-03, -0.5915E-03, -0.7144E-03, -0.8483E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 6, 6)/                                &
      -0.2557E-09, -0.5835E-09, -0.1495E-08, -0.3619E-08, -0.7472E-08,  &
      -0.1320E-07, -0.2055E-07, -0.2970E-07, -0.4281E-07, -0.6379E-07,  &
      -0.9492E-07, -0.1356E-06, -0.1876E-06, -0.2561E-06, -0.3451E-06,  &
      -0.4568E-06, -0.5924E-06, -0.7489E-06, -0.9229E-06, -0.1114E-05,  &
      -0.1321E-05, -0.1531E-05, -0.1700E-05, -0.1756E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 7, 7)/                                &
      0.1454E-03,  0.2404E-03,  0.3704E-03,  0.5368E-03,  0.7542E-03,   &
      0.1056E-02,  0.1491E-02,  0.2108E-02,  0.2951E-02,  0.4066E-02,   &
      0.5529E-02,  0.7457E-02,  0.1000E-01,  0.1336E-01,  0.1777E-01,   &
      0.2357E-01,  0.3115E-01,  0.4102E-01,  0.5382E-01,  0.7035E-01,   &
      0.9154E-01,  0.1184E+00,  0.1519E+00,  0.1926E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 7, 7)/                                &
      -0.2811E-06, -0.6147E-06, -0.1241E-05, -0.2272E-05, -0.3825E-05,  &
      -0.6093E-05, -0.9294E-05, -0.1354E-04, -0.1893E-04, -0.2577E-04,  &
      -0.3472E-04, -0.4672E-04, -0.6292E-04, -0.8464E-04, -0.1132E-03,  &
      -0.1500E-03, -0.1964E-03, -0.2539E-03, -0.3237E-03, -0.4074E-03,  &
      -0.5065E-03, -0.6222E-03, -0.7532E-03, -0.8955E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 7, 7)/                                &
      -0.2673E-09, -0.6022E-09, -0.1531E-08, -0.3682E-08, -0.7588E-08,  &
      -0.1342E-07, -0.2092E-07, -0.3030E-07, -0.4357E-07, -0.6448E-07,  &
      -0.9533E-07, -0.1359E-06, -0.1879E-06, -0.2570E-06, -0.3470E-06,  &
      -0.4598E-06, -0.5971E-06, -0.7563E-06, -0.9334E-06, -0.1127E-05,  &
      -0.1336E-05, -0.1543E-05, -0.1701E-05, -0.1738E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 8, 8)/                                &
      0.1460E-03,  0.2420E-03,  0.3740E-03,  0.5443E-03,  0.7681E-03,   &
      0.1081E-02,  0.1535E-02,  0.2184E-02,  0.3082E-02,  0.4286E-02,   &
      0.5885E-02,  0.8011E-02,  0.1083E-01,  0.1458E-01,  0.1954E-01,   &
      0.2608E-01,  0.3468E-01,  0.4595E-01,  0.6068E-01,  0.7979E-01,   &
      0.1043E+00,  0.1351E+00,  0.1731E+00,  0.2184E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 8, 8)/                                &
      -0.2770E-06, -0.6058E-06, -0.1224E-05, -0.2243E-05, -0.3777E-05,  &
      -0.6018E-05, -0.9181E-05, -0.1339E-04, -0.1876E-04, -0.2561E-04,  &
      -0.3467E-04, -0.4695E-04, -0.6370E-04, -0.8635E-04, -0.1163E-03,  &
      -0.1551E-03, -0.2043E-03, -0.2654E-03, -0.3400E-03, -0.4299E-03,  &
      -0.5366E-03, -0.6609E-03, -0.8010E-03, -0.9521E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 8, 8)/                                &
      -0.2845E-09, -0.6367E-09, -0.1591E-08, -0.3779E-08, -0.7752E-08,  &
      -0.1370E-07, -0.2140E-07, -0.3101E-07, -0.4437E-07, -0.6498E-07,  &
      -0.9551E-07, -0.1360E-06, -0.1887E-06, -0.2590E-06, -0.3503E-06,  &
      -0.4650E-06, -0.6052E-06, -0.7681E-06, -0.9488E-06, -0.1145E-05,  &
      -0.1354E-05, -0.1555E-05, -0.1698E-05, -0.1701E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 9, 9)/                                &
      0.1470E-03,  0.2444E-03,  0.3796E-03,  0.5557E-03,  0.7894E-03,   &
      0.1119E-02,  0.1600E-02,  0.2296E-02,  0.3271E-02,  0.4596E-02,   &
      0.6373E-02,  0.8752E-02,  0.1193E-01,  0.1617E-01,  0.2181E-01,   &
      0.2928E-01,  0.3916E-01,  0.5220E-01,  0.6930E-01,  0.9150E-01,   &
      0.1198E+00,  0.1551E+00,  0.1978E+00,  0.2475E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 9, 9)/                                &
      -0.2709E-06, -0.5925E-06, -0.1198E-05, -0.2199E-05, -0.3708E-05,  &
      -0.5913E-05, -0.9036E-05, -0.1322E-04, -0.1861E-04, -0.2556E-04,  &
      -0.3486E-04, -0.4760E-04, -0.6516E-04, -0.8909E-04, -0.1210E-03,  &
      -0.1624E-03, -0.2151E-03, -0.2808E-03, -0.3615E-03, -0.4590E-03,  &
      -0.5747E-03, -0.7088E-03, -0.8585E-03, -0.1018E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 9, 9)/                                &
      -0.3119E-09, -0.6873E-09, -0.1676E-08, -0.3915E-08, -0.7973E-08,  &
      -0.1407E-07, -0.2200E-07, -0.3179E-07, -0.4505E-07, -0.6522E-07,  &
      -0.9551E-07, -0.1364E-06, -0.1902E-06, -0.2622E-06, -0.3557E-06,  &
      -0.4735E-06, -0.6178E-06, -0.7853E-06, -0.9700E-06, -0.1169E-05,  &
      -0.1377E-05, -0.1567E-05, -0.1683E-05, -0.1631E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=10,10)/                                &
      0.1484E-03,  0.2482E-03,  0.3882E-03,  0.5732E-03,  0.8217E-03,   &
      0.1176E-02,  0.1696E-02,  0.2457E-02,  0.3536E-02,  0.5021E-02,   &
      0.7028E-02,  0.9728E-02,  0.1336E-01,  0.1821E-01,  0.2470E-01,   &
      0.3334E-01,  0.4482E-01,  0.6004E-01,  0.8003E-01,  0.1059E+00,   &
      0.1385E+00,  0.1785E+00,  0.2259E+00,  0.2794E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=10,10)/                                &
      -0.2620E-06, -0.5728E-06, -0.1161E-05, -0.2136E-05, -0.3612E-05,  &
      -0.5777E-05, -0.8867E-05, -0.1306E-04, -0.1854E-04, -0.2572E-04,  &
      -0.3543E-04, -0.4887E-04, -0.6756E-04, -0.9321E-04, -0.1275E-03,  &
      -0.1723E-03, -0.2295E-03, -0.3011E-03, -0.3894E-03, -0.4960E-03,  &
      -0.6220E-03, -0.7665E-03, -0.9259E-03, -0.1095E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=10,10)/                                &
      -0.3497E-09, -0.7575E-09, -0.1791E-08, -0.4091E-08, -0.8254E-08,  &
      -0.1452E-07, -0.2265E-07, -0.3255E-07, -0.4557E-07, -0.6530E-07,  &
      -0.9557E-07, -0.1374E-06, -0.1930E-06, -0.2675E-06, -0.3644E-06,  &
      -0.4866E-06, -0.6362E-06, -0.8090E-06, -0.9981E-06, -0.1199E-05,  &
      -0.1402E-05, -0.1574E-05, -0.1643E-05, -0.1506E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=11,11)/                                &
      0.1506E-03,  0.2538E-03,  0.4010E-03,  0.5992E-03,  0.8693E-03,   &
      0.1258E-02,  0.1834E-02,  0.2683E-02,  0.3901E-02,  0.5591E-02,   &
      0.7890E-02,  0.1100E-01,  0.1519E-01,  0.2082E-01,  0.2837E-01,   &
      0.3845E-01,  0.5192E-01,  0.6981E-01,  0.9323E-01,  0.1232E+00,   &
      0.1606E+00,  0.2055E+00,  0.2571E+00,  0.3133E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=11,11)/                                &
      -0.2494E-06, -0.5450E-06, -0.1108E-05, -0.2049E-05, -0.3485E-05,  &
      -0.5612E-05, -0.8695E-05, -0.1296E-04, -0.1865E-04, -0.2620E-04,  &
      -0.3654E-04, -0.5099E-04, -0.7121E-04, -0.9909E-04, -0.1365E-03,  &
      -0.1855E-03, -0.2483E-03, -0.3274E-03, -0.4248E-03, -0.5421E-03,  &
      -0.6794E-03, -0.8346E-03, -0.1003E-02, -0.1181E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=11,11)/                                &
      -0.3973E-09, -0.8499E-09, -0.1944E-08, -0.4319E-08, -0.8596E-08,  &
      -0.1501E-07, -0.2332E-07, -0.3326E-07, -0.4600E-07, -0.6541E-07,  &
      -0.9592E-07, -0.1392E-06, -0.1975E-06, -0.2757E-06, -0.3774E-06,  &
      -0.5057E-06, -0.6614E-06, -0.8401E-06, -0.1034E-05, -0.1235E-05,  &
      -0.1427E-05, -0.1565E-05, -0.1560E-05, -0.1310E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=12,12)/                                &
      0.1537E-03,  0.2618E-03,  0.4196E-03,  0.6368E-03,  0.9377E-03,   &
      0.1374E-02,  0.2024E-02,  0.2990E-02,  0.4387E-02,  0.6339E-02,   &
      0.9008E-02,  0.1263E-01,  0.1752E-01,  0.2410E-01,  0.3296E-01,   &
      0.4485E-01,  0.6077E-01,  0.8185E-01,  0.1092E+00,  0.1439E+00,   &
      0.1861E+00,  0.2356E+00,  0.2906E+00,  0.3483E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=12,12)/                                &
      -0.2326E-06, -0.5076E-06, -0.1037E-05, -0.1935E-05, -0.3329E-05,  &
      -0.5433E-05, -0.8553E-05, -0.1298E-04, -0.1902E-04, -0.2716E-04,  &
      -0.3840E-04, -0.5421E-04, -0.7643E-04, -0.1071E-03, -0.1485E-03,  &
      -0.2028E-03, -0.2727E-03, -0.3608E-03, -0.4689E-03, -0.5981E-03,  &
      -0.7471E-03, -0.9128E-03, -0.1091E-02, -0.1276E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=12,12)/                                &
      -0.4576E-09, -0.9621E-09, -0.2122E-08, -0.4569E-08, -0.8941E-08,  &
      -0.1550E-07, -0.2398E-07, -0.3404E-07, -0.4663E-07, -0.6577E-07,  &
      -0.9677E-07, -0.1421E-06, -0.2042E-06, -0.2878E-06, -0.3962E-06,  &
      -0.5318E-06, -0.6946E-06, -0.8798E-06, -0.1078E-05, -0.1275E-05,  &
      -0.1445E-05, -0.1523E-05, -0.1413E-05, -0.1030E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=13,13)/                                &
      0.1579E-03,  0.2729E-03,  0.4454E-03,  0.6893E-03,  0.1033E-02,   &
      0.1533E-02,  0.2280E-02,  0.3396E-02,  0.5018E-02,  0.7299E-02,   &
      0.1043E-01,  0.1468E-01,  0.2044E-01,  0.2820E-01,  0.3867E-01,   &
      0.5278E-01,  0.7166E-01,  0.9648E-01,  0.1283E+00,  0.1679E+00,   &
      0.2150E+00,  0.2685E+00,  0.3256E+00,  0.3836E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=13,13)/                                &
      -0.2120E-06, -0.4613E-06, -0.9487E-06, -0.1798E-05, -0.3153E-05,  &
      -0.5260E-05, -0.8480E-05, -0.1319E-04, -0.1976E-04, -0.2876E-04,  &
      -0.4125E-04, -0.5885E-04, -0.8357E-04, -0.1178E-03, -0.1640E-03,  &
      -0.2250E-03, -0.3036E-03, -0.4023E-03, -0.5226E-03, -0.6643E-03,  &
      -0.8250E-03, -0.1001E-02, -0.1187E-02, -0.1378E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=13,13)/                                &
      -0.5223E-09, -0.1082E-08, -0.2314E-08, -0.4826E-08, -0.9255E-08,  &
      -0.1596E-07, -0.2472E-07, -0.3507E-07, -0.4774E-07, -0.6677E-07,  &
      -0.9841E-07, -0.1466E-06, -0.2141E-06, -0.3049E-06, -0.4219E-06,  &
      -0.5662E-06, -0.7370E-06, -0.9290E-06, -0.1129E-05, -0.1315E-05,  &
      -0.1441E-05, -0.1427E-05, -0.1184E-05, -0.6731E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=14,14)/                                &
      0.1634E-03,  0.2873E-03,  0.4793E-03,  0.7589E-03,  0.1159E-02,   &
      0.1742E-02,  0.2614E-02,  0.3916E-02,  0.5817E-02,  0.8503E-02,   &
      0.1220E-01,  0.1723E-01,  0.2403E-01,  0.3324E-01,  0.4572E-01,   &
      0.6253E-01,  0.8488E-01,  0.1140E+00,  0.1507E+00,  0.1952E+00,   &
      0.2468E+00,  0.3031E+00,  0.3612E+00,  0.4186E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=14,14)/                                &
      -0.1896E-06, -0.4100E-06, -0.8500E-06, -0.1645E-05, -0.2972E-05,  &
      -0.5116E-05, -0.8508E-05, -0.1363E-04, -0.2097E-04, -0.3115E-04,  &
      -0.4531E-04, -0.6517E-04, -0.9298E-04, -0.1315E-03, -0.1837E-03,  &
      -0.2528E-03, -0.3417E-03, -0.4525E-03, -0.5860E-03, -0.7405E-03,  &
      -0.9123E-03, -0.1097E-02, -0.1290E-02, -0.1482E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=14,14)/                                &
      -0.5738E-09, -0.1185E-08, -0.2465E-08, -0.5015E-08, -0.9502E-08,  &
      -0.1640E-07, -0.2567E-07, -0.3675E-07, -0.4990E-07, -0.6893E-07,  &
      -0.1014E-06, -0.1533E-06, -0.2278E-06, -0.3278E-06, -0.4553E-06,  &
      -0.6098E-06, -0.7899E-06, -0.9876E-06, -0.1184E-05, -0.1342E-05,  &
      -0.1393E-05, -0.1254E-05, -0.8703E-06, -0.2593E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=15,15)/                                &
      0.1697E-03,  0.3043E-03,  0.5205E-03,  0.8458E-03,  0.1319E-02,   &
      0.2009E-02,  0.3034E-02,  0.4563E-02,  0.6800E-02,  0.9975E-02,   &
      0.1436E-01,  0.2033E-01,  0.2842E-01,  0.3941E-01,  0.5431E-01,   &
      0.7432E-01,  0.1007E+00,  0.1344E+00,  0.1762E+00,  0.2255E+00,   &
      0.2806E+00,  0.3385E+00,  0.3964E+00,  0.4532E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=15,15)/                                &
      -0.1689E-06, -0.3610E-06, -0.7531E-06, -0.1495E-05, -0.2803E-05,  &
      -0.5013E-05, -0.8646E-05, -0.1433E-04, -0.2270E-04, -0.3446E-04,  &
      -0.5077E-04, -0.7342E-04, -0.1049E-03, -0.1486E-03, -0.2080E-03,  &
      -0.2866E-03, -0.3873E-03, -0.5115E-03, -0.6586E-03, -0.8256E-03,  &
      -0.1008E-02, -0.1201E-02, -0.1398E-02, -0.1583E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=15,15)/                                &
      -0.6063E-09, -0.1245E-08, -0.2559E-08, -0.5110E-08, -0.9652E-08,  &
      -0.1685E-07, -0.2693E-07, -0.3933E-07, -0.5373E-07, -0.7330E-07,  &
      -0.1066E-06, -0.1625E-06, -0.2453E-06, -0.3564E-06, -0.4963E-06,  &
      -0.6636E-06, -0.8532E-06, -0.1054E-05, -0.1236E-05, -0.1339E-05,  &
      -0.1280E-05, -0.9947E-06, -0.4862E-06,  0.1889E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=16,16)/                                &
      0.1763E-03,  0.3227E-03,  0.5664E-03,  0.9465E-03,  0.1511E-02,   &
      0.2335E-02,  0.3549E-02,  0.5348E-02,  0.7977E-02,  0.1172E-01,   &
      0.1692E-01,  0.2402E-01,  0.3369E-01,  0.4685E-01,  0.6465E-01,   &
      0.8835E-01,  0.1192E+00,  0.1579E+00,  0.2046E+00,  0.2579E+00,   &
      0.3153E+00,  0.3736E+00,  0.4308E+00,  0.4875E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=16,16)/                                &
      -0.1533E-06, -0.3224E-06, -0.6725E-06, -0.1365E-05, -0.2657E-05,  &
      -0.4953E-05, -0.8878E-05, -0.1525E-04, -0.2490E-04, -0.3866E-04,  &
      -0.5766E-04, -0.8372E-04, -0.1197E-03, -0.1695E-03, -0.2372E-03,  &
      -0.3266E-03, -0.4401E-03, -0.5783E-03, -0.7390E-03, -0.9180E-03,  &
      -0.1110E-02, -0.1309E-02, -0.1503E-02, -0.1676E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=16,16)/                                &
      -0.6109E-09, -0.1253E-08, -0.2555E-08, -0.5100E-08, -0.9703E-08,  &
      -0.1729E-07, -0.2846E-07, -0.4291E-07, -0.5988E-07, -0.8135E-07,  &
      -0.1158E-06, -0.1750E-06, -0.2657E-06, -0.3890E-06, -0.5438E-06,  &
      -0.7262E-06, -0.9256E-06, -0.1122E-05, -0.1269E-05, -0.1284E-05,  &
      -0.1086E-05, -0.6553E-06, -0.5588E-07,  0.6660E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=17,17)/                                &
      0.1824E-03,  0.3403E-03,  0.6126E-03,  0.1054E-02,  0.1727E-02,   &
      0.2716E-02,  0.4160E-02,  0.6275E-02,  0.9353E-02,  0.1375E-01,   &
      0.1990E-01,  0.2837E-01,  0.3995E-01,  0.5571E-01,  0.7690E-01,   &
      0.1048E+00,  0.1404E+00,  0.1841E+00,  0.2353E+00,  0.2916E+00,   &
      0.3500E+00,  0.4078E+00,  0.4646E+00,  0.5215E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=17,17)/                                &
      -0.1436E-06, -0.2978E-06, -0.6179E-06, -0.1270E-05, -0.2546E-05,  &
      -0.4927E-05, -0.9164E-05, -0.1628E-04, -0.2740E-04, -0.4353E-04,  &
      -0.6579E-04, -0.9606E-04, -0.1375E-03, -0.1943E-03, -0.2712E-03,  &
      -0.3722E-03, -0.4993E-03, -0.6515E-03, -0.8255E-03, -0.1016E-02,  &
      -0.1217E-02, -0.1417E-02, -0.1602E-02, -0.1757E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=17,17)/                                &
      -0.6015E-09, -0.1225E-08, -0.2489E-08, -0.4978E-08, -0.9608E-08,  &
      -0.1756E-07, -0.2993E-07, -0.4715E-07, -0.6853E-07, -0.9454E-07,  &
      -0.1314E-06, -0.1920E-06, -0.2877E-06, -0.4222E-06, -0.5940E-06,  &
      -0.7936E-06, -0.1002E-05, -0.1181E-05, -0.1262E-05, -0.1156E-05,  &
      -0.8086E-06, -0.2604E-06,  0.4056E-06,  0.1164E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=18,18)/                                &
      0.1875E-03,  0.3555E-03,  0.6547E-03,  0.1159E-02,  0.1954E-02,   &
      0.3140E-02,  0.4861E-02,  0.7345E-02,  0.1093E-01,  0.1606E-01,   &
      0.2330E-01,  0.3339E-01,  0.4729E-01,  0.6613E-01,  0.9118E-01,   &
      0.1236E+00,  0.1642E+00,  0.2127E+00,  0.2674E+00,  0.3254E+00,   &
      0.3836E+00,  0.4408E+00,  0.4978E+00,  0.5551E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=18,18)/                                &
      -0.1390E-06, -0.2850E-06, -0.5878E-06, -0.1213E-05, -0.2477E-05,  &
      -0.4934E-05, -0.9466E-05, -0.1731E-04, -0.2990E-04, -0.4860E-04,  &
      -0.7471E-04, -0.1102E-03, -0.1582E-03, -0.2230E-03, -0.3098E-03,  &
      -0.4228E-03, -0.5632E-03, -0.7291E-03, -0.9158E-03, -0.1117E-02,  &
      -0.1323E-02, -0.1519E-02, -0.1689E-02, -0.1824E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=18,18)/                                &
      -0.5875E-09, -0.1187E-08, -0.2392E-08, -0.4777E-08, -0.9321E-08,  &
      -0.1745E-07, -0.3091E-07, -0.5121E-07, -0.7879E-07, -0.1130E-06,  &
      -0.1555E-06, -0.2161E-06, -0.3110E-06, -0.4527E-06, -0.6400E-06,  &
      -0.8571E-06, -0.1069E-05, -0.1209E-05, -0.1193E-05, -0.9472E-06,  &
      -0.4712E-06,  0.1597E-06,  0.8892E-06,  0.1671E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=19,19)/                                &
      0.1914E-03,  0.3677E-03,  0.6900E-03,  0.1252E-02,  0.2172E-02,   &
      0.3581E-02,  0.5632E-02,  0.8553E-02,  0.1271E-01,  0.1866E-01,   &
      0.2715E-01,  0.3914E-01,  0.5576E-01,  0.7817E-01,  0.1076E+00,   &
      0.1449E+00,  0.1903E+00,  0.2429E+00,  0.2999E+00,  0.3582E+00,   &
      0.4157E+00,  0.4727E+00,  0.5303E+00,  0.5878E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=19,19)/                                &
      -0.1371E-06, -0.2799E-06, -0.5756E-06, -0.1190E-05, -0.2455E-05,  &
      -0.4982E-05, -0.9770E-05, -0.1824E-04, -0.3214E-04, -0.5332E-04,  &
      -0.8371E-04, -0.1255E-03, -0.1814E-03, -0.2555E-03, -0.3528E-03,  &
      -0.4774E-03, -0.6306E-03, -0.8095E-03, -0.1008E-02, -0.1218E-02,  &
      -0.1424E-02, -0.1610E-02, -0.1763E-02, -0.1875E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=19,19)/                                &
      -0.5739E-09, -0.1144E-08, -0.2283E-08, -0.4524E-08, -0.8848E-08,  &
      -0.1686E-07, -0.3096E-07, -0.5411E-07, -0.8876E-07, -0.1343E-06,  &
      -0.1880E-06, -0.2511E-06, -0.3405E-06, -0.4800E-06, -0.6756E-06,  &
      -0.9041E-06, -0.1105E-05, -0.1184E-05, -0.1049E-05, -0.6701E-06,  &
      -0.1061E-06,  0.5899E-06,  0.1376E-05,  0.2160E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=20,20)/                                &
      0.1942E-03,  0.3767E-03,  0.7173E-03,  0.1328E-02,  0.2364E-02,   &
      0.4005E-02,  0.6433E-02,  0.9873E-02,  0.1471E-01,  0.2160E-01,   &
      0.3150E-01,  0.4565E-01,  0.6537E-01,  0.9183E-01,  0.1260E+00,   &
      0.1683E+00,  0.2183E+00,  0.2738E+00,  0.3318E+00,  0.3894E+00,   &
      0.4463E+00,  0.5038E+00,  0.5619E+00,  0.6191E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=20,20)/                                &
      -0.1368E-06, -0.2791E-06, -0.5744E-06, -0.1192E-05, -0.2475E-05,  &
      -0.5078E-05, -0.1008E-04, -0.1903E-04, -0.3392E-04, -0.5726E-04,  &
      -0.9202E-04, -0.1409E-03, -0.2063E-03, -0.2912E-03, -0.3997E-03,  &
      -0.5357E-03, -0.7004E-03, -0.8911E-03, -0.1100E-02, -0.1314E-02,  &
      -0.1514E-02, -0.1687E-02, -0.1822E-02, -0.1908E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=20,20)/                                &
      -0.5617E-09, -0.1109E-08, -0.2184E-08, -0.4264E-08, -0.8251E-08,  &
      -0.1582E-07, -0.3000E-07, -0.5536E-07, -0.9656E-07, -0.1549E-06,  &
      -0.2254E-06, -0.2999E-06, -0.3855E-06, -0.5114E-06, -0.6982E-06,  &
      -0.9171E-06, -0.1082E-05, -0.1078E-05, -0.8280E-06, -0.3561E-06,  &
      0.2636E-06,  0.1015E-05,  0.1836E-05,  0.2588E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=21,21)/                                &
      0.1962E-03,  0.3831E-03,  0.7370E-03,  0.1386E-02,  0.2520E-02,   &
      0.4379E-02,  0.7206E-02,  0.1125E-01,  0.1692E-01,  0.2493E-01,   &
      0.3644E-01,  0.5299E-01,  0.7611E-01,  0.1070E+00,  0.1463E+00,   &
      0.1936E+00,  0.2474E+00,  0.3046E+00,  0.3621E+00,  0.4188E+00,   &
      0.4758E+00,  0.5339E+00,  0.5921E+00,  0.6482E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=21,21)/                                &
      -0.1371E-06, -0.2803E-06, -0.5786E-06, -0.1206E-05, -0.2522E-05,  &
      -0.5211E-05, -0.1040E-04, -0.1969E-04, -0.3522E-04, -0.6021E-04,  &
      -0.9890E-04, -0.1552E-03, -0.2312E-03, -0.3285E-03, -0.4496E-03,  &
      -0.5973E-03, -0.7728E-03, -0.9733E-03, -0.1188E-02, -0.1399E-02,  &
      -0.1590E-02, -0.1748E-02, -0.1862E-02, -0.1922E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=21,21)/                                &
      -0.5521E-09, -0.1082E-08, -0.2100E-08, -0.4025E-08, -0.7661E-08,  &
      -0.1462E-07, -0.2837E-07, -0.5493E-07, -0.1013E-06, -0.1716E-06,  &
      -0.2627E-06, -0.3609E-06, -0.4548E-06, -0.5617E-06, -0.7128E-06,  &
      -0.8814E-06, -0.9684E-06, -0.8687E-06, -0.5417E-06, -0.3260E-07,  &
      0.6298E-06,  0.1417E-05,  0.2233E-05,  0.2884E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=22,22)/                                &
      0.1974E-03,  0.3872E-03,  0.7505E-03,  0.1427E-02,  0.2638E-02,   &
      0.4682E-02,  0.7896E-02,  0.1261E-01,  0.1927E-01,  0.2865E-01,   &
      0.4207E-01,  0.6125E-01,  0.8802E-01,  0.1236E+00,  0.1681E+00,   &
      0.2201E+00,  0.2766E+00,  0.3342E+00,  0.3906E+00,  0.4468E+00,   &
      0.5043E+00,  0.5628E+00,  0.6204E+00,  0.6743E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=22,22)/                                &
      -0.1377E-06, -0.2818E-06, -0.5836E-06, -0.1222E-05, -0.2570E-05,  &
      -0.5339E-05, -0.1069E-04, -0.2019E-04, -0.3606E-04, -0.6211E-04,  &
      -0.1038E-03, -0.1666E-03, -0.2537E-03, -0.3653E-03, -0.5012E-03,  &
      -0.6623E-03, -0.8484E-03, -0.1055E-02, -0.1268E-02, -0.1470E-02,  &
      -0.1649E-02, -0.1790E-02, -0.1882E-02, -0.1920E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=22,22)/                                &
      -0.5464E-09, -0.1064E-08, -0.2050E-08, -0.3874E-08, -0.7265E-08,  &
      -0.1373E-07, -0.2688E-07, -0.5376E-07, -0.1035E-06, -0.1833E-06,  &
      -0.2955E-06, -0.4267E-06, -0.5474E-06, -0.6443E-06, -0.7332E-06,  &
      -0.7933E-06, -0.7465E-06, -0.5424E-06, -0.1941E-06,  0.3078E-06,  &
      0.9845E-06,  0.1771E-05,  0.2515E-05,  0.2962E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=23,23)/                                &
      0.1981E-03,  0.3899E-03,  0.7594E-03,  0.1455E-02,  0.2722E-02,   &
      0.4913E-02,  0.8469E-02,  0.1387E-01,  0.2168E-01,  0.3275E-01,   &
      0.4842E-01,  0.7058E-01,  0.1012E+00,  0.1414E+00,  0.1908E+00,   &
      0.2467E+00,  0.3050E+00,  0.3620E+00,  0.4176E+00,  0.4739E+00,   &
      0.5318E+00,  0.5900E+00,  0.6460E+00,  0.6969E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=23,23)/                                &
      -0.1374E-06, -0.2821E-06, -0.5849E-06, -0.1227E-05, -0.2587E-05,  &
      -0.5392E-05, -0.1082E-04, -0.2043E-04, -0.3640E-04, -0.6291E-04,  &
      -0.1064E-03, -0.1742E-03, -0.2713E-03, -0.3983E-03, -0.5523E-03,  &
      -0.7302E-03, -0.9280E-03, -0.1135E-02, -0.1338E-02, -0.1526E-02,  &
      -0.1690E-02, -0.1811E-02, -0.1880E-02, -0.1904E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=23,23)/                                &
      -0.5505E-09, -0.1066E-08, -0.2044E-08, -0.3856E-08, -0.7199E-08,  &
      -0.1353E-07, -0.2638E-07, -0.5316E-07, -0.1044E-06, -0.1908E-06,  &
      -0.3207E-06, -0.4858E-06, -0.6471E-06, -0.7512E-06, -0.7676E-06,  &
      -0.6661E-06, -0.4252E-06, -0.1067E-06,  0.2334E-06,  0.6913E-06,  &
      0.1330E-05,  0.2055E-05,  0.2617E-05,  0.2760E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=24,24)/                                &
      0.1986E-03,  0.3917E-03,  0.7654E-03,  0.1475E-02,  0.2782E-02,   &
      0.5086E-02,  0.8931E-02,  0.1497E-01,  0.2401E-01,  0.3707E-01,   &
      0.5549E-01,  0.8107E-01,  0.1157E+00,  0.1604E+00,  0.2138E+00,   &
      0.2723E+00,  0.3311E+00,  0.3877E+00,  0.4433E+00,  0.5001E+00,   &
      0.5580E+00,  0.6152E+00,  0.6683E+00,  0.7158E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=24,24)/                                &
      -0.1372E-06, -0.2802E-06, -0.5797E-06, -0.1212E-05, -0.2549E-05,  &
      -0.5312E-05, -0.1068E-04, -0.2023E-04, -0.3609E-04, -0.6255E-04,  &
      -0.1068E-03, -0.1777E-03, -0.2830E-03, -0.4252E-03, -0.6004E-03,  &
      -0.8005E-03, -0.1011E-02, -0.1213E-02, -0.1399E-02, -0.1569E-02,  &
      -0.1712E-02, -0.1809E-02, -0.1858E-02, -0.1883E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=24,24)/                                &
      -0.5589E-09, -0.1071E-08, -0.2083E-08, -0.3965E-08, -0.7465E-08,  &
      -0.1408E-07, -0.2720E-07, -0.5414E-07, -0.1061E-06, -0.1958E-06,  &
      -0.3365E-06, -0.5263E-06, -0.7236E-06, -0.8420E-06, -0.7920E-06,  &
      -0.5166E-06, -0.5606E-07,  0.4032E-06,  0.7697E-06,  0.1160E-05,  &
      0.1692E-05,  0.2251E-05,  0.2483E-05,  0.2295E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=25,25)/                                &
      0.1990E-03,  0.3929E-03,  0.7699E-03,  0.1490E-02,  0.2829E-02,   &
      0.5226E-02,  0.9314E-02,  0.1593E-01,  0.2618E-01,  0.4144E-01,   &
      0.6312E-01,  0.9271E-01,  0.1317E+00,  0.1803E+00,  0.2364E+00,   &
      0.2956E+00,  0.3541E+00,  0.4111E+00,  0.4680E+00,  0.5255E+00,   &
      0.5829E+00,  0.6376E+00,  0.6869E+00,  0.7311E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=25,25)/                                &
      -0.1366E-06, -0.2772E-06, -0.5687E-06, -0.1179E-05, -0.2458E-05,  &
      -0.5093E-05, -0.1024E-04, -0.1950E-04, -0.3503E-04, -0.6107E-04,  &
      -0.1053E-03, -0.1782E-03, -0.2902E-03, -0.4470E-03, -0.6455E-03,  &
      -0.8715E-03, -0.1095E-02, -0.1290E-02, -0.1458E-02, -0.1604E-02,  &
      -0.1716E-02, -0.1783E-02, -0.1821E-02, -0.1862E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=25,25)/                                &
      -0.5574E-09, -0.1099E-08, -0.2136E-08, -0.4136E-08, -0.7893E-08,  &
      -0.1505E-07, -0.2894E-07, -0.5650E-07, -0.1084E-06, -0.1986E-06,  &
      -0.3416E-06, -0.5381E-06, -0.7439E-06, -0.8545E-06, -0.7482E-06,  &
      -0.3541E-06,  0.2762E-06,  0.9306E-06,  0.1416E-05,  0.1754E-05,  &
      0.2105E-05,  0.2343E-05,  0.2113E-05,  0.1689E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=26,26)/                                &
      0.1993E-03,  0.3940E-03,  0.7739E-03,  0.1503E-02,  0.2871E-02,   &
      0.5350E-02,  0.9655E-02,  0.1679E-01,  0.2817E-01,  0.4563E-01,   &
      0.7094E-01,  0.1052E+00,  0.1488E+00,  0.2006E+00,  0.2575E+00,   &
      0.3155E+00,  0.3732E+00,  0.4317E+00,  0.4909E+00,  0.5496E+00,   &
      0.6058E+00,  0.6569E+00,  0.7019E+00,  0.7436E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=26,26)/                                &
      -0.1351E-06, -0.2730E-06, -0.5547E-06, -0.1136E-05, -0.2337E-05,  &
      -0.4789E-05, -0.9589E-05, -0.1836E-04, -0.3337E-04, -0.5890E-04,  &
      -0.1031E-03, -0.1781E-03, -0.2974E-03, -0.4696E-03, -0.6912E-03,  &
      -0.9400E-03, -0.1174E-02, -0.1368E-02, -0.1521E-02, -0.1635E-02,  &
      -0.1706E-02, -0.1742E-02, -0.1779E-02, -0.1846E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=26,26)/                                &
      -0.5597E-09, -0.1126E-08, -0.2190E-08, -0.4298E-08, -0.8333E-08,  &
      -0.1610E-07, -0.3092E-07, -0.5912E-07, -0.1108E-06, -0.1982E-06,  &
      -0.3334E-06, -0.5129E-06, -0.6865E-06, -0.7484E-06, -0.5999E-06,  &
      -0.1961E-06,  0.5028E-06,  0.1395E-05,  0.2125E-05,  0.2489E-05,  &
      0.2584E-05,  0.2312E-05,  0.1587E-05,  0.1122E-05/
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "o3.tran3", which define pre-computed tables used for o3 (band5)
!  transmittance calculations.
!
!-----------------------------------------------------------------------
!
! o3.tran3

  REAL :: o1(26,21,7),o2(26,21,7),o3(26,21,7)

  COMMON /radtab003 /o1,o2,o3

  DATA ((o1(ip,iw,1),iw=1,21),ip= 1, 1)/                                &
      0.7117E-05,  0.1419E-04,  0.2828E-04,  0.5629E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8367E-03,  0.1586E-02,  0.2911E-02,   &
      0.5106E-02,  0.8433E-02,  0.1302E-01,  0.1896E-01,  0.2658E-01,   &
      0.3657E-01,  0.4988E-01,  0.6765E-01,  0.9092E-01,  0.1204E+00,   &
      0.1559E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 1, 1)/                                &
      0.6531E-10,  0.5926E-10, -0.1646E-09, -0.1454E-08, -0.7376E-08,   &
      -0.2968E-07, -0.1071E-06, -0.3584E-06, -0.1125E-05, -0.3289E-05,  &
      -0.8760E-05, -0.2070E-04, -0.4259E-04, -0.7691E-04, -0.1264E-03,  &
      -0.1957E-03, -0.2895E-03, -0.4107E-03, -0.5588E-03, -0.7300E-03,  &
      -0.9199E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 1, 1)/                                &
      -0.2438E-10, -0.4826E-10, -0.9474E-10, -0.1828E-09, -0.3406E-09,  &
      -0.6223E-09, -0.1008E-08, -0.1412E-08, -0.1244E-08,  0.8485E-09,  &
      0.6343E-08,  0.1201E-07,  0.2838E-08, -0.4024E-07, -0.1257E-06,   &
      -0.2566E-06, -0.4298E-06, -0.6184E-06, -0.7657E-06, -0.8153E-06,  &
      -0.7552E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 2, 2)/                                &
      0.7117E-05,  0.1419E-04,  0.2828E-04,  0.5629E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8367E-03,  0.1586E-02,  0.2912E-02,   &
      0.5107E-02,  0.8435E-02,  0.1303E-01,  0.1897E-01,  0.2660E-01,   &
      0.3660E-01,  0.4995E-01,  0.6777E-01,  0.9114E-01,  0.1207E+00,   &
      0.1566E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 2, 2)/                                &
      0.6193E-10,  0.5262E-10, -0.1774E-09, -0.1478E-08, -0.7416E-08,   &
      -0.2985E-07, -0.1071E-06, -0.3584E-06, -0.1124E-05, -0.3287E-05,  &
      -0.8753E-05, -0.2069E-04, -0.4256E-04, -0.7686E-04, -0.1264E-03,  &
      -0.1956E-03, -0.2893E-03, -0.4103E-03, -0.5580E-03, -0.7285E-03,  &
      -0.9171E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 2, 2)/                                &
      -0.2436E-10, -0.4822E-10, -0.9466E-10, -0.1827E-09, -0.3404E-09,  &
      -0.6220E-09, -0.1008E-08, -0.1414E-08, -0.1247E-08,  0.8360E-09,  &
      0.6312E-08,  0.1194E-07,  0.2753E-08, -0.4040E-07, -0.1260E-06,   &
      -0.2571E-06, -0.4307E-06, -0.6202E-06, -0.7687E-06, -0.8204E-06,  &
      -0.7636E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 3, 3)/                                &
      0.7117E-05,  0.1419E-04,  0.2828E-04,  0.5628E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8367E-03,  0.1586E-02,  0.2912E-02,   &
      0.5109E-02,  0.8439E-02,  0.1303E-01,  0.1899E-01,  0.2664E-01,   &
      0.3666E-01,  0.5005E-01,  0.6795E-01,  0.9147E-01,  0.1213E+00,   &
      0.1576E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 3, 3)/                                &
      0.5658E-10,  0.4212E-10, -0.1977E-09, -0.1516E-08, -0.7481E-08,   &
      -0.2995E-07, -0.1072E-06, -0.3583E-06, -0.1123E-05, -0.3283E-05,  &
      -0.8744E-05, -0.2067E-04, -0.4252E-04, -0.7679E-04, -0.1262E-03,  &
      -0.1953E-03, -0.2889E-03, -0.4096E-03, -0.5567E-03, -0.7263E-03,  &
      -0.9130E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 3, 3)/                                &
      -0.2433E-10, -0.4815E-10, -0.9453E-10, -0.1825E-09, -0.3400E-09,  &
      -0.6215E-09, -0.1007E-08, -0.1415E-08, -0.1253E-08,  0.8143E-09,  &
      0.6269E-08,  0.1186E-07,  0.2604E-08, -0.4067E-07, -0.1264E-06,   &
      -0.2579E-06, -0.4321E-06, -0.6229E-06, -0.7732E-06, -0.8277E-06,  &
      -0.7752E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 4, 4)/                                &
      0.7116E-05,  0.1419E-04,  0.2828E-04,  0.5628E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8368E-03,  0.1586E-02,  0.2913E-02,   &
      0.5111E-02,  0.8444E-02,  0.1305E-01,  0.1902E-01,  0.2669E-01,   &
      0.3676E-01,  0.5022E-01,  0.6825E-01,  0.9199E-01,  0.1222E+00,   &
      0.1591E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 4, 4)/                                &
      0.4814E-10,  0.2552E-10, -0.2298E-09, -0.1576E-08, -0.7579E-08,   &
      -0.3009E-07, -0.1074E-06, -0.3581E-06, -0.1122E-05, -0.3278E-05,  &
      -0.8729E-05, -0.2063E-04, -0.4245E-04, -0.7667E-04, -0.1260E-03,  &
      -0.1950E-03, -0.2883E-03, -0.4086E-03, -0.5549E-03, -0.7229E-03,  &
      -0.9071E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 4, 4)/                                &
      -0.2428E-10, -0.4805E-10, -0.9433E-10, -0.1821E-09, -0.3394E-09,  &
      -0.6206E-09, -0.1008E-08, -0.1416E-08, -0.1261E-08,  0.7860E-09,  &
      0.6188E-08,  0.1171E-07,  0.2389E-08, -0.4109E-07, -0.1271E-06,   &
      -0.2591E-06, -0.4344E-06, -0.6267E-06, -0.7797E-06, -0.8378E-06,  &
      -0.7901E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 5, 5)/                                &
      0.7116E-05,  0.1419E-04,  0.2827E-04,  0.5627E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8368E-03,  0.1586E-02,  0.2914E-02,   &
      0.5114E-02,  0.8454E-02,  0.1307E-01,  0.1906E-01,  0.2677E-01,   &
      0.3690E-01,  0.5048E-01,  0.6872E-01,  0.9281E-01,  0.1236E+00,   &
      0.1615E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 5, 5)/                                &
      0.3482E-10, -0.6492E-12, -0.2805E-09, -0.1671E-08, -0.7740E-08,   &
      -0.3032E-07, -0.1076E-06, -0.3582E-06, -0.1120E-05, -0.3270E-05,  &
      -0.8704E-05, -0.2058E-04, -0.4235E-04, -0.7649E-04, -0.1257E-03,  &
      -0.1945E-03, -0.2874E-03, -0.4070E-03, -0.5521E-03, -0.7181E-03,  &
      -0.8990E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 5, 5)/                                &
      -0.2419E-10, -0.4788E-10, -0.9401E-10, -0.1815E-09, -0.3385E-09,  &
      -0.6192E-09, -0.1006E-08, -0.1417E-08, -0.1273E-08,  0.7404E-09,  &
      0.6068E-08,  0.1148E-07,  0.2021E-08, -0.4165E-07, -0.1281E-06,   &
      -0.2609E-06, -0.4375E-06, -0.6323E-06, -0.7887E-06, -0.8508E-06,  &
      -0.8067E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 6, 6)/                                &
      0.7114E-05,  0.1419E-04,  0.2827E-04,  0.5627E-04,  0.1117E-03,   &
      0.2207E-03,  0.4325E-03,  0.8369E-03,  0.1587E-02,  0.2916E-02,   &
      0.5120E-02,  0.8468E-02,  0.1310E-01,  0.1913E-01,  0.2690E-01,   &
      0.3714E-01,  0.5090E-01,  0.6944E-01,  0.9407E-01,  0.1258E+00,   &
      0.1651E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 6, 6)/                                &
      0.1388E-10, -0.4180E-10, -0.3601E-09, -0.1820E-08, -0.7993E-08,   &
      -0.3068E-07, -0.1081E-06, -0.3580E-06, -0.1117E-05, -0.3257E-05,  &
      -0.8667E-05, -0.2049E-04, -0.4218E-04, -0.7620E-04, -0.1253E-03,  &
      -0.1937E-03, -0.2860E-03, -0.4047E-03, -0.5481E-03, -0.7115E-03,  &
      -0.8885E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 6, 6)/                                &
      -0.2406E-10, -0.4762E-10, -0.9351E-10, -0.1806E-09, -0.3370E-09,  &
      -0.6170E-09, -0.1004E-08, -0.1417E-08, -0.1297E-08,  0.6738E-09,  &
      0.5895E-08,  0.1113E-07,  0.1466E-08, -0.4265E-07, -0.1298E-06,   &
      -0.2636E-06, -0.4423E-06, -0.6402E-06, -0.8005E-06, -0.8658E-06,  &
      -0.8222E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 7, 7)/                                &
      0.7113E-05,  0.1418E-04,  0.2826E-04,  0.5625E-04,  0.1117E-03,   &
      0.2206E-03,  0.4325E-03,  0.8371E-03,  0.1588E-02,  0.2918E-02,   &
      0.5128E-02,  0.8491E-02,  0.1315E-01,  0.1923E-01,  0.2710E-01,   &
      0.3750E-01,  0.5154E-01,  0.7056E-01,  0.9600E-01,  0.1290E+00,   &
      0.1703E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 7, 7)/                                &
      -0.1889E-10, -0.1062E-09, -0.4847E-09, -0.2053E-08, -0.8389E-08,  &
      -0.3140E-07, -0.1089E-06, -0.3577E-06, -0.1112E-05, -0.3236E-05,  &
      -0.8607E-05, -0.2035E-04, -0.4192E-04, -0.7576E-04, -0.1245E-03,  &
      -0.1925E-03, -0.2840E-03, -0.4013E-03, -0.5427E-03, -0.7029E-03,  &
      -0.8756E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 7, 7)/                                &
      -0.2385E-10, -0.4722E-10, -0.9273E-10, -0.1791E-09, -0.3348E-09,  &
      -0.6121E-09, -0.9974E-09, -0.1422E-08, -0.1326E-08,  0.5603E-09,  &
      0.5604E-08,  0.1061E-07,  0.6106E-09, -0.4398E-07, -0.1321E-06,   &
      -0.2676E-06, -0.4490E-06, -0.6507E-06, -0.8145E-06, -0.8801E-06,  &
      -0.8311E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 8, 8)/                                &
      0.7110E-05,  0.1418E-04,  0.2825E-04,  0.5623E-04,  0.1116E-03,   &
      0.2206E-03,  0.4325E-03,  0.8373E-03,  0.1589E-02,  0.2923E-02,   &
      0.5141E-02,  0.8526E-02,  0.1324E-01,  0.1940E-01,  0.2741E-01,   &
      0.3807E-01,  0.5253E-01,  0.7227E-01,  0.9889E-01,  0.1338E+00,   &
      0.1777E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 8, 8)/                                &
      -0.6983E-10, -0.2063E-09, -0.6785E-09, -0.2416E-08, -0.9000E-08,  &
      -0.3243E-07, -0.1100E-06, -0.3574E-06, -0.1104E-05, -0.3205E-05,  &
      -0.8516E-05, -0.2014E-04, -0.4151E-04, -0.7508E-04, -0.1234E-03,  &
      -0.1907E-03, -0.2811E-03, -0.3966E-03, -0.5355E-03, -0.6924E-03,  &
      -0.8613E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 8, 8)/                                &
      -0.2353E-10, -0.4659E-10, -0.9153E-10, -0.1769E-09, -0.3313E-09,  &
      -0.6054E-09, -0.9899E-09, -0.1430E-08, -0.1375E-08,  0.3874E-09,  &
      0.5171E-08,  0.9807E-08, -0.7345E-09, -0.4604E-07, -0.1356E-06,   &
      -0.2731E-06, -0.4577E-06, -0.6632E-06, -0.8284E-06, -0.8894E-06,  &
      -0.8267E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 9, 9)/                                &
      0.7105E-05,  0.1417E-04,  0.2823E-04,  0.5620E-04,  0.1116E-03,   &
      0.2205E-03,  0.4325E-03,  0.8376E-03,  0.1591E-02,  0.2929E-02,   &
      0.5162E-02,  0.8581E-02,  0.1336E-01,  0.1966E-01,  0.2790E-01,   &
      0.3894E-01,  0.5404E-01,  0.7484E-01,  0.1031E+00,  0.1405E+00,   &
      0.1880E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 9, 9)/                                &
      -0.1481E-09, -0.3601E-09, -0.9762E-09, -0.2973E-08, -0.1014E-07,  &
      -0.3421E-07, -0.1121E-06, -0.3569E-06, -0.1092E-05, -0.3156E-05,  &
      -0.8375E-05, -0.1981E-04, -0.4090E-04, -0.7405E-04, -0.1218E-03,  &
      -0.1881E-03, -0.2770E-03, -0.3906E-03, -0.5269E-03, -0.6810E-03,  &
      -0.8471E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 9, 9)/                                &
      -0.2304E-10, -0.4564E-10, -0.8969E-10, -0.1735E-09, -0.3224E-09,  &
      -0.5933E-09, -0.9756E-09, -0.1428E-08, -0.1446E-08,  0.1156E-09,  &
      0.4499E-08,  0.8469E-08, -0.2720E-08, -0.4904E-07, -0.1401E-06,   &
      -0.2801E-06, -0.4681E-06, -0.6761E-06, -0.8387E-06, -0.8879E-06,  &
      -0.8040E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=10,10)/                                &
      0.7098E-05,  0.1415E-04,  0.2821E-04,  0.5615E-04,  0.1115E-03,   &
      0.2204E-03,  0.4325E-03,  0.8382E-03,  0.1593E-02,  0.2940E-02,   &
      0.5194E-02,  0.8666E-02,  0.1356E-01,  0.2006E-01,  0.2865E-01,   &
      0.4026E-01,  0.5631E-01,  0.7863E-01,  0.1093E+00,  0.1500E+00,   &
      0.2017E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=10,10)/                                &
      -0.2661E-09, -0.5923E-09, -0.1426E-08, -0.3816E-08, -0.1159E-07,  &
      -0.3654E-07, -0.1143E-06, -0.3559E-06, -0.1074E-05, -0.3083E-05,  &
      -0.8159E-05, -0.1932E-04, -0.3998E-04, -0.7253E-04, -0.1194E-03,  &
      -0.1845E-03, -0.2718E-03, -0.3833E-03, -0.5176E-03, -0.6701E-03,  &
      -0.8354E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=10,10)/                                &
      -0.2232E-10, -0.4421E-10, -0.8695E-10, -0.1684E-09, -0.3141E-09,  &
      -0.5765E-09, -0.9606E-09, -0.1434E-08, -0.1551E-08, -0.2663E-09,  &
      0.3515E-08,  0.6549E-08, -0.5479E-08, -0.5312E-07, -0.1460E-06,   &
      -0.2883E-06, -0.4787E-06, -0.6863E-06, -0.8399E-06, -0.8703E-06,  &
      -0.7602E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=11,11)/                                &
      0.7088E-05,  0.1413E-04,  0.2817E-04,  0.5608E-04,  0.1114E-03,   &
      0.2203E-03,  0.4325E-03,  0.8390E-03,  0.1598E-02,  0.2955E-02,   &
      0.5242E-02,  0.8796E-02,  0.1386E-01,  0.2067E-01,  0.2978E-01,   &
      0.4224E-01,  0.5964E-01,  0.8406E-01,  0.1178E+00,  0.1627E+00,   &
      0.2197E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=11,11)/                                &
      -0.4394E-09, -0.9330E-09, -0.2086E-08, -0.5054E-08, -0.1373E-07,  &
      -0.3971E-07, -0.1178E-06, -0.3546E-06, -0.1049E-05, -0.2976E-05,  &
      -0.7847E-05, -0.1860E-04, -0.3864E-04, -0.7038E-04, -0.1162E-03,  &
      -0.1798E-03, -0.2654E-03, -0.3754E-03, -0.5091E-03, -0.6621E-03,  &
      -0.8286E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=11,11)/                                &
      -0.2127E-10, -0.4216E-10, -0.8300E-10, -0.1611E-09, -0.3019E-09,  &
      -0.5597E-09, -0.9431E-09, -0.1450E-08, -0.1694E-08, -0.7913E-09,  &
      0.2144E-08,  0.3990E-08, -0.9282E-08, -0.5810E-07, -0.1525E-06,   &
      -0.2965E-06, -0.4869E-06, -0.6894E-06, -0.8281E-06, -0.8350E-06,  &
      -0.6956E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=12,12)/                                &
      0.7073E-05,  0.1411E-04,  0.2811E-04,  0.5598E-04,  0.1112E-03,   &
      0.2201E-03,  0.4324E-03,  0.8401E-03,  0.1604E-02,  0.2978E-02,   &
      0.5313E-02,  0.8987E-02,  0.1431E-01,  0.2158E-01,  0.3145E-01,   &
      0.4512E-01,  0.6440E-01,  0.9161E-01,  0.1293E+00,  0.1793E+00,   &
      0.2426E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=12,12)/                                &
      -0.6829E-09, -0.1412E-08, -0.3014E-08, -0.6799E-08, -0.1675E-07,  &
      -0.4450E-07, -0.1235E-06, -0.3538E-06, -0.1014E-05, -0.2827E-05,  &
      -0.7407E-05, -0.1759E-04, -0.3676E-04, -0.6744E-04, -0.1120E-03,  &
      -0.1742E-03, -0.2585E-03, -0.3683E-03, -0.5034E-03, -0.6594E-03,  &
      -0.8290E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=12,12)/                                &
      -0.1985E-10, -0.3937E-10, -0.7761E-10, -0.1511E-09, -0.2855E-09,  &
      -0.5313E-09, -0.9251E-09, -0.1470E-08, -0.1898E-08, -0.1519E-08,  &
      0.2914E-09,  0.5675E-09, -0.1405E-07, -0.6359E-07, -0.1584E-06,   &
      -0.3020E-06, -0.4893E-06, -0.6821E-06, -0.8021E-06, -0.7834E-06,  &
      -0.6105E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=13,13)/                                &
      0.7053E-05,  0.1407E-04,  0.2804E-04,  0.5584E-04,  0.1110E-03,   &
      0.2198E-03,  0.4324E-03,  0.8420E-03,  0.1613E-02,  0.3011E-02,   &
      0.5416E-02,  0.9263E-02,  0.1495E-01,  0.2289E-01,  0.3384E-01,   &
      0.4918E-01,  0.7096E-01,  0.1018E+00,  0.1442E+00,  0.2004E+00,   &
      0.2708E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=13,13)/                                &
      -0.1004E-08, -0.2043E-08, -0.4239E-08, -0.9104E-08, -0.2075E-07,  &
      -0.5096E-07, -0.1307E-06, -0.3520E-06, -0.9671E-06, -0.2630E-05,  &
      -0.6825E-05, -0.1624E-04, -0.3429E-04, -0.6369E-04, -0.1069E-03,  &
      -0.1680E-03, -0.2520E-03, -0.3635E-03, -0.5029E-03, -0.6647E-03,  &
      -0.8390E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=13,13)/                                &
      -0.1807E-10, -0.3587E-10, -0.7085E-10, -0.1385E-09, -0.2648E-09,  &
      -0.4958E-09, -0.8900E-09, -0.1473E-08, -0.2112E-08, -0.2399E-08,  &
      -0.2002E-08, -0.3646E-08, -0.1931E-07, -0.6852E-07, -0.1618E-06,  &
      -0.3021E-06, -0.4828E-06, -0.6634E-06, -0.7643E-06, -0.7177E-06,  &
      -0.5054E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=14,14)/                                &
      0.7029E-05,  0.1402E-04,  0.2795E-04,  0.5567E-04,  0.1107E-03,   &
      0.2195E-03,  0.4326E-03,  0.8447E-03,  0.1625E-02,  0.3056E-02,   &
      0.5554E-02,  0.9638E-02,  0.1584E-01,  0.2470E-01,  0.3713E-01,   &
      0.5470E-01,  0.7969E-01,  0.1149E+00,  0.1631E+00,  0.2263E+00,   &
      0.3045E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=14,14)/                                &
      -0.1387E-08, -0.2798E-08, -0.5706E-08, -0.1187E-07, -0.2564E-07,  &
      -0.5866E-07, -0.1398E-06, -0.3516E-06, -0.9148E-06, -0.2398E-05,  &
      -0.6122E-05, -0.1459E-04, -0.3125E-04, -0.5923E-04, -0.1013E-03,  &
      -0.1620E-03, -0.2473E-03, -0.3631E-03, -0.5098E-03, -0.6800E-03,  &
      -0.8603E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=14,14)/                                &
      -0.1610E-10, -0.3200E-10, -0.6337E-10, -0.1245E-09, -0.2408E-09,  &
      -0.4533E-09, -0.8405E-09, -0.1464E-08, -0.2337E-08, -0.3341E-08,  &
      -0.4467E-08, -0.8154E-08, -0.2436E-07, -0.7128E-07, -0.1604E-06,  &
      -0.2945E-06, -0.4666E-06, -0.6357E-06, -0.7187E-06, -0.6419E-06,  &
      -0.3795E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=15,15)/                                &
      0.7003E-05,  0.1397E-04,  0.2785E-04,  0.5550E-04,  0.1104E-03,   &
      0.2192E-03,  0.4329E-03,  0.8481E-03,  0.1641E-02,  0.3112E-02,   &
      0.5729E-02,  0.1012E-01,  0.1698E-01,  0.2708E-01,  0.4146E-01,   &
      0.6189E-01,  0.9085E-01,  0.1313E+00,  0.1862E+00,  0.2571E+00,   &
      0.3433E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=15,15)/                                &
      -0.1788E-08, -0.3588E-08, -0.7244E-08, -0.1479E-07, -0.3083E-07,  &
      -0.6671E-07, -0.1497E-06, -0.3519E-06, -0.8607E-06, -0.2154E-05,  &
      -0.5364E-05, -0.1276E-04, -0.2785E-04, -0.5435E-04, -0.9573E-04,  &
      -0.1570E-03, -0.2455E-03, -0.3682E-03, -0.5253E-03, -0.7065E-03,  &
      -0.8938E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=15,15)/                                &
      -0.1429E-10, -0.2843E-10, -0.5645E-10, -0.1115E-09, -0.2181E-09,  &
      -0.4200E-09, -0.7916E-09, -0.1460E-08, -0.2542E-08, -0.4168E-08,  &
      -0.6703E-08, -0.1215E-07, -0.2821E-07, -0.7073E-07, -0.1530E-06,  &
      -0.2791E-06, -0.4426E-06, -0.6027E-06, -0.6707E-06, -0.5591E-06,  &
      -0.2328E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=16,16)/                                &
      0.6981E-05,  0.1393E-04,  0.2777E-04,  0.5535E-04,  0.1102E-03,   &
      0.2190E-03,  0.4336E-03,  0.8527E-03,  0.1660E-02,  0.3177E-02,   &
      0.5930E-02,  0.1068E-01,  0.1836E-01,  0.3000E-01,  0.4686E-01,   &
      0.7083E-01,  0.1046E+00,  0.1511E+00,  0.2134E+00,  0.2924E+00,   &
      0.3861E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=16,16)/                                &
      -0.2141E-08, -0.4286E-08, -0.8603E-08, -0.1737E-07, -0.3548E-07,  &
      -0.7410E-07, -0.1590E-06, -0.3537E-06, -0.8142E-06, -0.1935E-05,  &
      -0.4658E-05, -0.1099E-04, -0.2444E-04, -0.4948E-04, -0.9067E-04,  &
      -0.1538E-03, -0.2474E-03, -0.3793E-03, -0.5495E-03, -0.7439E-03,  &
      -0.9383E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=16,16)/                                &
      -0.1295E-10, -0.2581E-10, -0.5136E-10, -0.1019E-09, -0.2011E-09,  &
      -0.3916E-09, -0.7585E-09, -0.1439E-08, -0.2648E-08, -0.4747E-08,  &
      -0.8301E-08, -0.1499E-07, -0.3024E-07, -0.6702E-07, -0.1399E-06,  &
      -0.2564E-06, -0.4117E-06, -0.5669E-06, -0.6239E-06, -0.4748E-06,  &
      -0.7013E-07/
  DATA ((o1(ip,iw,1),iw=1,21),ip=17,17)/                                &
      0.6967E-05,  0.1390E-04,  0.2772E-04,  0.5527E-04,  0.1101E-03,   &
      0.2191E-03,  0.4346E-03,  0.8579E-03,  0.1679E-02,  0.3244E-02,   &
      0.6139E-02,  0.1127E-01,  0.1986E-01,  0.3330E-01,  0.5315E-01,   &
      0.8139E-01,  0.1207E+00,  0.1741E+00,  0.2442E+00,  0.3311E+00,   &
      0.4312E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=17,17)/                                &
      -0.2400E-08, -0.4796E-08, -0.9599E-08, -0.1927E-07, -0.3892E-07,  &
      -0.7954E-07, -0.1661E-06, -0.3540E-06, -0.7780E-06, -0.1763E-05,  &
      -0.4092E-05, -0.9512E-05, -0.2142E-04, -0.4502E-04, -0.8640E-04,  &
      -0.1525E-03, -0.2526E-03, -0.3955E-03, -0.5805E-03, -0.7897E-03,  &
      -0.9899E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=17,17)/                                &
      -0.1220E-10, -0.2432E-10, -0.4845E-10, -0.9640E-10, -0.1912E-09,  &
      -0.3771E-09, -0.7392E-09, -0.1420E-08, -0.2702E-08, -0.5049E-08,  &
      -0.9214E-08, -0.1659E-07, -0.3101E-07, -0.6162E-07, -0.1235E-06,  &
      -0.2287E-06, -0.3755E-06, -0.5274E-06, -0.5790E-06, -0.3947E-06,  &
      0.1003E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=18,18)/                                &
      0.6963E-05,  0.1389E-04,  0.2771E-04,  0.5526E-04,  0.1101E-03,   &
      0.2193E-03,  0.4359E-03,  0.8629E-03,  0.1698E-02,  0.3305E-02,   &
      0.6331E-02,  0.1183E-01,  0.2133E-01,  0.3671E-01,  0.5996E-01,   &
      0.9320E-01,  0.1389E+00,  0.1999E+00,  0.2778E+00,  0.3717E+00,   &
      0.4761E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=18,18)/                                &
      -0.2557E-08, -0.5106E-08, -0.1020E-07, -0.2043E-07, -0.4103E-07,  &
      -0.8293E-07, -0.1697E-06, -0.3531E-06, -0.7531E-06, -0.1645E-05,  &
      -0.3690E-05, -0.8411E-05, -0.1902E-04, -0.4118E-04, -0.8276E-04,  &
      -0.1525E-03, -0.2601E-03, -0.4147E-03, -0.6149E-03, -0.8384E-03,  &
      -0.1042E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=18,18)/                                &
      -0.1189E-10, -0.2372E-10, -0.4729E-10, -0.9421E-10, -0.1873E-09,  &
      -0.3713E-09, -0.7317E-09, -0.1437E-08, -0.2764E-08, -0.5243E-08,  &
      -0.9691E-08, -0.1751E-07, -0.3122E-07, -0.5693E-07, -0.1076E-06,  &
      -0.1981E-06, -0.3324E-06, -0.4785E-06, -0.5280E-06, -0.3174E-06,  &
      0.2672E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=19,19)/                                &
      0.6963E-05,  0.1389E-04,  0.2771E-04,  0.5528E-04,  0.1102E-03,   &
      0.2196E-03,  0.4370E-03,  0.8672E-03,  0.1712E-02,  0.3355E-02,   &
      0.6488E-02,  0.1230E-01,  0.2262E-01,  0.3989E-01,  0.6677E-01,   &
      0.1056E+00,  0.1586E+00,  0.2276E+00,  0.3131E+00,  0.4124E+00,   &
      0.5188E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=19,19)/                                &
      -0.2630E-08, -0.5249E-08, -0.1048E-07, -0.2096E-07, -0.4198E-07,  &
      -0.8440E-07, -0.1710E-06, -0.3513E-06, -0.7326E-06, -0.1562E-05,  &
      -0.3416E-05, -0.7637E-05, -0.1719E-04, -0.3795E-04, -0.7926E-04,  &
      -0.1524E-03, -0.2680E-03, -0.4344E-03, -0.6486E-03, -0.8838E-03,  &
      -0.1089E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=19,19)/                                &
      -0.1188E-10, -0.2369E-10, -0.4725E-10, -0.9417E-10, -0.1875E-09,  &
      -0.3725E-09, -0.7365E-09, -0.1445E-08, -0.2814E-08, -0.5384E-08,  &
      -0.1008E-07, -0.1816E-07, -0.3179E-07, -0.5453E-07, -0.9500E-07,  &
      -0.1679E-06, -0.2819E-06, -0.4109E-06, -0.4555E-06, -0.2283E-06,  &
      0.4283E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=20,20)/                                &
      0.6963E-05,  0.1389E-04,  0.2772E-04,  0.5529E-04,  0.1103E-03,   &
      0.2198E-03,  0.4377E-03,  0.8701E-03,  0.1723E-02,  0.3391E-02,   &
      0.6606E-02,  0.1266E-01,  0.2366E-01,  0.4262E-01,  0.7304E-01,   &
      0.1179E+00,  0.1789E+00,  0.2563E+00,  0.3487E+00,  0.4516E+00,   &
      0.5572E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=20,20)/                                &
      -0.2651E-08, -0.5291E-08, -0.1056E-07, -0.2110E-07, -0.4221E-07,  &
      -0.8462E-07, -0.1705E-06, -0.3466E-06, -0.7155E-06, -0.1501E-05,  &
      -0.3223E-05, -0.7079E-05, -0.1581E-04, -0.3517E-04, -0.7553E-04,  &
      -0.1510E-03, -0.2746E-03, -0.4528E-03, -0.6789E-03, -0.9214E-03,  &
      -0.1124E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=20,20)/                                &
      -0.1193E-10, -0.2380E-10, -0.4748E-10, -0.9465E-10, -0.1886E-09,  &
      -0.3751E-09, -0.7436E-09, -0.1466E-08, -0.2872E-08, -0.5508E-08,  &
      -0.1038E-07, -0.1891E-07, -0.3279E-07, -0.5420E-07, -0.8711E-07,  &
      -0.1403E-06, -0.2248E-06, -0.3221E-06, -0.3459E-06, -0.1066E-06,  &
      0.5938E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=21,21)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5530E-04,  0.1103E-03,   &
      0.2199E-03,  0.4382E-03,  0.8719E-03,  0.1730E-02,  0.3416E-02,   &
      0.6690E-02,  0.1293E-01,  0.2445E-01,  0.4479E-01,  0.7837E-01,   &
      0.1291E+00,  0.1985E+00,  0.2846E+00,  0.3831E+00,  0.4875E+00,   &
      0.5902E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=21,21)/                                &
      -0.2654E-08, -0.5296E-08, -0.1057E-07, -0.2111E-07, -0.4219E-07,  &
      -0.8445E-07, -0.1696E-06, -0.3428E-06, -0.7013E-06, -0.1458E-05,  &
      -0.3084E-05, -0.6678E-05, -0.1476E-04, -0.3284E-04, -0.7173E-04,  &
      -0.1481E-03, -0.2786E-03, -0.4688E-03, -0.7052E-03, -0.9506E-03,  &
      -0.1148E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=21,21)/                                &
      -0.1195E-10, -0.2384E-10, -0.4755E-10, -0.9482E-10, -0.1890E-09,  &
      -0.3761E-09, -0.7469E-09, -0.1476E-08, -0.2892E-08, -0.5603E-08,  &
      -0.1060E-07, -0.1942E-07, -0.3393E-07, -0.5508E-07, -0.8290E-07,  &
      -0.1182E-06, -0.1657E-06, -0.2170E-06, -0.1997E-06,  0.6227E-07,  &
      0.7847E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=22,22)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5530E-04,  0.1103E-03,   &
      0.2200E-03,  0.4385E-03,  0.8731E-03,  0.1735E-02,  0.3433E-02,   &
      0.6748E-02,  0.1311E-01,  0.2502E-01,  0.4642E-01,  0.8258E-01,   &
      0.1385E+00,  0.2160E+00,  0.3107E+00,  0.4146E+00,  0.5188E+00,   &
      0.6171E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=22,22)/                                &
      -0.2653E-08, -0.5295E-08, -0.1057E-07, -0.2110E-07, -0.4215E-07,  &
      -0.8430E-07, -0.1690E-06, -0.3403E-06, -0.6919E-06, -0.1427E-05,  &
      -0.2991E-05, -0.6399E-05, -0.1398E-04, -0.3099E-04, -0.6824E-04,  &
      -0.1441E-03, -0.2795E-03, -0.4814E-03, -0.7282E-03, -0.9739E-03,  &
      -0.1163E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=22,22)/                                &
      -0.1195E-10, -0.2384E-10, -0.4756E-10, -0.9485E-10, -0.1891E-09,  &
      -0.3765E-09, -0.7483E-09, -0.1481E-08, -0.2908E-08, -0.5660E-08,  &
      -0.1075E-07, -0.1980E-07, -0.3472E-07, -0.5626E-07, -0.8149E-07,  &
      -0.1027E-06, -0.1136E-06, -0.1071E-06, -0.2991E-07,  0.2743E-06,  &
      0.1017E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=23,23)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5530E-04,  0.1103E-03,   &
      0.2200E-03,  0.4387E-03,  0.8738E-03,  0.1738E-02,  0.3445E-02,   &
      0.6786E-02,  0.1324E-01,  0.2541E-01,  0.4757E-01,  0.8567E-01,   &
      0.1459E+00,  0.2303E+00,  0.3331E+00,  0.4415E+00,  0.5444E+00,   &
      0.6377E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=23,23)/                                &
      -0.2653E-08, -0.5294E-08, -0.1057E-07, -0.2109E-07, -0.4212E-07,  &
      -0.8420E-07, -0.1686E-06, -0.3388E-06, -0.6858E-06, -0.1406E-05,  &
      -0.2928E-05, -0.6206E-05, -0.1344E-04, -0.2961E-04, -0.6533E-04,  &
      -0.1399E-03, -0.2780E-03, -0.4904E-03, -0.7488E-03, -0.9953E-03,  &
      -0.1175E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=23,23)/                                &
      -0.1195E-10, -0.2384E-10, -0.4756E-10, -0.9485E-10, -0.1891E-09,  &
      -0.3767E-09, -0.7492E-09, -0.1485E-08, -0.2924E-08, -0.5671E-08,  &
      -0.1084E-07, -0.2009E-07, -0.3549E-07, -0.5773E-07, -0.8208E-07,  &
      -0.9394E-07, -0.7270E-07, -0.3947E-08,  0.1456E-06,  0.5083E-06,  &
      0.1270E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=24,24)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5531E-04,  0.1103E-03,   &
      0.2201E-03,  0.4388E-03,  0.8743E-03,  0.1740E-02,  0.3452E-02,   &
      0.6811E-02,  0.1332E-01,  0.2567E-01,  0.4835E-01,  0.8782E-01,   &
      0.1511E+00,  0.2412E+00,  0.3507E+00,  0.4627E+00,  0.5638E+00,   &
      0.6526E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=24,24)/                                &
      -0.2653E-08, -0.5294E-08, -0.1056E-07, -0.2109E-07, -0.4210E-07,  &
      -0.8413E-07, -0.1684E-06, -0.3379E-06, -0.6820E-06, -0.1393E-05,  &
      -0.2889E-05, -0.6080E-05, -0.1307E-04, -0.2861E-04, -0.6310E-04,  &
      -0.1363E-03, -0.2758E-03, -0.4969E-03, -0.7681E-03, -0.1017E-02,  &
      -0.1186E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=24,24)/                                &
      -0.1195E-10, -0.2384E-10, -0.4756E-10, -0.9485E-10, -0.1891E-09,  &
      -0.3768E-09, -0.7497E-09, -0.1487E-08, -0.2933E-08, -0.5710E-08,  &
      -0.1089E-07, -0.2037E-07, -0.3616E-07, -0.5907E-07, -0.8351E-07,  &
      -0.8925E-07, -0.4122E-07,  0.8779E-07,  0.3143E-06,  0.7281E-06,  &
      0.1500E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=25,25)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5531E-04,  0.1103E-03,   &
      0.2201E-03,  0.4388E-03,  0.8745E-03,  0.1741E-02,  0.3456E-02,   &
      0.6827E-02,  0.1337E-01,  0.2584E-01,  0.4885E-01,  0.8924E-01,   &
      0.1547E+00,  0.2488E+00,  0.3632E+00,  0.4779E+00,  0.5771E+00,   &
      0.6627E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=25,25)/                                &
      -0.2653E-08, -0.5293E-08, -0.1056E-07, -0.2108E-07, -0.4209E-07,  &
      -0.8409E-07, -0.1682E-06, -0.3373E-06, -0.6797E-06, -0.1383E-05,  &
      -0.2862E-05, -0.5993E-05, -0.1283E-04, -0.2795E-04, -0.6158E-04,  &
      -0.1338E-03, -0.2743E-03, -0.5030E-03, -0.7863E-03, -0.1038E-02,  &
      -0.1196E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=25,25)/                                &
      -0.1195E-10, -0.2383E-10, -0.4755E-10, -0.9484E-10, -0.1891E-09,  &
      -0.3768E-09, -0.7499E-09, -0.1489E-08, -0.2939E-08, -0.5741E-08,  &
      -0.1100E-07, -0.2066E-07, -0.3660E-07, -0.6002E-07, -0.8431E-07,  &
      -0.8556E-07, -0.1674E-07,  0.1638E-06,  0.4525E-06,  0.8949E-06,  &
      0.1669E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=26,26)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5531E-04,  0.1103E-03,   &
      0.2201E-03,  0.4389E-03,  0.8747E-03,  0.1741E-02,  0.3458E-02,   &
      0.6836E-02,  0.1340E-01,  0.2594E-01,  0.4916E-01,  0.9011E-01,   &
      0.1569E+00,  0.2536E+00,  0.3714E+00,  0.4877E+00,  0.5856E+00,   &
      0.6695E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=26,26)/                                &
      -0.2652E-08, -0.5292E-08, -0.1056E-07, -0.2108E-07, -0.4208E-07,  &
      -0.8406E-07, -0.1681E-06, -0.3369E-06, -0.6784E-06, -0.1378E-05,  &
      -0.2843E-05, -0.5944E-05, -0.1269E-04, -0.2759E-04, -0.6078E-04,  &
      -0.1326E-03, -0.2742E-03, -0.5088E-03, -0.8013E-03, -0.1054E-02,  &
      -0.1202E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=26,26)/                                &
      -0.1194E-10, -0.2383E-10, -0.4754E-10, -0.9482E-10, -0.1891E-09,  &
      -0.3768E-09, -0.7499E-09, -0.1489E-08, -0.2941E-08, -0.5752E-08,  &
      -0.1104E-07, -0.2069E-07, -0.3661E-07, -0.6012E-07, -0.8399E-07,  &
      -0.8183E-07,  0.1930E-08,  0.2167E-06,  0.5434E-06,  0.9990E-06,  &
      0.1787E-05/
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "cai.dat", which define pre-computed tables cai
!
!-----------------------------------------------------------------------
!
!  integer   nm,nt,na
!  parameter (nm=11,nt=9,na=11)

  REAL :: caib(11,9,11),caif(9,11)

  COMMON /radtab004/ caib,caif

  DATA ((caib(1,i,j),j=1,11),i=1,9)/                                    &
      0.,0.084,0.170,0.258,0.349,0.442,0.540,0.643,0.752,0.870,1.,      &
      0.,0.076,0.153,0.233,0.315,0.401,0.492,0.589,0.698,0.826,1.,      &
      0.,0.069,0.139,0.210,0.283,0.359,0.438,0.523,0.619,0.741,1.,      &
      0.,0.065,0.130,0.196,0.263,0.332,0.403,0.478,0.561,0.671,1.,      &
      0.,0.062,0.126,0.189,0.253,0.318,0.385,0.454,0.533,0.681,1.,      &
      0.,0.062,0.123,0.185,0.248,0.311,0.375,0.444,0.539,0.738,1.,      &
      0.,0.061,0.122,0.183,0.244,0.307,0.370,0.444,0.577,0.752,1.,      &
      0.,0.060,0.121,0.182,0.243,0.304,0.368,0.457,0.574,0.732,1.,      &
      0.,0.060,0.120,0.181,0.242,0.302,0.367,0.451,0.551,0.690,1./
  DATA ((caib(2,i,j),j=1,11),i=1,9)/                                    &
      0.,0.094,0.190,0.286,0.384,0.482,0.583,0.684,0.788,0.893,1.,      &
      0.,0.090,0.180,0.274,0.368,0.466,0.566,0.668,0.774,0.885,1.,      &
      0.,0.082,0.167,0.254,0.343,0.436,0.533,0.636,0.746,0.866,1.,      &
      0.,0.074,0.151,0.229,0.310,0.395,0.485,0.582,0.692,0.822,1.,      &
      0.,0.068,0.138,0.209,0.282,0.358,0.439,0.527,0.630,0.769,1.,      &
      0.,0.065,0.130,0.197,0.265,0.336,0.410,0.493,0.599,0.766,1.,      &
      0.,0.063,0.126,0.190,0.256,0.323,0.394,0.480,0.604,0.772,1.,      &
      0.,0.062,0.124,0.186,0.249,0.314,0.385,0.475,0.594,0.749,1.,      &
      0.,0.061,0.122,0.183,0.245,0.309,0.378,0.462,0.564,0.704,1./
  DATA ((caib(3,i,j),j=1,11),i=1,9)/                                    &
      0.,0.097,0.194,0.292,0.392,0.491,0.591,0.692,0.794,0.897,1.,      &
      0.,0.094,0.189,0.286,0.383,0.482,0.582,0.684,0.788,0.893,1.,      &
      0.,0.090,0.180,0.274,0.368,0.466,0.566,0.668,0.775,0.885,1.,      &
      0.,0.083,0.167,0.254,0.344,0.438,0.535,0.638,0.748,0.868,1.,      &
      0.,0.075,0.152,0.232,0.314,0.400,0.492,0.592,0.703,0.835,1.,      &
      0.,0.069,0.140,0.212,0.288,0.366,0.451,0.546,0.659,0.805,1.,      &
      0.,0.066,0.132,0.200,0.270,0.344,0.424,0.518,0.638,0.794,1.,      &
      0.,0.063,0.127,0.192,0.259,0.329,0.406,0.499,0.616,0.769,1.,      &
      0.,0.062,0.124,0.187,0.251,0.318,0.391,0.477,0.580,0.721,1./
  DATA ((caib(4,i,j),j=1,11),i=1,9)/                                    &
      0.,0.098,0.196,0.295,0.394,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.290,0.389,0.488,0.589,0.690,0.792,0.896,1.,      &
      0.,0.093,0.187,0.282,0.379,0.478,0.578,0.680,0.784,0.891,1.,      &
      0.,0.087,0.176,0.268,0.362,0.458,0.557,0.661,0.768,0.881,1.,      &
      0.,0.080,0.163,0.248,0.336,0.428,0.524,0.628,0.739,0.862,1.,      &
      0.,0.074,0.149,0.226,0.308,0.393,0.485,0.586,0.700,0.835,1.,      &
      0.,0.068,0.138,0.210,0.285,0.365,0.452,0.550,0.668,0.814,1.,      &
      0.,0.065,0.131,0.199,0.269,0.344,0.426,0.522,0.638,0.786,1.,      &
      0.,0.063,0.126,0.191,0.257,0.327,0.404,0.491,0.596,0.737,1./
  DATA ((caib(5,i,j),j=1,11),i=1,9)/                                    &
      0.,0.098,0.197,0.296,0.396,0.496,0.596,0.696,0.797,0.898,1.,      &
      0.,0.097,0.195,0.293,0.392,0.492,0.592,0.693,0.794,0.897,1.,      &
      0.,0.095,0.190,0.287,0.385,0.484,0.584,0.686,0.789,0.894,1.,      &
      0.,0.090,0.182,0.276,0.372,0.470,0.570,0.672,0.778,0.887,1.,      &
      0.,0.084,0.171,0.259,0.351,0.446,0.545,0.649,0.758,0.875,1.,      &
      0.,0.077,0.157,0.239,0.325,0.415,0.511,0.614,0.728,0.855,1.,      &
      0.,0.071,0.145,0.220,0.300,0.384,0.476,0.578,0.694,0.832,1.,      &
      0.,0.067,0.135,0.206,0.280,0.358,0.444,0.542,0.658,0.802,1.,      &
      0.,0.064,0.129,0.195,0.264,0.337,0.416,0.504,0.610,0.751,1./
  DATA ((caib(6,i,j),j=1,11),i=1,9)/                                    &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.394,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.290,0.389,0.488,0.588,0.690,0.792,0.896,1.,      &
      0.,0.093,0.187,0.282,0.379,0.478,0.578,0.680,0.784,0.891,1.,      &
      0.,0.088,0.177,0.268,0.362,0.460,0.559,0.663,0.770,0.882,1.,      &
      0.,0.081,0.164,0.250,0.340,0.433,0.531,0.636,0.747,0.868,1.,      &
      0.,0.074,0.151,0.231,0.314,0.402,0.497,0.600,0.716,0.846,1.,      &
      0.,0.069,0.140,0.214,0.291,0.372,0.462,0.561,0.675,0.815,1.,      &
      0.,0.065,0.132,0.200,0.271,0.346,0.427,0.517,0.624,0.764,1./
  DATA ((caib(7,i,j),j=1,11),i=1,9)/                                    &
      0.,0.099,0.199,0.298,0.398,0.498,0.598,0.698,0.798,0.899,1.,      &
      0.,0.098,0.197,0.296,0.396,0.496,0.596,0.696,0.797,0.898,1.,      &
      0.,0.097,0.195,0.293,0.392,0.492,0.592,0.693,0.794,0.897,1.,      &
      0.,0.094,0.190,0.287,0.384,0.484,0.584,0.686,0.789,0.894,1.,      &
      0.,0.090,0.182,0.276,0.372,0.470,0.570,0.673,0.779,0.888,1.,      &
      0.,0.084,0.171,0.260,0.353,0.448,0.548,0.652,0.761,0.877,1.,      &
      0.,0.078,0.158,0.241,0.328,0.419,0.516,0.620,0.733,0.858,1.,      &
      0.,0.072,0.145,0.222,0.302,0.386,0.478,0.578,0.692,0.827,1.,      &
      0.,0.067,0.135,0.206,0.278,0.355,0.438,0.530,0.637,0.775,1./
  DATA ((caib(8,i,j),j=1,11),i=1,9)/                                    &
      0.,0.100,0.199,0.299,0.399,0.498,0.599,0.699,0.799,0.900,1.,      &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.395,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.291,0.390,0.489,0.589,0.690,0.793,0.896,1.,      &
      0.,0.093,0.188,0.283,0.380,0.479,0.579,0.682,0.786,0.892,1.,      &
      0.,0.088,0.178,0.270,0.365,0.462,0.562,0.665,0.772,0.884,1.,      &
      0.,0.082,0.165,0.252,0.341,0.434,0.532,0.636,0.747,0.867,1.,      &
      0.,0.074,0.151,0.230,0.313,0.400,0.492,0.593,0.706,0.837,1.,      &
      0.,0.069,0.139,0.211,0.286,0.364,0.448,0.541,0.649,0.786,1./
  DATA ((caib(9,i,j),j=1,11),i=1,9)/                                    &
      0.,0.100,0.200,0.299,0.399,0.499,0.599,0.700,0.800,0.900,1.,      &
      0.,0.100,0.199,0.299,0.399,0.498,0.599,0.699,0.799,0.900,1.,      &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.394,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.192,0.290,0.388,0.487,0.588,0.689,0.791,0.895,1.,      &
      0.,0.092,0.185,0.280,0.376,0.474,0.574,0.676,0.781,0.889,1.,      &
      0.,0.086,0.173,0.262,0.354,0.449,0.547,0.650,0.759,0.875,1.,      &
      0.,0.078,0.157,0.239,0.324,0.412,0.506,0.607,0.719,0.846,1.,      &
      0.,0.071,0.143,0.217,0.293,0.373,0.459,0.552,0.660,0.796,1./
  DATA ((caib(10,i,j),j=1,11),i=1,9)/                                   &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.299,0.399,0.499,0.599,0.699,0.799,0.900,1.,      &
      0.,0.099,0.198,0.297,0.396,0.496,0.595,0.696,0.796,0.898,1.,      &
      0.,0.096,0.192,0.289,0.387,0.485,0.585,0.686,0.788,0.893,1.,      &
      0.,0.090,0.181,0.273,0.366,0.462,0.560,0.662,0.769,0.881,1.,      &
      0.,0.082,0.164,0.248,0.335,0.424,0.519,0.620,0.730,0.854,1.,      &
      0.,0.073,0.147,0.223,0.301,0.382,0.468,0.563,0.671,0.805,1./
  DATA ((caib(11,i,j),j=1,11),i=1,9)/                                   &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.299,0.398,0.496,0.595,0.695,0.795,0.897,1.,      &
      0.,0.096,0.190,0.284,0.378,0.474,0.572,0.674,0.778,0.886,1.,      &
      0.,0.086,0.171,0.257,0.345,0.436,0.531,0.632,0.740,0.861,1.,      &
      0.,0.076,0.152,0.229,0.308,0.390,0.478,0.573,0.681,0.813,1./
!
  DATA ((caif(i,j),j=1,11),i=1,9)/                                      &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.395,0.495,0.595,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.291,0.390,0.489,0.589,0.690,0.793,0.896,1.,      &
      0.,0.093,0.187,0.283,0.380,0.479,0.580,0.681,0.786,0.892,1.,      &
      0.,0.087,0.177,0.268,0.363,0.460,0.561,0.665,0.772,0.884,1.,      &
      0.,0.079,0.160,0.246,0.335,0.430,0.529,0.635,0.747,0.869,1.,      &
      0.,0.068,0.141,0.217,0.298,0.385,0.481,0.586,0.704,0.840,1.,      &
      0.,0.059,0.120,0.185,0.256,0.333,0.419,0.518,0.637,0.789,1.,      &
      0.,0.051,0.104,0.160,0.219,0.284,0.357,0.443,0.551,0.707,1./
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "cah.dat", which define pre-computed tables used for co2.
!
!-----------------------------------------------------------------------
!
  REAL :: cah(22,19)

  COMMON /radtab005/ cah

  DATA ((cah(i,j),i=1,22),j= 1, 5)/                                     &
      0.9923, 0.9922, 0.9921, 0.9920, 0.9916, 0.9910, 0.9899, 0.9882,   &
      0.9856, 0.9818, 0.9761, 0.9678, 0.9558, 0.9395, 0.9188, 0.8945,   &
      0.8675, 0.8376, 0.8029, 0.7621, 0.7154, 0.6647, 0.9876, 0.9876,   &
      0.9875, 0.9873, 0.9870, 0.9864, 0.9854, 0.9837, 0.9811, 0.9773,   &
      0.9718, 0.9636, 0.9518, 0.9358, 0.9153, 0.8913, 0.8647, 0.8350,   &
      0.8005, 0.7599, 0.7133, 0.6627, 0.9808, 0.9807, 0.9806, 0.9805,   &
      0.9802, 0.9796, 0.9786, 0.9769, 0.9744, 0.9707, 0.9653, 0.9573,   &
      0.9459, 0.9302, 0.9102, 0.8866, 0.8604, 0.8311, 0.7969, 0.7565,   &
      0.7101, 0.6596, 0.9708, 0.9708, 0.9707, 0.9705, 0.9702, 0.9697,   &
      0.9687, 0.9671, 0.9647, 0.9612, 0.9560, 0.9483, 0.9372, 0.9221,   &
      0.9027, 0.8798, 0.8542, 0.8253, 0.7916, 0.7515, 0.7054, 0.6551,   &
      0.9568, 0.9568, 0.9567, 0.9565, 0.9562, 0.9557, 0.9548, 0.9533,   &
      0.9510, 0.9477, 0.9428, 0.9355, 0.9250, 0.9106, 0.8921, 0.8700,   &
      0.8452, 0.8171, 0.7839, 0.7443, 0.6986, 0.6486/

  DATA ((cah(i,j),i=1,22),j= 6,10)/                                     &
      0.9377, 0.9377, 0.9376, 0.9375, 0.9372, 0.9367, 0.9359, 0.9345,   &
      0.9324, 0.9294, 0.9248, 0.9181, 0.9083, 0.8948, 0.8774, 0.8565,   &
      0.8328, 0.8055, 0.7731, 0.7342, 0.6890, 0.6395, 0.9126, 0.9126,   &
      0.9125, 0.9124, 0.9121, 0.9117, 0.9110, 0.9098, 0.9079, 0.9052,   &
      0.9012, 0.8951, 0.8862, 0.8739, 0.8579, 0.8385, 0.8161, 0.7900,   &
      0.7585, 0.7205, 0.6760, 0.6270, 0.8809, 0.8809, 0.8808, 0.8807,   &
      0.8805, 0.8802, 0.8796, 0.8786, 0.8770, 0.8747, 0.8712, 0.8659,   &
      0.8582, 0.8473, 0.8329, 0.8153, 0.7945, 0.7697, 0.7394, 0.7024,   &
      0.6588, 0.6105, 0.8427, 0.8427, 0.8427, 0.8426, 0.8424, 0.8422,   &
      0.8417, 0.8409, 0.8397, 0.8378, 0.8350, 0.8306, 0.8241, 0.8148,   &
      0.8023, 0.7866, 0.7676, 0.7444, 0.7154, 0.6796, 0.6370, 0.5897,   &
      0.7990, 0.7990, 0.7990, 0.7989, 0.7988, 0.7987, 0.7983, 0.7978,   &
      0.7969, 0.7955, 0.7933, 0.7899, 0.7846, 0.7769, 0.7664, 0.7528,   &
      0.7357, 0.7141, 0.6866, 0.6520, 0.6108, 0.5646/

  DATA ((cah(i,j),i=1,22),j=11,15)/                                     &
      0.7515, 0.7515, 0.7515, 0.7515, 0.7514, 0.7513, 0.7511, 0.7507,   &
      0.7501, 0.7491, 0.7476, 0.7450, 0.7409, 0.7347, 0.7261, 0.7144,   &
      0.6992, 0.6793, 0.6533, 0.6203, 0.5805, 0.5357, 0.7020, 0.7020,   &
      0.7020, 0.7019, 0.7019, 0.7018, 0.7017, 0.7015, 0.7011, 0.7005,   &
      0.6993, 0.6974, 0.6943, 0.6894, 0.6823, 0.6723, 0.6588, 0.6406,   &
      0.6161, 0.5847, 0.5466, 0.5034, 0.6518, 0.6518, 0.6518, 0.6518,   &
      0.6518, 0.6517, 0.6517, 0.6515, 0.6513, 0.6508, 0.6500, 0.6485,   &
      0.6459, 0.6419, 0.6359, 0.6273, 0.6151, 0.5983, 0.5755, 0.5458,   &
      0.5095, 0.4681, 0.6017, 0.6017, 0.6017, 0.6017, 0.6016, 0.6016,   &
      0.6016, 0.6015, 0.6013, 0.6009, 0.6002, 0.5989, 0.5967, 0.5932,   &
      0.5879, 0.5801, 0.5691, 0.5535, 0.5322, 0.5043, 0.4700, 0.4308,   &
      0.5518, 0.5518, 0.5518, 0.5518, 0.5518, 0.5518, 0.5517, 0.5516,   &
      0.5514, 0.5511, 0.5505, 0.5493, 0.5473, 0.5441, 0.5393, 0.5322,   &
      0.5220, 0.5076, 0.4878, 0.4617, 0.4297, 0.3929/

  DATA ((cah(i,j),i=1,22),j=16,19)/                                     &
      0.5031, 0.5031, 0.5031, 0.5031, 0.5031, 0.5030, 0.5030, 0.5029,   &
      0.5028, 0.5025, 0.5019, 0.5008, 0.4990, 0.4960, 0.4916, 0.4850,   &
      0.4757, 0.4624, 0.4441, 0.4201, 0.3904, 0.3564, 0.4565, 0.4565,   &
      0.4565, 0.4564, 0.4564, 0.4564, 0.4564, 0.4563, 0.4562, 0.4559,   &
      0.4553, 0.4544, 0.4527, 0.4500, 0.4460, 0.4400, 0.4315, 0.4194,   &
      0.4028, 0.3809, 0.3538, 0.3227, 0.4122, 0.4122, 0.4122, 0.4122,   &
      0.4122, 0.4122, 0.4122, 0.4121, 0.4120, 0.4117, 0.4112, 0.4104,   &
      0.4089, 0.4065, 0.4029, 0.3976, 0.3900, 0.3792, 0.3643, 0.3447,   &
      0.3203, 0.2923, 0.3696, 0.3696, 0.3696, 0.3696, 0.3696, 0.3696,   &
      0.3695, 0.3695, 0.3694, 0.3691, 0.3687, 0.3680, 0.3667, 0.3647,   &
      0.3615, 0.3570, 0.3504, 0.3409, 0.3279, 0.3106, 0.2892, 0.2642/
!
!-----------------------------------------------------------------------
!
!  End of RADDATA
!
!-----------------------------------------------------------------------
!

END BLOCK DATA raddata
radlib3d.F      1587424407  1602  20    100644  25359     `
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE COEFF                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE coeff(n,x,f,w,iop,INT,wk)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n
  INTEGER :: iop(2)

  REAL :: x(n),f(n),w(n),wk(n,4)

  INTEGER :: i
  INTEGER :: i1,i2, ii,ii1, in,INT
  INTEGER :: j0,j1,j2,j3,j4
  INTEGER :: jm,mk
  INTEGER :: ml,nn

  REAL :: a12,a13,a14,a23,a24,a34, b2,y2
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ii(i)=(i-1)*INT+1
  j0=1
  DO i=2,n
    jm=j0
    j0=j0+INT
    wk(i,1)=x(i)-x(i-1)
    wk(i,2)=(f(j0)-f(jm))/wk(i,1)
    wk(i,3)=wk(i,1)/6.
    wk(i,1)=wk(i,1)/3.
  END DO
  nn=n
  mk=iop(1)
  ml=iop(2)
!  GO TO (102,103,104,105) ,mk
!  obsolescent feature correction by WYH
  SELECT CASE (mk)
  CASE (1)
    GO TO 102
  CASE (2)
    GO TO 103
  CASE (3)
    GO TO 104
  CASE (4)
    GO TO 105
  CASE DEFAULT
!   Do nothing
  END SELECT
! end of correction by wyh.

  102 CONTINUE
  wk(2,2)=wk(3,2)-wk(2,2)-wk(2,3)*w(1)
  wk(2,3)=0.
  wk(2,1)=wk(2,1)+wk(3,1)
  i1=2
  nn=nn-1
  GO TO 106
  103 CONTINUE
  wk(1,2)=wk(2,2)-w(1)
  wk(2,2)=wk(3,2)-wk(2,2)
  wk(1,3)=0.
  wk(1,1)=wk(2,1)
  wk(2,1)=wk(2,1)+wk(3,1)
  i1=1
  GO TO 106
  104 CONTINUE
  y2=wk(2,2)
  b2=wk(2,1)
  wk(2,2)=wk(3,2)-wk(2,2)
  wk(2,1)=wk(3,1)+wk(2,1)
  i1=2
  nn=nn-1
  GO TO 106
  105 CONTINUE
  a12=x(1)-x(2)
  a13=x(1)-x(3)
  a14=x(1)-x(4)
  a23=x(2)-x(3)
  a24=x(2)-x(4)
  a34=x(3)-x(4)
  j1=1
  j2=j1+INT
  j3=j2+INT
  j4=j3+INT
  w(1)=(1./a12+1./a13+1./a14)*f(j1)-                                    &
       a13*a14/(a12*a23*a24)*f(j2)+a12*a14/(a13*a23*a34)*f(j3)-         &
       a12*a13/(a14*a24*a34)*f(j4)
  GO TO 103
  106 CONTINUE
  i2=n-2
  DO i=3,i2
    wk(i,2)=wk(i+1,2)-wk(i,2)
    wk(i,1)=wk(i+1,1)+wk(i,1)
  END DO
  in=ii(n)
!  GO TO (108,109,110,111) ,ml
!  obsolescent feature correction by WYH
  SELECT CASE (ml)
  CASE (1)
    GO TO 108
  CASE (2)
    GO TO 109
  CASE (3)
    GO TO 110
  CASE (4)
    GO TO 111
  CASE DEFAULT
!   Do nothing
  END SELECT
! end of correction by WYH

  108 CONTINUE
  wk(n-1,2)=wk(n,2)-wk(n-1,2)-wk(n,3)*w(in)
  wk(n,3)=0.
  wk(n-1,1)=wk(n-1,1)+wk(n,1)
  nn=nn-1
  GO TO 112
  109 CONTINUE
  wk(n-1,2)=wk(n,2)-wk(n-1,2)
  wk(n,2)=-wk(n,2)+w(in)
  wk(n-1,1)=wk(n-1,1)+wk(n,1)
  wk(1,4)=0.
  GO TO 112
  110 CONTINUE
  wk(n-1,2)=wk(n,2)-wk(n-1,2)
  wk(n,2)=y2-wk(n,2)
  wk(n-1,1)=wk(n-1,1)+wk(n,1)
  wk(n,1)=wk(n,1)+b2
  wk(1,4)=wk(2,3)
  GO TO 112
  111 CONTINUE
  a12=x(n)-x(n-1)
  a13=x(n)-x(n-2)
  a14=x(n)-x(n-3)
  a23=x(n-1)-x(n-2)
  a24=x(n-1)-x(n-3)
  a34=x(n-2)-x(n-3)
  j1=in
  j2=j1-INT
  j3=j2-INT
  j4=j3-INT
  w(in)=(1./a12+1./a13+1./a14)*f(j1)-                                   &
        a13*a14/(a12*a23*a24)*f(j2)+a12*a14/(a13*a23*a34)*f(j3)-        &
        a12*a13/(a14*a24*a34)*f(j4)
  GO TO 109
  112 CONTINUE
  ii1=ii(i1)
  CALL trip (nn,wk(i1,3),wk(i1,1),wk(i1+1,3),wk(i1,2),w(ii1),INT)
!  GO TO (114,114,113,114) ,mk
!  obsolescent feature correction by WYH
  SELECT CASE (mk)
  CASE (1,2,4)
    GO TO 114
  CASE (3)
    GO TO 113
  CASE DEFAULT
!   Do nothing
  END SELECT
! end of correction by wyh

  113 CONTINUE
  w(1)=w(in)
  114 CONTINUE

  RETURN
END SUBROUTINE coeff
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE TERP1                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE terp1(n,x,f,w,y,INT,tab,itab)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!fpp$ expand (search)
!fpp$ expand (interp)
!!dir$ inline always interp, search
!*$*  inline routine (interp, search)
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n
  INTEGER :: INT
  INTEGER :: itab(3)

  REAL :: x(n),f(n),w(n),tab(3)

  INTEGER :: i
  REAL :: y
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  CALL search (y,x,n,i)
  CALL interp (n,x,f,w,y,i,INT,tab,itab)

  RETURN
END SUBROUTINE terp1
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE TRIP                       ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE trip(n,a,b,c,y,z,INT)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n

  REAL :: a(n),b(n),c(n),y(n),z(n)

  INTEGER :: INT

  INTEGER :: ii, ik, in, inm
  INTEGER :: i,j,k
  INTEGER :: nm1, nm2

  REAL :: bn, yn, v, den
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ii(i)=(i-1)*INT+1
  bn=b(n)
  yn=y(n)
  v=c(n)
  y(1)=y(1)/b(1)
  a(1)=a(1)/b(1)
  b(1)=c(1)/b(1)
  nm2=n-2
  DO j=2,nm2
    den=b(j)-a(j)*b(j-1)
    b(j)=c(j)/den
    y(j)=(y(j)-a(j)*y(j-1))/den
    a(j)=-a(j)*a(j-1)/den
    bn=bn-v*a(j-1)
    yn=yn-v*y(j-1)
    v=-v*b(j-1)
  END DO
  den=b(n-1)-a(n-1)*b(n-2)
  b(n-1)=(c(n-1)-a(n-1)*a(n-2))/den
  y(n-1)=(y(n-1)-a(n-1)*y(n-2))/den
  bn=bn-v*a(n-2)
  yn=yn-v*y(n-2)
  v=a(n)-v*b(n-2)
  nm1=n-1
  in=ii(n)
  inm=ii(nm1)
  z(in)=(yn-v*y(nm1))/(bn-v*b(nm1))
  z(inm)=y(nm1)-b(nm1)*z(in)
  DO j=2,nm1
    k=n-j
    ik=ii(k)
    z(ik)=y(k)-b(k)*z(ik+INT)-a(k)*z(in)
  END DO

  RETURN
END SUBROUTINE trip
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SEARCH                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE search(xbar,x,n,i)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: i,n

  REAL :: x(n)
  REAL :: xbar

  INTEGER :: k,m,nm1

  REAL :: b
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  b = .69314718

  IF(xbar > x(2)) GO TO 101
  i=1
  RETURN

  101 CONTINUE
  IF(xbar < x(n-1)) GO TO 102
  i=n-1
  RETURN

  102 CONTINUE
  m=INT((ALOG(FLOAT(n)))/b)
  i=2**m
  IF(i >= n) i=i/2
  k=i
  nm1=n-1
  103 CONTINUE
  k=k/2
  IF(xbar >= x(i)) GO TO 104
  i=i-k
  GO TO 103
  104 CONTINUE
  IF(xbar <= x(i+1)) RETURN
  i=MIN0(i+k,nm1)
  GO TO 103

END SUBROUTINE search
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE INTERP                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE interp(n,x,f,w,y,i,INT,tab,itab)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n
  INTEGER :: i, i0, ii, INT, ip

  INTEGER :: itab(3)
  REAL :: x(n),f(n),w(n),tab(3)
  REAL :: a,b,c, fl0,flk,flp, y
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ii(i)=(i-1)*INT+1
  flk=x(i+1)-x(i)
  flp=x(i+1)-y
  fl0=y-x(i)
  i0=ii(i)
  ip=i0+INT
  IF(itab(1) /= 1) GO TO 102
  a=(w(i0)*flp**3+w(ip)*fl0**3)/(6.*flk)
  b=(f(ip)/flk-w(ip)*flk/6.)*fl0
  c=(f(i0)/flk-w(i0)*flk/6.)*flp
  tab(1)=a+b+c
  102 IF(itab(2) /= 1) GO TO 104
  a=(w(ip)*fl0**2-w(i0)*flp**2)/(2.*flk)
  b=(f(ip)-f(i0))/flk
  c=(w(i0)-w(ip))*flk/6.
  tab(2)=a+b+c
  104 IF(itab(3) /= 1) GO TO 106
  tab(3)=(w(i0)*flp+w(ip)*fl0)/flk

  106 RETURN
END SUBROUTINE interp
!
!##################################################################
!##################################################################
!######                                                      ######
!######                FUNCTION EXPMN                        ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

  FUNCTION expmn(fin)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate exponential for arguments in the range 0> fin > -10.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**************************************************************************
! compute exponential for arguments in the range 0> fin > -10.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  REAL :: one, expmin
  PARAMETER (one=1.0, expmin=-10.0)

  REAL :: e1,e2,e3,e4
  PARAMETER (e1=1.0,        e2=-2.507213E-1)
  PARAMETER (e3=2.92732E-2, e4=-3.827800E-3)

  REAL :: fin, tmp
  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  tmp = MAX( fin, expmin )
  expmn = ((e4*tmp + e3)*tmp+e2)*tmp+e1
  expmn = expmn * expmn
  expmn = one / (expmn * expmn)

  RETURN
  END FUNCTION expmn
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE DELEDD                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE deledd(tau,ssc,g0,csm,rr,tt,td)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the bulk scattering properties of a single layer using
!  delta-eddington approximation.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*********************************************************************
!
!-----uses the delta-eddington approximation to compute the
!  bulk scattering properties of a single layer
!  coded following King and Harshvardhan (JAS, 1986)
!
!  inputs:
!
!  tau: the effective optical thickness
!  ssc: the effective single scattering albedo
!  g0:  the effective asymmetry factor
!  csm: the effective secant of the zenith angle
!
!  outputs:
!
!  rr: the layer reflection of the direct beam
!  tt: the layer diffuse transmission of the direct beam
!  td: the layer direct transmission of the direct beam
!
!*********************************************************************
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!*********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  REAL :: zero,one,two,three,four,fourth,seven,thresh
  PARAMETER (one =1., three=3.)
  PARAMETER (two =2., seven=7.)
  PARAMETER (four=4., fourth=.25)
  PARAMETER (zero=0., thresh=1.e-8)

!-----input parameters
  REAL :: tau,ssc,g0,csm

!-----output parameters
  REAL :: rr,tt,td

!-----temporary parameters

  REAL :: zth,ff,xx,taup,sscp,gp,gm1,gm2,gm3,akk,alf1,alf2,             &
       all,bll,st7,st8,cll,dll,fll,ell,st1,st2,st3,st4

  REAL, EXTERNAL :: expmn

!---------------------------------------------------------------------
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  zth = one / csm

!  delta-eddington scaling of single scattering albedo,
!  optical thickness, and asymmetry factor,
!  K & H eqs(27-29)

  ff  = g0*g0
  xx  = one-ff*ssc
  taup= tau*xx
  sscp= ssc*(one-ff)/xx
  gp  = g0/(one+g0)

!  gamma1, gamma2, and gamma3. see table 2 and eq(26) K & H
!  ssc and gp are the d-s single scattering
!  albedo and asymmetry factor.

  xx  =  three*gp
  gm1 =  (seven - sscp*(four+xx))*fourth
  gm2 = -(one   - sscp*(four-xx))*fourth

!  akk is k as defined in eq(25) of K & H

  akk = SQRT((gm1+gm2)*(gm1-gm2))

  xx  = akk * zth
  st7 = one - xx
  st8 = one + xx
  st3 = st7 * st8

  IF (ABS(st3) < thresh) THEN
    zth = zth + 0.001
    xx  = akk * zth
    st7 = one - xx
    st8 = one + xx
    st3 = st7 * st8
  END IF

!  extinction of the direct beam transmission

!wdt
  !td  = EXP(-taup/zth)
  td  = expmn(-taup/zth)  ! faster, but less accurate for long integrations

!  alf1 and alf2 are alpha1 and alpha2 from eqs (23) & (24) of K & H

  gm3  = (two - zth*three*gp)*fourth
  xx   = gm1 - gm2
  alf1 = gm1 - gm3 * xx
  alf2 = gm2 + gm3 * xx

!  all is last term in eq(21) of K & H
!  bll is last term in eq(22) of K & H

  xx  = akk * two
  all = (gm3 - alf2 * zth    )*xx*td
  bll = (one - gm3 + alf1*zth)*xx

  xx  = akk * gm3
  cll = (alf2 + xx) * st7
  dll = (alf2 - xx) * st8

  xx  = akk * (one-gm3)
  fll = (alf1 + xx) * st8
  ell = (alf1 - xx) * st7

!wdt
  !st2 = EXP(-akk*taup)
  st2 = expmn(-akk*taup)  ! faster, but less accurate for long integrations
  st4 = st2 * st2

  st1 =  sscp / ((akk+gm1 + (akk-gm1)*st4) * st3)

!  rr is r-hat of eq(21) of K & H
!  tt is diffuse part of t-hat of eq(22) of K & H

  rr =   ( cll-dll*st4    -all*st2)*st1
  tt = - ((fll-ell*st4)*td-bll*st2)*st1

  rr = MAX(rr,zero)
  tt = MAX(tt,zero)

  RETURN
END SUBROUTINE deledd
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SAGPOL                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE sagpol(tau,ssc,g0,rll,tll)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate transmittance and reflectance of diffuse radiation.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*********************************************************************
!-----transmittance (tll) and reflectance (rll) of diffuse radiation
!  follows Sagan and Pollock (JGR, 1967).
!  also, eq.(31) of Lacis and Hansen (JAS, 1974).
!
!-----input parameters:
!
!   tau: the effective optical thickness
!   ssc: the effective single scattering albedo
!   g0:  the effective asymmetry factor
!
!-----output parameters:
!
!   rll: the layer reflection of diffuse radiation
!   tll: the layer transmission of diffuse radiation
!
!*********************************************************************
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  REAL :: one,three,four
  PARAMETER (one=1., three=3., four=4.)

!-----output parameters:

  REAL :: tau,ssc,g0

!-----output parameters:

  REAL :: rll,tll

!-----temporary arrays

  REAL :: xx,uuu,ttt,emt,up1,um1,st1

!-----function

  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  xx  = one-ssc*g0
  uuu = SQRT( xx/(one-ssc))
  ttt = SQRT( xx*(one-ssc)*three )*tau
  emt = expmn(-ttt)
  up1 = uuu + one
  um1 = uuu - one
  xx  = um1*emt
  st1 = one / ((up1+xx) * (up1-xx))
  rll = up1*um1*(one-emt*emt)*st1
  tll = uuu*four*emt         *st1

  RETURN
END SUBROUTINE sagpol

irrad3d.F       1587424407  1602  20    100644  58682     `
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE IRRAD                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE irrad(idim,jdim,m,n,np,                                      &
           taucl,ccld,pl,ta,wa,oa,co2,ts,                               &
           high,radlwin,flx,flc,dfdts,st4,                              &
           fclr,dbs,trant,th2o,tcon,tco2,                               &
           pa,dt,sh2o,swpre,swtem,sco3,scopre,scotem,                   &
           dh2o,dcont,dco2,do3,flxu,flxd,clr,blayer,                    &
           h2oexp,conexp,co2exp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate IR fluxes due to water vapor, co2, and o3. Clouds in
!  different layers are assumed randomly overlapped.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!******************** CLIRAD IR1  Date: Oct. 17, 1994 ****************
!*********************************************************************
!
! This routine computes ir fluxes due to water vapor, co2, and o3.
!   Clouds in different layers are assumed randomly overlapped.
!
! This is a vectorized code.  It computes fluxes simultaneously for
!   (m x n) soundings, which is a subset of (m x ndim) soundings.
!   In a global climate model, m and ndim correspond to the numbers of
!   grid boxes in the zonal and meridional directions, respectively.
!
! Detailed description of the radiation routine is given in
!   Chou and Suarez (1994).
!
! There are two options for computing cooling rate profiles.
!
!   if high = .true., transmission functions in the co2, o3, and the
!   three water vapor bands with strong absorption are computed using
!   table look-up.  cooling rates are computed accurately from the
!   surface up to 0.01 mb.
!   if high = .false., transmission functions are computed using the
!   k-distribution method with linear pressure scaling.  cooling rates
!   are not calculated accurately for pressures less than 20 mb.
!   the computation is faster with high=.false. than with high=.true.
!
! The IR spectrum is divided into eight bands:
!
!   bnad     wavenumber (/cm)   absorber         method
!
!    1           0 - 340           h2o            K/T
!    2         340 - 540           h2o            K/T
!    3         540 - 800       h2o,cont,co2       K,S,K/T
!    4         800 - 980       h2o,cont           K,S
!    5         980 - 1100      h2o,cont,o3        K,S,T
!    6        1100 - 1380      h2o,cont           K,S
!    7        1380 - 1900          h2o            K/T
!    8        1900 - 3000          h2o            K
!
! Note : "h2o" for h2o line absorption
!     "cont" for h2o continuum absorption
!     "K" for k-distribution method
!     "S" for one-parameter temperature scaling
!     "T" for table look-up
!
! The 15 micrometer region (540-800/cm) is further divided into
!   3 sub-bands :
!
!   subbnad   wavenumber (/cm)
!
!    1          540 - 620
!    2          620 - 720
!    3          720 - 800
!
!---- Input parameters                               units    size
!
!   number of soundings in zonal direction (m)        n/d      1
!   number of soundings in meridional direction (n)   n/d      1
!   maximum number of soundings in
!              meridional direction (ndim)         n/d      1
!   number of atmospheric layers (np)                 n/d      1
!   cloud optical thickness (taucl)                   n/d     m*ndim*np
!   cloud cover (ccld)                              fraction  m*ndim*np
!   level pressure (pl)                               mb      m*ndim*(np+1)
!   layer temperature (ta)                            k       m*ndim*np
!   layer specific humidity (wa)                      g/g     m*ndim*np
!   layer ozone mixing ratio by mass (oa)             g/g     m*ndim*np
!   surface temperature (ts)                          k       m*ndim
!   co2 mixing ratio by volumn (co2)                  pppv     1
!   high                                                       1
!
! pre-computed tables used in table look-up for transmittance calculations:
!
!   c1 , c2, c3: for co2 (band 3)
!   o1 , o2, o3: for  o3 (band 5)
!   h11,h12,h13: for h2o (band 1)
!   h21,h22,h23: for h2o (band 2)
!   h71,h72,h73: for h2o (band 7)
!
!---- output parameters
!
!   net downward flux, all-sky   (flx)             w/m**2     m*ndim*(np+1)
!   net downward flux, clear-sky (flc)             w/m**2     m*ndim*(np+1)
!   sensitivity of net downward flux
!    to surface temperature (dfdts)             w/m**2/k   m*ndim*(np+1)
!   emission by the surface (st4)                  w/m**2     m*ndim
!
! Notes:
!
!   (1)  Water vapor continuum absorption is included in 540-1380 /cm.
!   (2)  Scattering by clouds is not included.
!   (3)  Clouds are assumed "gray" bodies.
!   (4)  The diffuse cloud transmission is computed to be exp(-1.66*taucl).
!   (5)  If there are no clouds, flx=flc.
!   (6)  plevel(1) is the pressure at the top of the model atmosphere, and
!     plevel(np+1) is the surface pressure.
!
!    ARPS note: pl was replaced by pa at scalar points (layers)
!
!   (7)  Downward flux is positive, and upward flux is negative.
!   (8)  dfdts is always negative because upward flux is defined as negative.
!   (9)  For questions and coding errors, please contact with Ming-Dah Chou,
!     Code 913, NASA/Goddard Space Flight Center, Greenbelt, MD 20771.
!     Phone: 301-286-4012, Fax: 301-286-1759,
!     e-mail: chou@climate.gsfc.nasa.gov
!
!-----parameters defining the size of the pre-computed tables for transmittance
!  calculations using table look-up.
!
!  "nx" is the number of intervals in pressure
!  "no" is the number of intervals in o3 amount
!  "nc" is the number of intervals in co2 amount
!  "nh" is the number of intervals in h2o amount
!  "nt" is the number of copies to be made from the pre-computed
!       transmittance tables to reduce "memory-bank conflict"
!       in parallel machines and, hence, enhancing the speed of
!       computations using table look-up.
!       If such advantage does not exist, "nt" can be set to 1.
!***************************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!

!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: idim,jdim

!!!  INTEGER :: nx,no,nc,nh,nt,m,n,np
  INTEGER :: m,n,np
  INTEGER :: i,j,k,ip,iw,it,ib,ik,iq,isb,k1,k2
!!!  PARAMETER (nx=26,no=21,nc=24,nh=31,nt=7)

!---- input parameters ------

  REAL :: taucl(idim,jdim,np)
  REAL :: ccld(idim,jdim,np)
  REAL :: pl(idim,jdim,np+1)
  REAL :: ta(idim,jdim,np)
  REAL :: wa(idim,jdim,np)
  REAL :: oa(idim,jdim,np)
  REAL :: ts(idim,jdim)
  REAL :: co2

  LOGICAL :: high

!---- output parameters ------

  REAL :: radlwin(idim,jdim) 
  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: dfdts(idim,jdim,np+1)
  REAL :: st4(idim,jdim)
!
!-----------------------------------------------------------------------
!
!  Temporary arrays
!
!-----------------------------------------------------------------------
!
  REAL :: fclr(m,n)
  REAL :: dbs(m,n)
  REAL :: trant(m,n)
  REAL :: th2o(m,n,6)
  REAL :: tcon(m,n,3)
  REAL :: tco2(m,n,6,2)

  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)
  REAL :: sh2o(m,n,np+1)
  REAL :: swpre(m,n,np+1)
  REAL :: swtem(m,n,np+1)
  REAL :: sco3(m,n,np+1)
  REAL :: scopre(m,n,np+1)
  REAL :: scotem(m,n,np+1)
  REAL :: dh2o(m,n,np)
  REAL :: dcont(m,n,np)
  REAL :: dco2(m,n,np)
  REAL :: do3(m,n,np)
  REAL :: flxu(m,n,np+1)
  REAL :: flxd(m,n,np+1)
  REAL :: clr(m,n,0:np+1)
  REAL :: blayer(m,n,0:np+1)

  REAL :: h2oexp(m,n,np,6)
  REAL :: conexp(m,n,np,3)

  REAL :: co2exp(m,n,np,6,2)
!
!-----------------------------------------------------------------------
!
!  Misc. local variables
!
!-----------------------------------------------------------------------
!
  LOGICAL :: oznbnd
  LOGICAL :: co2bnd
  LOGICAL :: h2otbl
  LOGICAL :: conbnd

!!!  REAL :: c1 (nx,nc,nt),c2 (nx,nc,nt),c3 (nx,nc,nt)
!!!  REAL :: o1 (nx,no,nt),o2 (nx,no,nt),o3 (nx,no,nt)
!!!  REAL :: h11(nx,nh,nt),h12(nx,nh,nt),h13(nx,nh,nt)
!!!  REAL :: h21(nx,nh,nt),h22(nx,nh,nt),h23(nx,nh,nt)
!!!  REAL :: h71(nx,nh,nt),h72(nx,nh,nt),h73(nx,nh,nt)
  include 'irrad.incl'

  REAL :: xx, w1,p1,dwe,dpe

!---- static data -----

  REAL :: cb(5,8)

!-----the following coefficients (table 2 of chou and suarez, 1995)
!  are for computing spectrally integtrated planck fluxes of
!  the 8 bands using eq. (22)

  DATA cb/                                                              &
      -2.6844E-1,-8.8994E-2, 1.5676E-3,-2.9349E-6, 2.2233E-9,           &
      3.7315E+1,-7.4758E-1, 4.6151E-3,-6.3260E-6, 3.5647E-9,            &
      3.7187E+1,-3.9085E-1,-6.1072E-4, 1.4534E-5,-1.6863E-8,            &
      -4.1928E+1, 1.0027E+0,-8.5789E-3, 2.9199E-5,-2.5654E-8,           &
      -4.9163E+1, 9.8457E-1,-7.0968E-3, 2.0478E-5,-1.5514E-8,           &
      -1.0345E+2, 1.8636E+0,-1.1753E-2, 2.7864E-5,-1.1998E-8,           &
      -6.9233E+0,-1.5878E-1, 3.9160E-3,-2.4496E-5, 4.9301E-8,           &
      1.1483E+2,-2.2376E+0, 1.6394E-2,-5.3672E-5, 6.6456E-8/

!-----copy tables to enhance the speed of co2 (band 3), o3 (band5),
!  and h2o (bands 1, 2, and 7 only) transmission calculations
!  using table look-up.

!!!  LOGICAL :: first
!!!  SAVE first
!!!  DATA first /.true./
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!
  REAL :: expmn
!
!-----------------------------------------------------------------------
!
!  Include files:
!
!-----------------------------------------------------------------------
!
!  include "h2o.tran3"
!  include "co2.tran3"
!  include "o3.tran3"

!!!  COMMON /radtab001/ h11,h12,h13,h21,h22,h23,h71,h72,h73
!!!  COMMON /radtab002/ c1,c2,c3
!!!  COMMON /radtab003/ o1,o2,o3
!
!-----------------------------------------------------------------------
!
!  Save variables:
!
!-----------------------------------------------------------------------
!
!  save c1,c2,c3,o1,o2,o3
!  save h11,h12,h13,h21,h22,h23,h71,h72,h73
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!----- moved this section of code to new initrad subroutine -----!

!-----compute layer pressure (pa) and layer temperature minus 250K (dt)

  DO k=1,np
    DO j=1,n
      DO i=1,m
        dt(i,j,k)=ta(i,j,k)-250.0
!!!     GHB, 101129:  pa is now given directly through radtrans3d
!!!        pa(i,j,k)=0.5*(pl(i,j,k)+pl(i,j,k+1))
!!!        print *,'  old,new,error:',k,0.5*(pl(i,j,k)+pl(i,j,k+1)),pa(i,j,k),   &
!!!                                     0.5*(pl(i,j,k)+pl(i,j,k+1))-pa(i,j,k)
      END DO
    END DO
  END DO

!-----compute layer absorber amount

!  dh2o : water vapor amount (g/cm**2)
!  dcont: scaled water vapor amount for continuum absorption (g/cm**2)
!  dco2 : co2 amount (cm-atm)stp
!  do3  : o3 amount (cm-atm)stp
!  the factor 1.02 is equal to 1000/980
!  factors 789 and 476 are for unit conversion
!  the factor 0.001618 is equal to 1.02/(.622*1013.25)
!  the factor 6.081 is equal to 1800/296

  DO k=1,np
    DO j=1,n
      DO i=1,m
        dh2o(i,j,k) = 1.02*wa(i,j,k)*(pl(i,j,k+1)-pl(i,j,k))+1.e-10
        dco2(i,j,k) = 789.*co2*(pl(i,j,k+1)-pl(i,j,k))+1.e-10
        do3 (i,j,k) = 476.0*oa(i,j,k)*(pl(i,j,k+1)-pl(i,j,k))+1.e-10

!-----compute scaled water vapor amount for h2o continuum absorption
!  following eq. (43).

        xx=pa(i,j,k)*0.001618*wa(i,j,k)*wa(i,j,k)                       &
            *(pl(i,j,k+1)-pl(i,j,k))
        dcont(i,j,k) = xx*expmn(1800./ta(i,j,k)-6.081)+1.e-10

!-----compute effective cloud-free fraction, clr, for each layer.
!  the cloud diffuse transmittance is approximated by using a
!  diffusivity factor of 1.66.

        clr(i,j,k)=1.0-(ccld(i,j,k)*(1.-expmn(-1.66*taucl(i,j,k))))

      END DO
    END DO
  END DO

!-----compute column-integrated h2o amoumt, h2o-weighted pressure
!  and temperature.  it follows eqs. (37) and (38).

  IF (high) THEN

    CALL column(m,n,np,pa,dt,dh2o,sh2o,swpre,swtem)

  END IF

!-----the surface (with an index np+1) is treated as a layer filled with
!  black clouds.

  DO j=1,n
    DO i=1,m
      clr(i,j,0)    = 1.0
      clr(i,j,np+1) = 0.0
      st4(i,j)      = 0.0
    END DO
  END DO

!-----initialize fluxes

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        flx(i,j,k)  = 0.0
        flc(i,j,k)  = 0.0
        dfdts(i,j,k)= 0.0
        flxu(i,j,k) = 0.0
        flxd(i,j,k) = 0.0
      END DO
    END DO
  END DO

!-----integration over spectral bands

  DO ib=1,8

!-----if h2otbl, compute h2o (line) transmittance using table look-up.
!  if conbnd, compute h2o (continuum) transmittance in bands 3, 4, 5 and 6.
!  if co2bnd, compute co2 transmittance in band 3.
!  if oznbnd, compute  o3 transmittance in band 5.

    h2otbl=high.AND.(ib == 1.OR.ib == 2.OR.ib == 7)
    conbnd=ib >= 3.AND.ib <= 6
    co2bnd=ib == 3
    oznbnd=ib == 5

!-----blayer is the spectrally integrated planck flux of the mean layer
!  temperature derived from eq. (22)
!  the fitting for the planck flux is valid in the range 160-345 K.

    DO k=1,np
      DO j=1,n
        DO i=1,m
          blayer(i,j,k)=ta(i,j,k)*(ta(i,j,k)*(ta(i,j,k)                 &
                       *(ta(i,j,k)*cb(5,ib)+cb(4,ib))+cb(3,ib))         &
                       +cb(2,ib))+cb(1,ib)
        END DO
      END DO
    END DO

!-----the earth's surface, with an index "np+1", is treated as a layer

    DO j=1,n
      DO i=1,m
        blayer(i,j,0)   = 0.0
        blayer(i,j,np+1)=ts(i,j)*(ts(i,j)*(ts(i,j)                      &
                        *(ts(i,j)*cb(5,ib)+cb(4,ib))+cb(3,ib))          &
                        +cb(2,ib))+cb(1,ib)

!-----dbs is the derivative of the surface planck flux with respect to
!  surface temperature (eq. 59).

        dbs(i,j)=ts(i,j)*(ts(i,j)*(ts(i,j)                              &
                *4.*cb(5,ib)+3.*cb(4,ib))+2.*cb(3,ib))+cb(2,ib)

      END DO
    END DO

!-----compute column-integrated absorber amoumt, absorber-weighted
!  pressure and temperature for co2 (band 3) and o3 (band 5).
!  it follows eqs. (37) and (38).

!-----this is in the band loop to save storage

    IF( high .AND. co2bnd) THEN

      CALL column(m,n,np,pa,dt,dco2,sco3,scopre,scotem)

    END IF

    IF(oznbnd) THEN

      CALL column(m,n,np,pa,dt,do3,sco3,scopre,scotem)

    END IF

!-----compute the exponential terms (eq. 32) at each layer for
!  water vapor line absorption when k-distribution is used

    IF( .NOT. h2otbl) THEN

      CALL h2oexps(ib,m,n,np,dh2o,pa,dt,h2oexp)

    END IF

!-----compute the exponential terms (eq. 46) at each layer for
!  water vapor continuum absorption

    IF( conbnd) THEN

      CALL conexps(ib,m,n,np,dcont,conexp)

    END IF


!-----compute the  exponential terms (eq. 32) at each layer for
!  co2 absorption

    IF( .NOT.high .AND. co2bnd) THEN

      CALL co2exps(m,n,np,dco2,pa,dt,co2exp)

    END IF

!-----compute transmittances for regions between levels k1 and k2
!  and update the fluxes at the two levels.

    DO k1=1,np

!-----initialize fclr, th2o, tcon, and tco2

      DO j=1,n
        DO i=1,m
          fclr(i,j)=1.0
        END DO
      END DO

!-----for h2o line absorption

      IF(.NOT. h2otbl) THEN
        DO ik=1,6
          DO j=1,n
            DO i=1,m
              th2o(i,j,ik)=1.0
            END DO
          END DO
        END DO
      END IF

!-----for h2o continuum absorption

      IF (conbnd) THEN
        DO iq=1,3
          DO j=1,n
            DO i=1,m
              tcon(i,j,iq)=1.0
            END DO
          END DO
        END DO
      END IF

!-----for co2 absorption when using k-distribution method.
!  band 3 is divided into 3 sub-bands, but sub-bands 3a and 3c
!  are combined in computing the co2 transmittance.

      IF (.NOT. high .AND. co2bnd) THEN
        DO isb=1,2
          DO ik=1,6
            DO j=1,n
              DO i=1,m
                tco2(i,j,ik,isb)=1.0
              END DO
            END DO
          END DO
        END DO
      END IF

!-----loop over the bottom level of the region (k2)

      DO k2=k1+1,np+1

        DO j=1,n
          DO i=1,m
            trant(i,j)=1.0
          END DO
        END DO

        IF(h2otbl) THEN

          w1=-8.0
          p1=-2.0
          dwe=0.3
          dpe=0.2

!-----compute water vapor transmittance using table look-up

          IF (ib == 1 ) THEN

            CALL tablup(k1,k2,m,n,np,nx,nh,nt,sh2o,swpre,swtem,         &
                        w1,p1,dwe,dpe,h11,h12,h13,trant)

          END IF
          IF (ib == 2 ) THEN

            CALL tablup(k1,k2,m,n,np,nx,nh,nt,sh2o,swpre,swtem,         &
                        w1,p1,dwe,dpe,h21,h22,h23,trant)

          END IF
          IF (ib == 7 ) THEN

            CALL tablup(k1,k2,m,n,np,nx,nh,nt,sh2o,swpre,swtem,         &
                        w1,p1,dwe,dpe,h71,h72,h73,trant)

          END IF

        ELSE

!-----compute water vapor transmittance using k-distribution.

          CALL wvkdis(ib,m,n,np,k2-1,h2oexp,conexp,th2o,tcon,trant)

        END IF

        IF(co2bnd) THEN

          IF( high ) THEN

!-----compute co2 transmittance using table look-up method

            w1=-4.0
            p1=-2.0
            dwe=0.3
            dpe=0.2

            CALL tablup(k1,k2,m,n,np,nx,nc,nt,sco3,scopre,scotem,       &
                        w1,p1,dwe,dpe,c1,c2,c3,trant)

          ELSE

!-----compute co2 transmittance using k-distribution method

            CALL co2kdis(m,n,np,k2-1,co2exp,tco2,trant)

          END IF

        END IF

!-----compute o3 transmittance using table look-up

        IF (oznbnd) THEN

          w1=-6.0
          p1=-2.0
          dwe=0.3
          dpe=0.2

          CALL tablup(k1,k2,m,n,np,nx,no,nt,sco3,scopre,scotem,         &
                      w1,p1,dwe,dpe,o1,o2,o3,trant)

        END IF

!-----fclr is the clear line-of-sight between levels k1 and k2.
!  in computing fclr, clouds are assumed randomly overlapped
!  using eq. (10).

        DO j=1,n
          DO i=1,m
            fclr(i,j) = fclr(i,j)*clr(i,j,k2-1)
          END DO
        END DO

!-----compute upward and downward fluxes


!-----add "boundary" terms to the net downward flux.
!  these are the first terms on the right-hand-side of
!  eqs. (56a) and (56b).
!  downward fluxes are positive.

        IF (k2 == k1+1) THEN
          DO j=1,n
            DO i=1,m
              flc(i,j,k1)=flc(i,j,k1)-blayer(i,j,k1)
              flc(i,j,k2)=flc(i,j,k2)+blayer(i,j,k1)
            END DO
          END DO
        END IF

!-----add flux components involving the four layers above and below
!  the levels k1 and k2.  it follows eqs. (56a) and (56b).

        DO j=1,n
          DO i=1,m
            xx=trant(i,j)*(blayer(i,j,k2-1)-blayer(i,j,k2))
            flc(i,j,k1) =flc(i,j,k1)+xx
            xx=trant(i,j)*(blayer(i,j,k1-1)-blayer(i,j,k1))
            flc(i,j,k2) =flc(i,j,k2)+xx
          END DO
        END DO

!-----compute upward and downward fluxes for all-sky situation

        IF (k2 == k1+1) THEN
          DO j=1,n
            DO i=1,m
              flxu(i,j,k1)=flxu(i,j,k1)-blayer(i,j,k1)
              flxd(i,j,k2)=flxd(i,j,k2)+blayer(i,j,k1)
            END DO
          END DO
        END IF

        DO j=1,n
          DO i=1,m
            xx=trant(i,j)*(blayer(i,j,k2-1)-blayer(i,j,k2))
            flxu(i,j,k1) =flxu(i,j,k1)+xx*fclr(i,j)
            xx=trant(i,j)*(blayer(i,j,k1-1)-blayer(i,j,k1))
            flxd(i,j,k2) =flxd(i,j,k2)+xx*fclr(i,j)
          END DO
        END DO


      END DO

!-----compute the partial derivative of fluxes with respect to
!  surface temperature (eq. 59).

      DO j=1,n
        DO i=1,m
          dfdts(i,j,k1) =dfdts(i,j,k1)-dbs(i,j)*trant(i,j)*fclr(i,j)
        END DO
      END DO

    END DO

!-----add contribution from the surface to the flux terms at the surface.

    DO j=1,n
      DO i=1,m
        dfdts(i,j,np+1) =dfdts(i,j,np+1)-dbs(i,j)
      END DO
    END DO

    DO j=1,n
      DO i=1,m
        flc(i,j,np+1)=flc(i,j,np+1)-blayer(i,j,np+1)
        flxu(i,j,np+1)=flxu(i,j,np+1)-blayer(i,j,np+1)
        st4(i,j)=st4(i,j)-blayer(i,j,np+1)
      END DO
    END DO


!  write(7,3211) ib, flxd(1,1,52),flxu(1,1,52)
!  write(7,3211) ib, flxd(1,1,np+1),flxu(1,1,np+1)
!    3211 FORMAT ('ib, fluxd, fluxu=', i3,2F12.3)

  END DO

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        flx(i,j,k)=flxd(i,j,k)+flxu(i,j,k)
        radlwin(i,j) = flxd(i,j,np+1) 
      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE irrad
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE H2OEXPS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE h2oexps(ib,m,n,np,dh2o,pa,dt,h2oexp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate exponentials for water vapor line absorption in
!  individual layers.
!
!-----------------------------------------------------------------------
!
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Formatted code to ARPS standard format
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!   compute exponentials for water vapor line absorption
!   in individual layers.
!
!---- input parameters
!  spectral band (ib)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of layers (np)
!  layer water vapor amount for line absorption (dh2o)
!  layer pressure (pa)
!  layer temperature minus 250K (dt)
!
!---- output parameters
!  6 exponentials for each layer  (h2oexp)
!
!**********************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: ib,m,n,np

!---- input parameters ------

  REAL :: dh2o(m,n,np)
  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)

!---- output parameters -----

  REAL :: h2oexp(m,n,np,6)

!---- static data -----

  INTEGER :: mw(8)

  REAL :: xkw(8)
  REAL :: aw(8)
  REAL :: bw(8)

!---- temporary arrays -----

  REAL :: xh

!---- local misc. variables

  INTEGER :: i,j,k,ik

!-----xkw  are the absorption coefficients for the first
!  k-distribution function due to water vapor line absorption
!  (tables 4 and 7).  units are cm**2/g

  DATA xkw / 29.55  , 4.167E-1, 1.328E-2, 5.250E-4,                     &
              5.25E-4, 2.340E-3, 1.320E-0, 5.250E-4/

!-----mw are the ratios between neighboring absorption coefficients
!  for water vapor line absorption (tables 4 and 7).

  DATA mw /6,6,8,6,6,8,6,16/

!-----aw and bw (table 3) are the coefficients for temperature scaling
!  in eq. (25).

  DATA aw/ 0.0021, 0.0140, 0.0167, 0.0302,                              &
           0.0307, 0.0154, 0.0008, 0.0096/
  DATA bw/ -1.01E-5, 5.57E-5, 8.54E-5, 2.96E-4,                         &
            2.86E-4, 7.53E-5,-3.52E-6, 1.64E-5/

!-----expmn is an external function

  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!**********************************************************************
!    note that the 3 sub-bands in band 3 use the same set of xkw, aw,
!    and bw.  therefore, h2oexp for these sub-bands are identical.
!**********************************************************************

  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----xh is   the scaled water vapor amount for line absorption
!  computed from (27).

        xh = dh2o(i,j,k)*(pa(i,j,k)*0.002)                              &
            * ( 1.+(aw(ib)+bw(ib)* dt(i,j,k))*dt(i,j,k) )

!-----h2oexp is the water vapor transmittance of the layer (k2-1)
!  due to line absorption

        h2oexp(i,j,k,1) = expmn(-xh*xkw(ib))

      END DO
    END DO
  END DO

  DO ik=2,6

    IF(mw(ib) == 6) THEN

      DO k=1,np
        DO j=1,n
          DO i=1,m
            xh = h2oexp(i,j,k,ik-1)*h2oexp(i,j,k,ik-1)
            h2oexp(i,j,k,ik) = xh*xh*xh
          END DO
        END DO
      END DO

    ELSE IF(mw(ib) == 8) THEN

      DO k=1,np
        DO j=1,n
          DO i=1,m
            xh = h2oexp(i,j,k,ik-1)*h2oexp(i,j,k,ik-1)
            xh = xh*xh
            h2oexp(i,j,k,ik) = xh*xh
          END DO
        END DO
      END DO

    ELSE

      DO k=1,np
        DO j=1,n
          DO i=1,m
            xh = h2oexp(i,j,k,ik-1)*h2oexp(i,j,k,ik-1)
            xh = xh*xh
            xh = xh*xh
            h2oexp(i,j,k,ik) = xh*xh
          END DO
        END DO
      END DO

    END IF
  END DO

  RETURN
END SUBROUTINE h2oexps
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CONEXPS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE conexps(ib,m,n,np,dcont,conexp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate exponentials for continuum absorption in individual
!  layers.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute exponentials for continuum absorption in individual layers.
!
!---- input parameters
!  spectral band (ib)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of layers (np)
!  layer scaled water vapor amount for continuum absorption (dcont)
!
!---- output parameters
!  1 or 3 exponentials for each layer (conexp)
!
!**********************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: ib,m,n,np,i,j,k,iq

!---- input parameters ------

  REAL :: dcont(m,n,np)

!---- updated parameters -----

  REAL :: conexp(m,n,np,3)

!---- static data -----

  INTEGER :: NE(8)
  REAL :: xke(8)


!-----xke are the absorption coefficients for the first
!  k-distribution function due to water vapor continuum absorption
!  (table 6).  units are cm**2/g

  DATA xke /  0.00,   0.00,   27.40,   15.8,                            &
              9.40,   7.75,     0.0,    0.0/


!-----ne is the number of terms in computing water vapor
!  continuum transmittance (Table 6).
!  band 3 is divided into 3 sub-bands.

  DATA NE /0,0,3,1,1,1,0,0/
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!

!-----expmn is an external function
  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO k=1,np
    DO j=1,n
      DO i=1,m
        conexp(i,j,k,1) = expmn(-dcont(i,j,k)*xke(ib))
      END DO
    END DO
  END DO

  IF (ib == 3) THEN

!-----the absorption coefficients for sub-bands 3b (iq=2) and 3a (iq=3)
!  are, respectively, double and quadruple that for sub-band 3c (iq=1)
!  (table 6).

    DO iq=2,3
      DO k=1,np
        DO j=1,n
          DO i=1,m
            conexp(i,j,k,iq) = conexp(i,j,k,iq-1) *conexp(i,j,k,iq-1)
          END DO
        END DO
      END DO
    END DO

  END IF

  RETURN
END SUBROUTINE conexps
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CO2EXPS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE co2exps(m,n,np,dco2,pa,dt,co2exp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate co2 exponentials for individual layers.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!
!**********************************************************************
!   compute co2 exponentials for individual layers.
!
!---- input parameters
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of layers (np)
!  layer co2 amount (dco2)
!  layer pressure (pa)
!  layer temperature minus 250K (dt)
!
!---- output parameters
!  6 exponentials for each layer (co2exp)
!**********************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: m,n,np,i,j,k

!---- input parameters -----

  REAL :: dco2(m,n,np)
  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)

!---- output parameters -----

  REAL :: co2exp(m,n,np,6,2)

!---- static data -----

  REAL :: xkc(2),ac(2),bc(2),pm(2),prc(2)

!---- temporary arrays -----

  REAL :: xc

!-----xkc is the absorption coefficients for the
!  first k-distribution function due to co2 (table 7).
!  units are 1/(cm-atm)stp.

  DATA xkc/2.656E-5,2.656E-3/

!-----parameters (table 3) for computing the scaled co2 amount
!  using (27).

  DATA prc/  300.0,   30.0/
  DATA pm /    0.5,   0.85/
  DATA ac / 0.0182, 0.0042/
  DATA bc /1.07E-4,2.00E-5/
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!

!-----function expmn

  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----compute the scaled co2 amount from eq. (27) for band-wings
!  (sub-bands 3a and 3c).

        xc = dco2(i,j,k)*(pa(i,j,k)/prc(1))**pm(1)                      &
                *(1.+(ac(1)+bc(1)*dt(i,j,k))*dt(i,j,k))

!-----six exponential by powers of 8 (table 7).

        co2exp(i,j,k,1,1)=expmn(-xc*xkc(1))

        xc=co2exp(i,j,k,1,1)*co2exp(i,j,k,1,1)
        xc=xc*xc
        co2exp(i,j,k,2,1)=xc*xc

        xc=co2exp(i,j,k,2,1)*co2exp(i,j,k,2,1)
        xc=xc*xc
        co2exp(i,j,k,3,1)=xc*xc

        xc=co2exp(i,j,k,3,1)*co2exp(i,j,k,3,1)
        xc=xc*xc
        co2exp(i,j,k,4,1)=xc*xc

        xc=co2exp(i,j,k,4,1)*co2exp(i,j,k,4,1)
        xc=xc*xc
        co2exp(i,j,k,5,1)=xc*xc

        xc=co2exp(i,j,k,5,1)*co2exp(i,j,k,5,1)
        xc=xc*xc
        co2exp(i,j,k,6,1)=xc*xc

!-----compute the scaled co2 amount from eq. (27) for band-center
!  region (sub-band 3b).

        xc = dco2(i,j,k)*(pa(i,j,k)/prc(2))**pm(2)                      &
                *(1.+(ac(2)+bc(2)*dt(i,j,k))*dt(i,j,k))

        co2exp(i,j,k,1,2)=expmn(-xc*xkc(2))

        xc=co2exp(i,j,k,1,2)*co2exp(i,j,k,1,2)
        xc=xc*xc
        co2exp(i,j,k,2,2)=xc*xc

        xc=co2exp(i,j,k,2,2)*co2exp(i,j,k,2,2)
        xc=xc*xc
        co2exp(i,j,k,3,2)=xc*xc

        xc=co2exp(i,j,k,3,2)*co2exp(i,j,k,3,2)
        xc=xc*xc
        co2exp(i,j,k,4,2)=xc*xc

        xc=co2exp(i,j,k,4,2)*co2exp(i,j,k,4,2)
        xc=xc*xc
        co2exp(i,j,k,5,2)=xc*xc

        xc=co2exp(i,j,k,5,2)*co2exp(i,j,k,5,2)
        xc=xc*xc
        co2exp(i,j,k,6,2)=xc*xc

      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE co2exps
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE COLUMN                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE column(m,n,np,pa,dt,sabs0,sabs,spre,stem)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate column-integrated (from top of the model atmosphere)
!  absorber amount, absorber-weighted pressure and temperature.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**************************************************************************
!-----compute column-integrated (from top of the model atmosphere)
!  absorber amount (sabs), absorber-weighted pressure (spre) and
!  temperature (stem).
!  computations of spre and stem follows eqs. (37) and (38).
!
!--- input parameters
!   number of soundings in zonal direction (m)
!   number of soundings in meridional direction (n)
!   number of atmospheric layers (np)
!   layer pressure (pa)
!   layer temperature minus 250K (dt)
!   layer absorber amount (sabs0)
!
!--- output parameters
!   column-integrated absorber amount (sabs)
!   column absorber-weighted pressure (spre)
!   column absorber-weighted temperature (stem)
!
!--- units of pa and dt are mb and k, respectively.
!    units of sabs are g/cm**2 for water vapor and (cm-atm)stp for co2 and o3
!**************************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: m,n,np,i,j,k

!---- input parameters -----

  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)
  REAL :: sabs0(m,n,np)

!---- output parameters -----

  REAL :: sabs(m,n,np+1)
  REAL :: spre(m,n,np+1)
  REAL :: stem(m,n,np+1)

!*********************************************************************
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

    DO j=1,n
    DO i=1,m
      sabs(i,j,1)=0.0
      DO k=1,np
        sabs(i,j,k+1)=sabs(i,j,k)+sabs0(i,j,k)
      ENDDO
    ENDDO
    ENDDO

    DO j=1,n
    DO i=1,m
      spre(i,j,1)=0.0
      DO k=1,np
        spre(i,j,k+1)=spre(i,j,k)+pa(i,j,k)*sabs0(i,j,k)
      ENDDO
    ENDDO
    ENDDO

    DO j=1,n
    DO i=1,m
      stem(i,j,1)=0.0
      DO k=1,np
        stem(i,j,k+1)=stem(i,j,k)+dt(i,j,k)*sabs0(i,j,k)
      ENDDO
    ENDDO
    ENDDO

  RETURN
END SUBROUTINE column
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE TABLUP                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE tablup(k1,k2,m,n,np,nx,nh,nt,sabs,spre,stem,w1,p1,           &
           dwe,dpe,coef1,coef2,coef3,tran)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate water vapor, co2, and o3 transmittances using table
!  look-up. rlwopt = 0, or high=.false.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute water vapor, co2, and o3 transmittances between levels k1 and k2
!   using table look-up for m x n soundings.
!
!   Calculations follow Eq. (40) of Chou and Suarez (1995)
!
!---- input ---------------------
!  indices for pressure levels (k1 and k2)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of atmospheric layers (np)
!  number of pressure intervals in the table (nx)
!  number of absorber amount intervals in the table (nh)
!  number of tables copied (nt)
!  column-integrated absorber amount (sabs)
!  column absorber amount-weighted pressure (spre)
!  column absorber amount-weighted temperature (stem)
!  first value of absorber amount (log10) in the table (w1)
!  first value of pressure (log10) in the table (p1)
!  size of the interval of absorber amount (log10) in the table (dwe)
!  size of the interval of pressure (log10) in the table (dpe)
!  pre-computed coefficients (coef1, coef2, and coef3)
!
!---- updated ---------------------
!  transmittance (tran)
!
!  Note:
!   (1) units of sabs are g/cm**2 for water vapor and (cm-atm)stp for co2 and o3.
!   (2) units of spre and stem are, respectively, mb and K.
!   (3) there are nt identical copies of the tables (coef1, coef2, and
!    coef3).  the prupose of using the multiple copies of tables is
!    to increase the speed in parallel (vectorized) computations.
!    if such advantage does not exist, nt can be set to 1.
!
!**********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: k1,k2,m,n,np,nx,nh,nt,i,j

!---- input parameters -----

  REAL :: w1,p1,dwe,dpe
  REAL :: sabs(m,n,np+1)
  REAL :: spre(m,n,np+1)
  REAL :: stem(m,n,np+1)

  REAL :: coef1(nx,nh,nt)
  REAL :: coef2(nx,nh,nt)
  REAL :: coef3(nx,nh,nt)

!---- update parameter -----

  REAL :: tran(m,n)

!---- temporary variables -----

  REAL :: x1,x2,x3,we,pe,fw,fp,pa,pb,pc,ax,ba,bb,t1,ca,cb,t2
  INTEGER :: iw,ip,nn

!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j=1,n
    DO i=1,m

      nn=MOD(i,nt)+1

      x1=sabs(i,j,k2)-sabs(i,j,k1)
      x2=(spre(i,j,k2)-spre(i,j,k1))/x1
      x3=(stem(i,j,k2)-stem(i,j,k1))/x1

      we=(LOG10(x1)-w1)/dwe
      pe=(LOG10(x2)-p1)/dpe

      we=MAX(we,w1-2.*dwe)
      pe=MAX(pe,p1)

      iw=INT(we+1.5)
      ip=INT(pe+1.5)

      iw=MIN(iw,nh-1)
      iw=MAX(iw, 2)

      ip=MIN(ip,nx-1)
      ip=MAX(ip, 1)

      fw=we-FLOAT(iw-1)
      fp=pe-FLOAT(ip-1)

!-----linear interpolation in pressure

      pa = coef1(ip,iw-1,nn)*(1.-fp)+coef1(ip+1,iw-1,nn)*fp
      pb = coef1(ip,iw,  nn)*(1.-fp)+coef1(ip+1,iw,  nn)*fp
      pc = coef1(ip,iw+1,nn)*(1.-fp)+coef1(ip+1,iw+1,nn)*fp

!-----quadratic interpolation in absorber amount for coef1

      ax = (-pa*(1.-fw)+pc*(1.+fw)) *fw*0.5 + pb*(1.-fw*fw)

!-----linear interpolation in absorber amount for coef2 and coef3

      ba = coef2(ip,iw,  nn)*(1.-fp)+coef2(ip+1,iw,  nn)*fp
      bb = coef2(ip,iw+1,nn)*(1.-fp)+coef2(ip+1,iw+1,nn)*fp
      t1 = ba*(1.-fw) + bb*fw

      ca = coef3(ip,iw,  nn)*(1.-fp)+coef3(ip+1,iw,  nn)*fp
      cb = coef3(ip,iw+1,nn)*(1.-fp)+coef3(ip+1,iw+1,nn)*fp
      t2 = ca*(1.-fw) + cb*fw

!-----update the total transmittance between levels k1 and k2

      tran(i,j)= (ax + (t1+t2*x3) * x3)*tran(i,j)

    END DO
  END DO

  RETURN
END SUBROUTINE tablup
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE WVKDIS                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE wvkdis(ib,m,n,np,k,h2oexp,conexp,th2o,tcon,tran)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate water vapor transmittance using the k-distribution
!  method.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute water vapor transmittance between levels k1 and k2 for
!   m x n soundings using the k-distribution method.
!
!   computations follow eqs. (34), (46), (50) and (52).
!
!---- input parameters
!  spectral band (ib)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of levels (np)
!  current level (k)
!  exponentials for line absorption (h2oexp)
!  exponentials for continuum absorption (conexp)
!
!---- updated parameters
!  transmittance between levels k1 and k2 due to
!    water vapor line absorption (th2o)
!  transmittance between levels k1 and k2 due to
!    water vapor continuum absorption (tcon)
!  total transmittance (tran)
!
!**********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: ib,m,n,np,k,i,j

!---- input parameters ------

  REAL :: conexp(m,n,np,3)
  REAL :: h2oexp(m,n,np,6)

!---- updated parameters -----

  REAL :: th2o(m,n,6)
  REAL :: tcon(m,n,3)
  REAL :: tran(m,n)

!---- static data -----

  INTEGER :: NE(8)
  REAL :: fkw(6,8),gkw(6,3)

!---- temporary variable -----

  REAL :: trnth2o

!-----fkw is the planck-weighted k-distribution function due to h2o
!  line absorption given in table 4 of Chou and Suarez (1995).
!  the k-distribution function for the third band, fkw(*,3), is not used

  DATA fkw / 0.2747,0.2717,0.2752,0.1177,0.0352,0.0255,                 &
             0.1521,0.3974,0.1778,0.1826,0.0374,0.0527,                 &
             6*1.00,                                                    &
             0.4654,0.2991,0.1343,0.0646,0.0226,0.0140,                 &
             0.5543,0.2723,0.1131,0.0443,0.0160,0.0000,                 &
             0.1846,0.2732,0.2353,0.1613,0.1146,0.0310,                 &
             0.0740,0.1636,0.4174,0.1783,0.1101,0.0566,                 &
             0.1437,0.2197,0.3185,0.2351,0.0647,0.0183/

!-----gkw is the planck-weighted k-distribution function due to h2o
!  line absorption in the 3 subbands (800-720,620-720,540-620 /cm)
!  of band 3 given in table 7.  Note that the order of the sub-bands
!  is reversed.

  DATA gkw/  0.1782,0.0593,0.0215,0.0068,0.0022,0.0000,                 &
             0.0923,0.1675,0.0923,0.0187,0.0178,0.0000,                 &
             0.0000,0.1083,0.1581,0.0455,0.0274,0.0041/

!-----ne is the number of terms used in each band to compute water vapor
!  continuum transmittance (table 6).

  DATA NE /0,0,3,1,1,1,0,0/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----tco2 are the six exp factors between levels k1 and k2
!  tran is the updated total transmittance between levels k1 and k2


!-----th2o is the 6 exp factors between levels k1 and k2 due to
!  h2o line absorption.

!-----tcon is the 3 exp factors between levels k1 and k2 due to
!  h2o continuum absorption.

!-----trnth2o is the total transmittance between levels k1 and k2 due
!  to both line and continuum absorption computed from eq. (52).

  DO j=1,n
    DO i=1,m
      th2o(i,j,1) = th2o(i,j,1)*h2oexp(i,j,k,1)
      th2o(i,j,2) = th2o(i,j,2)*h2oexp(i,j,k,2)
      th2o(i,j,3) = th2o(i,j,3)*h2oexp(i,j,k,3)
      th2o(i,j,4) = th2o(i,j,4)*h2oexp(i,j,k,4)
      th2o(i,j,5) = th2o(i,j,5)*h2oexp(i,j,k,5)
      th2o(i,j,6) = th2o(i,j,6)*h2oexp(i,j,k,6)
    END DO
  END DO


  IF (NE(ib) == 0) THEN


    DO j=1,n
      DO i=1,m

        trnth2o      =(fkw(1,ib)*th2o(i,j,1)                            &
                     + fkw(2,ib)*th2o(i,j,2)                            &
                     + fkw(3,ib)*th2o(i,j,3)                            &
                     + fkw(4,ib)*th2o(i,j,4)                            &
                     + fkw(5,ib)*th2o(i,j,5)                            &
                     + fkw(6,ib)*th2o(i,j,6))

        tran(i,j)=tran(i,j)*trnth2o

      END DO
    END DO

  ELSE IF (NE(ib) == 1) THEN


    DO j=1,n
      DO i=1,m

        tcon(i,j,1)= tcon(i,j,1)*conexp(i,j,k,1)

        trnth2o      =(fkw(1,ib)*th2o(i,j,1)                            &
                     + fkw(2,ib)*th2o(i,j,2)                            &
                     + fkw(3,ib)*th2o(i,j,3)                            &
                     + fkw(4,ib)*th2o(i,j,4)                            &
                     + fkw(5,ib)*th2o(i,j,5)                            &
                     + fkw(6,ib)*th2o(i,j,6))*tcon(i,j,1)

        tran(i,j)=tran(i,j)*trnth2o

      END DO
    END DO

  ELSE

    DO j=1,n
      DO i=1,m

        tcon(i,j,1)= tcon(i,j,1)*conexp(i,j,k,1)
        tcon(i,j,2)= tcon(i,j,2)*conexp(i,j,k,2)
        tcon(i,j,3)= tcon(i,j,3)*conexp(i,j,k,3)

        trnth2o      = (  gkw(1,1)*th2o(i,j,1)                          &
                        + gkw(2,1)*th2o(i,j,2)                          &
                        + gkw(3,1)*th2o(i,j,3)                          &
                        + gkw(4,1)*th2o(i,j,4)                          &
                        + gkw(5,1)*th2o(i,j,5)                          &
                        + gkw(6,1)*th2o(i,j,6) ) * tcon(i,j,1)          &
                     + (  gkw(1,2)*th2o(i,j,1)                          &
                        + gkw(2,2)*th2o(i,j,2)                          &
                        + gkw(3,2)*th2o(i,j,3)                          &
                        + gkw(4,2)*th2o(i,j,4)                          &
                        + gkw(5,2)*th2o(i,j,5)                          &
                        + gkw(6,2)*th2o(i,j,6) ) * tcon(i,j,2)          &
                     + (  gkw(1,3)*th2o(i,j,1)                          &
                        + gkw(2,3)*th2o(i,j,2)                          &
                        + gkw(3,3)*th2o(i,j,3)                          &
                        + gkw(4,3)*th2o(i,j,4)                          &
                        + gkw(5,3)*th2o(i,j,5)                          &
                        + gkw(6,3)*th2o(i,j,6) ) * tcon(i,j,3)

        tran(i,j)=tran(i,j)*trnth2o

      END DO
    END DO

  END IF

  RETURN
END SUBROUTINE wvkdis
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CO2KDIS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE co2kdis(m,n,np,k,co2exp,tco2,tran)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate co2 transmittances using the k-distribution method
!
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute co2 transmittances between levels k1 and k2 for m x n soundings
!   using the k-distribution method with linear pressure scaling.
!
!   computations follow eq. (34).
!
!---- input parameters
!   number of grid intervals in zonal direction (m)
!   number of grid intervals in meridional direction (n)
!
!---- updated parameters
!   transmittance between levels k1 and k2 due to co2 absorption
!  for the various values of the absorption coefficient (tco2)
!   total transmittance (tran)
!
!**********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: m,n,np,k,i,j

!---- input parameters -----

  REAL :: co2exp(m,n,np,6,2)

!---- updated parameters -----

  REAL :: tco2(m,n,6,2)
  REAL :: tran(m,n)

!---- static data -----

  REAL :: gkc(6,2)

!---- temporary variable -----

  REAL :: xc

!-----gkc is the planck-weighted co2 k-distribution function
!  in the band-wing and band-center regions given in table 7.
!  for computing efficiency, sub-bands 3a and 3c are combined.

  DATA gkc/  0.1395,0.1407,0.1549,0.1357,0.0182,0.0220,                 &
             0.0766,0.1372,0.1189,0.0335,0.0169,0.0059/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----tco2 is the 6 exp factors between levels k1 and k2.
!  xc is the total co2 transmittance given by eq. (53).

  DO j=1,n
    DO i=1,m

!-----band-wings

      tco2(i,j,1,1)=tco2(i,j,1,1)*co2exp(i,j,k,1,1)
      xc=             gkc(1,1)*tco2(i,j,1,1)

      tco2(i,j,2,1)=tco2(i,j,2,1)*co2exp(i,j,k,2,1)
      xc=xc+gkc(2,1)*tco2(i,j,2,1)

      tco2(i,j,3,1)=tco2(i,j,3,1)*co2exp(i,j,k,3,1)
      xc=xc+gkc(3,1)*tco2(i,j,3,1)

      tco2(i,j,4,1)=tco2(i,j,4,1)*co2exp(i,j,k,4,1)
      xc=xc+gkc(4,1)*tco2(i,j,4,1)

      tco2(i,j,5,1)=tco2(i,j,5,1)*co2exp(i,j,k,5,1)
      xc=xc+gkc(5,1)*tco2(i,j,5,1)

      tco2(i,j,6,1)=tco2(i,j,6,1)*co2exp(i,j,k,6,1)
      xc=xc+gkc(6,1)*tco2(i,j,6,1)

!-----band-center region

      tco2(i,j,1,2)=tco2(i,j,1,2)*co2exp(i,j,k,1,2)
      xc=xc+gkc(1,2)*tco2(i,j,1,2)

      tco2(i,j,2,2)=tco2(i,j,2,2)*co2exp(i,j,k,2,2)
      xc=xc+gkc(2,2)*tco2(i,j,2,2)

      tco2(i,j,3,2)=tco2(i,j,3,2)*co2exp(i,j,k,3,2)
      xc=xc+gkc(3,2)*tco2(i,j,3,2)

      tco2(i,j,4,2)=tco2(i,j,4,2)*co2exp(i,j,k,4,2)
      xc=xc+gkc(4,2)*tco2(i,j,4,2)

      tco2(i,j,5,2)=tco2(i,j,5,2)*co2exp(i,j,k,5,2)
      xc=xc+gkc(5,2)*tco2(i,j,5,2)

      tco2(i,j,6,2)=tco2(i,j,6,2)*co2exp(i,j,k,6,2)
      xc=xc+gkc(6,2)*tco2(i,j,6,2)

      tran(i,j)=tran(i,j)*xc

    END DO
  END DO

  RETURN
END SUBROUTINE co2kdis
sorad3d.F       1587424407  1602  20    100644  69494     `
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SORAD                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE sorad(idim,jdim,m,n,np,                                      &
           pl,ta,wa,oa,co2,                                             &
           taucldi,taucldl,reffi,reffl,fcld,ict,icb,                    &
           taual,rsirbm,rsirdf,rsuvbm,rsuvdf,cosz,                      &
           flx,flc,fdirir,fdifir,fdirpar,fdifpar,                       &
           fdiruv,fdifuv,                                               & ! MS add
           sdf,sclr,csm,cc,                                             &
           tauclb,tauclf,dp,wh,oh,scal,swh,so2,df,                      &
           tem2d1, tem2d2, tem2d3, tem2d4, tem2d5,                      &
           tem2d6, tem2d7, tem2d8, tem2d9, tem2d10,                     &
           tem2d11,tem2d12,tem2d13,tem2d14,tem2d15,                     &
           tem2d16,tem2d17,tem2d18,tem2d19,                             &
           tem3d1, tem3d2, tem3d3, tem3d4, tem3d5,                      &
           tem4d1, tem4d2, tem4d3, tem4d4, tem4d5,                      &
           tem5d1, tem5d2, tem5d3, tem5d4, tem5d5)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate solar fluxes due to the absoption by water vapor, ozone,
!  co2, o2, clouds, and aerosols and due to the scattering by clouds,
!  aerosols, and gases.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!****************  charney  /silo/z1mhy/new/solar.f  ***10/24/95******
!********************************************************************
!
! This routine computes solar fluxes due to the absoption by water
!  vapor, ozone, co2, o2, clouds, and aerosols and due to the
!  scattering by clouds, aerosols, and gases.
!
! This is a vectorized code. It computes the fluxes simultaneous for
!  (m x n) soundings, which is a subset of the (m x ndim) soundings.
!  In a global climate model, m and ndim correspond to the numbers of
!  grid boxes in the zonal and meridional directions, respectively.
!
! Ice and liquid cloud particles are allowed to co-exist in any of the
!  np layers. Two sets of cloud parameters are required as inputs, one
!  for ice paticles and the other for liquid particles.  These parameters
!  are optical thickness (taucld) and effective particle size (reff).
!
! If no information is available for reff, a default value of
!  10 micron for liquid water and 75 micron for ice can be used.
!
! Clouds are grouped into high, middle, and low clouds separated by the
!  level indices ict and icb.  For detail, see the subroutine cldscale.
!
!----- Input parameters:
!                                                units      size
!   number of soundings in zonal direction (m)       n/d        1
!   number of soundings in meridional direction (n)  n/d        1
!   maximum number of soundings in                   n/d        1
!        meridional direction (ndim)
!   number of atmospheric layers (np)                n/d        1
!   level pressure (pl)                              mb       m*ndim*(np+1)
!   layer temperature (ta)                           k        m*ndim*np
!   layer specific humidity (wa)                     gm/gm    m*ndim*np
!   layer ozone concentration (oa)                   gm/gm    m*ndim*np
!   co2 mixing ratio by volumn (co2)               parts/part   1
!   cloud optical thickness (taucld)                 n/d      m*ndim*np*2
!             index 1 for ice particles
!             index 2 for liquid drops
!   effective cloud-particle size (reff)           micrometer m*ndim*np*2
!             index 1 for ice particles
!             index 2 for liquid drops
!
!   ARPS notes: taucld were changed to taucldi and taucldl
!            reff   were changed to reffi   and reffl
!
!   cloud amount (fcld)                            fraction   m*ndim*np
!   level index separating high and middle           n/d        1
!             clouds (ict)
!   level index separating middle and low clouds     n/d        1
!             clouds (icb)
!   aerosol optical thickness (taual)                n/d      m*ndim*np
!   solar ir surface albedo for beam                fraction   m*ndim
!             radiation (rsirbm)
!   solar ir surface albedo for diffuse             fraction   m*ndim
!             radiation (rsirdf)
!   uv + par surface albedo for beam                     fraction   m*ndim
!             radiation (rsuvbm)
!   uv + par surface albedo for diffuse                  fraction   m*ndim
!             radiation (rsuvdf)
!   cosine of solar zenith angle (cosz)            n/d        m*ndim
!
!----- Output parameters
!
!   all-sky flux (downward minus upward) (flx)     fraction   m*ndim*(np+1)
!   clear-sky flux (downward minus upward) (flc)   fraction   m*ndim*(np+1)
!   all-sky direct downward ir (0.7-10 micron)
!             flux at the surface (fdirir)      fraction   m*ndim
!   all-sky diffuse downward ir flux at
!             the surface (fdifir)              fraction   m*ndim
!   all-sky direct downward par (0.4-0.7 micron)
!             flux at the surface (fdirpar)     fraction   m*ndim
!   all-sky diffuse downward par flux at
!             the surface (fdifpar)             fraction   m*ndim
!
! MS - add new variables to track the uv flux at the ground
!   all-sky direct downward uv (<0.4 micron)
!             flux at the surface (fdiruv)     fraction   m*ndim
!   all-sky diffuse downward par flux at
!             the surface (fdifuv)             fraction   m*ndim
!
!----- Notes:
!
!    (1) The unit of flux is fraction of the incoming solar radiation
!     at the top of the atmosphere.  Therefore, fluxes should
!     be equal to flux multiplied by the extra-terrestrial solar
!     flux and the cosine of solar zenith angle.
!    (2) Clouds and aerosols can be included in any layers by specifying
!     fcld(i,j,k), taucld(i,j,k,*) and taual(i,j,k), k=1,np.
!     For an atmosphere without clouds and aerosols,
!     set fcld(i,j,k)=taucld(i,j,k,*)=taual(i,j,k)=0.0.
!    (3) Aerosol single scattering albedos and asymmetry
!     factors are specified in the subroutines solir and soluv.
!    (4) pl(i,j,1) is the pressure at the top of the model, and
!     pl(i,j,np+1) is the surface pressure.
!
!    ARPS note: pl was replaced by pa at scalar points (layers)
!
!    (5) the pressure levels ict and icb correspond approximately
!     to 400 and 700 mb.
!
!**************************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: idim,jdim             ! ARPS nx, ny. NX is used in this
                                   ! subroutine for other purpose

  INTEGER :: m,n,np
  INTEGER :: ict,icb

  REAL :: pl(idim,jdim,np+1)       ! pressure at scalar points (layers)
  REAL :: ta(idim,jdim,np)
  REAL :: wa(idim,jdim,np)
  REAL :: oa(idim,jdim,np)
  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)
  REAL :: reffi(idim,jdim,np)
  REAL :: reffl(idim,jdim,np)
  REAL :: fcld(idim,jdim,np)
  REAL :: taual(idim,jdim,np)
  REAL :: rsirbm(idim,jdim)
  REAL :: rsirdf(idim,jdim)
  REAL :: rsuvbm(idim,jdim)
  REAL :: rsuvdf(idim,jdim)
  REAL :: cosz(idim,jdim)
  REAL :: co2

  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: fdirir(idim,jdim)
  REAL :: fdifir(idim,jdim)
  REAL :: fdirpar(idim,jdim)
  REAL :: fdifpar(idim,jdim)
  REAL :: fdiruv(idim,jdim) ! MS add
  REAL :: fdifuv(idim,jdim) ! MS add
!
!-----------------------------------------------------------------------
!
!  Local temporary arrays
!
!-----------------------------------------------------------------------
!
  REAL :: sdf(m,n)
  REAL :: sclr(m,n)
  REAL :: csm(m,n)
  REAL :: cc(m,n,3)

  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)
  REAL :: dp(m,n,np)
  REAL :: wh(m,n,np)
  REAL :: oh(m,n,np)
  REAL :: scal(m,n,np)
  REAL :: swh(m,n,np+1)
  REAL :: so2(m,n,np+1)
  REAL :: df(m,n,np+1)

!-----temporary arrays used in subroutine cldflx

  REAL :: tem2d1 (m,n)
  REAL :: tem2d2 (m,n)
  REAL :: tem2d3 (m,n)
  REAL :: tem2d4 (m,n)
  REAL :: tem2d5 (m,n)
  REAL :: tem2d6 (m,n)
  REAL :: tem2d7 (m,n)
  REAL :: tem2d8 (m,n)
  REAL :: tem2d9 (m,n)
  REAL :: tem2d10(m,n)
  REAL :: tem2d11(m,n)
  REAL :: tem2d12(m,n)
  REAL :: tem2d13(m,n)
  REAL :: tem2d14(m,n)
  REAL :: tem2d15(m,n)
  REAL :: tem2d16(m,n)
  REAL :: tem2d17(m,n)
  REAL :: tem2d18(m,n)
  REAL :: tem2d19(m,n)

  REAL :: tem3d1(m,n,np)
  REAL :: tem3d2(m,n,np)
  REAL :: tem3d3(m,n,np+1)
  REAL :: tem3d4(m,n,np+1)
  REAL :: tem3d5(m,n,np+1)

  REAL :: tem4d1(m,n,np+1,2)
  REAL :: tem4d2(m,n,np+1,2)
  REAL :: tem4d3(m,n,np+1,2)
  REAL :: tem4d4(m,n,np+1,2)
  REAL :: tem4d5(m,n,np+1,2)

  REAL :: tem5d1(m,n,np+1,2,2)
  REAL :: tem5d2(m,n,np+1,2,2)
  REAL :: tem5d3(m,n,np+1,2,2)
  REAL :: tem5d4(m,n,np+1,2,2)
  REAL :: tem5d5(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: i,j,k
  REAL :: x
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!
  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j=1,n
    DO i=1,m

      swh(i,j,1)=0.
      so2(i,j,1)=0.

!-----csm is the effective secant of the solar zenith angle
!  see equation (12) of Lacis and Hansen (1974, JAS)

      csm(i,j)=35./SQRT(1224.*cosz(i,j)*cosz(i,j)+1.)

    END DO
  END DO


  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----compute layer thickness and pressure-scaling function.
!  indices for the surface level and surface layer
!  are np+1 and np, respectively.

        dp(i,j,k)=pl(i,j,k+1)-pl(i,j,k)
        scal(i,j,k)=dp(i,j,k)*(.5*(pl(i,j,k)+pl(i,j,k+1))/300.)**.8

!-----compute scaled water vapor amount, unit is g/cm**2

        wh(i,j,k)=1.02*wa(i,j,k)*scal(i,j,k)*                           &
                  (1.-0.00135*(ta(i,j,k)-240.))
        swh(i,j,k+1)=swh(i,j,k)+wh(i,j,k)

!-----compute ozone amount, unit is (cm-atm)stp.

        oh(i,j,k)=1.02*oa(i,j,k)*dp(i,j,k)*466.7

      END DO
    END DO
  END DO


!-----scale cloud optical thickness in each layer from taucld (with
!  cloud amount fcld) to tauclb and tauclf (with cloud amount cc).
!  tauclb is the scaled optical thickness for beam radiation and
!  tauclf is for diffuse radiation.

  CALL cldscale(idim,jdim,                                              &
                m,n,np,cosz,fcld,taucldi,taucldl,ict,icb,               &
                cc,tauclb,tauclf)

!-----initialize fluxes for all-sky (flx), clear-sky (flc), and
!  flux reduction (df)

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        flx(i,j,k)=0.
        flc(i,j,k)=0.
        df(i,j,k)=0.
      END DO
    END DO
  END DO

!-----compute solar ir fluxes

  CALL solir (idim,jdim,                                                &
              m,n,np,wh,taucldi,taucldl,tauclb,tauclf,                  &
              reffi,reffl,ict,icb,                                      &
              fcld,cc,taual,csm,rsirbm,rsirdf,                          &
              flx,flc,fdirir,fdifir,                                    &
              tem2d1, tem2d2, tem2d3, tem2d4,                           &
              tem2d5, tem2d6, tem2d7, tem2d8, tem2d9,                   &
              tem2d10,tem2d11,tem2d12,tem2d13,tem2d14,                  &
              tem3d1, tem3d2, tem3d3, tem3d4,                           &
              tem4d1, tem4d2, tem4d3, tem4d4, tem4d5,                   &
              tem2d15,tem2d16,tem2d17,tem2d18,tem2d19,                  &
              tem3d5,                                                   &
              tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

!  DO k=1,np
!    write (6,'(a,i2,a,i2,a,e20.10)')
!    :  'IR:  flx(2,2,',k+1,')-flx(2,2,',k,')=',
!    :  flx(2,2,k+1)-flx(2,2,k)
!  ENDDO

!-----compute and update uv and par fluxes

  CALL soluv (idim,jdim,                                                &
              m,n,np,oh,dp,taucldi,taucldl,tauclb,tauclf,               &
              reffi,reffl,ict,icb,                                      &
              fcld,cc,taual,csm,rsuvbm,rsuvdf,                          &
              flx,flc,fdirpar,fdifpar,                                  &
              fdiruv,fdifuv,                                            & ! MS add
              tem2d1, tem2d2, tem2d3,                                   &
              tem2d5, tem2d6, tem2d7, tem2d8, tem2d9,                   &
              tem2d10,tem2d11,tem2d12,tem2d13,tem2d14,                  &
              tem3d1, tem3d3, tem3d4,                                   &
              tem4d1, tem4d2, tem4d3, tem4d4, tem4d5,                   &
              tem2d15,tem2d16,tem2d17,tem2d18,tem2d19,                  &
              tem3d5,                                                   &
              tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

!  write (6,'(a/a3,2a15)') 'Total flux for PAR',
!    :  'k','dflxPAR','flxPAR'
!  DO k=1,np
!    write (6,'(i3,2e15.7)')
!    :  k,flx(2,2,k+1)-flx(2,2,k),flx(2,2,k)
!  ENDDO

!-----compute scaled amount of o2 (so2), unit is (cm-atm)stp.

  DO k=1,np
    DO j=1,n
      DO i=1,m
        so2(i,j,k+1)=so2(i,j,k)+165.22*scal(i,j,k)
      END DO
    END DO
  END DO

!-----compute flux reduction due to oxygen following
!   chou (J. climate, 1990). The fraction 0.0287 is the
!   extraterrestrial solar flux in the o2 bands.

  DO k=2,np+1
    DO j=1,n
      DO i=1,m
        x=so2(i,j,k)*csm(i,j)
        df(i,j,k)=df(i,j,k)+0.0287*(1.-expmn(-0.00027*SQRT(x)))
      END DO
    END DO
  END DO

!  write (6,'(a/a3,3a15)')
!    : 'Flux reduction due to oxygen, i=j=3',
!    : 'k','ddf','df','so2'
!  DO k=2,np+1
!    write (6,'(i3,3e15.7)')
!    :  k,df(3,3,k)-df(3,3,k-1),df(3,3,k),so2(3,3,k)
!  ENDDO

!-----compute scaled amounts for co2 (so2). unit is (cm-atm)stp.

  DO k=1,np
    DO j=1,n
      DO i=1,m
        so2(i,j,k+1)=so2(i,j,k)+co2*789.*scal(i,j,k)
      END DO
    END DO
  END DO

!-----compute and update flux reduction due to co2 following
!  chou (J. Climate, 1990)

  CALL flxco2(m,n,np,so2,swh,csm,df)

!-----adjust for the effect of o2 cnd co2 on clear-sky fluxes.

  DO k=2,np+1
    DO j=1,n
      DO i=1,m
        flc(i,j,k)=flc(i,j,k)-df(i,j,k)
      END DO
    END DO
  END DO

!-----adjust for the all-sky fluxes due to o2 and co2.  It is
!  assumed that o2 and co2 have no effects on solar radiation
!  below clouds. clouds are assumed randomly overlapped.

  DO j=1,n
    DO i=1,m
      sdf(i,j)=0.0
      sclr(i,j)=1.0
    END DO
  END DO

  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----sclr is the fraction of clear sky.
!  sdf is the flux reduction below clouds.

        IF(fcld(i,j,k) > 0.01) THEN
          sdf(i,j)=sdf(i,j)+df(i,j,k)*sclr(i,j)*fcld(i,j,k)
          sclr(i,j)=sclr(i,j)*(1.-fcld(i,j,k))
        END IF
        flx(i,j,k+1)=flx(i,j,k+1)-sdf(i,j)-df(i,j,k+1)*sclr(i,j)

      END DO
    END DO
  END DO

!-----adjust for the direct downward ir flux.
  DO j=1,n
    DO i=1,m
!!!      fdirir(i,j)=fdirir(i,j)-sdf(i,j)-df(i,j,np+1)*sclr(i,j)
      ! MS - this line was altered to keep it consistent with the net flux calculation
      fdirir(i,j)=fdirir(i,j)-( sdf(i,j) + df(i,j,np+1)*sclr(i,j) )/(1. - rsirbm(i,j))
    END DO
  END DO

!  write (6,'(a3,2a15)') 'k','flx','flc'
!  DO k=1,np
!    write (6,'(i3,2e15.8)') k,flx(1,1,k),flc(1,1,k)
!  ENDDO
!
!  write (6,'(4a15)')
!    : 'fdirir','fdifir','fdirpar','fdifpar'
!
!  write (6,'(4e15.8)')
!    :  fdirir(1,1),fdifir(1,1),fdirpar(1,1),fdifpar(1,1)

  RETURN
END SUBROUTINE sorad
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SOLIR                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE solir(idim,jdim,                                             &
           m,n,np,wh,taucldi,taucldl,tauclb,tauclf,reffi,reffl,         &
           ict,icb,fcld,cc,taual,csm,rsirbm,rsirdf,                     &
           flx,flc,fdirir,fdifir,                                       &
           fsdir,fsdif, ssaclt,asyclt,                                  &
           rr1t,tt1t,td1t,rs1t,ts1t,                                    &
           rr2t,tt2t,td2t,rs2t,ts2t,                                    &
           ssacl,asycl,fall,fclr,                                       &
           rr,tt,td,rs,ts,                                              &
           tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                          &
           tem3d,                                                       &
           tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate solar flux in the infrared region. The spectrum is
!  divided into three bands. (See original comments.)
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Modified the original code from 1-D to 3-D
!
!  12/14/1998 (Keith Brewster)
!  Modified values of ssaal and asymal in data statement.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!************************************************************************
!  compute solar flux in the infrared region. The spectrum is divided
!   into three bands:
!
!       band   wavenumber(/cm)  wavelength (micron)
!        1       1000-4400         2.27-10.0
!        2       4400-8200         1.22-2.27
!        3       8200-14300        0.70-1.22
!
!----- Input parameters:                            units      size
!
!   number of soundings in zonal direction (m)       n/d        1
!   number of soundings in meridional direction (n)  n/d        1
!   maximum number of soundings in                   n/d        1
!       meridional direction (ndim)
!   number of atmospheric layers (np)                n/d        1
!   layer water vapor content (wh)                 gm/cm^2    m*n*np
!   cloud optical thickness (taucld)                 n/d      m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   scaled cloud optical thickness                   n/d      m*n*np
!       for beam radiation (tauclb)
!   scaled cloud optical thickness                   n/d      m*n*np
!       for diffuse radiation  (tauclf)
!   effective cloud-particle size (reff)           micrometer m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   level index separating high and                  n/d      m*n
!       middle clouds (ict)
!   level index separating middle and                n/d      m*n
!       low clouds (icb)
!   cloud amount (fcld)                            fraction   m*ndim*np
!   cloud amount of high, middle, and                n/d      m*n*3
!       low clouds (cc)
!   aerosol optical thickness (taual)                n/d      m*ndim*np
!   cosecant of the solar zenith angle (csm)         n/d      m*n
!   near ir surface albedo for beam                fraction   m*ndim
!             radiation (rsirbm)
!   near ir surface albedo for diffuse             fraction   m*ndim
!             radiation (rsirdf)
!
!----- output (updated) parameters:
!
!   all-sky flux (downward-upward) (flx)           fraction   m*ndim*(np+1)
!   clear-sky flux (downward-upward) (flc)         fraction   m*ndim*(np+1)
!   all-sky direct downward ir flux at
!       the surface (fdirir)                    fraction   m*ndim
!   all-sky diffuse downward ir flux at
!       the surface (fdifir)                    fraction   m*ndim
!
!----- note: the following parameters must be specified by users:
!   aerosol single scattering albedo (ssaal)         n/d      nband
!   aerosol asymmetry factor (asyal)                 n/d      nband
!
!*************************************************************************
!
!fpp$ expand (expmn)
!fpp$ expand (deledd)
!fpp$ expand (sagpol)
!!dir$ inline always expmn,deledd,sagpol
!*$*  inline routine (expmn,deledd,sagpol)
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: idim,jdim
  INTEGER :: m,n,np,ict,icb

  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)
  REAL :: reffi(idim,jdim,np)
  REAL :: reffl(idim,jdim,np)
  REAL :: fcld(idim,jdim,np)
  REAL :: rsirbm(idim,jdim)
  REAL :: rsirdf(idim,jdim)
  REAL :: taual(idim,jdim,np)

  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)
  REAL :: cc(m,n,3)
  REAL :: wh(m,n,np)
  REAL :: csm(m,n)

!-----output (updated) parameters

  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: fdirir(idim,jdim)
  REAL :: fdifir(idim,jdim)

!-----static parameters

  INTEGER :: nk,nband
  PARAMETER (nk=10,nband=3)
  REAL :: xk(nk),hk(nband,nk),ssaal(nband),asyal(nband)
  REAL :: aia(nband,3),awa(nband,3),aig(nband,3),awg(nband,3)

!-----temporary array

  REAL :: fsdir(m,n)
  REAL :: fsdif(m,n)

  REAL :: ssaclt(m,n)
  REAL :: asyclt(m,n)
  REAL :: rr1t(m,n)
  REAL :: tt1t(m,n)
  REAL :: td1t(m,n)
  REAL :: rs1t(m,n)
  REAL :: ts1t(m,n)
  REAL :: rr2t(m,n)
  REAL :: tt2t(m,n)
  REAL :: td2t(m,n)
  REAL :: rs2t(m,n)
  REAL :: ts2t(m,n)

  REAL :: ssacl(m,n,np)
  REAL :: asycl(m,n,np)
  REAL :: fall(m,n,np+1)
  REAL :: fclr(m,n,np+1)

  REAL :: rr(m,n,np+1,2)
  REAL :: tt(m,n,np+1,2)
  REAL :: td(m,n,np+1,2)
  REAL :: rs(m,n,np+1,2)
  REAL :: ts(m,n,np+1,2)

!-----temporary arrays used in subroutine cldflx

  REAL :: tem2d1(m,n)
  REAL :: tem2d2(m,n)
  REAL :: tem2d3(m,n)
  REAL :: tem2d4(m,n)
  REAL :: tem2d5(m,n)

  REAL :: tem3d (m,n,np+1)

  REAL :: tem5d1(m,n,np+1,2,2)
  REAL :: tem5d2(m,n,np+1,2,2)
  REAL :: tem5d3(m,n,np+1,2,2)
  REAL :: tem5d4(m,n,np+1,2,2)
  REAL :: tem5d5(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: ib,ik,i,j,k

  REAL :: tauwv,tausto,ssatau,asysto,tauto,ssato,asyto
  REAL :: taux,reff1,reff2,w1,w2,g1,g2

!-----function

  REAL :: expmn

!-----water vapor absorption coefficient for 10 k-intervals.
!  unit: cm^2/gm

  DATA xk/                                                              &
      0.0010, 0.0133, 0.0422, 0.1334, 0.4217,                           &
      1.334,  5.623,  31.62,  177.8,  1000.0/

!-----water vapor k-distribution function,
!  the sum of hk is 0.52926. unit: fraction

  DATA hk/                                                              &
      .01074,.08236,.20673,  .00360,.01157,.03497,                      &
      .00411,.01133,.03011,  .00421,.01143,.02260,                      &
      .00389,.01240,.01336,  .00326,.01258,.00696,                      &
      .00499,.01381,.00441,  .00465,.00650,.00115,                      &
      .00245,.00244,.00026,  .00145,.00094,.00000/

!-----aerosol single-scattering albedo and asymmetry factor

!  data ssaal,asyal/nband*0.999,nband*0.850/
  DATA ssaal/0.75,0.55,0.90/
  DATA asyal/0.40,0.50,0.60/

!  data ssaal,asyal/nband*0.400,nband*0.500/

!-----coefficients for computing the single scattering albedo of
!  ice clouds from ssa=1-(aia(*,1)+aia(*,2)*reff+aia(*,3)*reff**2)

  DATA aia/                                                             &
      .08938331, .00215346,-.00000260,                                  &
      .00299387, .00073709, .00000746,                                  &
      -.00001038,-.00000134, .00000000/

!-----coefficients for computing the single scattering albedo of
!  liquid clouds from ssa=1-(awa(*,1)+awa(*,2)*reff+awa(*,3)*reff**2)

  DATA awa/                                                             &
      .01209318,-.00019934, .00000007,                                  &
      .01784739, .00088757, .00000845,                                  &
      -.00036910,-.00000650,-.00000004/

!-----coefficients for computing the asymmetry factor of ice clouds
!  from asycl=aig(*,1)+aig(*,2)*reff+aig(*,3)*reff**2

  DATA aig/                                                             &
      .84090400, .76098937, .74935228,                                  &
      .00126222, .00141864, .00119715,                                  &
      -.00000385,-.00000396,-.00000367/

!-----coefficients for computing the asymmetry factor of liquid clouds
!  from asycl=awg(*,1)+awg(*,2)*reff+awg(*,3)*reff**2

  DATA awg/                                                             &
      .83530748, .74513197, .79375035,                                  &
      .00257181, .01370071, .00832441,                                  &
      .00005519,-.00038203,-.00023263/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----initialize surface fluxes, reflectances, and transmittances

  DO j= 1, n
    DO i= 1, m
      fdirir(i,j)=0.0
      fdifir(i,j)=0.0
      rr(i,j,np+1,1)=rsirbm(i,j)
      rr(i,j,np+1,2)=rsirdf(i,j)
      rs(i,j,np+1,1)=rsirbm(i,j)
      rs(i,j,np+1,2)=rsirdf(i,j)
      td(i,j,np+1,1)=0.0
      td(i,j,np+1,2)=0.0
      tt(i,j,np+1,1)=0.0
      tt(i,j,np+1,2)=0.0
      ts(i,j,np+1,1)=0.0
      ts(i,j,np+1,2)=0.0
    END DO
  END DO

!-----integration over spectral bands

  DO ib=1,nband

!-----compute cloud single scattering albedo and asymmetry factor
!  for a mixture of ice and liquid particles.

    DO k= 1, np

      DO j= 1, n
        DO i= 1, m

          ssaclt(i,j)=1.0
          asyclt(i,j)=1.0

          taux=taucldi(i,j,k)+taucldl(i,j,k)
          IF (taux > 0.05 .AND. fcld(i,j,k) > 0.01) THEN

            reff1=MIN(reffi(i,j,k),130.)
            reff2=MIN(reffl(i,j,k),20.0)

            w1=(1.-(aia(ib,1)+(aia(ib,2)+                               &
                aia(ib,3)*reff1)*reff1))*taucldi(i,j,k)
            w2=(1.-(awa(ib,1)+(awa(ib,2)+                               &
                awa(ib,3)*reff2)*reff2))*taucldl(i,j,k)
            ssaclt(i,j)=(w1+w2)/taux

            g1=(aig(ib,1)+(aig(ib,2)+aig(ib,3)*reff1)*reff1)*w1
            g2=(awg(ib,1)+(awg(ib,2)+awg(ib,3)*reff2)*reff2)*w2
            asyclt(i,j)=(g1+g2)/(w1+w2)

          END IF

        END DO
      END DO

      DO j=1,n
        DO i=1,m
          ssacl(i,j,k)=ssaclt(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          asycl(i,j,k)=asyclt(i,j)
        END DO
      END DO

    END DO

!-----integration over the k-distribution function

    DO ik=1,nk

      DO k= 1, np

        DO j= 1, n
          DO i= 1, m

            tauwv=xk(ik)*wh(i,j,k)

!-----compute total optical thickness, single scattering albedo,
!  and asymmetry factor.

            tausto=tauwv+taual(i,j,k)+1.0E-8
            ssatau=ssaal(ib)*taual(i,j,k)
            asysto=asyal(ib)*ssaal(ib)*taual(i,j,k)

!-----compute reflectance and transmittance for cloudless layers

            tauto=tausto
            ssato=ssatau/tauto+1.0E-8

            IF (ssato > 0.001) THEN

              ssato=MIN(ssato,0.999999)
              asyto=asysto/(ssato*tauto)

              CALL deledd (tauto,ssato,asyto,csm(i,j),                  &
                           rr1t(i,j),tt1t(i,j),td1t(i,j))

              CALL sagpol (tauto,ssato,asyto,rs1t(i,j),ts1t(i,j))

            ELSE

              td1t(i,j)=expmn(-tauto*csm(i,j))
              ts1t(i,j)=expmn(-1.66*tauto)
              tt1t(i,j)=0.0
              rr1t(i,j)=0.0
              rs1t(i,j)=0.0

            END IF

!-----compute reflectance and transmittance for cloud layers

            IF (tauclb(i,j,k) < 0.01) THEN

              rr2t(i,j)=rr1t(i,j)
              tt2t(i,j)=tt1t(i,j)
              td2t(i,j)=td1t(i,j)
              rs2t(i,j)=rs1t(i,j)
              ts2t(i,j)=ts1t(i,j)

            ELSE

              tauto=tausto+tauclb(i,j,k)
              ssato=(ssatau+ssacl(i,j,k)*tauclb(i,j,k))/tauto+1.0E-8
              ssato=MIN(ssato,0.999999)
              asyto=(asysto+asycl(i,j,k)*ssacl(i,j,k)*tauclb(i,j,k))/   &
                    (ssato*tauto)

              CALL deledd (tauto,ssato,asyto,csm(i,j),                  &
                           rr2t(i,j),tt2t(i,j),td2t(i,j))

              tauto=tausto+tauclf(i,j,k)
              ssato=(ssatau+ssacl(i,j,k)*tauclf(i,j,k))/tauto+1.0E-8
              ssato=MIN(ssato,0.999999)
              asyto=(asysto+asycl(i,j,k)*ssacl(i,j,k)*tauclf(i,j,k))/   &
                    (ssato*tauto)

              CALL sagpol (tauto,ssato,asyto,rs2t(i,j),ts2t(i,j))

            END IF

          END DO
        END DO

        DO j=1,n
          DO i=1,m
            rr(i,j,k,1)=rr1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            tt(i,j,k,1)=tt1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            td(i,j,k,1)=td1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            rs(i,j,k,1)=rs1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            ts(i,j,k,1)=ts1t(i,j)
          END DO
        END DO

        DO j=1,n
          DO i=1,m
            rr(i,j,k,2)=rr2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            tt(i,j,k,2)=tt2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            td(i,j,k,2)=td2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            rs(i,j,k,2)=rs2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            ts(i,j,k,2)=ts2t(i,j)
          END DO
        END DO

      END DO

!-----flux calculations

      CALL cldflx (m,n,np,ict,icb,cc,rr,tt,td,rs,ts,                    &
                   fclr,fall,fsdir,fsdif,                               &
                   tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                  &
                   tem3d, tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

      DO k= 1, np+1
        DO j= 1, n
          DO i= 1, m
            flx(i,j,k) = flx(i,j,k)+fall(i,j,k)*hk(ib,ik)
          END DO
        END DO
        DO j= 1, n
          DO i= 1, m
            flc(i,j,k) = flc(i,j,k)+fclr(i,j,k)*hk(ib,ik)
          END DO
        END DO
      END DO

!  write (6,'(a/2a3,2a15)') 'Flux for IR',
!    :  'ib','k','dflxIR','flxIR'
!  DO k=1,np
!    write (6,'(2i3,2e15.7)')
!    :  ib,k,fall(2,2,k+1)-fall(2,2,k),fall(2,2,k)
!  ENDDO

      DO j= 1, n
        DO i= 1, m
          fdirir(i,j) = fdirir(i,j)+fsdir(i,j)*hk(ib,ik)
          fdifir(i,j) = fdifir(i,j)+fsdif(i,j)*hk(ib,ik)
        END DO
      END DO

    END DO
  END DO

  RETURN
END SUBROUTINE solir
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SOLUV                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE soluv(idim,jdim,                                             &
           m,n,np,oh,dp,taucldi,taucldl,tauclb,tauclf,reffi,reffl,      &
           ict,icb,fcld,cc,taual,csm,rsuvbm,rsuvdf,                     &
           flx,flc,fdirpar,fdifpar,                                     &
           fdiruv,fdifuv,                                               & ! MS add
           fsdir,fsdif,asyclt,                                          &
           rr1t,tt1t,td1t,rs1t,ts1t,                                    &
           rr2t,tt2t,td2t,rs2t,ts2t,                                    &
           asycl,fall,fclr,                                             &
           td,rr,tt,rs,ts,                                              &
           tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                          &
           tem3d,                                                       &
           tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate solar fluxes in the uv+visible region. the spectrum is
!  grouped into 8 bands. (See original comments.)
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adapted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!  12/07/1998 (Keith Brewster)
!  Modified values of ssaal and asymal in data statement.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!************************************************************************
!  compute solar fluxes in the uv+visible region. the spectrum is
!  grouped into 8 bands:
!
!           Band     Micrometer
!
!    UV-C    1.     .175 - .225
!            2.     .225 - .245
!                   .260 - .280
!            3.     .245 - .260
!
!    UV-B    4.     .280 - .295
!            5.     .295 - .310
!            6.     .310 - .320
!
!    UV-A    7.     .320 - .400
!
!    PAR     8.     .400 - .700
!
!----- Input parameters:                            units      size
!
!   number of soundings in zonal direction (m)       n/d        1
!   number of soundings in meridional direction (n)  n/d        1
!   maximum number of soundings in                   n/d        1
!        meridional direction (ndim)
!   number of atmospheric layers (np)                n/d        1
!   layer ozone content (oh)                      (cm-atm)stp m*n*np
!   layer pressure thickness (dp)                    mb       m*n*np
!   cloud optical thickness (taucld)                 n/d      m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   scaled cloud optical thickness                   n/d      m*n*np
!       for beam radiation (tauclb)
!   scaled cloud optical thickness                   n/d      m*n*np
!       for diffuse radiation  (tauclf)
!   effective cloud-particle size (reff)           micrometer m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   level indiex separating high and                 n/d      m*n
!       middle clouds (ict)
!   level indiex separating middle and               n/d      m*n
!       low clouds (icb)
!   cloud amount (fcld)                            fraction   m*ndim*np
!   cloud amounts of high, middle, and               n/d      m*n*3
!       low clouds (cc)
!   aerosol optical thickness (taual)                n/d      m*ndim*np
!   cosecant of the solar zenith angle (csm)         n/d      m*n
!   uv+par surface albedo for beam                 fraction   m*ndim
!        radiation (rsuvbm)
!   uv+par surface albedo for diffuse              fraction   m*ndim
!        radiation (rsuvdf)
!
!----- output (updated) parameters:
!
!   all-sky net downward flux (flx)                fraction   m*ndim*(np+1)
!   clear-sky net downward flux (flc)              fraction   m*ndim*(np+1)
!   all-sky direct downward par flux at
!       the surface (fdirpar)                   fraction   m*ndim
!   all-sky diffuse downward par flux at
!       the surface (fdifpar)                   fraction   m*ndim
!
! MS - add new vars to track uv fluxes at surface
!   all-sky direct downward par flux at
!       the surface (fdiruv)                   fraction   m*ndim
!   all-sky diffuse downward par flux at
!       the surface (fdifuv)                   fraction   m*ndim
!
!----- note: the following parameters must be specified by users:
!
!   aerosol single scattering albedo (ssaal)         n/d        1
!   aerosol asymmetry factor (asyal)                 n/d        1
!
!
!***********************************************************************
!
!fpp$ expand (deledd)
!fpp$ expand (sagpol)
!!dir$ inline always deledd,sagpol
!*$*  inline routine (deledd,sagpol)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: idim,jdim
  INTEGER :: m,n,np,ict,icb

  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)
  REAL :: reffi(idim,jdim,np)
  REAL :: reffl(idim,jdim,np)
  REAL :: fcld(idim,jdim,np)
  REAL :: taual(idim,jdim,np)
  REAL :: rsuvbm(idim,jdim)
  REAL :: rsuvdf(idim,jdim)

  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)
  REAL :: cc(m,n,3)
  REAL :: oh(m,n,np)
  REAL :: dp(m,n,np)
  REAL :: csm(m,n)

!-----output (updated) parameter

  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: fdirpar(idim,jdim)
  REAL :: fdifpar(idim,jdim)
  REAL :: fdiruv(idim,jdim) ! MS add
  REAL :: fdifuv(idim,jdim) ! MS add

!-----static parameters

  INTEGER :: nband
  PARAMETER (nband=8)
  REAL :: hk(nband)
  REAL :: xk(nband)
  REAL :: ry(nband)
  REAL :: asyal(nband)
  REAL :: ssaal(nband)
  REAL :: aig(3)
  REAL :: awg(3)

!-----temporary array

  REAL :: fsdir(m,n)
  REAL :: fsdif(m,n)
  REAL :: asyclt(m,n)
  REAL :: rr1t(m,n)
  REAL :: tt1t(m,n)
  REAL :: td1t(m,n)
  REAL :: rs1t(m,n)
  REAL :: ts1t(m,n)
  REAL :: rr2t(m,n)
  REAL :: tt2t(m,n)
  REAL :: td2t(m,n)
  REAL :: rs2t(m,n)
  REAL :: ts2t(m,n)

  REAL :: asycl(m,n,np)
  REAL :: fall(m,n,np+1)
  REAL :: fclr(m,n,np+1)

  REAL :: td(m,n,np+1,2)
  REAL :: rr(m,n,np+1,2)
  REAL :: tt(m,n,np+1,2)
  REAL :: rs(m,n,np+1,2)
  REAL :: ts(m,n,np+1,2)

!-----temporary arrays used in subroutine cldflx

  REAL :: tem2d1(m,n)
  REAL :: tem2d2(m,n)
  REAL :: tem2d3(m,n)
  REAL :: tem2d4(m,n)
  REAL :: tem2d5(m,n)

  REAL :: tem3d (m,n,np+1)

  REAL :: tem5d1(m,n,np+1,2,2)
  REAL :: tem5d2(m,n,np+1,2,2)
  REAL :: tem5d3(m,n,np+1,2,2)
  REAL :: tem5d4(m,n,np+1,2,2)
  REAL :: tem5d5(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: i,j,k,ib
  REAL :: taurs,tauoz,tausto,ssatau,asysto,tauto,ssato,asyto
  REAL :: taux,reff1,reff2,g1,g2

!-----hk is the fractional extra-terrestrial solar flux.
!  the sum of hk is 0.47074.

  DATA hk/.00057, .00367, .00083, .00417,                               &
          .00600, .00556, .05913, .39081/

!-----xk is the ozone absorption coefficient. unit: /(cm-atm)stp

  DATA xk /30.47, 187.2,  301.9,   42.83,                               &
           7.09,  1.25,   0.0345,  0.0539/

!-----ry is the extinction coefficient for Rayleigh scattering.
!  unit: /mb.

  DATA ry /.00604, .00170, .00222, .00132,                              &
           .00107, .00091, .00055, .00012/

!-----aerosol single-scattering albedo and asymmetry factor

!  data ssaal,asyal/nband*0.999,nband*0.850/
  DATA ssaal,asyal/nband*0.960,nband*0.700/

!-----coefficients for computing the asymmetry factor of ice clouds
!  from asycl=aig(*,1)+aig(*,2)*reff+aig(*,3)*reff**2

  DATA aig/.74625000,.00105410,-.00000264/

!-----coefficients for computing the asymmetry factor of liquid
!  clouds from asycl=awg(*,1)+awg(*,2)*reff+awg(*,3)*reff**2

  DATA awg/.82562000,.00529000,-.00014866/

!-----initialize surface reflectances and transmittances

!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j= 1, n
    DO i= 1, m
      fdirpar(i,j)=0.0
      fdifpar(i,j)=0.0
      fdiruv(i,j)=0.0 ! MS add
      fdifuv(i,j)=0.0 ! MS add
      rr(i,j,np+1,1)=rsuvbm(i,j)
      rr(i,j,np+1,2)=rsuvdf(i,j)
      rs(i,j,np+1,1)=rsuvbm(i,j)
      rs(i,j,np+1,2)=rsuvdf(i,j)
      td(i,j,np+1,1)=0.0
      td(i,j,np+1,2)=0.0
      tt(i,j,np+1,1)=0.0
      tt(i,j,np+1,2)=0.0
      ts(i,j,np+1,1)=0.0
      ts(i,j,np+1,2)=0.0
    END DO
  END DO

!-----compute cloud asymmetry factor for a mixture of
!  liquid and ice particles.  unit of reff is micrometers.

  DO k= 1, np

    DO j= 1, n
      DO i= 1, m

        asyclt(i,j)=1.0

        taux=taucldi(i,j,k)+taucldl(i,j,k)
        IF (taux > 0.05 .AND. fcld(i,j,k) > 0.01) THEN

          reff1=MIN(reffi(i,j,k),130.)
          reff2=MIN(reffl(i,j,k),20.0)

          g1=(aig(1)+(aig(2)+aig(3)*reff1)*reff1)*taucldi(i,j,k)
          g2=(awg(1)+(awg(2)+awg(3)*reff2)*reff2)*taucldl(i,j,k)
          asyclt(i,j)=(g1+g2)/taux

        END IF

      END DO
    END DO

    DO j=1,n
      DO i=1,m
        asycl(i,j,k)=asyclt(i,j)
      END DO
    END DO

  END DO

!-----integration over spectral bands

  DO ib=1,nband

    DO k= 1, np

      DO j= 1, n
        DO i= 1, m

!-----compute ozone and rayleigh optical thicknesses

          taurs=ry(ib)*dp(i,j,k)
          tauoz=xk(ib)*oh(i,j,k)

!-----compute total optical thickness, single scattering albedo,
!  and asymmetry factor

          tausto=taurs+tauoz+taual(i,j,k)+1.0E-8
          ssatau=ssaal(ib)*taual(i,j,k)+taurs
          asysto=asyal(ib)*ssaal(ib)*taual(i,j,k)

!-----compute reflectance and transmittance for cloudless layers

          tauto=tausto
          ssato=ssatau/tauto+1.0E-8
          ssato=MIN(ssato,0.999999)
          asyto=asysto/(ssato*tauto)

          CALL deledd (tauto,ssato,asyto,csm(i,j),                      &
                       rr1t(i,j),tt1t(i,j),td1t(i,j))

          CALL sagpol (tauto,ssato,asyto,rs1t(i,j),ts1t(i,j))

!-----compute reflectance and transmittance for cloud layers

          IF (tauclb(i,j,k) < 0.01) THEN

            rr2t(i,j)=rr1t(i,j)
            tt2t(i,j)=tt1t(i,j)
            td2t(i,j)=td1t(i,j)
            rs2t(i,j)=rs1t(i,j)
            ts2t(i,j)=ts1t(i,j)

          ELSE

            tauto=tausto+tauclb(i,j,k)
            ssato=(ssatau+tauclb(i,j,k))/tauto+1.0E-8
            ssato=MIN(ssato,0.999999)
            asyto=(asysto+asycl(i,j,k)*tauclb(i,j,k))/(ssato*tauto)

            CALL deledd (tauto,ssato,asyto,csm(i,j),                    &
                         rr2t(i,j),tt2t(i,j),td2t(i,j))

            tauto=tausto+tauclf(i,j,k)
            ssato=(ssatau+tauclf(i,j,k))/tauto+1.0E-8
            ssato=MIN(ssato,0.999999)
            asyto=(asysto+asycl(i,j,k)*tauclf(i,j,k))/(ssato*tauto)

            CALL sagpol (tauto,ssato,asyto,rs2t(i,j),ts2t(i,j))

          END IF

        END DO
      END DO

      DO j=1,n
        DO i=1,m
          rr(i,j,k,1)=rr1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          tt(i,j,k,1)=tt1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          td(i,j,k,1)=td1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          rs(i,j,k,1)=rs1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          ts(i,j,k,1)=ts1t(i,j)
        END DO
      END DO

      DO j=1,n
        DO i=1,m
          rr(i,j,k,2)=rr2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          tt(i,j,k,2)=tt2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          td(i,j,k,2)=td2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          rs(i,j,k,2)=rs2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          ts(i,j,k,2)=ts2t(i,j)
        END DO
      END DO

    END DO

!-----flux calculations

    CALL cldflx (m,n,np,ict,icb,cc,rr,tt,td,rs,ts,                      &
                 fclr,fall,fsdir,fsdif,                                 &
                 tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                    &
                 tem3d, tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

    DO k= 1, np+1
      DO j= 1, n
        DO i= 1, m
          flx(i,j,k)=flx(i,j,k)+fall(i,j,k)*hk(ib)
        END DO
      END DO
      DO j= 1, n
        DO i= 1, m
          flc(i,j,k)=flc(i,j,k)+fclr(i,j,k)*hk(ib)
        END DO
      END DO
    END DO

!  write (6,'(a/2a3,2a15)') 'Flux for PAR',
!    :  'ib','k','dflxpa','flxpa'
!  DO k=1,np
!    write (6,'(2i3,2e15.7)')
!    :  ib,k,fall(2,2,k+1)-fall(2,2,k),fall(2,2,k)
!  ENDDO

   ! MS change for energy conservation  
    IF(ib == 8) THEN
      DO j=1,n
        DO i=1,m
!!!          fdirpar(i,j)=fsdir(i,j)*hk(ib)
!!!          fdifpar(i,j)=fsdif(i,j)*hk(ib)
          fdirpar(i,j)= fdirpar(i,j) + fsdir(i,j)*hk(ib)
          fdifpar(i,j)= fdifpar(i,j) + fsdif(i,j)*hk(ib)
        END DO
      END DO
    ELSE ! MS addition to count the UV radiation hitting the ground
      DO j=1,n
        DO i=1,m
          fdiruv(i,j)= fdiruv(i,j) + fsdir(i,j)*hk(ib)
          fdifuv(i,j)= fdifuv(i,j) + fsdif(i,j)*hk(ib)
        END DO
      END DO
    END IF

  END DO

  RETURN
END SUBROUTINE soluv
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CLDSCALE                   ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE cldscale(idim,jdim,                                          &
           m,n,np,cosz,fcld,taucldi,taucldl,ict,icb,                    &
           cc,tauclb,tauclf)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the covers of high, middle, and low clouds and scales
!  the cloud optical thickness.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Formatted code to ARPS standard format
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!********************************************************************
!
!   This subroutine computes the covers of high, middle, and
!    low clouds and scales the cloud optical thickness.
!
!   To simplify calculations in a cloudy atmosphere, clouds are
!    grouped into high, middle and low clouds separated by the levels
!    ict and icb (level 1 is the top of the atmosphere).
!
!   Within each of the three groups, clouds are assumed maximally
!    overlapped, and the cloud cover (cc) of a group is the maximum
!    cloud cover of all the layers in the group.  The optical thickness
!    (taucld) of a given layer is then scaled to new values (tauclb and
!    tauclf) so that the layer reflectance corresponding to the cloud
!    cover cc is the same as the original reflectance with optical
!    thickness taucld and cloud cover fcld.
!
!---input parameters
!
!    number of grid intervals in zonal direction (m)
!    number of grid intervals in meridional direction (n)
!    maximum number of grid intervals in meridional direction (ndim)
!    number of atmospheric layers (np)
!    cosine of the solar zenith angle (cosz)
!    fractional cloud cover (fcld)
!    cloud optical thickness (taucld)
!    index separating high and middle clouds (ict)
!    index separating middle and low clouds (icb)
!
!---output parameters
!
!    fractional cover of high, middle, and low clouds (cc)
!    scaled cloud optical thickness for beam radiation (tauclb)
!    scaled cloud optical thickness for diffuse radiation (tauclf)
!
!********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: idim,jdim
  INTEGER :: m,n,np,ict,icb

  REAL :: cosz(idim,jdim)
  REAL :: fcld(idim,jdim,np)
  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)

!-----output parameters

  REAL :: cc(m,n,3)
  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)

!-----temporary variables

  INTEGER :: i,j,k,im,it,ia,kk
  REAL :: fm,ft,fa,xai,taux

!-----pre-computed table

  INTEGER :: nm,nt,na
  PARAMETER (nm=11,nt=9,na=11)
  REAL :: dm,dt,da,t1,caib(nm,nt,na),caif(nt,na)
  PARAMETER (dm=0.1,dt=0.30103,da=0.1,t1=-0.9031)

!-----include the pre-computed table for cai

!  include "cai.dat"
!  save caib,caif

  COMMON /radtab004/ caib,caif
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----clouds within each of the high, middle, and low clouds are
!  assumed maximally overlapped, and the cloud cover (cc)
!  for a group is the maximum cloud cover of all the layers
!  in the group

!!!  print *,'  ict,icb = ',ict,icb

    DO j=1,n
    DO i=1,m
      cc(i,j,1)=0.0
      DO k=1,ict-1
        cc(i,j,1)=MAX(cc(i,j,1),fcld(i,j,k))
      END DO
    END DO
    END DO

    DO j=1,n
    DO i=1,m
      cc(i,j,2)=0.0
      DO k=ict,icb-1
        cc(i,j,2)=MAX(cc(i,j,2),fcld(i,j,k))
      END DO
    END DO
    END DO

    DO j=1,n
    DO i=1,m
      cc(i,j,3)=0.0
      DO k=icb,np
        cc(i,j,3)=MAX(cc(i,j,3),fcld(i,j,k))
      END DO
    END DO
    END DO

!!!  print *,cc(1,1,1),cc(1,1,2),cc(1,1,3)

!-----scale the cloud optical thickness.
!  taucldi(i,j,k) is the optical thickness for ice particles, and
!  taucldl(i,j,k) is the optical thickness for liquid particles.

  DO k=1,np

    IF(k < ict) THEN
      kk=1
    ELSE IF(k >= ict .AND. k < icb) THEN
      kk=2
    ELSE
      kk=3
    END IF

    DO j=1,n
      DO i=1,m

        tauclb(i,j,k) = 0.0
        tauclf(i,j,k) = 0.0

        taux=taucldi(i,j,k)+taucldl(i,j,k)
        IF (taux > 0.05 .AND. fcld(i,j,k) > 0.01) THEN

!-----normalize cloud cover

          fa=fcld(i,j,k)/cc(i,j,kk)

!-----table look-up

          taux=MIN(taux,32.)

          fm=cosz(i,j)/dm
          ft=(LOG10(taux)-t1)/dt
          fa=fa/da

          im=INT(fm+1.5)
          it=INT(ft+1.5)
          ia=INT(fa+1.5)

          im=MAX(im,2)
          it=MAX(it,2)
          ia=MAX(ia,2)

          im=MIN(im,nm-1)
          it=MIN(it,nt-1)
          ia=MIN(ia,na-1)

          fm=fm-FLOAT(im-1)
          ft=ft-FLOAT(it-1)
          fa=fa-FLOAT(ia-1)

!-----scale cloud optical thickness for beam radiation.
!  the scaling factor, xai, is a function of the solar zenith
!  angle, optical thickness, and cloud cover.

          xai=    (-caib(im-1,it,ia)*(1.-fm)+                           &
              caib(im+1,it,ia)*(1.+fm))*fm*.5+caib(im,it,ia)*(1.-fm*fm)

          xai=xai+(-caib(im,it-1,ia)*(1.-ft)+                           &
              caib(im,it+1,ia)*(1.+ft))*ft*.5+caib(im,it,ia)*(1.-ft*ft)

          xai=xai+(-caib(im,it,ia-1)*(1.-fa)+                           &
              caib(im,it,ia+1)*(1.+fa))*fa*.5+caib(im,it,ia)*(1.-fa*fa)

          xai= xai-2.*caib(im,it,ia)
          xai=MAX(xai,0.0)

          tauclb(i,j,k) = taux*xai

!-----scale cloud optical thickness for diffuse radiation.
!  the scaling factor, xai, is a function of the cloud optical
!  thickness and cover but not the solar zenith angle.

          xai=    (-caif(it-1,ia)*(1.-ft)+                              &
              caif(it+1,ia)*(1.+ft))*ft*.5+caif(it,ia)*(1.-ft*ft)

          xai=xai+(-caif(it,ia-1)*(1.-fa)+                              &
              caif(it,ia+1)*(1.+fa))*fa*.5+caif(it,ia)*(1.-fa*fa)

          xai= xai-caif(it,ia)
          xai=MAX(xai,0.0)

          tauclf(i,j,k) = taux*xai

        END IF

      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE cldscale
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE FLXCO2                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE flxco2(m,n,np,swc,swh,csm,df)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the reduction of clear-sky downward solar flux
!  due to co2 absorption.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*****************************************************************
!
!-----compute the reduction of clear-sky downward solar flux
!  due to co2 absorption.
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: m,n,np

  REAL :: csm(m,n)
  REAL :: swc(m,n,np+1)
  REAL :: swh(m,n,np+1)
  REAL :: cah(22,19)

!-----output (undated) parameter

  REAL :: df(m,n,np+1)

!-----temporary variables

  INTEGER :: i,j,k,ic,iw
  REAL :: xx,CLOG,wlog,dc,dw,x1,x2,y2

!********************************************************************
!-----include co2 look-up table
!
!  include "cah.dat"
!  save cah

  COMMON /radtab005/ cah
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!********************************************************************
!-----table look-up for the reduction of clear-sky solar
!  radiation due to co2. The fraction 0.0343 is the
!  extraterrestrial solar flux in the co2 bands.

!  write (6,'(a/3a3,7a10)') 'Flux reduction due to co2, i=j=3',
!    :'k','ic','iw','x1','y2','x1-y2','ddf','df','swc','swh'

  DO k= 2, np+1
    DO j= 1, n
      DO i= 1, m
        xx=1./.3
        CLOG=LOG10(swc(i,j,k)*csm(i,j))
        wlog=LOG10(swh(i,j,k)*csm(i,j))
        ic=INT( (CLOG+3.15)*xx+1.)
        iw=INT( (wlog+4.15)*xx+1.)
        IF(ic < 2)ic=2
        IF(iw < 2)iw=2
        IF(ic > 22)ic=22
        IF(iw > 19)iw=19
        dc=CLOG-FLOAT(ic-2)*.3+3.
        dw=wlog-FLOAT(iw-2)*.3+4.
        x1=cah(1,iw-1)+(cah(1,iw)-cah(1,iw-1))*xx*dw
        x2=cah(ic-1,iw-1)+(cah(ic-1,iw)-cah(ic-1,iw-1))*xx*dw
        y2=x2+(cah(ic,iw-1)-cah(ic-1,iw-1))*xx*dc
        IF (x1 < y2) x1=y2
        df(i,j,k)=df(i,j,k)+0.0343*(x1-y2)
      END DO
    END DO

!    write (6,'(3i3,7f10.5)')
!    :  k,ic,iw,x1,y2,x1-y2,
!    :  df(3,3,k)-df(3,3,k-1),df (3,3,k),swc(3,3,k),swh(3,3,k)

  END DO

  RETURN
END SUBROUTINE flxco2
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CLDFLX                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE cldflx(m,n,np,ict,icb,cc,rr,tt,td,rs,ts,                     &
           fclr,fall,fsdir,fsdif,                                       &
           ch,cm,ct,fdndir,fdndif,                                      &
           flxdn,                                                       &
           rra,tta,tda,rsa,rxa)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate upward and downward fluxes using a two-stream adding
!  method.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*******************************************************************
!  compute upward and downward fluxes using a two-stream adding method
!  following equations (3)-(5) of Chou (1992, JAS).
!
!  clouds are grouped into high, middle, and low clouds which are
!  assumed randomly overlapped. It involves eight sets of calculations.
!  In each set of calculations, each atmospheric layer is homogeneous,
!  either with clouds or without clouds.

!  input parameters:
!  m:   number of soundings in zonal direction
!  n:   number of soundings in meridional direction
!  np:  number of atmospheric layers
!  ict: the level separating high and middle clouds
!  icb: the level separating middle and low clouds
!  cc:  effective cloud covers for high, middle and low clouds
!  tt:  diffuse transmission of a layer illuminated by beam radiation
!  td:  direct beam tranmssion
!  ts:  transmission of a layer illuminated by diffuse radiation
!  rr:  reflection of a layer illuminated by beam radiation
!  rs:  reflection of a layer illuminated by diffuse radiation
!
!  output parameters:
!  fclr:  clear-sky flux (downward minus upward)
!  fall:  all-sky flux (downward minus upward)
!  fdndir: surface direct downward flux
!  fdndif: surface diffuse downward flux
!*********************************************************************c
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: m,n,np,ict,icb

  REAL :: rr(m,n,np+1,2)
  REAL :: tt(m,n,np+1,2)
  REAL :: td(m,n,np+1,2)
  REAL :: rs(m,n,np+1,2)
  REAL :: ts(m,n,np+1,2)
  REAL :: cc(m,n,3)

!-----output parameters

  REAL :: fclr(m,n,np+1)
  REAL :: fall(m,n,np+1)
  REAL :: fsdir(m,n)
  REAL :: fsdif(m,n)

!-----temporary array

  REAL :: ch(m,n)
  REAL :: cm(m,n)
  REAL :: ct(m,n)
  REAL :: fdndir(m,n)
  REAL :: fdndif(m,n)

  REAL :: flxdn(m,n,np+1)

  REAL :: rra(m,n,np+1,2,2)
  REAL :: tta(m,n,np+1,2,2)
  REAL :: tda(m,n,np+1,2,2)
  REAL :: rsa(m,n,np+1,2,2)
  REAL :: rxa(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: i,j,k,ih,im,is
  REAL :: fupdif
  REAL :: denm,xx
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

    jloop:  DO j=1,n
    iloop:  DO i=1,m

!-----initialize all-sky flux (fall) and surface downward fluxes

  DO k=1,np+1
        fall(i,j,k)=0.0
  END DO

      fsdir(i,j)=0.0
      fsdif(i,j)=0.0

!-----compute transmittances and reflectances for a composite of
!  layers. layers are added one at a time, going down from the top.
!  tda is the composite transmittance illuminated by beam radiation
!  tta is the composite diffuse transmittance illuminated by
!      beam radiation
!  rsa is the composite reflectance illuminated from below
!      by diffuse radiation
!  tta and rsa are computed from eqs. (4b) and (3b) of Chou

!-----for high clouds. indices 1 and 2 denote clear and cloudy
!  situations, respectively.

  DO ih=1,2

        tda(i,j,1,ih,1)=td(i,j,1,ih)
        tta(i,j,1,ih,1)=tt(i,j,1,ih)
        rsa(i,j,1,ih,1)=rs(i,j,1,ih)
        tda(i,j,1,ih,2)=td(i,j,1,ih)
        tta(i,j,1,ih,2)=tt(i,j,1,ih)
        rsa(i,j,1,ih,2)=rs(i,j,1,ih)
        DO k= 2, ict-1
          denm = ts(i,j,k,ih)/( 1.-rsa(i,j,k-1,ih,1)*rs(i,j,k,ih))
          tda(i,j,k,ih,1)= tda(i,j,k-1,ih,1)*td(i,j,k,ih)
          tta(i,j,k,ih,1)= tda(i,j,k-1,ih,1)*tt(i,j,k,ih)               &
                        +(tda(i,j,k-1,ih,1)*rr(i,j,k,ih)                &
                        *rsa(i,j,k-1,ih,1)+tta(i,j,k-1,ih,1))*denm
          rsa(i,j,k,ih,1)= rs(i,j,k,ih)+ts(i,j,k,ih)                    &
                        *rsa(i,j,k-1,ih,1)*denm
          tda(i,j,k,ih,2)= tda(i,j,k,ih,1)
          tta(i,j,k,ih,2)= tta(i,j,k,ih,1)
          rsa(i,j,k,ih,2)= rsa(i,j,k,ih,1)
        END DO

!-----for middle clouds

    DO im=1,2

      DO k= ict, icb-1
            denm = ts(i,j,k,im)/( 1.-rsa(i,j,k-1,ih,im)*rs(i,j,k,im))
            tda(i,j,k,ih,im)= tda(i,j,k-1,ih,im)*td(i,j,k,im)
            tta(i,j,k,ih,im)= tda(i,j,k-1,ih,im)*tt(i,j,k,im)           &
                          +(tda(i,j,k-1,ih,im)*rr(i,j,k,im)             &
                          *rsa(i,j,k-1,ih,im)+tta(i,j,k-1,ih,im))*denm
            rsa(i,j,k,ih,im)= rs(i,j,k,im)+ts(i,j,k,im)                 &
                          *rsa(i,j,k-1,ih,im)*denm
      END DO

    END DO
  END DO

!-----layers are added one at a time, going up from the surface.
!  rra is the composite reflectance illuminated by beam radiation
!  rxa is the composite reflectance illuminated from above
!      by diffuse radiation
!  rra and rxa are computed from eqs. (4a) and (3a) of Chou

!-----for the low clouds

  DO is=1,2

        rra(i,j,np+1,1,is)=rr(i,j,np+1,is)
        rxa(i,j,np+1,1,is)=rs(i,j,np+1,is)
        rra(i,j,np+1,2,is)=rr(i,j,np+1,is)
        rxa(i,j,np+1,2,is)=rs(i,j,np+1,is)
        DO k=np,icb,-1
          denm=ts(i,j,k,is)/( 1.-rs(i,j,k,is)*rxa(i,j,k+1,1,is) )
          rra(i,j,k,1,is)=rr(i,j,k,is)+(td(i,j,k,is)                    &
              *rra(i,j,k+1,1,is)+tt(i,j,k,is)*rxa(i,j,k+1,1,is))*denm
          rxa(i,j,k,1,is)= rs(i,j,k,is)+ts(i,j,k,is)                    &
              *rxa(i,j,k+1,1,is)*denm
          rra(i,j,k,2,is)=rra(i,j,k,1,is)
          rxa(i,j,k,2,is)=rxa(i,j,k,1,is)
        END DO

!-----for middle clouds

    DO im=1,2

      DO k= icb-1,ict,-1
            denm=ts(i,j,k,im)/( 1.-rs(i,j,k,im)*rxa(i,j,k+1,im,is) )
            rra(i,j,k,im,is)= rr(i,j,k,im)+(td(i,j,k,im)                &
                *rra(i,j,k+1,im,is)+tt(i,j,k,im)*rxa(i,j,k+1,im,is))*denm
            rxa(i,j,k,im,is)= rs(i,j,k,im)+ts(i,j,k,im)                 &
                *rxa(i,j,k+1,im,is)*denm
      END DO

    END DO
  END DO

!-----integration over eight sky situations.
!  ih, im, is denotes high, middle and low cloud groups.

  DO ih=1,2

!-----clear portion

    IF(ih == 1) THEN
          ch(i,j)=1.0-cc(i,j,1)

    ELSE

!-----cloudy portion

          ch(i,j)=cc(i,j,1)

    END IF

    DO im=1,2

!-----clear portion

      IF(im == 1) THEN

            cm(i,j)=ch(i,j)*(1.0-cc(i,j,2))

      ELSE

!-----cloudy portion

            cm(i,j)=ch(i,j)*cc(i,j,2)

      END IF

      DO is=1,2

!-----clear portion

        IF(is == 1) THEN

              ct(i,j)=cm(i,j)*(1.0-cc(i,j,3))

        ELSE

!-----cloudy portion

              ct(i,j)=cm(i,j)*cc(i,j,3)

        END IF

!-----add one layer at a time, going down.

        DO k= icb, np
              denm = ts(i,j,k,is)/( 1.-rsa(i,j,k-1,ih,im)*rs(i,j,k,is) )
              tda(i,j,k,ih,im)= tda(i,j,k-1,ih,im)*td(i,j,k,is)
              tta(i,j,k,ih,im)=  tda(i,j,k-1,ih,im)*tt(i,j,k,is)        &
                   +(tda(i,j,k-1,ih,im)*rr(i,j,k,is)                    &
                   *rsa(i,j,k-1,ih,im)+tta(i,j,k-1,ih,im))*denm
              rsa(i,j,k,ih,im)= rs(i,j,k,is)+ts(i,j,k,is)               &
                   *rsa(i,j,k-1,ih,im)*denm
        END DO

!-----add one layer at a time, going up.

        DO k= ict-1,1,-1
              denm =ts(i,j,k,ih)/(1.-rs(i,j,k,ih)*rxa(i,j,k+1,im,is))
              rra(i,j,k,im,is)= rr(i,j,k,ih)+(td(i,j,k,ih)              &
                  *rra(i,j,k+1,im,is)+tt(i,j,k,ih)*rxa(i,j,k+1,im,is))*denm
              rxa(i,j,k,im,is)= rs(i,j,k,ih)+ts(i,j,k,ih)               &
                  *rxa(i,j,k+1,im,is)*denm
        END DO

!-----compute fluxes following eq (5) of Chou (1992)

!  fdndir is the direct  downward flux
!  fdndif is the diffuse downward flux
!  fupdif is the diffuse upward flux

        DO k=2,np+1
              denm= 1./(1.- rxa(i,j,k,im,is)*rsa(i,j,k-1,ih,im))
              fdndir(i,j)= tda(i,j,k-1,ih,im)
              xx = tda(i,j,k-1,ih,im)*rra(i,j,k,im,is)
              fdndif(i,j)= (xx*rsa(i,j,k-1,ih,im)+tta(i,j,k-1,ih,im))*denm
              fupdif= (xx+tta(i,j,k-1,ih,im)*rxa(i,j,k,im,is))*denm
              flxdn(i,j,k)=fdndir(i,j)+fdndif(i,j)-fupdif
        END DO

            flxdn(i,j,1)=1.0-rra(i,j,1,im,is)

!-----summation of fluxes over all (eight) sky situations.

        DO k=1,np+1
              IF(ih == 1 .AND. im == 1 .AND. is == 1) THEN
                fclr(i,j,k)=flxdn(i,j,k)
              END IF
              fall(i,j,k)=fall(i,j,k)+flxdn(i,j,k)*ct(i,j)
        END DO

            fsdir(i,j)=fsdir(i,j)+fdndir(i,j)*ct(i,j)
            fsdif(i,j)=fsdif(i,j)+fdndif(i,j)*ct(i,j)

      END DO
    END DO
  END DO

  END DO  iloop
  END DO  jloop

  RETURN
END SUBROUTINE cldflx

radtrns3d.F     1587424407  1602  20    100644  76236     `
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE RADTRNS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE radtrns(nx,ny,nz,rbufsz,tipa,myid,dx,dy,                     &
           ib,ie,jb,je,kb,ke,xh,yh,prs0s,olr,dsr,                       &  ! MS add olr, dsr
           ptprt,pprt,qv,qc,qr,qi,qs,qh,cvm,                            &
           ptbar,pbar,ppi, o31, rhostr, tsfc, zp,                       &
           radsw,rnflx,radswnet,radlwin, cosss,                         &
           rsirbm,rsirdf,rsuvbm,rsuvdf, cosz, az,                       &
           fdirir,fdifir,fdirpar,fdifpar,                               &
           plinv,tinv,qvinv,o3a,ccld,                                   &
           flxir,flcir,flxuv,flcuv,dfdts,                               &
           tauir,taual, tauswi,tauswl,reffi,reffl,                      &
           radbuf, tem1, swfrc,lwfrc,doirrad,dosorad,                   &
           effc,effi,effs,effr,effg,effis,                              &
           cgs1,cgs2,cgs3,cgt1,cgt2,cgt3,ptype,g,cp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  This subroutine is to compute the atmospheric radiation forcing
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  03/11/1996
!
!  MODIFICATION HISTORY:
!
!  04/09/1997 (Yuhe Liu)
!  Removed dimension size check statement. For normal ARPS run, the
!  dimension size check is now done in the main driver, arps##. For
!  nested runs, no need to check the dimension size because the
!  working array is allocated automatically from existing space.
!
!  Added call of subroutine SETRADWRK to set the indeces of working
!  arrays in the radiation buffer. Those indeces are passed by
!  common blocks in radcst.inc.
!
!  10/11/1998 (Keith Brewster)
!  Added option for using RH in cloud optical depth calculation.
!
!  10/30/1998 (Keith Brewster)
!  Added calculation of aerosol density.
!
!  11/18/98 (Keith Brewster)
!  Changed pibar to ppi (full pi).
!
!  07/16/03  (J. Brotzge)
!  Fixed new radswnet bug (detected by T. Katopodes)
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER, intent(in) :: nx,ny,nz
  INTEGER, intent(in) :: rbufsz
  integer, intent(in) :: tipa,myid
  real, intent(in) :: dx,dy
  integer, intent(in) :: ib,ie,jb,je,kb,ke
  real, dimension(ib:ie), intent(in) :: xh
  real, dimension(jb:je), intent(in) :: yh
  real, intent(in) :: prs0s
  logical, intent(in) :: doirrad,dosorad
!
!-----------------------------------------------------------------------
!
!  Define ARPS variables
!
!-----------------------------------------------------------------------
!
  REAL :: x(nx+1)
  REAL :: y(ny+1)
!!!  REAL :: z(nz)
!!!  REAL :: za(nz)
  REAL :: zp(nx,ny,nz)

  REAL :: ptprt (nx,ny,nz)
  REAL :: pprt  (nx,ny,nz)
  REAL :: qv    (nx,ny,nz)
  REAL :: qc    (nx,ny,nz)
  REAL :: qr    (nx,ny,nz)
  REAL :: qi    (nx,ny,nz)
  REAL :: qs    (nx,ny,nz)
  REAL :: qh    (nx,ny,nz)
  REAL :: cvm   (nx,ny,nz)

  REAL :: ptbar (nx,ny,nz)
  REAL :: pbar  (nx,ny,nz)
  REAL :: ppi   (nx,ny,nz)
  REAL :: o31   (nx,ny,nz)

  REAL :: rhostr(nx,ny,nz)

  REAL :: tsfc  (nx,ny)     ! Surface temperature (K)

  REAL, intent(inout) ::  swfrc(nx,ny,nz)  ! Radiation forcing (K/s)
  REAL, intent(inout) ::  lwfrc(nx,ny,nz)  ! Radiation forcing (K/s)

  REAL :: radsw (nx,ny)     ! Solar radiation reaching the surface
  REAL :: rnflx (nx,ny)     ! Net upward radiation flux
  REAL :: radswnet(nx,ny)   ! Net solar radiation at surface
  REAL :: radlwin(nx,ny)    ! Incoming longwave radiation at surface
  REAL :: flxd(nx,ny)         
  ! MS addition
  REAL :: olr(nx,ny)        ! TOA outgoing longwave
  REAL :: dsr(nx,ny)        ! TOA outgoing shortwave

  REAL :: cosz  (nx,ny)     ! Cosine of zenith
  REAL :: cosss (nx,ny)     ! Cosine of angle between sun light and
                            ! surface terrain slope

  REAL :: az, zen           ! Solar angles

  REAL :: sh(nx,ny)         ! augustin add sh
!
!-----------------------------------------------------------------------
!
!  Define 2-D variables for radiation calculation.
!
!-----------------------------------------------------------------------
!
  REAL :: rsirbm(nx,ny)     ! Solar IR surface albedo for beam radiation
  REAL :: rsirdf(nx,ny)     ! Solar IR surface albedo for diffuse radiation
  REAL :: rsuvbm(nx,ny)     ! Solar UV surface albedo for beam radiation
  REAL :: rsuvdf(nx,ny)     ! Solar UV surface albedo for diffuse radiation

  REAL :: fdirir (nx,ny)    ! all-sky direct downward IR flux
                            ! (0.7-10 micron) at the surface
  REAL :: fdifir (nx,ny)    ! all-sky diffuse downward IR flux
                            ! at the surface
  REAL :: fdirpar(nx,ny)    ! all-sky direct downward par flux
                            ! (0.4-0.7 micron) at the surface
  REAL :: fdifpar(nx,ny)    ! all-sky diffuse downward par flux
                            ! at the surface
! MS add
  REAL :: fdiruv(nx,ny)    ! all-sky direct downward uv flux
                            ! (<0.4 micron) at the surface
  REAL :: fdifuv(nx,ny)    ! all-sky diffuse downward uv flux
                            ! at the surface

!!!  REAL :: st4(nx,ny)        ! Emission by the surface
!
!-----------------------------------------------------------------------
!
!  Arrays which have the vertical coordinate inversed, that
!  is, k=1 is for top while k=nz is at the surface.
!
!-----------------------------------------------------------------------
!
  REAL :: plinv (nx,ny,nz)  ! Pressure in mb at scalar points
                 ! GHB:  I think plinv is really p at w points
  REAL :: tinv  (nx,ny,nz)  ! Temperature
  REAL :: qvinv (nx,ny,nz)  ! Water vapor mixing ratio (g/g)

  REAL :: o3a   (nx,ny,nz)  ! Ozone (o3) mixing ratio (g/g)
  REAL :: ccld  (nx,ny,nz)  ! Cloud coverage (fraction)

  REAL :: flxir (nx,ny,nz)  ! all-sky net downward flux
  REAL :: flcir (nx,ny,nz)  ! clear-sky net downward flux

  REAL :: flxuv (nx,ny,nz)  ! all-sky solar flux (downward minus upward)
  REAL :: flcuv (nx,ny,nz)  ! clear-sky solar flux (downward minus upward)

  REAL :: dfdts (nx,ny,nz)  ! Sensitivity of net downward flux to surface
                            ! temperature

  REAL :: tauir (nx,ny,nz)  ! Cloud optical depth for LW IR
  REAL :: taual (nx,ny,nz)  ! Aerosol optical thickness

  REAL :: tauswi(nx,ny,nz)  ! Cloud optical depth for solar IR for
                            ! ice particles
  REAL :: tauswl(nx,ny,nz)  ! Cloud optical depth for solar IR for
                            ! liquid particles

  REAL :: reffi (nx,ny,nz)  ! Effective cloud-particle size for
                            ! ice particles
  REAL :: reffl (nx,ny,nz)  ! Effective cloud-particle size for
                            ! liquid particles

  REAL :: tem1 (nx,ny,nz)   ! Work array for message passing

! hm 8/20/12
  real, intent(in), dimension(nz) :: effc,effi,effs,effr,effg,effis
  real, intent(in) :: cgs1,cgs2,cgs3
  real, intent(in) :: cgt1,cgt2,cgt3
  integer, intent(in) :: ptype
  real, intent(in) :: g,cp

!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!  REAL :: temp (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: tempp (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: tempt (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temptp (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temppi (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqv (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqc (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqr (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqi (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqs (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqh (nx,ny,nz)   ! Work array for new coordinate
!!!  REAL :: dz (nz)            ! Vertical grid spacing
!
!-----------------------------------------------------------------------
!
!  Include files:
!
!-----------------------------------------------------------------------
!
!!!  INCLUDE 'globcst.inc'
!!!  INCLUDE 'phycst.inc'
  INCLUDE 'radcst.incl'
  INCLUDE 'radmore.incl'

!!!  INCLUDE 'bndry.inc'                !  add by Yunheng
!!!  INCLUDE 'mp.inc'                   
!
!-----------------------------------------------------------------------
!
!  Include file radcst.inc which contains the definition of dimension
!  sizes for 2-d and 3-d temporary arrays represented by a buffer,
!  radbuf. When radopt is NOT set to 1, the dimensions and buffer
!  sizes can be 1. Otherwise, the dimension sizes should be the same
!  as nx, ny, and nz, and the buffer size should be larger than the
!  total size of 27 2-d arrays and 44 3-d arrays.
!
!  integer n2d_rad  ! number of 2-d arrays in the buffer
!  integer n3d_rad  ! number of 3-d arrays in the buffer
!
!  integer rbufsz   ! nx*ny*(n2d_rad+n3d_rad*nz)
!  real radbuf( rbufsz )
!
!  The 2-d arrays should be always at the beginning of radbuf and
!  the 3-d arrays then following.
!
!-----------------------------------------------------------------------
!
  REAL :: radbuf( rbufsz )
!
!-----------------------------------------------------------------------
!
!  Local variables
!
!-----------------------------------------------------------------------
!
  INTEGER :: nxy, nxyz
  INTEGER :: i,j,k
  INTEGER :: im,jm,km, ij, ijm

  INTEGER :: istgr, jstgr
  INTEGER :: nxodd, nyodd, jeven, jodd

  INTEGER :: m, n

  INTEGER :: night           ! Flag for night time

  REAL :: tqe, dp, coolrate,heatrate
  REAL :: pk,psfc,tk,qvsat,rh,hgtagl,ccld1,ccld2,aden,psqc,aersum
  REAL :: gcp

!  REAL, ALLOCATABLE :: difir(:,:)
!  REAL, ALLOCATABLE :: difpa(:,:)
!  REAL, ALLOCATABLE :: ptmp(:,:,:)
!  REAL, ALLOCATABLE :: temc(:,:,:)
!  REAL, ALLOCATABLE :: temal(:,:,:)
!  REAL, ALLOCATABLE :: temsi(:,:,:)
!  REAL, ALLOCATABLE :: temsl(:,:,:)
!  REAL, ALLOCATABLE :: temri(:,:,:)
!  REAL, ALLOCATABLE :: temrl(:,:,:)
!  REAL, ALLOCATABLE :: h_rate(:,:,:)
!  REAL, ALLOCATABLE :: c_rate(:,:,:)
  real, dimension(nx,ny,nz) :: h_rate,c_rate

  LOGICAL :: high

  INTEGER :: rh2cldopt
  REAL :: rhcldwgt,qcwgt
  PARAMETER (rh2cldopt=0,rhcldwgt=0.667)

  INTEGER :: ict             ! Vertical indices of height cldh2m
  INTEGER :: icb             ! Vertical indices of height cldm2l

!-----------------------------------------------------------------------

!  REAL :: fclr(1,1)
!  REAL :: dbs(1,1)
!  REAL :: trant(1,1)
!  REAL :: th2o(1,1,6)
!  REAL :: tcon(1,1,3)
!  REAL :: tco2(1,1,6,2)

!  REAL :: pa(1,1,nz-1)
!  REAL :: dt(1,1,nz-1)
!  REAL :: sh2o(1,1,nz)
!  REAL :: swpre(1,1,nz)
!  REAL :: swtem(1,1,nz)
!  REAL :: sco3(1,1,nz)
!  REAL :: scopre(1,1,nz)
!  REAL :: scotem(1,1,nz)
!  REAL :: dh2o(1,1,nz-1)
!  REAL :: dcont(1,1,nz-1)
!  REAL :: dco2(1,1,nz-1)
!  REAL :: do3(1,1,nz-1)
!  REAL :: flxu(1,1,nz)
!  REAL :: flxdd(1,1,nz)
!  REAL :: clr(1,1,0:nz)
!  REAL :: blayer(1,1,0:nz)

!  REAL :: h2oexp(1,1,nz-1,6)
!  REAL :: conexp(1,1,nz-1,3)

!  REAL :: co2exp(1,1,nz-1,6,2)

!-----------------------------------------------------------------------

 
!
!-----------------------------------------------------------------------
!
!  Functions
!
!-----------------------------------------------------------------------
!
  REAL :: aeroden

!-----------------------------------------------------------------------
!
!  Define additional layer to the top of model atmosphere
!
!-----------------------------------------------------------------------
!
  REAL :: padd                ! Additional pressure level (mb) to TOA
  REAL :: tadd                ! Temperature for additional layer to TOA

  PARAMETER (padd =  1.0)
  PARAMETER (tadd =223.0)

 

!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!  ALLOCATE(difir(nx,ny))
!  ALLOCATE(difpa(nx,ny))
!  ALLOCATE(ptmp(nx,ny,nz))
!  ALLOCATE(temc(nx,ny,nz))
!  ALLOCATE(temal(nx,ny,nz))
!  ALLOCATE(temsi(nx,ny,nz))
!  ALLOCATE(temsl(nx,ny,nz))
!  ALLOCATE(temri(nx,ny,nz))
!  ALLOCATE(temrl(nx,ny,nz))
!  ALLOCATE(h_rate(nx,ny,nz))
!  ALLOCATE(c_rate(nx,ny,nz))

  IF ( rlwopt == 0 ) THEN
    high = .false.
  ELSE
    high = .true.
  END IF

  sh = 1.0

!!!  gcp = 0.01*g/cp
  gcp = 0.01*g

!!!  CALL setradwrk(nx,ny,nz)

  nxy  = nx*ny
  nxyz = nxy*nz
  qcwgt=1.-rhcldwgt

  IF ( (pbar(1,1,nz-1)*0.01) <= padd ) THEN
!    WRITE (6,'(a/a)')                                                   &
!        'The pressure at the top of atmosphere was too low to add ',    &
!        'additional levels. Check the sounding profile.',               &
!        'Program stopped in RADTRNS.'
!    CALL arpsstop('arpsstop stopped RADTRNS pressure to low at the top ',1)
    print *,'Program stopped in RADTRNS.'
    call stopcm1
  END IF

!!! 700   CONTINUE   
  ! replace go-to with do loop:   GHB, 100729

!!!      zen = acos(cosz(max(1,nx/2),max(1,ny/2)))
      zen = acos(cosz(1,1))
!---------------


  DO j=1,ny
    DO i=1,nx
      DO k=1,nz-1
        o3a(i,j,k)=qc(i,j,k)
      END DO
    END DO
  END DO
!
!-----------------------------------------------------------------------
!
!  In the staggering case, only those points of (i,j) = (even,even)
!  and (odd,odd) will be calculated. Do defragment to move the points
!  to the left half domain, i=1,nx/2 and j=1,ny-1
!
!-----------------------------------------------------------------------
!
  nyodd = MOD(ny,2)
  nxodd = MOD(nx,2)

  ict = 0
  icb = 0

  m = nx
  n = ny

  IF ( radstgr == 0 ) THEN
!    WARNING: this loop is repeated for radstgr=1, changes made here must
!    also be made there as well.
      DO j=1,n
        DO i=1,m
          psfc = prs0s + pprt(i,j,1)
    DO km=3,nz-1
      k = nz+1-km
          pk = pbar(i,j,k)+pprt(i,j,k)
          ! plinv is pressure (in mb) at w points:
          plinv(i,j,km) = 0.005*((pbar(i,j,k  ) + pprt(i,j,k  ))        &
                                +(pbar(i,j,k+1) + pprt(i,j,k+1)))
          tk = (ptbar(i,j,k)+ptprt(i,j,k))*ppi(i,j,k)
          tinv (i,j,km) = MAX(tk, 190.)
          qvinv(i,j,km) = MAX(qv(i,j,k), 1.0E-6)

          tqe = qc(i,j,k)+qr(i,j,k)+qi(i,j,k)+qs(i,j,k)+qh(i,j,k)
          tqe = MAX(1.0E-20, tqe)

          if( ict.eq.0 )then
            if( (zp(i,j,k)-zp(i,j,2)).le.cldh2m )  ict = km
          endif
          if( icb.eq.0 )then
            if( (zp(i,j,k)-zp(i,j,2)).le.cldm2l )  icb = km
          endif

          IF( rh2cldopt > 0 ) THEN
            stop 22222
          ELSE
            ccld(i,j,km) = MIN(1.0, MAX(0.0, 0.25*ALOG10(tqe)+1.5))
!  borrow o3a to store psuedo-cloud
            o3a(i,j,k) = qc(i,j,k)
          END IF

!!!          psfc = 0.5* (pbar(i,j,1)+pprt(i,j,1) +                        &
!!!                       pbar(i,j,2)+pprt(i,j,2) )
!!!          psfc = prs0s + pprt(i,j,1)
          aden=2.0*aeroden(pk,psfc)
          taual(i,j,km)=aden*0.5*((pbar(i,j,k-1)+pprt(i,j,k-1))         &
                                 -(pbar(i,j,k+1)+pprt(i,j,k+1)))
        END DO
      END DO
    END DO

    if( ict.eq.0 .or. icb.eq.0 )then
      print *
      print *,'  Could not find ict,icb '
      print *
      print *,'  ict,icb = ',ict,icb
      print *
      call stopcm1
    endif

!    WARNING: this loop is repeated for radstgr=1, changes made here must
!    also be made there as well.
    DO j=1,n
      DO i=1,m
        ij = nx*(j-1) + i
        radbuf(ij) = tsfc(i,j)

        plinv(i,j,1) = padd
        tinv (i,j,1) = tadd
        qvinv(i,j,1) = 1.0E-6
        ccld (i,j,1) = 0.0
        taual(i,j,1) = 0.0

        plinv(i,j,3) = 0.01*( cgt1*(pbar(i,j,nz-2) + pprt(i,j,nz-2)) &
                             +cgt2*(pbar(i,j,nz-3) + pprt(i,j,nz-3)) &
                             +cgt3*(pbar(i,j,nz-4) + pprt(i,j,nz-4)) )
        plinv(i,j,2) = 0.5*(plinv(i,j,1)+plinv(i,j,3))
        tinv (i,j,2) = MAX(0.5*(tinv(i,j,1)+tinv(i,j,3)), 190.0)
        qvinv(i,j,2) = MAX(qv(i,j,nz-1), 1.0E-6)
        ccld (i,j,2) = 0.0
        taual(i,j,2) = 0.0

!!!        plinv(i,j,nz) = 0.005*((pbar(i,j,1) + pprt(i,j,1))              &
!!!                            +(pbar(i,j,2) + pprt(i,j,2)))
!!!        plinv(i,j,nz) = 0.01*( prs0s + pprt(i,j,1) )
        plinv(i,j,nz) = 0.01*( cgs1*(pbar(i,j,2) + pprt(i,j,2)) &
                              +cgs2*(pbar(i,j,3) + pprt(i,j,3)) &
                              +cgs3*(pbar(i,j,4) + pprt(i,j,4)) )
      END DO
    END DO

  ELSE IF ( radstgr == 1 ) THEN
    stop 77771

  END IF

  DO km=1,nz-1
    DO j=1,n
      DO i=1,m
        dp = plinv(i,j,km+1) - plinv(i,j,km)
        IF ( dp <= 0.0 ) THEN
        print*, 'dp is=',dp
        print*, 'location is=', i  ,j,  km
        print*, 'plinv =',plinv(i,j,:)
!          WRITE (6,'(a,i3,a,i3,a,i3,a,i3,a/a,a/a)')                     &
!              'ERROR: The pressure gradient between level k = ',nz+1-km, &
!              ' and ',nz-km, ' at i = ',i,' and j = ',j,' was <=0.',    &
!              'Please check the sounding file, ',                       &
!              runname(1:lfnkey)//'.sound, or the data sets.',           &
!              'Program stopped in RADTRNS.'
!          CALL arpsstop('arpsstop stopped RADTRNS problem with sounding',1)
          print *,'Program stopped in RADTRNS.'
          call stopcm1
        END IF
      END DO
    END DO
  END DO

!
!-----------------------------------------------------------------------
!
!  Notes: The arguments in subroutine CLDOPTD have different vertical
!         coordinates orders:
!
!         plinv  -- 1 for top
!         tinv   -- 1 for top
!
!         qc     -- 1 for bottom
!         qr     -- 1 for bottom
!         qi     -- 1 for bottom
!         qs     -- 1 for bottom
!         qh     -- 1 for bottom
!
!         tauir  -- 1 for top
!         tauswi -- 1 for top
!         tauswl -- 1 for top
!         reffi  -- 1 for top
!         reffl  -- 1 for top
!
!-----------------------------------------------------------------------
!
!  note borrowed o3a to store psuedo-cloud in place of qc.
  CALL cldoptd(nx,ny,m,n,nz, radstgr,                                   &
               plinv,tinv,o3a,qr,qi,qs,qh, rhostr, zp,                  &
               tauir,tauswi,tauswl,reffi,reffl,zen,                     &
               effc,effi,effs,effr,effg,effis,ptype)   ! hm 8/20/12

  IF ( radstgr == 1 ) THEN
    stop 77771
  END IF
!
!-----------------------------------------------------------------------
!
!  Fit the ozone concentration by interpolating a standard o3 profile
!  to ARPS pressure levels.
!
!-----------------------------------------------------------------------
!
!!!  CALL fito3(nx,ny,m,n, nz-1, plinv,o3a)
    do k=1,nz-1
    do j=1,ny
    do i=1,nx
      o3a(i,j,k) = o31(i,j,k)
    enddo
    enddo
    enddo
!
!-----------------------------------------------------------------------
!
!  Calculate the downward longwave IR radiation.
!
!  Positions of 2-d arrays in the buffer:
!
!    fclr (m,n)     -- radbuf(1+ 1*nxy)
!    dbs  (m,n)     -- radbuf(1+ 2*nxy)
!    trant(m,n)     -- radbuf(1+ 3*nxy)
!
!    th2o (m,n,6)   -- radbuf(1+ 4*nxy)
!    tcon (m,n,3)   -- radbuf(1+10*nxy)
!    tco2 (m,n,6,2) -- radbuf(1+13*nxy)
!
!  Positions of 3-d arrays in the buffer:
!
!    pa    (m,n,np)     -- radbuf(1+25*nxy)
!    dt    (m,n,np)     -- radbuf(1+25*nxy+ 1*nxyz)
!    sh2o  (m,n,np+1)   -- radbuf(1+25*nxy+ 2*nxyz)
!    swpre (m,n,np+1)   -- radbuf(1+25*nxy+ 3*nxyz)
!    swtem (m,n,np+1)   -- radbuf(1+25*nxy+ 4*nxyz)
!    sco3  (m,n,np+1)   -- radbuf(1+25*nxy+ 5*nxyz)
!    scopre(m,n,np+1)   -- radbuf(1+25*nxy+ 6*nxyz)
!    scotem(m,n,np+1)   -- radbuf(1+25*nxy+ 7*nxyz)
!    dh2o  (m,n,np)     -- radbuf(1+25*nxy+ 8*nxyz)
!    dcont (m,n,np)     -- radbuf(1+25*nxy+ 9*nxyz)
!    dco2  (m,n,np)     -- radbuf(1+25*nxy+10*nxyz)
!    do3   (m,n,np)     -- radbuf(1+25*nxy+11*nxyz)
!    flxu  (m,n,np+1)   -- radbuf(1+25*nxy+12*nxyz)
!    flxd  (m,n,np+1)   -- radbuf(1+25*nxy+13*nxyz)
!    clr   (m,n,0:np+1) -- radbuf(1+25*nxy+14*nxyz) ! nz+1
!    blayer(m,n,0:np+1) -- radbuf(1+26*nxy+15*nxyz) ! nz+1
!
!    h2oexp(m,n,np,6)   -- radbuf(1+27*nxy+16*nxyz)
!    conexp(m,n,np,3)   -- radbuf(1+27*nxy+22*nxyz)
!
!    co2exp(m,n,np,6,2) -- radbuf(1+27*nxy+25*nxyz)
!
!-----------------------------------------------------------------------
!
 IF (doirrad) THEN
  ! (arps code is absurd ... interpolate, then intepolate back?  ugh.)
  ! give irrad the pressure at scalar pts directly:
  do j=1,ny
  do i=1,nx
    km = 1
    radbuf(ir3d1-1+km) = 0.5*(plinv(i,j,km)+plinv(i,j,km+1))
    km = 2
    radbuf(ir3d1-1+km) = 0.5*(plinv(i,j,km)+plinv(i,j,km+1))
    do km=3,nz-1
      k = nz+1-km
      radbuf(ir3d1-1+km) = 0.01*(pbar(i,j,k)+pprt(i,j,k))
    enddo
  enddo
  enddo
  m = nx
  n = ny
  CALL irrad(nx,ny,m,n,nz-1,                                            &
             tauir(1,1,1),ccld(1,1,1), plinv(1,1,1),tinv(1,1,1),qvinv(1,1,1),o3a(1,1,1), co2,radbuf(1),           &
             high,flxd(1,1),flxir(1,1,1),flcir(1,1,1),dfdts(1,1,1),rnflx(1,1),                        &
!!!           fclr,dbs,trant,th2o,tcon,tco2,                               &
!!!           pa,dt,sh2o,swpre,swtem,sco3,scopre,scotem,                   &
!!!           dh2o,dcont,dco2,do3,flxu,flxdd,clr,blayer,                    &
!!!           h2oexp,conexp,co2exp)
             radbuf(ir2d1),radbuf(ir2d2),radbuf(ir2d3),                 &
             radbuf(ir2d4),radbuf(ir2d5),radbuf(ir2d6),                 &
             radbuf(ir3d1),radbuf(ir3d2),radbuf(ir3d3),                 &
             radbuf(ir3d4),radbuf(ir3d5),radbuf(ir3d6),                 &
             radbuf(ir3d7),radbuf(ir3d8),radbuf(ir3d9),                 &
             radbuf(ir3d10),radbuf(ir3d11),radbuf(ir3d12),              &
             radbuf(ir3d13),radbuf(ir3d14),radbuf(ir3d15),              &
             radbuf(ir3d16),radbuf(ir4d1),radbuf(ir4d2),                &
             radbuf(ir5d1))
    DO k=2,nz-2
      km=nz+1-k          ! inverse vertical coordinates to ARPS grid
      DO j=1,ny
        DO i=1,nx
          ! NOTE:  plinv is pressure (in mb) at w points:
!!!          c_rate(i,j,k) = 9.770687E-05               & ! = g/cp in cgs unit
!!!               * ( flxir(i,j,km+1) - flxir(i,j,km) )                    &
!!!                   / (ppi(i,j,k) * ( plinv(i,j,km) - plinv(i,j,km+1) ))
          ! cm1r17:  c_rate is now a TEMPERATURE tendency:
          c_rate(i,j,k) = gcp                        & ! = g/cp in cgs unit
               * ( flxir(i,j,km+1) - flxir(i,j,km) )                    &
                   / ( cvm(i,j,k)*( plinv(i,j,km) - plinv(i,j,km+1) ) )
        END DO
      END DO
    END DO

 END IF
!
!-----------------------------------------------------------------------
!
!  Calculate solar radiation fluxes.
!
!  Output flxuv and flcuv are the fractions to incoming solar flux
!  at the top of atmosphere
!
!  Positions of 2-d arrays used in subroutine SORAD
!
!    sdf  (m,n)     -- radbuf(1+ 1*nxy    )
!    sclr (m,n)     -- radbuf(1+ 2*nxy)
!    csm  (m,n)     -- radbuf(1+ 3*nxy)
!    cc   (m,n,3)   -- radbuf(1+ 4*nxy)
!
!  Positions of 3-d arrays used in subroutine SORAD
!
!    tauclb(m,n,np)   -- radbuf(1+ 7*nxy            )
!    tauclf(m,n,np)   -- radbuf(1+ 7*nxy+ 1*nxyz)
!    dp    (m,n,np)   -- radbuf(1+ 7*nxy+ 2*nxyz)
!    wh    (m,n,np)   -- radbuf(1+ 7*nxy+ 3*nxyz)
!    oh    (m,n,np)   -- radbuf(1+ 7*nxy+ 4*nxyz)
!    scal  (m,n,np)   -- radbuf(1+ 7*nxy+ 5*nxyz)
!    swh   (m,n,np+1) -- radbuf(1+ 7*nxy+ 6*nxyz)
!    so2   (m,n,np+1) -- radbuf(1+ 7*nxy+ 7*nxyz)
!    df    (m,n,np+1) -- radbuf(1+ 7*nxy+ 8*nxyz)
!
!  Positions of temporary arrays used in subroutine SOLIR, SOLUV, and
!  CLDFLX:
!
!    tem2d1 (m,n)         -- radbuf(1+ 7*nxy+ 9*nxyz)
!    tem2d2 (m,n)         -- radbuf(1+ 8*nxy+ 9*nxyz)
!    tem2d3 (m,n)         -- radbuf(1+ 9*nxy+ 9*nxyz)
!    tem2d4 (m,n)         -- radbuf(1+10*nxy+ 9*nxyz)
!    tem2d5 (m,n)         -- radbuf(1+11*nxy+ 9*nxyz)
!    tem2d6 (m,n)         -- radbuf(1+12*nxy+ 9*nxyz)
!    tem2d7 (m,n)         -- radbuf(1+13*nxy+ 9*nxyz)
!    tem2d8 (m,n)         -- radbuf(1+14*nxy+ 9*nxyz)
!    tem2d9 (m,n)         -- radbuf(1+15*nxy+ 9*nxyz)
!    tem2d10(m,n)         -- radbuf(1+16*nxy+ 9*nxyz)
!    tem2d11(m,n)         -- radbuf(1+17*nxy+ 9*nxyz)
!    tem2d12(m,n)         -- radbuf(1+18*nxy+ 9*nxyz)
!    tem2d13(m,n)         -- radbuf(1+19*nxy+ 9*nxyz)
!    tem2d14(m,n)         -- radbuf(1+20*nxy+ 9*nxyz)
!    tem2d15(m,n)         -- radbuf(1+21*nxy+ 9*nxyz)
!    tem2d16(m,n)         -- radbuf(1+22*nxy+ 9*nxyz)
!    tem2d17(m,n)         -- radbuf(1+23*nxy+ 9*nxyz)
!    tem2d18(m,n)         -- radbuf(1+24*nxy+ 9*nxyz)
!    tem2d19(m,n)         -- radbuf(1+25*nxy+ 9*nxyz)
!
!    tem3d1 (m,n,np+1)    -- radbuf(1+26*nxy+ 9*nxyz)
!    tem3d2 (m,n,np+1)    -- radbuf(1+26*nxy+10*nxyz)
!    tem3d3 (m,n,np+1)    -- radbuf(1+26*nxy+11*nxyz)
!    tem3d4 (m,n,np+1)    -- radbuf(1+26*nxy+12*nxyz)
!    tem3d5 (m,n,np+1)    -- radbuf(1+26*nxy+13*nxyz)
!
!    tem4d1 (m,n,np+1,2)  -- radbuf(1+26*nxy+14*nxyz)
!    tem4d2 (m,n,np+1,2)  -- radbuf(1+26*nxy+16*nxyz)
!    tem4d3 (m,n,np+1,2)  -- radbuf(1+26*nxy+18*nxyz)
!    tem4d4 (m,n,np+1,2)  -- radbuf(1+26*nxy+20*nxyz)
!    tem4d5 (m,n,np+1,2)  -- radbuf(1+26*nxy+22*nxyz)
!
!    tem5d1(m,n,np+1,2,2) -- radbuf(1+26*nxy+24*nxyz)
!    tem5d2(m,n,np+1,2,2) -- radbuf(1+26*nxy+28*nxyz)
!    tem5d3(m,n,np+1,2,2) -- radbuf(1+26*nxy+32*nxyz)
!    tem5d4(m,n,np+1,2,2) -- radbuf(1+26*nxy+36*nxyz)
!    tem5d5(m,n,np+1,2,2) -- radbuf(1+26*nxy+40*nxyz)
!
!-----------------------------------------------------------------------
!
 ! GHB, 100729:
 IF( dosorad )THEN

  night = 1
  DO j=1,n
    DO i=1,m
      IF ( cosz(i,j) > 0.0 ) THEN
        night = 0
        GO TO 500
      END IF
    END DO
  END DO

  500   CONTINUE

!  aersum=0.
!  DO 505 k=1,nz-1
!    aersum=aersum+taual(2,2,k)
! 505 CONTINUE
!  write(6,'(a,f10.4))') ' Total aerosol optical depth: ',aersum

  IF ( night == 0 ) THEN

    m = nx
    n = ny

    CALL sorad(nx,ny,m,n,nz-1, plinv,tinv,qvinv,o3a,co2,                &
         tauswi,tauswl,reffi,reffl,ccld,ict,icb,                        &
         taual,rsirbm,rsirdf,rsuvbm,rsuvdf,cosz,                        &
         flxuv,flcuv,fdirir,fdifir,fdirpar,fdifpar,                     &
         fdiruv,fdifuv,                                                 & ! MS add
         radbuf(so2d1),radbuf(so2d2),radbuf(so2d3),radbuf(so2d4),       &
         radbuf(so3d1),radbuf(so3d2),radbuf(so3d3),radbuf(so3d4),       &
         radbuf(so3d5),radbuf(so3d6),radbuf(so3d7),radbuf(so3d8),       &
         radbuf(so3d9),radbuf(so2d5),radbuf(so2d6),radbuf(so2d7),       &
         radbuf(so2d8),radbuf(so2d9),radbuf(so2d10),radbuf(so2d11),     &
         radbuf(so2d12),radbuf(so2d13),radbuf(so2d14),                  &
         radbuf(so2d15),radbuf(so2d16),radbuf(so2d17),                  &
         radbuf(so2d18),radbuf(so2d19),radbuf(so2d20),                  &
         radbuf(so2d21),radbuf(so2d22),radbuf(so2d23),                  &
         radbuf(so3d10),radbuf(so3d11),radbuf(so3d12),                  &
         radbuf(so3d13),radbuf(so3d14),radbuf(so4d1),                   &
         radbuf(so4d2),radbuf(so4d3),radbuf(so4d4),radbuf(so4d5),       &
         radbuf(so5d1), radbuf(so5d2),                                  &
         radbuf(so5d3), radbuf(so5d4), radbuf(so5d5))

  ELSE

    DO k=1,nz
      DO j=1,n
        DO i=1,m
          flxuv(i,j,k) = 0.0
        END DO
      END DO
    END DO

    DO j=1,n
      DO i=1,m
        fdirir (i,j) = 0.0
        fdifir (i,j) = 0.0
        fdirpar(i,j) = 0.0
        fdifpar(i,j) = 0.0
        fdiruv(i,j) = 0.0 ! MS add
        fdifuv(i,j) = 0.0 ! MS add
      END DO
    END DO

  ENDIF

 ENDIF

!------------------------------------------------------------------------------


!   IF ((tipa == 1) .AND. (repeat == 0))THEN !.AND. (abs(cosz(1,1)) > 0.5))THEN
!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!      ptmp = plinv
!      temc = ccld
!      temal = taual
!      temsi = tauswi
!      temsl = tauswl
!      temri = reffi
!      temrl = reffl
!      temp = pbar
!      tempp = pprt
!      tempt = ptbar
!      temptp = ptprt
!      temppi = ppi
!      temqv = qv
!      temqc = qc
!      temqr = qr
!      temqi = qi
!      temqs = qs
!      temqh = qh
!      tem1 = rhostr
!
!      repeat = 1
!
!      zen = acos(cosz(nx/2,ny/2))
!
!      GOTO 700
!
!   END IF


!   IF (tipa == 1) THEN

!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!      pbar = temp
!      pprt = tempp
!      ptbar = tempt
!      ptprt = temptp
!      qv = temqv
!      qc = temqc
!      qr = temqr
!      qi = temqi
!      qs = temqs
!      qh = temqh
!      rhostr = tem1
!      ccld = temc
!      taual = temal
!      tauswi = temsi
!      tauswl = temsl
!      reffi = temri
!      reffl = temrl

      !Fill-in edges of SW fluxes

!    DO k=1,nz
!        DO j=1,ny
!          flxuv(1,j,k) = flxuv(2,j,k)
!          flxuv(nx,j,k) = flxuv(nx-1,j,k)
!          flcuv(1,j,k) = flcuv(2,j,k)
!          flcuv(nx,j,k) = flcuv(nx-1,j,k)
!        END DO
!
!        DO i=1,nx
!          flxuv(i,1,k) = flxuv(i,2,k)
!          flxuv(i,ny,k) = flxuv(i,ny-1,k)
!          flcuv(i,1,k) = flcuv(i,2,k)
!          flcuv(i,ny,k) = flcuv(i,ny-1,k)
!        END DO
!
!        flxuv(1,1,k) = flxuv(2,2,k)
!        flxuv(nx,1,k) = flxuv(nx-1,2,k)
!        flxuv(nx,ny,k) = flxuv(nx-1,ny-1,k)
!        flxuv(1,ny,k) = flxuv(2,ny-1,k)
!        flcuv(1,1,k) = flcuv(2,2,k)
!        flcuv(nx,1,k) = flcuv(nx-1,2,k)
!        flcuv(nx,ny,k) = flcuv(nx-1,ny-1,k)
!        flcuv(1,ny,k) = flcuv(2,ny-1,k)
!
!    END DO
!   END IF


!  ELSEIF ((repeat == 0) .AND. (tipa == 1)) THEN 
!
!    ! not needed:  GHB, 100729
!    DO k=1,nz-1
!      DO j=1,n
!        DO i=1,m
!          flxuv(i,j,k) = 0.0
!        END DO
!      END DO
!    END DO
!
!    ! moved back to original location (just after sorad):  GHB, 100729
!    DO j=1,n
!      DO i=1,m
!        fdirir (i,j) = 0.0
!        fdifir (i,j) = 0.0
!        fdirpar(i,j) = 0.0
!        fdifpar(i,j) = 0.0
!      END DO
!    END DO

!  END IF
!
!-----------------------------------------------------------------------
!
!  Added the heating rate of solar radiation to total radiation
!  forcing (K/s)
!
!  Constant 9.770687e-05 is equal to g/cp in cgs unit, where g = 980
!  and cp = 1.003e7.
!
!  Outputs from SORAD such as flxuv, flcuv, etc., are fractions of
!  solar flux at the top of atmosphere. Therefore we need to multipy
!  solar constant and cosine of zenith angle to obtain the solar
!  radiation flux.
!
!-----------------------------------------------------------------------
!

!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!  IF (repeat == 0) THEN
!    temppi = ppi
!    ptmp = plinv
!  END IF

  IF ( radstgr == 0 ) THEN

  IF( night.eq.0 .and. dosorad )THEN
! moved calculation of coolrate up near irrad to avoid unnecessary
! calculations when using tipa:  GHB, 100726
    DO k=2,nz-2
      km=nz+1-k          ! inverse vertical coordinates to ARPS grid
      DO j=1,ny
        DO i=1,nx
          ! NOTE:  plinv is pressure (in mb) at w points:
!!!          h_rate(i,j,k) = solarc * cosz(i,j) * 9.770687E-05                  &
!!!                   * ( flxuv(i,j,km+1) - flxuv(i,j,km) )                &
!!!                   / (ppi(i,j,k) * ( plinv(i,j,km) - plinv(i,j,km+1) ))
          ! cm1r17:  h_rate is now a TEMPERATURE tendency:
          h_rate(i,j,k) = solarc * cosz(i,j) * gcp                           &
                   * ( flxuv(i,j,km+1) - flxuv(i,j,km) )                &
                   / ( cvm(i,j,k)*( plinv(i,j,km) - plinv(i,j,km+1) ) )
        END DO
      END DO
    END DO
  ELSE
    h_rate = 0.0
  ENDIF


!!!    radfrc = 0

  IF( doirrad )THEN
    DO k=2,nz-2
      DO j=1,ny
        DO i=1,nx
          lwfrc(i,j,k) = c_rate(i,j,k)
        END DO
      END DO
    END DO
    DO j=1,ny
      DO i=1,nx
        radlwin(i,j) = flxd(i,j) 
      END DO
    END DO
  ENDIF

  IF( dosorad )THEN
    DO k=2,nz-2
      DO j=1,ny
        DO i=1,nx
          swfrc(i,j,k) = h_rate(i,j,k)  
        END DO
      END DO
    END DO

    ! MS altered code begin !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! MS altered this calculation to include UV (<0.4 micron) radiation
    ! don't know what 'sh' is, but in current code is set to unity.
    ! also changed to use cosz instead of cosss. In my view this is more correct in 
    ! the presence of terrain than cosss. 

    DO j=1,ny
      DO i=1,nx
        ! net radiation at the surface
        rnflx(i,j) = solarc * radsw(i,j) * cosz(i,j)                    & ! radsw = a2dr2
                 * ( sh(i,j)*(1.0-rsirbm(i,j)) * fdirir(i,j)            &
                       + sh(i,j)*(1.0-rsuvbm(i,j)) * fdirpar(i,j)       &
                       + sh(i,j)*(1.0-rsuvbm(i,j)) * fdiruv(i,j)        &
                       + (1.0-rsirdf(i,j)) * fdifir(i,j)                &
                       + (1.0-rsuvdf(i,j)) * fdifpar(i,j)               &
                       + (1.0-rsuvdf(i,j)) * fdifuv(i,j) )              &
                       + flxir(i,j,nz)       ! net downward LW flux at sfc
	! net shortwave radiation at the surface
        radswnet(i,j) = solarc * radsw(i,j) * cosz(i,j)       & ! radsw = a2dr2
                 * (sh(i,j)*(1.0-rsirbm(i,j)) * fdirir(i,j)             &
                 + sh(i,j)*(1.0-rsuvbm(i,j)) * fdirpar(i,j)             &
                 + sh(i,j)*(1.0-rsuvbm(i,j)) * fdiruv(i,j)              &
                          + (1.0-rsirdf(i,j)) * fdifir(i,j)             &
                          + (1.0-rsuvdf(i,j)) * fdifpar(i,j)		&
                          + (1.0-rsuvdf(i,j)) * fdifuv(i,j) )
        ! MS add
        ! TOA fluxes - currently calculated at third level from top
        !              This is to be consistent with the heating rates
        !              which ignore the top two flux levels 
        olr(i,j) = -flxir(i,j,3)
        dsr(i,j) = solarc*radsw(i,j)*cosz(i,j)*flxuv(i,j,3)
        radsw(i,j) = solarc * radsw(i,j) * cosz(i,j)                      &
                     * ( sh(i,j)*(fdirir(i,j) + fdirpar(i,j)+ fdiruv(i,j))  &
                       + fdifir(i,j) + fdifpar(i,j) + fdifuv(i,j) )

      END DO
    END DO
    ! MS end altered code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ENDIF

  ELSE IF ( radstgr == 1 ) THEN
    stop 77773

  END IF

!---------------------------------------------------------------------
!
! Added by Yunheng to update the fake zone for radfrc, radsw, rnflx.
! two more variables (radswnet and radlwin) since IHOP_3
!
!--------------------------------------------------------------------

!  MPI stuff?  Commented out, for now:  GHB, 100720
!  IF (mp_opt > 0) THEN
!    CALL acct_interrupt(mp_acct)
!    CALL mpsendrecv2dew(radfrc, nx, ny, nz, ebc, wbc, 0, tem1)
!    CALL mpsendrecv2dns(radfrc, nx, ny, nz, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(radsw,  nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(radsw,  nx, ny, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(rnflx,  nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(rnflx,  nx, ny, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(radswnet, nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(radswnet, nx, ny, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(radlwin,  nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(radlwin,  nx, ny, nbc, sbc, 0, tem1)
!
!    CALL acct_stop_inter
!  END IF

!  IF ( raddiag == 1 ) THEN
!    WRITE(6,'(a,i8,a,f10.2,a)')                                         &
!        ' Dump radiation variables at time step,', nstep,               &
!        ', model time=',curtim,' (s)'
!!
!!-----------------------------------------------------------------------
!!
!!  Write out results to GrADS file for display
!!
!!-----------------------------------------------------------------------
!!
!    CALL wrtrad(nx,ny,nz,m,n,x,y,z,                                     &
!                plinv,tinv,qvinv,qc,qr,qi,qs,qh, o3a,radbuf(1),         &
!                ccld, tauir,taual,tauswi,tauswl,reffi,reffl,            &
!                rsirbm,rsirdf,rsuvbm,rsuvdf,                            &
!                fdirir,fdifir,fdirpar,fdifpar,                          &
!                dfdts, radsw,rnflx, cosz,                               &
!                flxir,flcir, flxuv,flcuv,                               &
!                radfrc)
!!    :              radfrc, coolr,heatr)
!
!  END IF

!  DEALLOCATE(difir)
!  DEALLOCATE(difpa)
!  DEALLOCATE(ptmp)
!  DEALLOCATE(temc)
!  DEALLOCATE(temal)
!  DEALLOCATE(temsi)
!  DEALLOCATE(temsl)
!  DEALLOCATE(temri)
!  DEALLOCATE(temrl)
!  DEALLOCATE(h_rate)
!  DEALLOCATE(c_rate)

  RETURN

END SUBROUTINE radtrns
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SETRADWRK                  ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE setradwrk( nx,ny,nz )
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Set the indeces for radiation working arrays
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  04/09/1997
!
!  MODIFICATION HISTORY:
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    nx       Number of grid points in the x-direction (east/west)
!    ny       Number of grid points in the y-direction (north/south)
!    nz       Number of grid points in the z-direction (vertical)
!
!-----------------------------------------------------------------------
!

!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny,nz       ! The number grid points in 3 directions
  INTEGER :: nxy, nxyz
!
!-----------------------------------------------------------------------
!
!  Include files
!
!-----------------------------------------------------------------------
!
  INCLUDE 'radcst.incl'
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  nxy  = nx*ny
  nxyz = nxy*nz
!
!-----------------------------------------------------------------------
!
!  Define indices which determine the positions of temporary arrays
!  used in subroutine IRRAD and the subroutine IRRAD calls.
!
!-----------------------------------------------------------------------
!
  ir2d1  = 1+ 1*nxy
  ir2d2  = 1+ 2*nxy
  ir2d3  = 1+ 3*nxy
  ir2d4  = 1+ 4*nxy
  ir2d5  = 1+10*nxy
  ir2d6  = 1+13*nxy

  ir3d1  = 1+25*nxy+ 0*nxyz
  ir3d2  = 1+25*nxy+ 1*nxyz
  ir3d3  = 1+25*nxy+ 2*nxyz
  ir3d4  = 1+25*nxy+ 3*nxyz
  ir3d5  = 1+25*nxy+ 4*nxyz
  ir3d6  = 1+25*nxy+ 5*nxyz
  ir3d7  = 1+25*nxy+ 6*nxyz
  ir3d8  = 1+25*nxy+ 7*nxyz
  ir3d9  = 1+25*nxy+ 8*nxyz
  ir3d10 = 1+25*nxy+ 9*nxyz
  ir3d11 = 1+25*nxy+10*nxyz
  ir3d12 = 1+25*nxy+11*nxyz
  ir3d13 = 1+25*nxy+12*nxyz
  ir3d14 = 1+25*nxy+13*nxyz
  ir3d15 = 1+25*nxy+14*nxyz
  ir3d16 = 1+26*nxy+15*nxyz

  ir4d1  = 1+27*nxy+16*nxyz
  ir4d2  = 1+27*nxy+22*nxyz

  ir5d1  = 1+27*nxy+25*nxyz
!
!-----------------------------------------------------------------------
!
!  Define indices which determine the positions of temporary arrays
!  used in subroutine SOLIR, SOLUV, and CLDFLX.
!
!-----------------------------------------------------------------------
!
  so2d1  = 1+ 1*nxy
  so2d2  = 1+ 2*nxy
  so2d3  = 1+ 3*nxy
  so2d4  = 1+ 4*nxy
  so2d5  = 1+ 7*nxy
  so2d6  = 1+ 8*nxy
  so2d7  = 1+ 9*nxy
  so2d8  = 1+10*nxy
  so2d9  = 1+11*nxy
  so2d10 = 1+12*nxy
  so2d11 = 1+13*nxy
  so2d12 = 1+14*nxy
  so2d13 = 1+15*nxy
  so2d14 = 1+16*nxy
  so2d15 = 1+17*nxy
  so2d16 = 1+18*nxy
  so2d17 = 1+19*nxy
  so2d18 = 1+20*nxy
  so2d19 = 1+21*nxy
  so2d20 = 1+22*nxy
  so2d21 = 1+23*nxy
  so2d22 = 1+24*nxy
  so2d23 = 1+25*nxy

  so3d1  = 1+26*nxy+ 0*nxyz
  so3d2  = 1+26*nxy+ 1*nxyz
  so3d3  = 1+26*nxy+ 2*nxyz
  so3d4  = 1+26*nxy+ 3*nxyz
  so3d5  = 1+26*nxy+ 4*nxyz
  so3d6  = 1+26*nxy+ 5*nxyz
  so3d7  = 1+26*nxy+ 6*nxyz
  so3d8  = 1+26*nxy+ 7*nxyz
  so3d9  = 1+26*nxy+ 8*nxyz
  so3d10 = 1+26*nxy+ 9*nxyz
  so3d11 = 1+26*nxy+10*nxyz
  so3d12 = 1+26*nxy+11*nxyz
  so3d13 = 1+26*nxy+12*nxyz
  so3d14 = 1+26*nxy+13*nxyz

  so4d1  = 1+26*nxy+14*nxyz
  so4d2  = 1+26*nxy+16*nxyz
  so4d3  = 1+26*nxy+18*nxyz
  so4d4  = 1+26*nxy+20*nxyz
  so4d5  = 1+26*nxy+22*nxyz

  so5d1  = 1+26*nxy+24*nxyz
  so5d2  = 1+26*nxy+28*nxyz
  so5d3  = 1+26*nxy+32*nxyz
  so5d4  = 1+26*nxy+36*nxyz
  so5d5  = 1+26*nxy+40*nxyz

  RETURN
END SUBROUTINE setradwrk
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE WRTRAD                     ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!
!  REMOVED ... GHB 100720
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CLDOPTD                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE cldoptd(nx,ny,m,n,nz, radstgr,                               &
           pres,temp,qc,qr,qi,qs,qh, rhostr, zp,                        &
           tauir,tauswi,tauswl,reffi,reffl,zen,                         &
           effc,effi,effs,effr,effg,effis,ptype)  ! hm 8/20/12
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the optical depth
!
!-----------------------------------------------------------------------
!
!  AUTHOR: NASA Goddard Center
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Modified the original code from 1-D to 3-D
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    nx       Number of grid points in the x-direction (east/west)
!    ny       Number of grid points in the y-direction (north/south)
!    nz       Number of grid points in the z-direction (vertical)
!
!                                               Vertical index order
!    pres     Pressure (mb)                       1 for top
!    temp     Temperature (K),                    1 for top
!    qc       Cloud water mixing ratio (g/g),     1 for bottom
!    qr       Rain water mixing ratio (g/g),      1 for bottom
!    qi       cloud ice mixing ratio (g/g),       1 for bottom
!    qs       Snow mixing ratio (g/g),            1 for bottom
!    qh       Hail mixing ratio (g/g),            1 for bottom
!    rhostr   Density multiply by j3,             1 for bottom
!    j3inv    1/j3,                               1 for bottom
!    zen      Solar zenith angle
!
!  OUTPUT:
!
!    tauir    Cloud optical depth for longwave,   1 for bottom
!    tauswi   Cloud optical depth for ice cloud
!             for shortwave,                      1 for bottom
!    tauswl   Cloud optical depth for liquid cloud
!             for shortwave,                      1 for bottom
!    reffi    Effective cloud-particle size (mm)
!             for ice cloud for shortwave,        1 for bottom
!    reffl    Effective cloud-particle size (mm)
!             for liquid cloud for shortwave,     1 for bottom
!
!  WORK ARRAY:
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny,nz
  INTEGER :: m,n
  INTEGER :: radstgr

  REAL :: pres  (nx,ny,nz)      ! in mb
  REAL :: temp  (nx,ny,nz)      ! in K
  REAL :: qc    (nx,ny,nz)      ! in g/g
  REAL :: qr    (nx,ny,nz)      ! in g/g
  REAL :: qi    (nx,ny,nz)      ! in g/g
  REAL :: qs    (nx,ny,nz)      ! in g/g
  REAL :: qh    (nx,ny,nz)      ! in g/g
  REAL :: rhostr(nx,ny,nz)      ! in kg/m**3
  REAL :: zp    (nx,ny,nz)      ! in kg/m**3

  REAL :: tauir (nx,ny,nz)
  REAL :: tauswi(nx,ny,nz)
  REAL :: tauswl(nx,ny,nz)
  REAL :: reffi (nx,ny,nz)
  REAL :: reffl (nx,ny,nz)

  REAL :: tauqc
  REAL :: tauqr
  REAL :: tauqi
  REAL :: tauqs
  REAL :: tauqh
  REAL :: reff1
  REAL :: reff2
  REAL :: zen

  REAL :: w1, effrad

  REAL :: cpi,twco, dpg, rho

! hm 8/20/12
  real, intent(in), dimension(nz) :: effc,effi,effs,effr,effg,effis
  integer, intent(in) :: ptype

  INTEGER :: i,j,k, im,jm,km
!!!  INTEGER :: istgr, jstgr, jodd

      real, parameter :: g      = 9.81
!
!-----------------------------------------------------------------------
!
!  Include files:
!
!-----------------------------------------------------------------------
!
!!!  INCLUDE 'phycst.inc'
  INCLUDE 'radcst.incl'
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  cpi  = 4.*ATAN(1.)
  twco = 1.e-6

!!!  IF ( radstgr == 0 ) THEN
!!!    istgr = 0
!!!    jstgr = 1
!!!  ELSE
!!!    stop 77774
!!!  END IF

  if( nx.ne.1 .or. ny.ne.1 ) stop 23323

  DO km=3,nz-1
    k = nz+1-km

    DO j=1,ny
      DO i=1,nx

        im = i
        jm = j

        rho = rhostr(i,j,k)*1.0E-3        ! g/cm**3
!!!        dpg = 10.0*(pres(im,jm,km+1)-pres(im,jm,km))/g ! g/cm**2
        ! cm1r17:  instead of using (dry?) hydrostatic equation, 
        !          use actual rho and actual delta-z
        dpg = 0.1*rhostr(i,j,k)*(zp(i,j,k+1)-zp(i,j,k))

        IF ( qc(i,j,k) >= twco ) THEN
          w1     = dpg*qc(i,j,k)
          effrad = 0.0015
! hm 8/20/12
          if(ptype.eq.5) effrad = effc(k)*1.e-4 !convert from micron to cm
          tauqc  = w1/effrad
          reff2  = effrad*1.0E4
        ELSE
          tauqc = 0.0
          reff2 = 0.0
        END IF

        IF ( qr(i,j,k) >= twco ) THEN
          w1     = dpg*qr(i,j,k)
          effrad = 3./((cpi*tnw*roqr/(rho*qr(i,j,k)))**.25)
! hm 8/20/12
          if(ptype.eq.5) effrad = effr(k)*1.e-4 !convert from micron to cm 
          tauqr  = w1/effrad
        ELSE
          tauqr=0.0
        END IF

        IF ( qi(i,j,k)+qs(i,j,k) >= twco ) THEN
          w1 = 1.e4*dpg*(qi(i,j,k)+qs(i,j,k))

          IF ( temp(im,jm,km) > 243.16 ) THEN
            effrad = 0.0125
          ELSE IF ( temp(im,jm,km) < 223.16 ) THEN
            effrad = 0.0025
          ELSE
            effrad = 0.0125+(temp(im,jm,km)-243.16)*0.00050
          END IF

! hm 8/20/12 overwrite with predicted effective radii
          if(ptype.eq.5) effrad = effs(k)*1.e-4
          tauqs = w1*(-0.006656 +  3.686E-4/effrad)
          if(ptype.eq.5) effrad = effi(k)*1.e-4
          tauqi = w1*(-0.011500 +  4.110E-4/effrad                      &
                                + 17.300E-8/(effrad*effrad))
! hm 8/20/12 combined cloud ice + snow effective radius
          if(ptype.eq.5) effrad = effis(k)*1.e-4 ! micron to cm
          reff1 = effrad*1.0E4
        ELSE
          tauqi = 0.0
          tauqs = 0.0
          reff1 = 0.0
        END IF

        IF ( qh(i,j,k) >= twco ) THEN
          w1     = dpg*qh(i,j,k)
          effrad = 3./((cpi*tng*roqg/(rho*qh(i,j,k)))**.25)
! hm 8/20/12
          if(ptype.eq.5) effrad = effg(k)*1.e-4 ! micron to cm
          tauqh  = w1/effrad
        ELSE
          tauqh  = 0.0
        END IF

!!!        tauswi(im,jm,km) = tauqs + tauqh
        ! GHB, bug fix (I think):  include qi  (130903)
        tauswi(im,jm,km) = tauqs + tauqh + tauqi
        tauswl(im,jm,km) = 1.5 * ( tauqc + tauqr )
        reffi (im,jm,km) = reff1
        reffl (im,jm,km) = reff2
        tauir (im,jm,km)  = 0.5 * tauswl(im,jm,km) + tauqi + tauqh
      END DO
    END DO
  END DO

  IF ( radstgr /= 0 .AND. MOD(ny,2) == 0 ) THEN
    stop 77775
  END IF

  DO jm=1,n
    DO im=1,m
      tauswi(im,jm,1) = 0.0
      tauswl(im,jm,1) = 0.0
      reffi (im,jm,1) = 0.0
      reffl (im,jm,1) = 0.0
      tauir (im,jm,1) = 0.0

      tauswi(im,jm,2) = 0.0
      tauswl(im,jm,2) = 0.0
      reffi (im,jm,2) = 0.0
      reffl (im,jm,2) = 0.0
      tauir (im,jm,2) = 0.0
    END DO
  END DO

  RETURN
END SUBROUTINE cldoptd
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE FITO3                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE fito3(nx,ny,m,n,np,pl,ao,prs0,o30,ib,ie,jb,je,kb,ke,nk)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  This subroutine is to fit o3 to the model grid
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Modified the subroutine from 1-D to 3-D
!
!-----------------------------------------------------------------------
!
!fpp$ expand (terp1)
!!dir$ inline always terp1
!*$*  inline routine (terp1)
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny,np
  INTEGER :: m,n

  REAL :: pl(nx,ny,np+1)      ! Model pressure (mb)
  REAL :: ao(nx,ny,np+1)        ! Model o3 mixing ratio (g/g)

  integer, intent(in) :: ib,ie,jb,je,kb,ke,nk
  real, dimension(ib:ie,jb:je,kb:ke) :: prs0,o30
!
!-----------------------------------------------------------------------
!
!  Local definitions
!
!-----------------------------------------------------------------------
!
  INTEGER :: lay
  PARAMETER (lay=75)

!  integer iop(2),itab(3),iflag(5)
  INTEGER :: iop(2),itab(3)

  REAL :: pa(lay)       ! Local layer pressure (mb)
  REAL :: ta(lay)       ! Local layer temperature (K)
  REAL :: wa(lay)       ! Local layer water vapor mixing ratio (g/g)
  REAL :: oa(lay)       ! Local layer o3 mixing ratio (g/g)

!  real tsi(5)
!  real w(lay)
  REAL :: tab(3)
  REAL :: wk(lay,4)

  INTEGER :: i,j,k
  INTEGER :: INT, ix
!  integer lun

!  real y
  REAL :: p
!
!----- ix=        1:trp; 2:mls; 3:mlw; 4:sas; 5:saw
!  data iflag/  1   ,  0   ,  0   ,  0   ,  0   /
!  data   tsi/ 300.0, 294.0, 272.2, 287.0, 257.1/
!
!-----------------------------------------------------------------------
!
!  Local data bank for pressure, temperature, moisture, and o3
!
!-----------------------------------------------------------------------
!
  DATA (pa(k),k=1,lay)/                                                 &
           .0003,    .0008,    .0011,    .0015,     .0021,              &
           .0029,    .0041,    .0058,    .0081,     .0113,              &
           .0158,    .0221,    .0310,    .0435,     .0609,              &
           .0855,    .1200,    .1700,    .2400,     .3350,              &
           .4650,    .6500,    .9150,   1.2850,    1.8000,              &
          2.5250,   3.5450,   4.9700,   6.9700,    9.7800,              &
         13.7150,  19.2350,  26.9850,  37.8550,   53.1000,              &
         73.8900,  97.6650, 121.4350, 145.2100,  168.9900,              &
        192.7650, 216.5400, 240.3150, 264.0900,  287.8650,              &
        311.6350, 335.4100, 359.1900, 382.9650,  406.7400,              &
        430.5150, 454.2850, 478.0600, 501.8350,  525.6100,              &
        549.3900, 573.1650, 596.9400, 620.7150,  644.4900,              &
        668.2650, 692.0350, 715.8100, 739.5850,  763.3600,              &
        787.1400, 810.9150, 834.6900, 858.4650,  882.2400,              &
        906.0150, 929.7850, 953.5600, 977.3350, 1001.1100/

  DATA (ta(k),k=1,lay)/                                                 &
        209.86, 210.20, 210.73, 211.27, 211.81,                         &
        212.35, 212.89, 213.44, 213.98, 214.53,                         &
        215.08, 215.62, 216.17, 216.74, 218.11,                         &
        223.20, 230.04, 237.14, 244.46, 252.00,                         &
        259.76, 267.70, 274.93, 274.60, 269.38,                         &
        262.94, 256.45, 250.12, 244.31, 238.96,                         &
        233.74, 228.69, 224.59, 221.75, 219.10,                         &
        216.64, 215.76, 215.75, 215.78, 216.22,                         &
        219.15, 223.79, 228.29, 232.45, 236.33,                         &
        239.92, 243.32, 246.53, 249.56, 252.43,                         &
        255.14, 257.69, 260.11, 262.39, 264.57,                         &
        266.66, 268.67, 270.60, 272.48, 274.29,                         &
        276.05, 277.75, 279.41, 281.02, 282.59,                         &
        284.09, 285.53, 286.86, 288.06, 289.13,                         &
        290.11, 291.03, 291.91, 292.76, 293.59/


  DATA (wa(k),k=1,lay)/                                                 &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.406E-05, 0.520E-05,          &
        0.115E-04, 0.275E-04, 0.572E-04, 0.107E-03, 0.166E-03,          &
        0.223E-03, 0.285E-03, 0.360E-03, 0.446E-03, 0.547E-03,          &
        0.655E-03, 0.767E-03, 0.890E-03, 0.103E-02, 0.118E-02,          &
        0.136E-02, 0.159E-02, 0.190E-02, 0.225E-02, 0.264E-02,          &
        0.306E-02, 0.351E-02, 0.399E-02, 0.450E-02, 0.504E-02,          &
        0.560E-02, 0.619E-02, 0.680E-02, 0.742E-02, 0.805E-02,          &
        0.869E-02, 0.935E-02, 0.100E-01, 0.107E-01, 0.113E-01/

  DATA (oa(k),k=1,lay)/                                                 &
       .643E-07, .202E-06, .246E-06, .290E-06, .334E-06,                &
       .378E-06, .422E-06, .467E-06, .512E-06, .557E-06,                &
       .603E-06, .648E-06, .694E-06, .740E-06, .793E-06,                &
       .101E-05, .131E-05, .164E-05, .198E-05, .234E-05,                &
       .272E-05, .312E-05, .359E-05, .465E-05, .590E-05,                &
       .765E-05, .910E-05, .960E-05, .994E-05, .101E-04,                &
       .990E-05, .853E-05, .710E-05, .576E-05, .423E-05,                &
       .260E-05, .152E-05, .102E-05, .786E-06, .598E-06,                &
       .448E-06, .352E-06, .302E-06, .252E-06, .212E-06,                &
       .193E-06, .176E-06, .160E-06, .147E-06, .137E-06,                &
       .127E-06, .118E-06, .109E-06, .103E-06, .975E-07,                &
       .924E-07, .883E-07, .846E-07, .810E-07, .778E-07,                &
       .749E-07, .721E-07, .694E-07, .671E-07, .648E-07,                &
       .626E-07, .607E-07, .593E-07, .579E-07, .565E-07,                &
       .552E-07, .540E-07, .528E-07, .517E-07, .505E-07/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ix=1

  iop(1)=4
  iop(2)=4
  INT=1

  CALL coeff(lay,pa,oa,wa,iop,INT,wk)

!$omp parallel do default(shared)  &
!$omp private(i,j,k,p,tab,itab)
  DO k=kb,ke
    DO j=jb,je
      DO i=ib,ie
        itab(1)=1
        itab(2)=0
        itab(3)=0
!!!        p = 0.5 * ( pl(i,j,k+1) + pl(i,j,k) )
        p = 0.01*prs0(i,j,k)
        CALL terp1(lay,pa,oa,wa,p,INT,tab,itab)
!!!        ao(i,j,k)=tab(1)
        o30(i,j,nk+1-k)=tab(1)
      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE fito3
!
!##################################################################
!##################################################################
!######                                                      ######
!######                   FUNCTION AERODEN                   ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

  FUNCTION aeroden(p,psfc)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Assign aerosol optical density (per Pa)
!  For now we use an estimate based on the aerosol density used
!  in simple climate models, where 0.05 of optical depth is
!  assumed uniformly distributed over mass sfc to 800 mb and
!  0.025 is uniformly distributed over mass 800 mb to 225 mb.
!
!  Here we normalize that distribution according to the
!  surface pressure so that the mountains don't lose aerosols.
!
!  Aerosol optical depth is computed by calling routine as
!  layer depth (Pa) times this aerosol density.
!
!  AUTHOR:   Keith Brewster
!
!  MODIFICATION HISTORY
!
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  REAL :: p,psfc
  REAL :: aeroden
!
  IF (p < (.225*psfc)) THEN
    aeroden=0.
  ELSE IF (p < (.80*psfc)) THEN
    aeroden=0.025/(0.575*psfc)
  ELSE
    aeroden=0.050/(0.2*psfc)
  END IF
  RETURN
  END FUNCTION aeroden

!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE JULDAY                     ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE julday( year, month, day, jday )
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Compute Julian day from year, month, and day
!
!  Start from 1 (Jan. 1) to 365, or 366 for leap year (Dec. 31)
!
!  The rule is that a year will be a leap year if
!
!    the year can be divided by 400, or
!    the year can by divided by 4, but not by 100
!
!  Form this rule year 1972, 1984, 1996, and 2000 are leap years,
!  but 1700, 1800 and 1900 are not.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  07/29/93
!
!  MODIFICATIONS:
!
!  05/06/1998 (Yuhe Liu)
!  Corrected the leap year calculation.
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    year       Reference calendar year
!    month      Reference monthe of the year
!    day        Reference day of the month
!
!    OUTPUT:
!
!    jday       Julian day, start from 1 -- Jan. 1 to 365 -- Dec. 31
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: year, month, day, jday
  INTEGER :: lpyear, lp

  INTEGER :: mndys(12)     ! Day numbers for each month
  DATA mndys/0,31,59,90,120,151,181,212,243,273,304,334/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  IF ( MOD(year,400) == 0 .OR.                                          &
         (MOD(year,4) == 0 .AND. MOD(year,100) /= 0 ) ) THEN
    lpyear = 1
  ELSE
    lpyear = 0
  END IF

  lp = 0
  IF ( month > 2 ) lp = lpyear

  jday = mndys(month) + day + lp

  RETURN
END SUBROUTINE julday

!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE ZENANGL                    ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!
SUBROUTINE zenangl(nx,ny,      hterain, cosz, cosss, a2dr2,             &
           rjday,tloc, latscl,lonscl, slpmag,slpdir,                    &
           tem1,tem2,saltitude,sazimuth,dx,dy,dtbig,curtim,             &
           ctrlat,ctrlon,year,month,day,hour,minute,second,jday)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate cosine of solar zenith angle.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu and Vince Wong
!  11/16/93
!
!  MODIFICATION HISTORY:
!  2/2/99  Vince Wong and Jik Leong
!  This modification calculates the solar declination angle and
!  equation of time using a method found on page C24 of the
!  1996 Astronomical Almanac.
!  The mothod is good to 0.01 degrees in the sky over the
!  period 1950 to 2050.
!
! augustin
!  8/23/01 Augustin Colette EFML/ Stanford University
!
! Computation of the solar altitude and azimuth
! saltitude and sazimuth are outputs of zenangl to be used in shade
! sources:
! http://www.usc.edu/dept/architecture/mbs/tools/vrsolar/Help/ &
! solar_concepts.html
! http://www.uwinnipeg.ca/~blair/physclim/lab2.htm
! http://ra.stsci.edu/cgi-bin/gethelp.cgi?altaz.src
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    nx       Number of grid points in the x-direction (east/west)
!    ny       Number of grid points in the y-direction (north/south)
!
!    x        X coordinates at scalar points
!    y        Y coordinates at scalar points
!    hterain  Surface terrain
!
!  OUTPUT:
!
!    cosz     Cosine of zenith
!    cosss    Cosine of angle between sun light and terrain slope
!    a2dr2    Square ratio of average distance to the time
!             dependent distance from the earth to the sun
!
!augustin
!    sazimuth  solar azimuth
!    saltitude solar altitude
!
!  WORK ARRAY:
!
!    rjday    Julian day at each grid point
!    tloc     Local time at each grid point
!    latscl   Latitudes  at scalar points
!    lonscl   Longitudes at scalar points
!    slpmag   Surface terrain slope magnitude
!    slpdir   Surface terrain slope direction
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny
  real :: dx,dy
  real :: dtbig,curtim
  real :: ctrlat,ctrlon
  integer :: year,month,day,hour,minute,second,jday

  REAL :: hterain(nx,ny)

  REAL :: cosz(nx,ny),   cosss(nx,ny), a2dr2(nx,ny)
  REAL :: rjday(nx,ny),  tloc(nx,ny)
  REAL :: latscl(nx,ny), lonscl(nx,ny)
  REAL :: slpmag(nx,ny), slpdir(nx,ny)
!augustin add saltitude and sazimuth in the outputs of zenanlg
  REAL :: saltitude
  REAL :: sazimuth

  REAL :: tem1(nx,ny), tem2(nx,ny)
!
!-----------------------------------------------------------------------
!
!  Include file:
!
!-----------------------------------------------------------------------
!
  INCLUDE 'radcst.incl'
  INCLUDE 'radmore.incl'
!!!  INCLUDE 'globcst.inc'
!!!  INCLUDE 'grid.inc'          ! Grid & map parameters.
!!!  INCLUDE 'phycst.inc'
!!!  INCLUDE 'mp.inc'
!
!-----------------------------------------------------------------------
!
!  Local variables:
!
!-----------------------------------------------------------------------
!
  INTEGER :: i,j

  REAL :: xs, ys

!!!  REAL :: hour0, yrday
!!!  REAL :: deg2rad, pi, pi2

  REAL :: etau, shrangl, sdeclin
  REAL :: azimuth, sinz
  REAL :: dpsi, sinpsi, cospsi

  REAL :: anncyc

  REAL :: hr, days2k, lsun, gsun, obliq, lambda, xsun, ysun
!!!  REAL :: asun, alpha, rad2deg
  REAL :: asun, alpha

  LOGICAL :: firstcall        ! First call flag of this subroutine

  include 'radzen.incl'

!!!  SAVE firstcall, hour0, pi, pi2, deg2rad, yrday, rad2deg
!!!  DATA firstcall/.true./

!!!  ! added to calculate saltitude and sazimuth at the middle domain
!!!  INTEGER :: nxmid, nymid, source 
!!!  SAVE nxmid, nymid, source

  REAL :: shrangl_mid
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!----- moved this section of code to initrad -----!
!  IF (firstcall) THEN
!    pi  = 3.14159265358979
!    pi2 = 2.0 * pi
!    deg2rad = pi/180.0
!    rad2deg = 1./deg2rad
!
!    hour0 = FLOAT(hour)                                                 &
!          + FLOAT(minute)/60.0                                          &
!          + FLOAT(second)/3600.0
!
!    IF ( MOD(year, 4) == 0 ) THEN
!      yrday = 366.
!    ELSE
!      yrday = 365.
!    END IF
!
!    nxmid = CEILING( 0.5*((nx-3)*nproc_x + 3) )   ! Middle point index at
!    nymid = CEILING( 0.5*((ny-3)*nproc_y + 3) )   ! global domain
!!!! Not using arps MPI code:  GHB, 100720
!    source = 0
!!!!    source = proc( (nxmid-2)/(nx-3)+1 + ( (nymid-2)/(ny-3) )*nproc_x )
!!!!                                ! source processor contain the middle point.
!    nxmid = MOD( (nxmid-2), (nx-3) ) + 2    ! local index of central domain
!    nymid = MOD( (nymid-2), (ny-3) ) + 2
!
!    firstcall = .false.
!  END IF

        slpmag = 0.
        slpdir = 0.
!!!  CALL sfcslp( nx,ny, hterain, slpmag,slpdir, tem1,tem2,dx,dy )

!!! not considering map projections, for now:  GHB, 100720
!  IF ( mapproj == 0 ) THEN
    DO j=1,ny
      DO i=1,nx
        latscl(i,j) = ctrlat
        lonscl(i,j) = ctrlon
      END DO
    END DO
!  ELSE
!    DO j=1,ny
!      ys = 0.5*(y(j)+y(j+1))
!      DO i=1,nx
!        xs = 0.5*(x(i)+x(i+1))
!        CALL xytoll(1,1, xs,ys, latscl(i,j), lonscl(i,j))
!      END DO
!    END DO
!  END IF
!
!-----------------------------------------------------------------------
!
!  Calculate the local time at each grid point. The
!  following formula is based on that the input time is the GMT
!  time at the reference grid point of the center.
!
!-----------------------------------------------------------------------
!
  DO j=1,ny
    DO i=1,nx

      latscl(i,j) = deg2rad * latscl(i,j)        ! lat: -90 to 90

      tloc(i,j) = hour0 + (curtim-dtbig)/3600.0                         &
                + lonscl(i,j)/15.0

      rjday(i,j) = jday + INT( tloc(i,j)/24.0 )

      tloc(i,j) = MOD( tloc(i,j), 24.0 )

      IF ( tloc(i,j) < 0. ) THEN
        tloc(i,j) = tloc(i,j) + 24.0            ! Local time
        rjday(i,j) = MOD( rjday(i,j)-1, yrday ) ! Julian day at each pts
      END IF

    END DO
  END DO

!!!  print *,'  curtim,dtbig = ',curtim,dtbig
!!!  print *,'  tloc,rjday,latscl = ',tloc(2,2),rjday(2,2),latscl(2,2)

  DO j=1,ny
    DO i=1,nx
      anncyc = pi2 * ( rjday(i,j) - 1.0 ) / yrday

      a2dr2(i,j) = 1.000110                                             &
                 + 0.034221 * COS(anncyc)                               &
                 + 0.00128  * SIN(anncyc)                               &
                 + 0.000719 * COS(2.*anncyc)                            &
                 + 0.000077 * SIN(2.*anncyc)  ! PX, Eq. 17

      hr = hour + minute / 60.

!  days before (-ve) or after (+ve) 1/1/2000
      days2k = 367 * year - 7 * ( year + ( month + 9 ) / 12 ) / 4       &
              + 275 * month / 9 + day - 730531.5 + hr / 24.

      lsun = 280.461 + 0.9856474 * days2k     ! Mean Longitude of the Sun
      950     IF ( lsun < 0 ) THEN
        lsun = lsun + 360.
        GO TO 950
      ELSE IF ( lsun > 360 ) THEN
        lsun = lsun - 360.
        GO TO 950
      END IF

      gsun = 357.528 + 0.9856003 * days2k     ! Mean anomaly of the Sun
      960     IF ( gsun < 0 ) THEN
        gsun = gsun + 360.
        GO TO 960
      ELSE IF ( gsun > 360 ) THEN
        gsun = gsun - 360.
        GO TO 960
      END IF

      lambda = lsun + 1.915 * SIN(gsun*deg2rad)  & ! Ecliptic longitude
          + 0.02 * SIN(2*gsun*deg2rad)
      970     IF ( lambda < 0 ) THEN
        lambda = lambda + 360.
        GO TO 970
      ELSE IF ( lambda > 360 ) THEN
        lambda = lambda - 360.
        GO TO 970
      END IF

      obliq = 23.439 - 0.0000004 * days2k     ! Obliquity of the ecliptic

      xsun = COS(lambda*deg2rad)
      ysun = COS(obliq*deg2rad) * SIN(lambda*deg2rad)
      asun = ATAN(ysun/xsun)*rad2deg
      IF ( xsun < 0. ) THEN
        alpha = asun + 180   ! Right Ascension (RA)
      ELSE IF ( ( ysun < 0. ) .AND. ( xsun > 0. ) ) THEN
        alpha = asun + 360
      ELSE
        alpha = asun
      END IF

      etau = ( lsun - alpha ) * 4. / 60.      ! Equation of time in hour

!    etau = 0.158 * sin( pi*(rjday(i,j)+10.)/91.25 ) ! Equation of time
!    :       + 0.125 * sin( pi*rjday(i,j)/182.5 )       ! Wong, Eq. 8

      shrangl = 15.0 * deg2rad                        & ! Hour angle
                     * ( tloc(i,j) + etau - 12.0)       ! Wong, Eq. 7

!    sdeclin = 23.5 * deg2rad
!    :          * cos( 2.0*pi*(rjday(i,j)-173.)/yrday ) ! Wong, Eq. 6
      sdeclin = ASIN(SIN(obliq*deg2rad)*SIN(lambda*deg2rad))
                                                ! Declination (in radian)

      cosz(i,j) = COS(latscl(i,j)) * COS(sdeclin) * COS(shrangl)        &
                + SIN(latscl(i,j)) * SIN(sdeclin)

!    print *, cos(latscl(i,j)),cos(sdeclin),cos(shrangl)
!    print *, sin(latscl(i,j)),sin(sdeclin)
!    print *,sdeclin,shrangl

      sinz = SIN ( ACOS(cosz(i,j)) )
!
!-----------------------------------------------------------------------
!
!  Consider the effects of the terrain slope on the solar radiation.
!  The slope magnitude and direction has been computed by subroutine
!  SFCSLP and passed in by slpmag and slpdir.
!
!-----------------------------------------------------------------------
!

      sinpsi = COS(sdeclin) * SIN(shrangl) *COS(latscl(i,j))
      cospsi = COSZ(i,j) * SIN( latscl(i,j) ) - SIN( sdeclin )
      azimuth = ATAN2( sinpsi, cospsi)

      dpsi = azimuth - slpdir(i,j)

      cosss(i,j) = COS( slpmag(i,j) ) * cosz(i,j)                       &
                 + SIN( slpmag(i,j) ) * sinz * COS( dpsi )

      cosz (i,j) = MAX( cosz (i,j), 0.0 )
      cosss(i,j) = MAX( cosss(i,j), 0.0 )

! added to calculate saltitude and sazimuth later for shading
!     IF( radshade /= 0) THEN  want azimuth regardless of shading

        IF (i == nxmid .AND. j == nymid) THEN
  
! augustin
! computes the solar altitudes and azimuth,
! sazimuth: 0=North; pi/2=East; Pi=South; 3*pi/2=West
! see the reference listed in the header of subroutine ZENANGL for more 
! information

        saltitude = pi/2-ACOS(cosz(i,j))

!  the following code is not computation safe (division by zero) DBW
!       sazimuth  = ACOS ( (SIN(sdeclin) * COS (latscl(i,j))             &
!                   - COS(sdeclin) * SIN (latscl(i,j))                   &
!                      * COS (shrangl))/sinz)

!  the above is replaced with:   DBW

        sinpsi = COS(sdeclin) * SIN(shrangl) * COS(latscl(i,j))
        cospsi = - COSZ(i,j) * SIN( latscl(i,j) ) + SIN( sdeclin )
        sazimuth = ABS( ATAN2(sinpsi, cospsi) )

!  end or replacement code  DBW

        shrangl_mid = shrangl

       END IF

 !     END IF  !  end of radshade if block..!want azimuth regardless of rshade

    END DO
  END DO

 ! IF( radshade /= 0) THEN

! broadcast these value from source to all other processors

! GHB, 100720
!!!    CALL mpbcastr(saltitude,   source)
!!!    CALL mpbcastr(sazimuth,    source)
!!!    CALL mpbcastr(shrangl_mid, source)

! modification of shrangl

! In the definition of the hour angle, shrangl  should be
! between -pi and 0 before solar noon and between 0 and pi after.
! Before this error, zenangl gave positive values
! between pi and 2*pi of shrangl
! before solar noon for some latitudes and day.
! for instance, +45 deg north March 21 2001
! it causes not problem in the original ARPS since it is just 
! a problem of module but subroutine shade needs to have shrangl 
! between -pi and pi


    IF ((shrangl_mid > pi) .AND. (shrangl_mid < pi2)) THEN
      shrangl_mid = shrangl_mid - pi2
    END IF
    IF ((shrangl_mid > pi2) .AND. (shrangl_mid < pi2+pi)) THEN
      shrangl_mid = shrangl_mid - pi2
    END IF

    IF (shrangl_mid > 0) THEN
      sazimuth = pi2 - sazimuth
    END IF

 ! END IF  !  end of radshade if block...

  RETURN
END SUBROUTINE zenangl
getcape.F       1587424407  1602  20    100644  16655     `
!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    subroutine getcape( source, nk , p_in , t_in , q_in, cape , cin,   &
                        zlcl, zlfc, zel , psource , tsource , qvsource )
    implicit none

    integer, intent(in) :: source,nk
    real, dimension(nk), intent(in) :: p_in,t_in,q_in
    real, intent(out) :: cape,cin,psource,tsource,qvsource

!-----------------------------------------------------------------------
!
!  getcape - a fortran90 subroutine to calculate Convective Available
!            Potential Energy (CAPE) from a sounding.
!
!   *** Modified version to calculate Lifted Condensation Level (LCL)  ***
!   *** Level of Free Convection (LFC), and Equilibrium Level (EL)     ***
!
!  Version 1.04                           Last modified:  8 October 2010
!
!  Author:  George H. Bryan
!           Mesoscale and Microscale Meteorology Division
!           National Center for Atmospheric Research
!           Boulder, Colorado, USA
!           gbryan@ucar.edu
!
!  Disclaimer:  This code is made available WITHOUT WARRANTY.
!
!  References:  Bolton (1980, MWR, p. 1046) (constants and definitions)
!               Bryan and Fritsch (2004, MWR, p. 2421) (ice processes)
!
!-----------------------------------------------------------------------
!
!  Input:     nk - number of levels in the sounding (integer)
!
!           p_in - one-dimensional array of pressure (mb) (real)
!
!           t_in - one-dimensional array of temperature (C) (real)
!
!           q_in - one-dimensional array of water vapor mixing ratio (kg/kg) (real)
!
!  Output:  cape - Convective Available Potential Energy (J/kg) (real)
!
!            cin - Convective Inhibition (J/kg) (real)
!
!-----------------------------------------------------------------------
!  User options:

    real, parameter :: pinc = 100.0   ! Pressure increment (Pa)
                                      ! (smaller number yields more accurate
                                      !  results,larger number makes code 
                                      !  go faster)

!!!    integer, parameter :: source = 2    ! Source parcel:
!!!                                        ! 1 = surface
!!!                                        ! 2 = most unstable (max theta-e)
!!!                                        ! 3 = mixed-layer (specify ml_depth)

    real, parameter :: ml_depth =  500.0  ! depth (m) of mixed layer 
                                          ! for source=3

    integer, parameter :: adiabat = 1   ! Formulation of moist adiabat:
                                        ! 1 = pseudoadiabatic, liquid only
                                        ! 2 = reversible, liquid only
                                        ! 3 = pseudoadiabatic, with ice
                                        ! 4 = reversible, with ice

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!            No need to modify anything below here:
!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    logical :: doit,ice,cloud,not_converged
    integer :: k,kmax,n,nloop,i,orec
    real, dimension(nk) :: p,t,td,pi,q,th,thv,z,pt,pb,pc,pn,ptv,ptd,pqv,pql

    real :: the,maxthe,parea,narea,lfc
    real :: th1,p1,t1,qv1,ql1,qi1,b1,pi1,thv1,qt,dp,dz,ps,frac
    real :: th2,p2,t2,qv2,ql2,qi2,b2,pi2,thv2
    real :: thlast,fliq,fice,tbar,qvbar,qlbar,qibar,lhv,lhs,lhf,rm,cpm
    double precision :: avgth,avgqv
    real :: getqvl,getqvi,getthx,gettd
    real :: ee,zlcl,zlfc,zel,plcl,plfc,pel,zh

!-----------------------------------------------------------------------

    real, parameter :: g     = 9.81
    real, parameter :: p00   = 100000.0
    real, parameter :: cp    = 1005.7
    real, parameter :: rd    = 287.04
    real, parameter :: rv    = 461.5
    real, parameter :: xlv   = 2501000.0
    real, parameter :: xls   = 2836017.0
    real, parameter :: t0    = 273.15
    real, parameter :: cpv   = 1875.0
    real, parameter :: cpl   = 4190.0
    real, parameter :: cpi   = 2118.636
    real, parameter :: lv1   = xlv+(cpl-cpv)*t0
    real, parameter :: lv2   = cpl-cpv
    real, parameter :: ls1   = xls+(cpi-cpv)*t0
    real, parameter :: ls2   = cpi-cpv

    real, parameter :: rp00  = 1.0/p00
    real, parameter :: eps   = rd/rv
    real, parameter :: reps  = rv/rd
    real, parameter :: rddcp = rd/cp
    real, parameter :: cpdrd = cp/rd
    real, parameter :: cpdg  = cp/g

    real, parameter :: converge = 0.0002

    integer, parameter :: debug_level =   0

!-----------------------------------------------------------------------

!---- convert p,t,td to mks units; get pi,q,th,thv ----!

    do k=1,nk
        p(k) = 100.0*p_in(k)
        t(k) = 273.15+t_in(k)
        q(k) = q_in(k)
!!!       td(k) = 273.15+td_in(k)
       ee = alog((q(k)/eps)*p(k)/100.0/(1.0+(q(k)/eps)))
       td(k) = 273.15+(243.5*ee-440.8)/(19.48-ee)
       pi(k) = (p(k)*rp00)**rddcp
!!!        q(k) = getqvl(p(k),td(k))
       th(k) = t(k)/pi(k)
      thv(k) = th(k)*(1.0+reps*q(k))/(1.0+q(k))
!!!      print *,k,t(k)-273.15,td(k)-273.15
    enddo

!---- get height using the hydrostatic equation ----!

    z(1) = 0.0
    do k=2,nk
      dz = -cpdg*0.5*(thv(k)+thv(k-1))*(pi(k)-pi(k-1))
      z(k) = z(k-1) + dz
    enddo

!----------------------------------------------------------------

!---- find source parcel ----!

  IF(source.eq.1)THEN
    ! use surface parcel
    kmax = 1

  ELSEIF(source.eq.2)THEN
    ! use most unstable parcel (max theta-e)

    IF(p(1).lt.50000.0)THEN
      ! first report is above 500 mb ... just use the first level reported
      kmax = 1
      maxthe = getthx(p(1),t(1),td(1),q(1))
    ELSE
      ! find max thetae below 500 mb
      maxthe = 0.0
      do k=1,nk
        if(p(k).ge.50000.0)then
          the = getthx(p(k),t(k),td(k),q(k))
          if( the.gt.maxthe )then
            maxthe = the
            kmax = k
          endif
        endif
      enddo
    ENDIF
    if(debug_level.ge.100) print *,'  kmax,maxthe = ',kmax,maxthe

  ELSEIF(source.eq.3)THEN
    ! use mixed layer

    IF( (z(2)-z(1)).gt.ml_depth )THEN
      ! the second level is above the mixed-layer depth:  just use the
      ! lowest level

      avgth = th(1)
      avgqv = q(1)
      kmax = 1

    ELSEIF( z(nk).lt.ml_depth )THEN
      ! the top-most level is within the mixed layer:  just use the
      ! upper-most level

      avgth = th(nk)
      avgqv = q(nk)
      kmax = nk

    ELSE
      ! calculate the mixed-layer properties:

      avgth = 0.0
      avgqv = 0.0
      k = 2
      if(debug_level.ge.100) print *,'  ml_depth = ',ml_depth
      if(debug_level.ge.100) print *,'  k,z,th,q:'
      if(debug_level.ge.100) print *,1,z(1),th(1),q(1)

      do while( (z(k).le.ml_depth) .and. (k.le.nk) )

        if(debug_level.ge.100) print *,k,z(k),th(k),q(k)

        avgth = avgth + 0.5*(z(k)-z(k-1))*(th(k)+th(k-1))
        avgqv = avgqv + 0.5*(z(k)-z(k-1))*(q(k)+q(k-1))

        k = k + 1

      enddo

      th2 = th(k-1)+(th(k)-th(k-1))*(ml_depth-z(k-1))/(z(k)-z(k-1))
      qv2 =  q(k-1)+( q(k)- q(k-1))*(ml_depth-z(k-1))/(z(k)-z(k-1))

      if(debug_level.ge.100) print *,999,ml_depth,th2,qv2

      avgth = avgth + 0.5*(ml_depth-z(k-1))*(th2+th(k-1))
      avgqv = avgqv + 0.5*(ml_depth-z(k-1))*(qv2+q(k-1))

      if(debug_level.ge.100) print *,k,z(k),th(k),q(k)

      avgth = avgth/ml_depth
      avgqv = avgqv/ml_depth

      kmax = 1

    ENDIF

    if(debug_level.ge.100) print *,avgth,avgqv

  ELSE

    print *
    print *,'  Unknown value for source'
    print *
    print *,'  source = ',source
    print *
    stop

  ENDIF

!---- define parcel properties at initial location ----!
    narea = 0.0

  if( (source.eq.1).or.(source.eq.2) )then
    k    = kmax
    th2  = th(kmax)
    pi2  = pi(kmax)
    p2   = p(kmax)
    t2   = t(kmax)
    thv2 = thv(kmax)
    qv2  = q(kmax)
    b2   = 0.0
  elseif( source.eq.3 )then
    k    = kmax
    th2  = avgth
    qv2  = avgqv
    thv2 = th2*(1.0+reps*qv2)/(1.0+qv2)
    pi2  = pi(kmax)
    p2   = p(kmax)
    t2   = th2*pi2
    b2   = g*( thv2-thv(kmax) )/thv(kmax)
  endif

    psource = p2
    tsource = t2
   qvsource = qv2

    ql2 = 0.0
    qi2 = 0.0
    qt  = qv2

    cape = 0.0
    cin  = 0.0
    lfc  = 0.0

    doit = .true.
    cloud = .false.
    if(adiabat.eq.1.or.adiabat.eq.2)then
      ice = .false.
    else
      ice = .true.
    endif

      the = getthx(p2,t2,t2,qv2)
      if(debug_level.ge.100) print *,'  the = ',the

      pt(k) = t2
      if( cloud )then
        ptd(k) = t2
      else
        ptd(k) = gettd(p2,t2,qv2)
      endif
      ptv(k) = t2*(1.0+reps*qv2)/(1.0+qv2)
      pb(k) = 0.0
      pqv(k) = qv2
      pql(k) = 0.0

      zlcl = -1.0
      zlfc = -1.0
      zel  = -1.0

!---- begin ascent of parcel ----!

      if(debug_level.ge.100)then
        print *,'  Start loop:'
        print *,'  p2,th2,qv2 = ',p2,th2,qv2
      endif

    do while( doit .and. (k.lt.nk) )

        k = k+1
       b1 =  b2

       dp = p(k-1)-p(k)

      if( dp.lt.pinc )then
        nloop = 1
      else
        nloop = 1 + int( dp/pinc )
        dp = dp/float(nloop)
      endif

      do n=1,nloop

         p1 =  p2
         t1 =  t2
        pi1 = pi2
        th1 = th2
        qv1 = qv2
        ql1 = ql2
        qi1 = qi2
        thv1 = thv2

        p2 = p2 - dp
        pi2 = (p2*rp00)**rddcp

        thlast = th1
        i = 0
        not_converged = .true.

        do while( not_converged )
          i = i + 1
          t2 = thlast*pi2
          if(ice)then
            fliq = max(min((t2-233.15)/(273.15-233.15),1.0),0.0)
            fice = 1.0-fliq
          else
            fliq = 1.0
            fice = 0.0
          endif
          qv2 = min( qt , fliq*getqvl(p2,t2) + fice*getqvi(p2,t2) )
          qi2 = max( fice*(qt-qv2) , 0.0 )
          ql2 = max( qt-qv2-qi2 , 0.0 )

          tbar  = 0.5*(t1+t2)
          qvbar = 0.5*(qv1+qv2)
          qlbar = 0.5*(ql1+ql2)
          qibar = 0.5*(qi1+qi2)

          lhv = lv1-lv2*tbar
          lhs = ls1-ls2*tbar
          lhf = lhs-lhv

          rm=rd+rv*qvbar
          cpm=cp+cpv*qvbar+cpl*qlbar+cpi*qibar
          th2=th1*exp(  lhv*(ql2-ql1)/(cpm*tbar)     &
                       +lhs*(qi2-qi1)/(cpm*tbar)     &
                       +(rm/cpm-rd/cp)*alog(p2/p1) )

          if(i.gt.90) print *,i,th2,thlast,th2-thlast
          if(i.gt.100)then
            print *
            print *,'  Error:  lack of convergence'
            print *
            print *,'  ... stopping iteration '
            print *
            stop 1001
          endif
          if( abs(th2-thlast).gt.converge )then
            thlast=thlast+0.3*(th2-thlast)
          else
            not_converged = .false.
          endif
        enddo

        ! Latest pressure increment is complete.  Calculate some
        ! important stuff:

        if( ql2.ge.1.0e-10 ) cloud = .true.
        if( cloud .and. zlcl.lt.0.0 )then
           zlcl = z(k-1)+(z(k)-z(k-1))*float(n)/float(nloop)
           plcl = p(k-1)+(p(k)-p(k-1))*float(n)/float(nloop)
        endif

        IF(adiabat.eq.1.or.adiabat.eq.3)THEN
          ! pseudoadiabat
          qt  = qv2
          ql2 = 0.0
          qi2 = 0.0
        ELSEIF(adiabat.le.0.or.adiabat.ge.5)THEN
          print *
          print *,'  Undefined adiabat'
          print *
          stop 10000
        ENDIF

      enddo

      thv2 = th2*(1.0+reps*qv2)/(1.0+qv2+ql2+qi2)
        b2 = g*( thv2-thv(k) )/thv(k)
        dz = -cpdg*0.5*(thv(k)+thv(k-1))*(pi(k)-pi(k-1))

      if( zlcl.gt.0.0 .and. zlfc.lt.0.0 .and. b2.gt.0.0 )then
        if( b1.gt.0.0 )then
          zlfc = zlcl
          plfc = plcl
        else
          zlfc = z(k-1)+(z(k)-z(k-1))*(0.0-b1)/(b2-b1)
          plfc = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
        endif
      endif

      if( zlfc.gt.0.0 .and. zel.lt.0.0 .and. b2.lt.0.0 )then
        zel = z(k-1)+(z(k)-z(k-1))*(0.0-b1)/(b2-b1)
        pel = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
      endif

      the = getthx(p2,t2,t2,qv2)

      pt(k) = t2
      if( cloud )then
        ptd(k) = t2
      else
        ptd(k) = gettd(p2,t2,qv2)
      endif
      ptv(k) = t2*(1.0+reps*qv2)/(1.0+qv2)
      pb(k) = b2
      pqv(k) = qv2
      pql(k) = ql2

      ! Get contributions to CAPE and CIN:

      if( (b2.ge.0.0) .and. (b1.lt.0.0) )then
        ! first trip into positive area
        ps = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
        frac = b2/(b2-b1)
        parea =  0.5*b2*dz*frac
        narea = narea-0.5*b1*dz*(1.0-frac)
        if(debug_level.ge.200)then
          print *,'      b1,b2 = ',b1,b2
          print *,'      p1,ps,p2 = ',p(k-1),ps,p(k)
          print *,'      frac = ',frac
          print *,'      parea = ',parea
          print *,'      narea = ',narea
        endif
        cin  = cin  + narea
        narea = 0.0
      elseif( (b2.lt.0.0) .and. (b1.gt.0.0) )then
        ! first trip into neg area
        ps = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
        frac = b1/(b1-b2)
        parea =  0.5*b1*dz*frac
        narea = -0.5*b2*dz*(1.0-frac)
        if(debug_level.ge.200)then
          print *,'      b1,b2 = ',b1,b2
          print *,'      p1,ps,p2 = ',p(k-1),ps,p(k)
          print *,'      frac = ',frac
          print *,'      parea = ',parea
          print *,'      narea = ',narea
        endif
      elseif( b2.lt.0.0 )then
        ! still collecting negative buoyancy
        parea =  0.0
        narea = narea-0.5*dz*(b1+b2)
      else
        ! still collecting positive buoyancy
        parea =  0.5*dz*(b1+b2)
        narea =  0.0
      endif

      cape = cape + max(0.0,parea)
      pc(k) = cape

      if(debug_level.ge.200)then
        write(6,102) p2,b1,b2,cape,cin,cloud
102     format(5(f13.4),2x,l1)
      endif

      if( (p(k).le.10000.0).and.(b2.lt.0.0) )then
        ! stop if b < 0 and p < 100 mb
        doit = .false.
      endif

    enddo

!!!    print *,'  zlcl,zlfc,zel = ',zlcl,zlfc,zel
!!!    print *,'  plcl,plfc,pel = ',plcl,plfc,pel

!---- All done ----!

    return
    end subroutine getcape

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function getqvl(p,t)
    implicit none

    real :: p,t,es

    real, parameter :: eps = 287.04/461.5

    es = 611.2*exp(17.67*(t-273.15)/(t-29.65))
    getqvl = eps*es/(p-es)

    return
    end function getqvl

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function getqvi(p,t)
    implicit none

    real :: p,t,es

    real, parameter :: eps = 287.04/461.5

    es = 611.2*exp(21.8745584*(t-273.15)/(t-7.66))
    getqvi = eps*es/(p-es)

    return
    end function getqvi

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function getthx(p,t,td,q)
    implicit none

    real :: p,t,td,q
    real :: tlcl

    if( (td-t).ge.-0.1 )then
      tlcl = t
    else
      tlcl = 56.0 + ( (td-56.0)**(-1) + 0.00125*alog(t/td) )**(-1)
    endif

    getthx=t*( (100000.0/p)**(0.2854*(1.0-0.28*q)) )   &
            *exp( ((3376.0/tlcl)-2.54)*q*(1.0+0.81*q) )

    return
    end function getthx

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function gettd(p,t,q)
    implicit none

    real :: p,t,q

    real :: el
    real, parameter :: eps = 287.04/461.5

    el = alog((q/eps)*p/100.0/(1.0+(q/eps)))
    gettd = 273.15+(243.5*el-440.8)/(19.48-el)

    return
    end function gettd

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

ysu.F           1587424407  1602  20    100644  58705     `
!WRF:model_layer:physics
!
!
!
!
!
!
!
module module_bl_ysu
contains
!
!
!-------------------------------------------------------------------------------
!
   subroutine ysu(u3d,v3d,th3d,t3d,qv3d,qc3d,qi3d,p3d,p3di,pi3d,               &
                  rublten,rvblten,rthblten,                                    &
                  rqvblten,rqcblten,rqiblten,flag_qi,                          &
                  cp,g,rovcp,rd,rovg,ep1,ep2,karman,xlv,lv1,lv2,rv,            &
                  dz8w,psfc,                                                   &
!!!                  znu,znw,mut,p_top,                                        &
                  znt,ust,hpbl,psim,psih,                                      &
                  xland,hfx,qfx,wspd,br,                                       &
                  dt,kpbl2d,                                                   &
                  exch_h,exch_m,                                               &
                  wstar,delta,                                                 &
                  u10,v10,                                                     &
!!!                  ctopo,ctopo2,                                                &
                  ids,ide, jds,jde, kds,kde,                                   &
                  ims,ime, jms,jme, kms,kme,                                   &
                  its,ite, jts,jte, kts,kte,                                   &
                !optional
                  regime                                           )
!-------------------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------------------
!-- u3d         3d u-velocity interpolated to theta points (m/s)
!-- v3d         3d v-velocity interpolated to theta points (m/s)
!-- th3d        3d potential temperature (k)
!-- t3d         temperature (k)
!-- qv3d        3d water vapor mixing ratio (kg/kg)
!-- qc3d        3d cloud mixing ratio (kg/kg)
!-- qi3d        3d ice mixing ratio (kg/kg)
!               (note: if P_QI<PARAM_FIRST_SCALAR this should be zero filled)
!-- p3d         3d pressure (pa)
!-- p3di        3d pressure (pa) at interface level
!-- pi3d        3d exner function (dimensionless)
!-- rr3d        3d dry air density (kg/m^3)
!-- rublten     u tendency due to
!               pbl parameterization (m/s/s)
!-- rvblten     v tendency due to
!               pbl parameterization (m/s/s)
!-- rthblten    theta tendency due to
!               pbl parameterization (K/s)
!-- rqvblten    qv tendency due to
!               pbl parameterization (kg/kg/s)
!-- rqcblten    qc tendency due to
!               pbl parameterization (kg/kg/s)
!-- rqiblten    qi tendency due to
!               pbl parameterization (kg/kg/s)
!-- cp          heat capacity at constant pressure for dry air (j/kg/k)
!-- g           acceleration due to gravity (m/s^2)
!-- rovcp       r/cp
!-- rd          gas constant for dry air (j/kg/k)
!-- rovg        r/g
!-- dz8w        dz between full levels (m)
!-- xlv         latent heat of vaporization (j/kg)
!-- rv          gas constant for water vapor (j/kg/k)
!-- psfc        pressure at the surface (pa)
!-- znt         roughness length (m)
!-- ust         u* in similarity theory (m/s)
!-- hpbl        pbl height (m)
!-- psim        similarity stability function for momentum
!-- psih        similarity stability function for heat
!-- xland       land mask (1 for land, 2 for water)
!-- hfx         upward heat flux at the surface (w/m^2)
!-- qfx         upward moisture flux at the surface (kg/m^2/s)
!-- wspd        wind speed at lowest model level (m/s)
!-- u10         u-wind speed at 10 m (m/s)
!-- v10         v-wind speed at 10 m (m/s)
!-- uoce        sea surface zonal currents (m s-1)
!-- voce        sea surface meridional currents (m s-1)
!-- br          bulk richardson number in surface layer
!-- dt          time step (s)
!-- rvovrd      r_v divided by r_d (dimensionless)
!-- ep1         constant for virtual temperature (r_v/r_d - 1)
!-- ep2         constant for specific humidity calculation
!-- karman      von karman constant
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------------------
!
   integer,parameter ::  ndiff = 3
   real,parameter    ::  rcl = 1.0
!
   integer,  intent(in   )   ::      ids,ide, jds,jde, kds,kde,                &
                                     ims,ime, jms,jme, kms,kme,                &
                                     its,ite, jts,jte, kts,kte
!
   real,     intent(in   )   ::      dt,cp,g,rovcp,rovg,rd,xlv,lv1,lv2,rv
!
   real,     intent(in )     ::      ep1,ep2,karman
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(in   )   ::                                          qv3d, &
                                                                         qc3d, &
                                                                         qi3d, &
                                                                          p3d, &
                                                                         pi3d, &
                                                                         th3d, &
                                                                          t3d, &
                                                                         dz8w
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(in   )   ::                                          p3di
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(inout)   ::                                       rublten, &
                                                                      rvblten, &
                                                                     rthblten, &
                                                                     rqvblten, &
                                                                     rqcblten
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                         , &
             intent(inout)   ::                                        exch_h,exch_m
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(inout)   ::                                         wstar
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(inout)   ::                                         delta
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(inout)   ::                                           u10, &
                                                                          v10
!
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(in   )   ::                                         xland, &
                                                                          hfx, &
                                                                          qfx, &
                                                                           br, &
                                                                         psfc
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(in   )   ::                                                &
                                                                         psim, &
                                                                         psih
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(inout)   ::                                           znt, &
                                                                          ust, &
                                                                         hpbl, &
                                                                          wspd
!
  real,      dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(in   )   ::                                           u3d, &
                                                                          v3d
!
   integer,  dimension( ims:ime, jms:jme )                                   , &
             intent(out  )   ::                                        kpbl2d
   logical,  intent(in)      ::                                       flag_qi
!
!optional
   real,     dimension( ims:ime, jms:jme )                                   , &
             optional                                                        , &
             intent(inout)   ::                                        regime
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             optional                                                        , &
             intent(inout)   ::                                       rqiblten
!
!!!   real,     dimension( kms:kme )                                            , &
!!!             optional                                                        , &
!!!             intent(in   )   ::                                           znu, &
!!!                                                                          znw
!
!!!   real,     dimension( ims:ime, jms:jme )                                   , &
!!!             optional                                                        , &
!!!             intent(in   )   ::                                           mut
!
!!!   real,     optional, intent(in   )   ::                               p_top
!
!!!   real,     dimension( ims:ime, jms:jme )                                   , &
!!!             optional                                                        , &
!!!             intent(in   )   ::                                         ctopo, &
!!!                                                                       ctopo2
!local
   integer ::  i,j,k
   real,     dimension( its:ite, kts:kte*ndiff )  ::                 rqvbl2dt, &
                                                                         qv2d
   real,     dimension( its:ite, kts:kte )  ::                            pdh
   real,     dimension( ims:ime, kms:kme )  ::                                 &
                         u2d,v2d,t2d,pi2d,dz2d,uten,vten,tten,km2d,kh2d
   real,     dimension( its:ite, kts:kte+1 )  ::                         pdhi
   real,     dimension( its:ite )  ::                                          &
                                                                        dusfc, &
                                                                        dvsfc, &
                                                                        dtsfc, &
                                                                        dqsfc
   real,     dimension( ims:ime, jms:jme )  ::                       uoce,voce
!
   qv2d = 0.0
   uoce = 0.0
   voce = 0.0

!$omp parallel do default(shared)  &
!$omp private(i,j,k,pdh,pdhi,u2d,v2d,t2d,pi2d,dz2d,qv2d,tten,uten,vten,   &
!$omp rqvbl2dt,dusfc,dvsfc,dtsfc,dqsfc,km2d,kh2d)
   do j = jts,jte
!      if(present(mut))then
!! For ARW we will replace p and p8w with dry hydrostatic pressure
!        do k = kts,kte+1
!          do i = its,ite
!             if(k.le.kte)pdh(i,k) = mut(i,j)*znu(k) + p_top
!             pdhi(i,k) = mut(i,j)*znw(k) + p_top
!          enddo
!        enddo
!      else
        do k = kts,kte+1
          do i = its,ite
             if(k.le.kte)pdh(i,k) = p3d(i,j,k)
             pdhi(i,k) = p3di(i,j,k)
          enddo
        enddo
!      endif
      do k = kts,kte
        do i = its,ite
          u2d(i,k) = u3d(i,j,k)
          v2d(i,k) = v3d(i,j,k)
          t2d(i,k) = t3d(i,j,k)
          pi2d(i,k) = pi3d(i,j,k)
          dz2d(i,k) = dz8w(i,j,k)
          qv2d(i,k) = qv3d(i,j,k)
          qv2d(i,k+kte) = qc3d(i,j,k)
          if(present(rqiblten)) qv2d(i,k+kte+kte) = qi3d(i,j,k)
        enddo
      enddo
      km2d = 0.0
      kh2d = 0.0
!
      call ysu2d(J=j,ux=u2d(ims,kms),vx=v2d(ims,kms)                           &
              ,tx=t2d(ims,kms)                                                 &
              ,qx=qv2d(its,kts)                                                &
              ,p2d=pdh(its,kts),p2di=pdhi(its,kts)                             &
              ,pi2d=pi2d(ims,kms)                                              &
              ,utnp=uten(ims,kms),vtnp=vten(ims,kms)                           &
              ,ttnp=tten(ims,kms),qtnp=rqvbl2dt(its,kts),ndiff=ndiff           &
              ,cp=cp,g=g,rovcp=rovcp,rd=rd,rovg=rovg                           &    
              ,xlv=xlv,lv1=lv1,lv2=lv2,rv=rv                                   &
              ,ep1=ep1,ep2=ep2,karman=karman                                   &
              ,dz8w2d=dz2d(ims,kms)                                            &
              ,psfcpa=psfc(ims,j),znt=znt(ims,j),ust=ust(ims,j)                &
              ,hpbl=hpbl(ims,j)                                                &
              ,regime=regime(ims,j),psim=psim(ims,j)                           &
              ,psih=psih(ims,j),xland=xland(ims,j)                             &
              ,hfx=hfx(ims,j),qfx=qfx(ims,j)                                   &
              ,wspd=wspd(ims,j),br=br(ims,j)                                   &
              ,dusfc=dusfc,dvsfc=dvsfc,dtsfc=dtsfc,dqsfc=dqsfc                 &
              ,dt=dt,rcl=1.0,kpbl1d=kpbl2d(ims,j)                              &
              ,exch_hx=kh2d(ims,kms)                                           &
              ,exch_mx=km2d(ims,kms)                                           &
              ,wstar=wstar(ims,j)                                              &
              ,delta=delta(ims,j)                                              &
              ,u10=u10(ims,j),v10=v10(ims,j)                                   &
!!!              ,ctopo=ctopo(ims,j),ctopo2=ctopo2(ims,j)                         &
              ,uox=uoce(ims,j),vox=voce(ims,j)                                 &
              ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kds,kde=kde               &
              ,ims=ims,ime=ime, jms=jms,jme=jme, kms=kms,kme=kme               &
              ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte   )
!
      do k = kts,kte
        do i = its,ite
          rthblten(i,j,k) = tten(i,k)/pi3d(i,j,k)
          rublten(i,j,k) = uten(i,k)
          rvblten(i,j,k) = vten(i,k)
          rqvblten(i,j,k) = rqvbl2dt(i,k)
          rqcblten(i,j,k) = rqvbl2dt(i,k+kte)
          if(present(rqiblten)) rqiblten(i,j,k) = rqvbl2dt(i,k+kte+kte)
          exch_h(i,j,k) = kh2d(i,k)
          exch_m(i,j,k) = km2d(i,k)
        enddo
      enddo
   enddo
!
   end subroutine ysu
!
!-------------------------------------------------------------------------------
!
   subroutine ysu2d(j,ux,vx,tx,qx,p2d,p2di,pi2d,                               &
                  utnp,vtnp,ttnp,qtnp,ndiff,                                   &
                  cp,g,rovcp,rd,rovg,ep1,ep2,karman,xlv,lv1,lv2,rv,            &
                  dz8w2d,psfcpa,                                               &
                  znt,ust,hpbl,psim,psih,                                      &
                  xland,hfx,qfx,wspd,br,                                       &
                  dusfc,dvsfc,dtsfc,dqsfc,                                     &
                  dt,rcl,kpbl1d,                                               &
                  exch_hx,                                                     &
                  exch_mx,                                                     &
                  wstar,delta,                                                 &
                  u10,v10,                                                     &
!!!                  ctopo,ctopo2,                                                &
                  uox,vox,                                                     &
                  ids,ide, jds,jde, kds,kde,                                   &
                  ims,ime, jms,jme, kms,kme,                                   &
                  its,ite, jts,jte, kts,kte,                                   &
                !optional
                  regime )
!-------------------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------------------
!
!     this code is a revised vertical diffusion package ("ysupbl")
!     with a nonlocal turbulent mixing in the pbl after "mrfpbl".
!     the ysupbl (hong et al. 2006) is based on the study of noh
!     et al.(2003) and accumulated realism of the behavior of the
!     troen and mahrt (1986) concept implemented by hong and pan(1996).
!     the major ingredient of the ysupbl is the inclusion of an explicit
!     treatment of the entrainment processes at the entrainment layer.
!     this routine uses an implicit approach for vertical flux
!     divergence and does not require "miter" timesteps.
!     it includes vertical diffusion in the stable atmosphere
!     and moist vertical diffusion in clouds.
!
!     mrfpbl:
!     coded by song-you hong (ncep), implemented by jimy dudhia (ncar)
!              fall 1996
!
!     ysupbl:
!     coded by song-you hong (yonsei university) and implemented by
!              song-you hong (yonsei university) and jimy dudhia (ncar)
!              summer 2002
!
!     further modifications :
!              an enhanced stable layer mixing, april 2008
!              ==> increase pbl height when sfc is stable (hong 2010)
!              pressure-level diffusion, april 2009
!              ==> negligible differences
!              implicit forcing for momentum with clean up, july 2009
!              ==> prevents model blowup when sfc layer is too low
!              incresea of lamda, maximum (30, 0.1 x del z) feb 2010
!              ==> prevents model blowup when delz is extremely large
!              revised prandtl number at surface, peggy lemone, feb 2010
!              ==> increase kh, decrease mixing due to counter-gradient term
!              revised thermal, shin et al. mon. wea. rev. , songyou hong, aug 2011
!              ==> reduce the thermal strength when z1 < 0.1 h
!              revised prandtl number for free convection, dudhia, mar 2012
!              ==> pr0 = 1 + bke (=0.272) when newtral, kh is reduced
!              minimum kzo = 0.01, lo = min (30m,delz), hong, mar 2012
!              ==> weaker mixing when stable, and les resolution in vertical
!              gz1oz0 is removed, and phim phih are ln(z1/z0)-phim,h, hong, mar 2012
!              ==> consider thermal z0 when differs from mechanical z0
!              a bug fix in wscale computation in stable bl, sukanta basu, jun 2012
!              ==> wscale becomes small with height, and less mixing in stable bl
!
!     references:
!
!        hong (2010) quart. j. roy. met. soc
!        hong, noh, and dudhia (2006), mon. wea. rev.
!        hong and pan (1996), mon. wea. rev.
!        noh, chun, hong, and raasch (2003), boundary layer met.
!        troen and mahrt (1986), boundary layer met.
!
!-------------------------------------------------------------------------------
!
   real,parameter    ::  xkzmin = 0.01,xkzmax = 1000.,rimin = -100.
   real,parameter    ::  rlam = 30.,prmin = 0.25,prmax = 4.
   real,parameter    ::  brcr_ub = 0.0,brcr_sb = 0.25,cori = 1.e-4
   real,parameter    ::  afac = 6.8,bfac = 6.8,pfac = 2.0,pfac_q = 2.0
   real,parameter    ::  phifac = 8.,sfcfrac = 0.1
   real,parameter    ::  d1 = 0.02, d2 = 0.05, d3 = 0.001
   real,parameter    ::  h1 = 0.33333335, h2 = 0.6666667
   real,parameter    ::  ckz = 0.001,zfmin = 1.e-8,aphi5 = 5.,aphi16 = 16.
   real,parameter    ::  tmin=1.e-2
   real,parameter    ::  gamcrt = 3.,gamcrq = 2.e-3
   real,parameter    ::  xka = 2.4e-5
   integer,parameter ::  imvdif = 1
!
   integer,  intent(in   )   ::     ids,ide, jds,jde, kds,kde,                 &
                                    ims,ime, jms,jme, kms,kme,                 &
                                    its,ite, jts,jte, kts,kte,                 &
                                    j,ndiff
!
   real,     intent(in   )   ::     dt,rcl,cp,g,rovcp,rovg,rd,xlv,lv1,lv2,rv
!
   real,     intent(in )     ::     ep1,ep2,karman
!
   real,     dimension( ims:ime, kms:kme ),                                    &
             intent(in)      ::                                        dz8w2d, &
                                                                         pi2d
!
   real,     dimension( ims:ime, kms:kme )                                   , &
             intent(in   )   ::                                            tx
   real,     dimension( its:ite, kts:kte*ndiff )                             , &
             intent(in   )   ::                                            qx
!
   real,     dimension( ims:ime, kms:kme )                                   , &
             intent(inout)   ::                                          utnp, &
                                                                         vtnp, &
                                                                         ttnp
   real,     dimension( its:ite, kts:kte*ndiff )                             , &
             intent(inout)   ::                                          qtnp
!
   real,     dimension( its:ite, kts:kte+1 )                                 , &
             intent(in   )   ::                                          p2di
!
   real,     dimension( its:ite, kts:kte )                                   , &
             intent(in   )   ::                                           p2d
!
!
   real,     dimension( ims:ime )                                            , &
             intent(inout)   ::                                           ust, &
                                                                         hpbl, &
                                                                          znt
   real,     dimension( ims:ime )                                            , &
             intent(in   )   ::                                         xland, &
                                                                          hfx, &
                                                                          qfx
!
   real,     dimension( ims:ime ), intent(inout)   ::                    wspd
   real,     dimension( ims:ime ), intent(in  )    ::                      br
!
   real,     dimension( ims:ime ), intent(in   )   ::                    psim, &
                                                                         psih
!
   real,     dimension( ims:ime ), intent(in   )   ::                  psfcpa
   integer,  dimension( ims:ime ), intent(out  )   ::                  kpbl1d
!
   real,     dimension( ims:ime, kms:kme )                                   , &
             intent(in   )   ::                                            ux, &
                                                                           vx
!!!   real,     dimension( ims:ime )                                            , &
!!!             optional                                                        , &
!!!             intent(in   )   ::                                         ctopo, &
!!!                                                                       ctopo2
   real,     dimension( ims:ime )                                            , &
             optional                                                        , &
             intent(inout)   ::                                        regime
!
! local vars
!
   real,     dimension( its:ite )            ::                           hol
   real,     dimension( its:ite, kts:kte+1 ) ::                            zq
!
   real,     dimension( its:ite, kts:kte )   ::                                &
                                                               thx,thvx,thlix, &
                                                                          del, &
                                                                          dza, &
                                                                          dzq, &
                                                                         xkzo, &
                                                                           za
!
   real,    dimension( its:ite )             ::                                &
                                                                         rhox, &
                                                                       govrth, &
                                                                  zl1,thermal, &
                                                                       wscale, &
                                                                  hgamt,hgamq, &
                                                                    brdn,brup, &
                                                                    phim,phih, &
                                                                  dusfc,dvsfc, &
                                                                  dtsfc,dqsfc, &
                                                                        prpbl, &
                                                              wspd1,thermalli
!
   real,    dimension( its:ite, kts:kte )    ::                     xkzm,xkzh, &
                                                                        f1,f2, &
                                                                        r1,r2, &
                                                                        ad,au, &
                                                                           cu, &
                                                                           al, &
                                                                         xkzq, &
                                                                         zfac, &
                                                                        rhox2, &
                                                                       hgamt2
!
!jdf added exch_hx
!
   real,    dimension( ims:ime, kms:kme )                                    , &
            intent(inout)   ::                                        exch_hx,exch_mx
!
   real,    dimension( ims:ime )                                             , &
            intent(inout)    ::                                           u10, &
                                                                          v10
   real,    dimension( ims:ime )                                             , &
            intent(in  )    ::                                            uox, &
                                                                          vox
   real,    dimension( its:ite )    ::                                         &
                                                                         brcr, &
                                                                        sflux, &
                                                                         zol1, &
                                                                    brcr_sbro
!
   real,    dimension( its:ite, kts:kte, ndiff)  ::                     r3,f3
   integer, dimension( its:ite )             ::                  kpbl,kpblold
!
   logical, dimension( its:ite )             ::                        pblflg, &
                                                                       sfcflg, &
                                                                       stable, &
                                                                     cloudflg

   logical                                   ::                     definebrup
!
   integer ::  n,i,k,l,ic,is,kk
   integer ::  klpbl, ktrace1, ktrace2, ktrace3
!
!
   real    ::  dt2,rdt,spdk2,fm,fh,hol1,gamfac,vpert,prnum,prnum0
   real    ::  ss,ri,qmean,tmean,alph,chi,zk,rl2,dk,sri
   real    ::  brint,dtodsd,dtodsu,rdz,dsdzt,dsdzq,dsdz2,rlamdz
   real    ::  utend,vtend,ttend,qtend
   real    ::  dtstep,govrthv
   real    ::  cont, conq, conw, conwrc
!

   real, dimension( its:ite, kts:kte )     ::                wscalek,wscalek2
   real, dimension( ims:ime )              ::                           wstar
   real, dimension( ims:ime )              ::                           delta
   real, dimension( its:ite, kts:kte )     ::                     xkzml,xkzhl, &
                                                               zfacent,entfac
   real, dimension( its:ite )              ::                            ust3, &
                                                                       wstar3, &
                                                                     wstar3_2, &
                                                                  hgamu,hgamv, &
                                                                      wm2, we, &
                                                                       bfxpbl, &
                                                                hfxpbl,qfxpbl, &
                                                                ufxpbl,vfxpbl, &
                                                                        dthvx
   real    ::  prnumfac,bfx0,hfx0,qfx0,delb,dux,dvx,                           &
               dsdzu,dsdzv,wm3,dthx,dqx,wspd10,ross,tem1,dsig,tvcon,conpr,     &
               prfac,prfac2,phim8z,radsum,tmp1,templ,rvls,temps,ent_eff,    &
               rcldb,bruptmp,radflux
!
!-------------------------------------------------------------------------------
!
   klpbl = kte
!
   cont=cp/g
!!!   conq=xlv/g
   conq=1.0/g
   conw=1./g
   conwrc = conw*sqrt(rcl)
   conpr = bfac*karman*sfcfrac
!
!  k-start index for tracer diffusion
!
   ktrace1 = 0
   ktrace2 = 0 + kte
   ktrace3 = 0 + kte*2
!
   do k = kts,kte
     do i = its,ite
       thx(i,k) = tx(i,k)/pi2d(i,k)
       thlix(i,k) = (tx(i,k)-xlv*qx(i,ktrace2+k)/cp-2.834E6*qx(i,ktrace3+k)/cp)/pi2d(i,k)
     enddo
   enddo
!
   do k = kts,kte
     do i = its,ite
       tvcon = (1.+ep1*qx(i,k))
       thvx(i,k) = thx(i,k)*tvcon
     enddo
   enddo
!
   do i = its,ite
     tvcon = (1.+ep1*qx(i,1))
     rhox(i) = psfcpa(i)/(rd*tx(i,1)*tvcon)
     govrth(i) = g/thx(i,1)
   enddo
!
!-----compute the height of full- and half-sigma levels above ground
!     level, and the layer thicknesses.
!
   do i = its,ite
     zq(i,1) = 0.
   enddo
!
   do k = kts,kte
     do i = its,ite
       zq(i,k+1) = dz8w2d(i,k)+zq(i,k)
       tvcon = (1.+ep1*qx(i,k))
       rhox2(i,k) = p2d(i,k)/(rd*tx(i,k)*tvcon)
     enddo
   enddo
!
   do k = kts,kte
     do i = its,ite
       za(i,k) = 0.5*(zq(i,k)+zq(i,k+1))
       dzq(i,k) = zq(i,k+1)-zq(i,k)
       del(i,k) = p2di(i,k)-p2di(i,k+1)
     enddo
   enddo
!
   do i = its,ite
     dza(i,1) = za(i,1)
   enddo
!
   do k = kts+1,kte
     do i = its,ite
       dza(i,k) = za(i,k)-za(i,k-1)
     enddo
   enddo
!
!
!-----initialize vertical tendencies and
!
   utnp(its:ite,:) = 0.
   vtnp(its:ite,:) = 0.
   ttnp(its:ite,:) = 0.
   qtnp(its:ite,:) = 0.
!
   do i = its,ite
     wspd1(i) = sqrt( (ux(i,1)-uox(i))*(ux(i,1)-uox(i)) + (vx(i,1)-vox(i))*(vx(i,1)-vox(i)) )+1.e-9
   enddo
!
!---- compute vertical diffusion
!
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     compute preliminary variables
!
   dtstep = dt
   dt2 = 2.*dtstep
   rdt = 1./dt2
!
   do i = its,ite
     bfxpbl(i) = 0.0
     hfxpbl(i) = 0.0
     qfxpbl(i) = 0.0
     ufxpbl(i) = 0.0
     vfxpbl(i) = 0.0
     hgamu(i)  = 0.0
     hgamv(i)  = 0.0
     delta(i)  = 0.0
     wstar3_2(i) =  0.0
   enddo
!
   do k = kts,klpbl
     do i = its,ite
       wscalek(i,k) = 0.0
       wscalek2(i,k) = 0.0
     enddo
   enddo
!
   do k = kts,klpbl
     do i = its,ite
       zfac(i,k) = 0.0
     enddo
   enddo
   do k = kts,klpbl-1
     do i = its,ite
       xkzo(i,k) = ckz*dza(i,k+1)
     enddo
   enddo
!
   do i = its,ite
     dusfc(i) = 0.
     dvsfc(i) = 0.
     dtsfc(i) = 0.
     dqsfc(i) = 0.
   enddo
!
   do i = its,ite
     hgamt(i)  = 0.
     hgamq(i)  = 0.
     wscale(i) = 0.
     kpbl(i)   = 1
     hpbl(i)   = zq(i,1)
     zl1(i)    = za(i,1)
     thermal(i)= thvx(i,1)
     thermalli(i) = thlix(i,1)
     pblflg(i) = .true.
     sfcflg(i) = .true.
     sflux(i) = hfx(i)/rhox(i)/cp + qfx(i)/rhox(i)*ep1*thx(i,1)
     if(br(i).gt.0.0) sfcflg(i) = .false.
   enddo
!
!     compute the first guess of pbl height
!
   do i = its,ite
     stable(i) = .false.
     brup(i) = br(i)
     brcr(i) = brcr_ub
   enddo
!
   do k = 2,klpbl
     do i = its,ite
       if(.not.stable(i))then
         brdn(i) = brup(i)
         spdk2   = max(ux(i,k)**2+vx(i,k)**2,1.)
         brup(i) = (thvx(i,k)-thermal(i))*(g*za(i,k)/thvx(i,1))/spdk2
         kpbl(i) = k
         stable(i) = brup(i).gt.brcr(i)
       endif
     enddo
   enddo
!
   do i = its,ite
     k = kpbl(i)
     if(brdn(i).ge.brcr(i))then
       brint = 0.
     elseif(brup(i).le.brcr(i))then
       brint = 1.
     else
       brint = (brcr(i)-brdn(i))/(brup(i)-brdn(i))
     endif
     hpbl(i) = za(i,k-1)+brint*(za(i,k)-za(i,k-1))
     if(hpbl(i).lt.zq(i,2)) kpbl(i) = 1
     if(kpbl(i).le.1) pblflg(i) = .false.
   enddo
!
   do i = its,ite
     fm = psim(i)
     fh = psih(i)
     zol1(i) = max(br(i)*fm*fm/(1.0e-12+fh),rimin)
     if(sfcflg(i))then
       zol1(i) = min(zol1(i),-zfmin)
     else
       zol1(i) = max(zol1(i),zfmin)
     endif
     hol1 = zol1(i)*hpbl(i)/zl1(i)*sfcfrac
     if(sfcflg(i))then
       phim(i) = (1.-aphi16*hol1)**(-1./4.)
       phih(i) = (1.-aphi16*hol1)**(-1./2.)
       bfx0 = max(sflux(i),0.)
       hfx0 = max(hfx(i)/rhox(i)/cp,0.)
       qfx0 = max(ep1*thx(i,1)*qfx(i)/rhox(i),0.)
       wstar3(i) = (govrth(i)*bfx0*hpbl(i))
       wstar(i) = (wstar3(i))**h1
     else
       phim(i) = (1.+aphi5*hol1)
       phih(i) = phim(i)
       wstar(i)  = 0.
       wstar3(i) = 0.
     endif
     ust3(i)   = ust(i)**3.
     wscale(i) = (ust3(i)+phifac*karman*wstar3(i)*0.5)**h1
     wscale(i) = min(wscale(i),ust(i)*aphi16)
     wscale(i) = max(wscale(i),ust(i)/aphi5)
   enddo
!
!     compute the surface variables for pbl height estimation
!     under unstable conditions
!
   do i = its,ite
     if(sfcflg(i).and.sflux(i).gt.0.0)then
       gamfac   = bfac/rhox(i)/wscale(i)
       hgamt(i) = min(gamfac*hfx(i)/cp,gamcrt)
       hgamq(i) = min(gamfac*qfx(i),gamcrq)
       vpert = (hgamt(i)+ep1*thx(i,1)*hgamq(i))/bfac*afac
       thermal(i) = thermal(i)+max(vpert,0.)*min(za(i,1)/(sfcfrac*hpbl(i)),1.0)
       thermalli(i)= thermalli(i)+max(vpert,0.)*min(za(i,1)/(sfcfrac*hpbl(i)),1.0)
       hgamt(i) = max(hgamt(i),0.0)
       hgamq(i) = max(hgamq(i),0.0)
       brint    = -15.9*ust(i)*ust(i)/wspd(i)*wstar3(i)/(wscale(i)**4.)
       hgamu(i) = brint*ux(i,1)
       hgamv(i) = brint*vx(i,1)
     else
       pblflg(i) = .false.
     endif
   enddo
!
!     enhance the pbl height by considering the thermal
!
   do i = its,ite
     if(pblflg(i))then
       kpbl(i) = 1
       hpbl(i) = zq(i,1)
     endif
   enddo
!
   do i = its,ite
     if(pblflg(i))then
       stable(i) = .false.
       brup(i) = br(i)
       brcr(i) = brcr_ub
     endif
   enddo
!
   do k = 2,klpbl
     do i = its,ite
       if(.not.stable(i).and.pblflg(i))then
         brdn(i) = brup(i)
         spdk2   = max(ux(i,k)**2+vx(i,k)**2,1.)
         brup(i) = (thvx(i,k)-thermal(i))*(g*za(i,k)/thvx(i,1))/spdk2
         kpbl(i) = k
         stable(i) = brup(i).gt.brcr(i)
       endif
     enddo
   enddo
!
   do i = its,ite
     if(pblflg(i)) then
       k = kpbl(i)
       if(brdn(i).ge.brcr(i))then
         brint = 0.
       elseif(brup(i).le.brcr(i))then
         brint = 1.
       else
         brint = (brcr(i)-brdn(i))/(brup(i)-brdn(i))
       endif
       hpbl(i) = za(i,k-1)+brint*(za(i,k)-za(i,k-1))
       if(hpbl(i).lt.zq(i,2)) kpbl(i) = 1
       if(kpbl(i).le.1) pblflg(i) = .false.
     endif
   enddo
!
!     stable boundary layer
!
   do i = its,ite
     if((.not.sfcflg(i)).and.hpbl(i).lt.zq(i,2)) then
       brup(i) = br(i)
       stable(i) = .false.
     else
       stable(i) = .true.
     endif
   enddo
!
   do i = its,ite
     if((.not.stable(i)).and.((xland(i)-1.5).ge.0))then
       wspd10 = u10(i)*u10(i) + v10(i)*v10(i)
       wspd10 = sqrt(wspd10)
       ross = (1.0e-10+wspd10) / (cori*znt(i))
       brcr_sbro(i) = min(0.16*(1.e-7*ross)**(-0.18),.3)
     endif
   enddo
!
   do i = its,ite
     if(.not.stable(i))then
       if((xland(i)-1.5).ge.0)then
         brcr(i) = brcr_sbro(i)
       else
         brcr(i) = brcr_sb
       endif
     endif
   enddo
!
   do k = 2,klpbl
     do i = its,ite
       if(.not.stable(i))then
         brdn(i) = brup(i)
         spdk2   = max(ux(i,k)**2+vx(i,k)**2,1.)
         brup(i) = (thvx(i,k)-thermal(i))*(g*za(i,k)/thvx(i,1))/spdk2
         kpbl(i) = k
         stable(i) = brup(i).gt.brcr(i)
       endif
     enddo
   enddo
!
   do i = its,ite
     if((.not.sfcflg(i)).and.hpbl(i).lt.zq(i,2)) then
       k = kpbl(i)
       if(brdn(i).ge.brcr(i))then
         brint = 0.
       elseif(brup(i).le.brcr(i))then
         brint = 1.
       else
         brint = (brcr(i)-brdn(i))/(brup(i)-brdn(i))
       endif
       hpbl(i) = za(i,k-1)+brint*(za(i,k)-za(i,k-1))
       if(hpbl(i).lt.zq(i,2)) kpbl(i) = 1
       if(kpbl(i).le.1) pblflg(i) = .false.
     endif
   enddo
!
!     estimate the entrainment parameters
!
   do i = its,ite
     cloudflg(i)=.false. 
     if(pblflg(i)) then
       k = kpbl(i) - 1
       wm3       = wstar3(i) + 5. * ust3(i)
       wm2(i)    = wm3**h2
       bfxpbl(i) = -0.15*thvx(i,1)/g*wm3/hpbl(i)
       dthvx(i)  = max(thvx(i,k+1)-thvx(i,k),tmin)
       we(i) = max(bfxpbl(i)/dthvx(i),-sqrt(wm2(i)))
       prpbl(i) = 1.0
       dthx  = max(thx(i,k+1)-thx(i,k),tmin)
       dqx   = min(qx(i,k+1)-qx(i,k),0.0)
       hfxpbl(i) = we(i)*dthx
       qfxpbl(i) = we(i)*dqx
!
       dux = ux(i,k+1)-ux(i,k)
       dvx = vx(i,k+1)-vx(i,k)
       if(dux.gt.tmin) then
         ufxpbl(i) = max(prpbl(i)*we(i)*dux,-ust(i)*ust(i))
       elseif(dux.lt.-tmin) then
         ufxpbl(i) = min(prpbl(i)*we(i)*dux,ust(i)*ust(i))
       else
         ufxpbl(i) = 0.0
       endif
       if(dvx.gt.tmin) then
         vfxpbl(i) = max(prpbl(i)*we(i)*dvx,-ust(i)*ust(i))
       elseif(dvx.lt.-tmin) then
         vfxpbl(i) = min(prpbl(i)*we(i)*dvx,ust(i)*ust(i))
       else
         vfxpbl(i) = 0.0
       endif
       delb  = govrth(i)*d3*hpbl(i)
       delta(i) = min(d1*hpbl(i) + d2*wm2(i)/delb,100.)
     endif
   enddo
!
   do k = kts,klpbl
     do i = its,ite
       if(pblflg(i).and.k.ge.kpbl(i))then
         entfac(i,k) = ((zq(i,k+1)-hpbl(i))/delta(i))**2.
       else
         entfac(i,k) = 1.e30
       endif
     enddo
   enddo
!
!     compute diffusion coefficients below pbl
!
   do k = kts,klpbl
     do i = its,ite
       if(k.lt.kpbl(i)) then
         zfac(i,k) = min(max((1.-(zq(i,k+1)-zl1(i))/(hpbl(i)-zl1(i))),zfmin),1.)
         zfacent(i,k) = (1.-zfac(i,k))**3.
         wscalek(i,k) = (ust3(i)+phifac*karman*wstar3(i)*(1.-zfac(i,k)))**h1
         wscalek2(i,k) = (phifac*karman*wstar3_2(i)*(zfac(i,k)))**h1
         if(sfcflg(i)) then
           prfac = conpr
           prfac2 = 15.9*(wstar3(i)+wstar3_2(i))/ust3(i)/(1.+4.*karman*(wstar3(i)+wstar3_2(i))/ust3(i))
           prnumfac = -3.*(max(zq(i,k+1)-sfcfrac*hpbl(i),0.))**2./hpbl(i)**2.
         else
           prfac = 0.
           prfac2 = 0.
           prnumfac = 0.
           phim8z = 1.+aphi5*zol1(i)*zq(i,k+1)/zl1(i)
           wscalek(i,k) = ust(i)/phim8z
           wscalek(i,k) = max(wscalek(i,k),0.001)
         endif
         prnum0 = (phih(i)/phim(i)+prfac)
         prnum0 = max(min(prnum0,prmax),prmin)
           xkzm(i,k) = wscalek(i,k) *karman*    zq(i,k+1)      *    zfac(i,k)**pfac+ &
                       wscalek2(i,k)*karman*(hpbl(i)-zq(i,k+1))*(1-zfac(i,k))**pfac
         !Do not include xkzm at kpbl-1 since it changes entrainment
         if (k.eq.kpbl(i)-1.and.cloudflg(i).and.we(i).lt.0.0) then
           xkzm(i,k) = 0.0
         endif
         prnum =  1. + (prnum0-1.)*exp(prnumfac)
         xkzq(i,k) = xkzm(i,k)/prnum*zfac(i,k)**(pfac_q-pfac)
         prnum0 = prnum0/(1.+prfac2*karman*sfcfrac)
         prnum =  1. + (prnum0-1.)*exp(prnumfac)
         xkzh(i,k) = xkzm(i,k)/prnum
         xkzm(i,k) = min(xkzm(i,k),xkzmax)
         xkzm(i,k) = max(xkzm(i,k),xkzo(i,k))
         xkzh(i,k) = min(xkzh(i,k),xkzmax)
         xkzh(i,k) = max(xkzh(i,k),xkzo(i,k))
         xkzq(i,k) = min(xkzq(i,k),xkzmax)
         xkzq(i,k) = max(xkzq(i,k),xkzo(i,k))
       endif
     enddo
   enddo
!
!     compute diffusion coefficients over pbl (free atmosphere)
!
   do k = kts,kte-1
     do i = its,ite
       if(k.ge.kpbl(i)) then
         ss = ((ux(i,k+1)-ux(i,k))*(ux(i,k+1)-ux(i,k))                         &
              +(vx(i,k+1)-vx(i,k))*(vx(i,k+1)-vx(i,k)))                        &
              /(dza(i,k+1)*dza(i,k+1))+1.e-9
         govrthv = g/(0.5*(thvx(i,k+1)+thvx(i,k)))
         ri = govrthv*(thvx(i,k+1)-thvx(i,k))/(ss*dza(i,k+1))
         if(imvdif.eq.1.and.ndiff.ge.3)then
           if((qx(i,ktrace2+k)+qx(i,ktrace3+k)).gt.0.01e-3.and.(qx(i           &
             ,ktrace2+k+1)+qx(i,ktrace3+k+1)).gt.0.01e-3)then
!      in cloud
             qmean = 0.5*(qx(i,k)+qx(i,k+1))
             tmean = 0.5*(tx(i,k)+tx(i,k+1))
!!!             alph  = xlv*qmean/rd/tmean
!!!             chi   = xlv*xlv*qmean/cp/rv/tmean/tmean
             alph  = (lv1-lv2*tmean)*qmean/rd/tmean
             chi   = (lv1-lv2*tmean)*(lv1-lv2*tmean)*qmean/cp/rv/tmean/tmean
             ri    = (1.+alph)*(ri-g*g/ss/tmean/cp*((chi-alph)/(1.+chi)))
           endif
         endif
         zk = karman*zq(i,k+1)
         rlamdz = min(max(0.1*dza(i,k+1),rlam),300.)
         rlamdz = min(dza(i,k+1),rlamdz)
         rl2 = (zk*rlamdz/(rlamdz+zk))**2
         dk = rl2*sqrt(ss)
         if(ri.lt.0.)then
! unstable regime
           ri = max(ri, rimin)
           sri = sqrt(-ri)
           xkzm(i,k) = dk*(1+8.*(-ri)/(1+1.746*sri))
           xkzh(i,k) = dk*(1+8.*(-ri)/(1+1.286*sri))
         else
! stable regime
           xkzh(i,k) = dk/(1+5.*ri)**2
           prnum = 1.0+2.1*ri
           prnum = min(prnum,prmax)
           xkzm(i,k) = xkzh(i,k)*prnum
         endif
!
         xkzm(i,k) = min(xkzm(i,k),xkzmax)
         xkzm(i,k) = max(xkzm(i,k),xkzo(i,k))
         xkzh(i,k) = min(xkzh(i,k),xkzmax)
         xkzh(i,k) = max(xkzh(i,k),xkzo(i,k))
         xkzml(i,k) = xkzm(i,k)
         xkzhl(i,k) = xkzh(i,k)
       endif
     enddo
   enddo
!
!     compute tridiagonal matrix elements for heat
!
   do k = kts,kte
     do i = its,ite
       au(i,k) = 0.
       al(i,k) = 0.
       ad(i,k) = 0.
       f1(i,k) = 0.
     enddo
   enddo
!
   do i = its,ite
     ad(i,1) = 1.
     f1(i,1) = thx(i,1)-300.+hfx(i)/cont/del(i,1)*dt2
   enddo
!
   do k = kts,kte-1
     do i = its,ite
       dtodsd = dt2/del(i,k)
       dtodsu = dt2/del(i,k+1)
       dsig   = p2d(i,k)-p2d(i,k+1)
       rdz    = 1./dza(i,k+1)
       tem1   = dsig*xkzh(i,k)*rdz
       if(pblflg(i).and.k.lt.kpbl(i)) then
         dsdzt = tem1*(-hgamt(i)/hpbl(i)-hfxpbl(i)*zfacent(i,k)/xkzh(i,k))
         f1(i,k)   = f1(i,k)+dtodsd*dsdzt
         f1(i,k+1) = thx(i,k+1)-300.-dtodsu*dsdzt
       elseif(pblflg(i).and.k.ge.kpbl(i).and.entfac(i,k).lt.4.6) then
         xkzh(i,k) = -we(i)*dza(i,kpbl(i))*exp(-entfac(i,k))
         xkzh(i,k) = sqrt(xkzh(i,k)*xkzhl(i,k))
         xkzh(i,k) = min(xkzh(i,k),xkzmax)
         xkzh(i,k) = max(xkzh(i,k),xkzo(i,k))
         f1(i,k+1) = thx(i,k+1)-300.
       else
         f1(i,k+1) = thx(i,k+1)-300.
       endif
       tem1   = dsig*xkzh(i,k)*rdz
       dsdz2     = tem1*rdz
       au(i,k)   = -dtodsd*dsdz2
       al(i,k)   = -dtodsu*dsdz2
       ad(i,k)   = ad(i,k)-au(i,k)
       ad(i,k+1) = 1.-al(i,k)
       exch_hx(i,k+1) = xkzh(i,k)
     enddo
   enddo
!
! copies here to avoid duplicate input args for tridin
!
   do k = kts,kte
     do i = its,ite
       cu(i,k) = au(i,k)
       r1(i,k) = f1(i,k)
     enddo
   enddo
!
   call tridin_ysu(al,ad,cu,r1,au,f1,its,ite,kts,kte,1)
!
!     recover tendencies of heat
!
   do k = kte,kts,-1
     do i = its,ite
       ttend = (f1(i,k)-thx(i,k)+300.)*rdt*pi2d(i,k)
       ttnp(i,k) = ttnp(i,k)+ttend
       dtsfc(i) = dtsfc(i)+ttend*cont*del(i,k)/pi2d(i,k)
     enddo
   enddo
!
!     compute tridiagonal matrix elements for moisture, clouds, and gases
!
   do k = kts,kte
     do i = its,ite
       au(i,k) = 0.
       al(i,k) = 0.
       ad(i,k) = 0.
     enddo
   enddo
!
   do ic = 1,ndiff
     do i = its,ite
       do k = kts,kte
         f3(i,k,ic) = 0.
       enddo
     enddo
   enddo
!
   do i = its,ite
     ad(i,1) = 1.
     f3(i,1,1) = qx(i,1)+qfx(i)*g/del(i,1)*dt2
   enddo
!
   if(ndiff.ge.2) then
     do ic = 2,ndiff
       is = (ic-1) * kte
       do i = its,ite
         f3(i,1,ic) = qx(i,1+is)
       enddo
     enddo
   endif
!
   do k = kts,kte-1
     do i = its,ite
       if(k.ge.kpbl(i)) then
         xkzq(i,k) = xkzh(i,k)
       endif
     enddo
   enddo
!
   do k = kts,kte-1
     do i = its,ite
       dtodsd = dt2/del(i,k)
       dtodsu = dt2/del(i,k+1)
       dsig   = p2d(i,k)-p2d(i,k+1)
       rdz    = 1./dza(i,k+1)
       tem1   = dsig*xkzq(i,k)*rdz
       if(pblflg(i).and.k.lt.kpbl(i)) then
         dsdzq = tem1*(-qfxpbl(i)*zfacent(i,k)/xkzq(i,k))
         f3(i,k,1) = f3(i,k,1)+dtodsd*dsdzq
         f3(i,k+1,1) = qx(i,k+1)-dtodsu*dsdzq
       elseif(pblflg(i).and.k.ge.kpbl(i).and.entfac(i,k).lt.4.6) then
         xkzq(i,k) = -we(i)*dza(i,kpbl(i))*exp(-entfac(i,k))
         xkzq(i,k) = sqrt(xkzq(i,k)*xkzhl(i,k))
         xkzq(i,k) = min(xkzq(i,k),xkzmax)
         xkzq(i,k) = max(xkzq(i,k),xkzo(i,k))
         f3(i,k+1,1) = qx(i,k+1)
       else
         f3(i,k+1,1) = qx(i,k+1)
       endif
       tem1   = dsig*xkzq(i,k)*rdz
       dsdz2     = tem1*rdz
       au(i,k)   = -dtodsd*dsdz2
       al(i,k)   = -dtodsu*dsdz2
       ad(i,k)   = ad(i,k)-au(i,k)
       ad(i,k+1) = 1.-al(i,k)
!      exch_hx(i,k+1) = xkzh(i,k)
     enddo
   enddo
!
   if(ndiff.ge.2) then
     do ic = 2,ndiff
       is = (ic-1) * kte
       do k = kts,kte-1
         do i = its,ite
           f3(i,k+1,ic) = qx(i,k+1+is)
         enddo
       enddo
     enddo
   endif
!
! copies here to avoid duplicate input args for tridin
!
   do k = kts,kte
     do i = its,ite
       cu(i,k) = au(i,k)
     enddo
   enddo
!
   do ic = 1,ndiff
     do k = kts,kte
       do i = its,ite
         r3(i,k,ic) = f3(i,k,ic)
       enddo
     enddo
   enddo
!
!     solve tridiagonal problem for moisture, clouds, and gases
!
   call tridin_ysu(al,ad,cu,r3,au,f3,its,ite,kts,kte,ndiff)
!
!     recover tendencies of heat and moisture
!
   do k = kte,kts,-1
     do i = its,ite
       qtend = (f3(i,k,1)-qx(i,k))*rdt
       qtnp(i,k) = qtnp(i,k)+qtend
       dqsfc(i) = dqsfc(i)+qtend*(lv1-lv2*tx(i,k))*conq*del(i,k)
     enddo
   enddo
!
   if(ndiff.ge.2) then
     do ic = 2,ndiff
       is = (ic-1) * kte
       do k = kte,kts,-1
         do i = its,ite
           qtend = (f3(i,k,ic)-qx(i,k+is))*rdt
           qtnp(i,k+is) = qtnp(i,k+is)+qtend
         enddo
       enddo
     enddo
   endif
!
!     compute tridiagonal matrix elements for momentum
!
   do i = its,ite
     do k = kts,kte
       au(i,k) = 0.
       al(i,k) = 0.
       ad(i,k) = 0.
       f1(i,k) = 0.
       f2(i,k) = 0.
     enddo
   enddo
!
   do i = its,ite
! paj: ctopo=1 if topo_wind=0 (default)
! mchen add this line to make sure NMM can still work with YSU PBL
!!!     if(present(ctopo)) then
!!!       ad(i,1) = 1.+ctopo(i)*ust(i)**2/wspd1(i)*rhox(i)*g/del(i,1)*dt2         &
!!!        *(wspd1(i)/wspd(i))**2
!!!     else
       ad(i,1) = 1.+ust(i)**2/wspd1(i)*rhox(i)*g/del(i,1)*dt2                  &
        *(wspd1(i)/wspd(i))**2
!!!     endif
     f1(i,1) = ux(i,1)+uox(i)*ust(i)**2*g/del(i,1)*dt2/wspd1(i)
     f2(i,1) = vx(i,1)+vox(i)*ust(i)**2*g/del(i,1)*dt2/wspd1(i)
   enddo
!
   do k = kts,kte-1
     do i = its,ite
       dtodsd = dt2/del(i,k)
       dtodsu = dt2/del(i,k+1)
       dsig   = p2d(i,k)-p2d(i,k+1)
       rdz    = 1./dza(i,k+1)
       tem1   = dsig*xkzm(i,k)*rdz
       if(pblflg(i).and.k.lt.kpbl(i))then
         dsdzu     = tem1*(-hgamu(i)/hpbl(i)-ufxpbl(i)*zfacent(i,k)/xkzm(i,k))
         dsdzv     = tem1*(-hgamv(i)/hpbl(i)-vfxpbl(i)*zfacent(i,k)/xkzm(i,k))
         f1(i,k)   = f1(i,k)+dtodsd*dsdzu
         f1(i,k+1) = ux(i,k+1)-dtodsu*dsdzu
         f2(i,k)   = f2(i,k)+dtodsd*dsdzv
         f2(i,k+1) = vx(i,k+1)-dtodsu*dsdzv
       elseif(pblflg(i).and.k.ge.kpbl(i).and.entfac(i,k).lt.4.6) then
         xkzm(i,k) = prpbl(i)*xkzh(i,k)
         xkzm(i,k) = sqrt(xkzm(i,k)*xkzml(i,k))
         xkzm(i,k) = min(xkzm(i,k),xkzmax)
         xkzm(i,k) = max(xkzm(i,k),xkzo(i,k))
         f1(i,k+1) = ux(i,k+1)
         f2(i,k+1) = vx(i,k+1)
       else
         f1(i,k+1) = ux(i,k+1)
         f2(i,k+1) = vx(i,k+1)
       endif
       tem1   = dsig*xkzm(i,k)*rdz
       dsdz2     = tem1*rdz
       au(i,k)   = -dtodsd*dsdz2
       al(i,k)   = -dtodsu*dsdz2
       ad(i,k)   = ad(i,k)-au(i,k)
       ad(i,k+1) = 1.-al(i,k)
       exch_mx(i,k+1) = xkzm(i,k)
     enddo
   enddo
!
! copies here to avoid duplicate input args for tridin
!
   do k = kts,kte
     do i = its,ite
       cu(i,k) = au(i,k)
       r1(i,k) = f1(i,k)
       r2(i,k) = f2(i,k)
     enddo
   enddo
!
!     solve tridiagonal problem for momentum
!
   call tridi1n(al,ad,cu,r1,r2,au,f1,f2,its,ite,kts,kte,1)
!
!     recover tendencies of momentum
!
   do k = kte,kts,-1
     do i = its,ite
       utend = (f1(i,k)-ux(i,k))*rdt
       vtend = (f2(i,k)-vx(i,k))*rdt
       utnp(i,k) = utnp(i,k)+utend
       vtnp(i,k) = vtnp(i,k)+vtend
       dusfc(i) = dusfc(i) + utend*conwrc*del(i,k)
       dvsfc(i) = dvsfc(i) + vtend*conwrc*del(i,k)
     enddo
   enddo
!
! paj: ctopo2=1 if topo_wind=0 (default)
!
!!!   do i = its,ite
!!!     if(present(ctopo).and.present(ctopo2)) then ! mchen for NMM
!!!       u10(i) = ctopo2(i)*u10(i)+(1-ctopo2(i))*ux(i,1)
!!!       v10(i) = ctopo2(i)*v10(i)+(1-ctopo2(i))*vx(i,1)
!!!     endif !mchen
!!!   enddo
!
!---- end of vertical diffusion
!
   do i = its,ite
     kpbl1d(i) = kpbl(i)
   enddo
!
!
   end subroutine ysu2d
!-------------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
   subroutine tridi1n(cl,cm,cu,r1,r2,au,f1,f2,its,ite,kts,kte,nt)
!-------------------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------------------
!
   integer, intent(in )      ::     its,ite, kts,kte, nt
!
   real, dimension( its:ite, kts+1:kte+1 )                                   , &
         intent(in   )  ::                                                 cl
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(in   )  ::                                                 cm, &
                                                                           r1
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(in   )  ::                                                 r2
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(inout)  ::                                                 au, &
                                                                           cu, &
                                                                           f1
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(inout)  ::                                                 f2
!
   real    :: fk
   integer :: i,k,l,n,it
!
!-------------------------------------------------------------------------------
!
   l = ite
   n = kte
!
   do i = its,l
     fk = 1./cm(i,1)
     au(i,1) = fk*cu(i,1)
     f1(i,1) = fk*r1(i,1)
   enddo
!
   do it = 1,nt
     do i = its,l
       fk = 1./cm(i,1)
       f2(i,1,it) = fk*r2(i,1,it)
     enddo
   enddo
!
   do k = kts+1,n-1
     do i = its,l
       fk = 1./(cm(i,k)-cl(i,k)*au(i,k-1))
       au(i,k) = fk*cu(i,k)
       f1(i,k) = fk*(r1(i,k)-cl(i,k)*f1(i,k-1))
     enddo
   enddo
!
   do it = 1,nt
     do k = kts+1,n-1
       do i = its,l
         fk = 1./(cm(i,k)-cl(i,k)*au(i,k-1))
         f2(i,k,it) = fk*(r2(i,k,it)-cl(i,k)*f2(i,k-1,it))
       enddo
     enddo
   enddo
!
   do i = its,l
     fk = 1./(cm(i,n)-cl(i,n)*au(i,n-1))
     f1(i,n) = fk*(r1(i,n)-cl(i,n)*f1(i,n-1))
   enddo
!
   do it = 1,nt
     do i = its,l
       fk = 1./(cm(i,n)-cl(i,n)*au(i,n-1))
       f2(i,n,it) = fk*(r2(i,n,it)-cl(i,n)*f2(i,n-1,it))
     enddo
   enddo
!
   do k = n-1,kts,-1
     do i = its,l
       f1(i,k) = f1(i,k)-au(i,k)*f1(i,k+1)
     enddo
   enddo
!
   do it = 1,nt
     do k = n-1,kts,-1
       do i = its,l
         f2(i,k,it) = f2(i,k,it)-au(i,k)*f2(i,k+1,it)
       enddo
     enddo
   enddo
!
   end subroutine tridi1n
!-------------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
   subroutine tridin_ysu(cl,cm,cu,r2,au,f2,its,ite,kts,kte,nt)
!-------------------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------------------
!
   integer, intent(in )      ::     its,ite, kts,kte, nt
!
   real, dimension( its:ite, kts+1:kte+1 )                                   , &
         intent(in   )  ::                                                 cl
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(in   )  ::                                                 cm
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(in   )  ::                                                 r2
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(inout)  ::                                                 au, &
                                                                           cu
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(inout)  ::                                                 f2
!
   real    :: fk
   integer :: i,k,l,n,it
!
!-------------------------------------------------------------------------------
!
   l = ite
   n = kte
!
   do it = 1,nt
     do i = its,l
       fk = 1./cm(i,1)
       au(i,1) = fk*cu(i,1)
       f2(i,1,it) = fk*r2(i,1,it)
     enddo
   enddo
!
   do it = 1,nt
     do k = kts+1,n-1
       do i = its,l
         fk = 1./(cm(i,k)-cl(i,k)*au(i,k-1))
         au(i,k) = fk*cu(i,k)
         f2(i,k,it) = fk*(r2(i,k,it)-cl(i,k)*f2(i,k-1,it))
       enddo
     enddo
   enddo
!
   do it = 1,nt
     do i = its,l
       fk = 1./(cm(i,n)-cl(i,n)*au(i,n-1))
       f2(i,n,it) = fk*(r2(i,n,it)-cl(i,n)*f2(i,n-1,it))
     enddo
   enddo
!
   do it = 1,nt
     do k = n-1,kts,-1
       do i = its,l
         f2(i,k,it) = f2(i,k,it)-au(i,k)*f2(i,k+1,it)
       enddo
     enddo
   enddo
!
   end subroutine tridin_ysu
!-------------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
   subroutine ysuinit(rublten,rvblten,rthblten,rqvblten,                       &
                      rqcblten,rqiblten,p_qi,p_first_scalar,                   &
                      restart, allowed_to_read,                                &
                      ids, ide, jds, jde, kds, kde,                            &
                      ims, ime, jms, jme, kms, kme,                            &
                      its, ite, jts, jte, kts, kte                 )
!-------------------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------------------
!
   logical , intent(in)          :: restart, allowed_to_read
   integer , intent(in)          ::  ids, ide, jds, jde, kds, kde,             &
                                     ims, ime, jms, jme, kms, kme,             &
                                     its, ite, jts, jte, kts, kte
   integer , intent(in)          ::  p_qi,p_first_scalar
   real , dimension( ims:ime , kms:kme , jms:jme ), intent(out) ::             &
                                                                      rublten, &
                                                                      rvblten, &
                                                                     rthblten, &
                                                                     rqvblten, &
                                                                     rqcblten, &
                                                                     rqiblten
   integer :: i, j, k, itf, jtf, ktf
!
   jtf = min0(jte,jde-1)
   ktf = min0(kte,kde-1)
   itf = min0(ite,ide-1)
!
   if(.not.restart)then
     do j = jts,jtf
       do k = kts,ktf
         do i = its,itf
            rublten(i,k,j) = 0.
            rvblten(i,k,j) = 0.
            rthblten(i,k,j) = 0.
            rqvblten(i,k,j) = 0.
            rqcblten(i,k,j) = 0.
         enddo
       enddo
     enddo
   endif
!
   if (p_qi .ge. p_first_scalar .and. .not.restart) then
     do j = jts,jtf
       do k = kts,ktf
         do i = its,itf
           rqiblten(i,k,j) = 0.
         enddo
       enddo
     enddo
   endif
!
   end subroutine ysuinit
!-------------------------------------------------------------------------------
end module module_bl_ysu
!-------------------------------------------------------------------------------

sfclay.F        1587424407  1602  20    100644  50166     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_sfclay

 REAL    , PARAMETER ::  VCONVC=1.
 REAL    , PARAMETER ::  CZO=0.0185
 REAL    , PARAMETER ::  OZO=1.59E-5

 REAL,   DIMENSION(0:1000 ),SAVE          :: PSIMTB,PSIHTB

CONTAINS

!-------------------------------------------------------------------
   SUBROUTINE SFCLAY(U3D,V3D,T3D,QV3D,P3D,dz8w,                    &
                     CP,G,ROVCP,R,XLV,lv1,lv2,PSFC,CHS,CHS2,CQS2,CPM, &
                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
                     FM,FH,                                        &
                     XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                     U10,V10,TH2,T2,Q2,rhocm1,                     &
                     GZ1OZ0,WSPD,BR,ISFFLX,DX,                     &
                     SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                     KARMAN,EOMEG,STBOLT,                          &
                     P1000mb,                                      &
                     ids,ide, jds,jde, kds,kde,                    &
                     ims,ime, jms,jme, kms,kme,                    &
                     its,ite, jts,jte, kts,kte,                    &
                     ustm,ck,cka,cd,cda,isftcflx,iz0tlnd           )
!-------------------------------------------------------------------
      IMPLICIT NONE
!-------------------------------------------------------------------
!   Changes in V3.7 over water surfaces: 
!          1. for ZNT/Cd, replacing constant OZO with 0.11*1.5E-5/UST(I)
!             the COARE 3.5 (Edson et al. 2013) formulation is also available
!          2. for VCONV, reducing magnitude by half
!          3. for Ck, replacing Carlson-Boland with COARE 3
!-------------------------------------------------------------------
!-- U3D         3D u-velocity interpolated to theta points (m/s)
!-- V3D         3D v-velocity interpolated to theta points (m/s)
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- dz8w        dz between full levels (m)
!-- CP          heat capacity at constant pressure for dry air (J/kg/K)
!-- G           acceleration due to gravity (m/s^2)
!-- ROVCP       R/CP
!-- R           gas constant for dry air (J/kg/K)
!-- XLV         latent heat of vaporization for water (J/kg)
!-- PSFC        surface pressure (Pa)
!-- ZNT         roughness length (m)
!-- UST         u* in similarity theory (m/s)
!-- USTM        u* in similarity theory (m/s) without vconv correction
!               used to couple with TKE scheme
!-- PBLH        PBL height from previous time (m)
!-- MAVAIL      surface moisture availability (between 0 and 1)
!-- ZOL         z/L height over Monin-Obukhov length
!-- MOL         T* (similarity theory) (K)
!-- REGIME      flag indicating PBL regime (stable, unstable, etc.)
!-- PSIM        similarity stability function for momentum
!-- PSIH        similarity stability function for heat
!-- FM          integrated stability function for momentum
!-- FH          integrated stability function for heat
!-- XLAND       land mask (1 for land, 2 for water)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          net upward latent heat flux at surface (W/m^2)
!-- TSK         surface temperature (K)
!-- FLHC        exchange coefficient for heat (W/m^2/K)
!-- FLQC        exchange coefficient for moisture (kg/m^2/s)
!-- CHS         heat/moisture exchange coefficient for LSM (m/s)
!-- QGH         lowest-level saturated mixing ratio
!-- QSFC        ground saturated mixing ratio
!-- U10         diagnostic 10m u wind
!-- V10         diagnostic 10m v wind
!-- TH2         diagnostic 2m theta (K)
!-- T2          diagnostic 2m temperature (K)
!-- Q2          diagnostic 2m mixing ratio (kg/kg)
!-- GZ1OZ0      log(z/z0) where z0 is roughness length
!-- WSPD        wind speed at lowest model level (m/s)
!-- BR          bulk Richardson number in surface layer
!-- ISFFLX      isfflx=1 for surface heat and moisture fluxes
!-- DX          horizontal grid size (m)
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- ck          enthalpy exchange coeff at 10 meters
!-- cd          momentum exchange coeff at 10 meters
!-- cka         enthalpy exchange coeff at the lowest model level
!-- cda         momentum exchange coeff at the lowest model level
!-- isftcflx    =0, (Charnock and Carlson-Boland); =1, AHW Ck, Cd, =2 Garratt
!-- iz0tlnd     =0 Carlson-Boland, =1 Czil_new
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
      INTEGER,  INTENT(IN )   ::        ids,ide, jds,jde, kds,kde, &
                                        ims,ime, jms,jme, kms,kme, &
                                        its,ite, jts,jte, kts,kte
!                                                               
      INTEGER,  INTENT(IN )   ::        ISFFLX
      REAL,     INTENT(IN )   ::        SVP1,SVP2,SVP3,SVPT0
      REAL,     INTENT(IN )   ::        EP1,EP2,KARMAN,EOMEG,STBOLT
      REAL,     INTENT(IN )   ::        P1000mb
!
      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                           dz8w
                                        
      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                           QV3D, &
                                                              P3D, &
                                                              T3D

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::             MAVAIL, &
                                                             PBLH, &
                                                            XLAND, &
                                                              TSK
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(OUT  )               ::                U10, &
                                                              V10, &
                                                              TH2, &
                                                               T2, &
                                                               Q2

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::             rhocm1

!
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)               ::             REGIME, &
                                                              HFX, &
                                                              QFX, &
                                                               LH, &
                                                             QSFC, &
                                                          MOL,RMOL
!m the following 5 are change to memory size
!
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
                                                  PSIM,PSIH,FM,FH

      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                            U3D, &
                                                              V3D
                                        
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::               PSFC, &
                                                               DX

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                            ZNT, &
                                                              ZOL, &
                                                              UST, &
                                                              CPM, &
                                                             CHS2, &
                                                             CQS2, &
                                                              CHS

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                      FLHC,FLQC

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                                 &
                                                              QGH


                                    
      REAL,     INTENT(IN   )               ::   CP,G,ROVCP,R,XLV,lv1,lv2
 
      REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme )              , &
                INTENT(OUT)     ::              ck,cka,cd,cda,ustm

      INTEGER,  OPTIONAL,  INTENT(IN )   ::     ISFTCFLX, IZ0TLND

! LOCAL VARS

      REAL,     DIMENSION( its:ite ) ::                       U1D, &
                                                              V1D, &
                                                             QV1D, &
                                                              P1D, &
                                                              T1D

      REAL,     DIMENSION( its:ite ) ::                    dz8w1d

      INTEGER ::  I,J

!$omp parallel do default(shared)   &
!$omp private(i,j,dz8w1d,u1d,v1d,qv1d,p1d,t1d)
      DO J=jts,jte
        DO i=its,ite
          dz8w1d(I) = dz8w(i,j,1)
        ENDDO
   
        DO i=its,ite
           U1D(i) =U3D(i,j,1)
           V1D(i) =V3D(i,j,1)
           QV1D(i)=QV3D(i,j,1)
           P1D(i) =P3D(i,j,1)
           T1D(i) =T3D(i,j,1)
        ENDDO

        !  Sending array starting locations of optional variables may cause
        !  troubles, so we explicitly change the call.

        CALL SFCLAY1D(J,U1D,V1D,T1D,QV1D,P1D,dz8w1d,               &
                CP,G,ROVCP,R,XLV,lv1,lv2,PSFC(ims,j),CHS(ims,j),CHS2(ims,j), &
                CQS2(ims,j),CPM(ims,j),PBLH(ims,j), RMOL(ims,j),   &
                ZNT(ims,j),UST(ims,j),MAVAIL(ims,j),ZOL(ims,j),    &
                MOL(ims,j),REGIME(ims,j),PSIM(ims,j),PSIH(ims,j),  &
                FM(ims,j),FH(ims,j),                               &
                XLAND(ims,j),HFX(ims,j),QFX(ims,j),TSK(ims,j),     &
                U10(ims,j),V10(ims,j),TH2(ims,j),T2(ims,j),        &
                Q2(ims,j),FLHC(ims,j),FLQC(ims,j),QGH(ims,j),      &
                QSFC(ims,j),LH(ims,j),rhocm1(ims,j),               &
                GZ1OZ0(ims,j),WSPD(ims,j),BR(ims,j),ISFFLX,DX(ims,j),  &
                SVP1,SVP2,SVP3,SVPT0,EP1,EP2,KARMAN,EOMEG,STBOLT,  &
                P1000mb,                                           &
                ids,ide, jds,jde, kds,kde,                         &
                ims,ime, jms,jme, kms,kme,                         &
                its,ite, jts,jte, kts,kte                          &
!!!#if ( EM_CORE == 1 )
                ,isftcflx,iz0tlnd,                                 &
                USTM(ims,j),CK(ims,j),CKA(ims,j),                  &
                CD(ims,j),CDA(ims,j)                               &
!!!#endif
                                                                   )
      ENDDO


   END SUBROUTINE SFCLAY


!-------------------------------------------------------------------
   SUBROUTINE SFCLAY1D(J,UX,VX,T1D,QV1D,P1D,dz8w1d,                &
                     CP,G,ROVCP,R,XLV,lv1,lv2,PSFCPA,CHS,CHS2,CQS2,CPM,PBLH,RMOL, &
                     ZNT,UST,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH,FM,FH,&
                     XLAND,HFX,QFX,TSK,                            &
                     U10,V10,TH2,T2,Q2,FLHC,FLQC,QGH,              &
                     QSFC,LH,rhocm1,GZ1OZ0,WSPD,BR,ISFFLX,DX,      &
                     SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                     KARMAN,EOMEG,STBOLT,                          &
                     P1000mb,                                      &
                     ids,ide, jds,jde, kds,kde,                    &
                     ims,ime, jms,jme, kms,kme,                    &
                     its,ite, jts,jte, kts,kte,                    &
                     isftcflx, iz0tlnd,                            &
                     ustm,ck,cka,cd,cda                            )
!-------------------------------------------------------------------
      IMPLICIT NONE
!-------------------------------------------------------------------
      REAL,     PARAMETER     ::        XKA=2.4E-5
      REAL,     PARAMETER     ::        PRT=1.

      INTEGER,  INTENT(IN )   ::        ids,ide, jds,jde, kds,kde, &
                                        ims,ime, jms,jme, kms,kme, &
                                        its,ite, jts,jte, kts,kte, &
                                        J
!                                                               
      INTEGER,  INTENT(IN )   ::        ISFFLX
      REAL,     INTENT(IN )   ::        SVP1,SVP2,SVP3,SVPT0
      REAL,     INTENT(IN )   ::        EP1,EP2,KARMAN,EOMEG,STBOLT
      REAL,     INTENT(IN )   ::        P1000mb

!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN   )               ::             MAVAIL, &
                                                             PBLH, &
                                                            XLAND, &
                                                              TSK
!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN   )               ::             PSFCPA, &
                                                               DX

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)               ::             REGIME, &
                                                              HFX, &
                                                              QFX, &
                                                         MOL,RMOL
!m the following 5 are changed to memory size---
!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
                                                  PSIM,PSIH,FM,FH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                            ZNT, &
                                                              ZOL, &
                                                              UST, &
                                                              CPM, &
                                                             CHS2, &
                                                             CQS2, &
                                                              CHS

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                      FLHC,FLQC

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                                 &
                                                         QSFC,QGH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(OUT)     ::                        U10,V10, &
                                                     TH2,T2,Q2,LH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN )     ::                         rhocm1

                                    
      REAL,     INTENT(IN   )               ::   CP,G,ROVCP,R,XLV,lv1,lv2

! MODULE-LOCAL VARIABLES, DEFINED IN SUBROUTINE SFCLAY
      REAL,     DIMENSION( its:ite ),  INTENT(IN   )   ::  dz8w1d

      REAL,     DIMENSION( its:ite ),  INTENT(IN   )   ::      UX, &
                                                               VX, &
                                                             QV1D, &
                                                              P1D, &
                                                              T1D
 
      REAL, OPTIONAL, DIMENSION( ims:ime )                       , &
                INTENT(OUT)     ::              ck,cka,cd,cda,ustm

      INTEGER,  OPTIONAL,  INTENT(IN )   ::     ISFTCFLX, IZ0TLND

! LOCAL VARS

      REAL,     DIMENSION( its:ite )        ::                 ZA, &
                                                        THVX,ZQKL, &
                                                           ZQKLP1, &
                                                           THX,QX, &
                                                            PSIH2, &
                                                            PSIM2, &
                                                           PSIH10, &
                                                           PSIM10, &
                                                           DENOMQ, &
                                                          DENOMQ2, &
                                                          DENOMT2, &
                                                            WSPDI, &
                                                           GZ2OZ0, &
                                                           GZ10OZ0
!
      REAL,     DIMENSION( its:ite )        ::                     &
                                                      RHOX,GOVRTH, &
                                                            TGDSA
!
      REAL,     DIMENSION( its:ite)         ::          SCR3,SCR4
      REAL,     DIMENSION( its:ite )        ::         THGB, PSFC
!
      INTEGER                               ::                 KL

      INTEGER ::  N,I,K,KK,L,NZOL,NK,NZOL2,NZOL10

      REAL    ::  PL,THCON,TVCON,E1
      REAL    ::  ZL,TSKV,DTHVDZ,DTHVM,VCONV,RZOL,RZOL2,RZOL10,ZOL2,ZOL10
      REAL    ::  DTG,PSIX,DTTHX,PSIX10,PSIT,PSIT2,PSIQ,PSIQ2,PSIQ10
      REAL    ::  FLUXC,VSGD,Z0Q,VISC,RESTAR,CZIL,GZ0OZQ,GZ0OZT
      REAL    ::  ZW, ZN1, ZN2
      REAL    ::  Z0T, CZC
!-------------------------------------------------------------------
      KL=kte

      DO i=its,ite
! PSFC cb
         PSFC(I)=PSFCPA(I)/1000.
      ENDDO
!                                                      
!----CONVERT GROUND TEMPERATURE TO POTENTIAL TEMPERATURE:  
!                                                            
      DO 5 I=its,ite                                   
        TGDSA(I)=TSK(I)                                    
! PSFC cb
!        THGB(I)=TSK(I)*(100./PSFC(I))**ROVCP                
        THGB(I)=TSK(I)*(P1000mb/PSFCPA(I))**ROVCP   
    5 CONTINUE                                               
!                                                            
!-----DECOUPLE FLUX-FORM VARIABLES TO GIVE U,V,T,THETA,THETA-VIR.,
!     T-VIR., QV, AND QC AT CROSS POINTS AND AT KTAU-1.  
!                                                                 
!     *** NOTE ***                                           
!         THE BOUNDARY WINDS MAY NOT BE ADEQUATELY AFFECTED BY FRICTION,         
!         SO USE ONLY INTERIOR VALUES OF UX AND VX TO CALCULATE 
!         TENDENCIES.                             
!                                                           
   10 CONTINUE                                                     

!     DO 24 I=its,ite
!        UX(I)=U1D(I)
!        VX(I)=V1D(I)
!  24 CONTINUE                                             
                                                             
   26 CONTINUE                                               
                                                   
!.....SCR3(I,K) STORE TEMPERATURE,                           
!     SCR4(I,K) STORE VIRTUAL TEMPERATURE.                                       
                                                                                 
      DO 30 I=its,ite
! PL cb
         PL=P1D(I)/1000.
         SCR3(I)=T1D(I)                                                   
!         THCON=(100./PL)**ROVCP                                                 
         THCON=(P1000mb*0.001/PL)**ROVCP
         THX(I)=SCR3(I)*THCON                                               
         SCR4(I)=SCR3(I)                                                    
         THVX(I)=THX(I)                                                     
         QX(I)=0.                                                             
   30 CONTINUE                                                                 
!                                                                                
      DO I=its,ite
         QGH(I)=0.                                                                
         FLHC(I)=0.                                                               
         FLQC(I)=0.                                                               
         CPM(I)=CP                                                                
      ENDDO
!                                                                                
!     IF(IDRY.EQ.1)GOTO 80                                                   
      DO 50 I=its,ite
         QX(I)=QV1D(I)                                                    
         TVCON=(1.+EP1*QX(I))                                      
         THVX(I)=THX(I)*TVCON                                               
         SCR4(I)=SCR3(I)*TVCON                                              
   50 CONTINUE                                                                 
!                                                                                
      DO 60 I=its,ite
        E1=SVP1*EXP(SVP2*(TGDSA(I)-SVPT0)/(TGDSA(I)-SVP3))                       
!  for land points QSFC can come from previous time step
        if(xland(i).gt.1.5.or.qsfc(i).le.0.0)QSFC(I)=EP2*E1/(PSFC(I)-E1)                                                 
! QGH CHANGED TO USE LOWEST-LEVEL AIR TEMP CONSISTENT WITH MYJSFC CHANGE
! Q2SAT = QGH IN LSM
        E1=SVP1*EXP(SVP2*(T1D(I)-SVPT0)/(T1D(I)-SVP3))                       
        PL=P1D(I)/1000.
        QGH(I)=EP2*E1/(PL-E1)                                                 
        CPM(I)=CP*(1.+0.8*QX(I))                                   
   60 CONTINUE                                                                   
   80 CONTINUE
                                                                                 
!-----COMPUTE THE HEIGHT OF FULL- AND HALF-SIGMA LEVELS ABOVE GROUND             
!     LEVEL, AND THE LAYER THICKNESSES.                                          
                                                                                 
      DO 90 I=its,ite
        ZQKLP1(I)=0.
!!!        RHOX(I)=PSFC(I)*1000./(R*SCR4(I))                                       
        RHOX(I)=rhocm1(i)
   90 CONTINUE                                                                   
!                                                                                
      DO 110 I=its,ite                                                   
           ZQKL(I)=dz8w1d(I)+ZQKLP1(I)
  110 CONTINUE                                                                 
!                                                                                
      DO 120 I=its,ite
         ZA(I)=0.5*(ZQKL(I)+ZQKLP1(I))                                        
  120 CONTINUE                                                                 
!                                                                                
      DO 160 I=its,ite
        GOVRTH(I)=G/THX(I)                                                    
  160 CONTINUE                                                                   
                                                                                 
!-----CALCULATE BULK RICHARDSON NO. OF SURFACE LAYER, ACCORDING TO               
!     AKB(1976), EQ(12).                                                         
                   
      DO 260 I=its,ite
        GZ1OZ0(I)=ALOG(ZA(I)/ZNT(I))                                        
        GZ2OZ0(I)=ALOG(2./ZNT(I))                                        
        GZ10OZ0(I)=ALOG(10./ZNT(I))                                        
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZL=ZNT(I)                                                            
        ELSE                                                                     
          ZL=0.01                                                                
        ENDIF                                                                    
        WSPD(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))                        

        TSKV=THGB(I)*(1.+EP1*QSFC(I))                     
        DTHVDZ=(THVX(I)-TSKV)                                                 
!  Convective velocity scale Vc and subgrid-scale velocity Vsg
!  following Beljaars (1994, QJRMS) and Mahrt and Sun (1995, MWR)
!                                ... HONG Aug. 2001
!
!       VCONV = 0.25*sqrt(g/tskv*pblh(i)*dthvm)
!      Use Beljaars over land, old MM5 (Wyngaard) formula over water
        if (xland(i).lt.1.5) then
        fluxc = max(hfx(i)/rhox(i)/cp                    &
              + ep1*tskv*qfx(i)/rhox(i),0.)
        VCONV = vconvc*(g/tgdsa(i)*pblh(i)*fluxc)**.33
        else
        IF(-DTHVDZ.GE.0)THEN
          DTHVM=-DTHVDZ
        ELSE
          DTHVM=0.
        ENDIF
!       VCONV = 2.*SQRT(DTHVM)
! V3.7: reducing contribution in calm conditions
        VCONV = SQRT(DTHVM)
        endif
! Mahrt and Sun low-res correction
        VSGD = 0.32 * (max(dx(i)/5000.-1.,0.))**.33
        WSPD(I)=SQRT(WSPD(I)*WSPD(I)+VCONV*VCONV+vsgd*vsgd)
        WSPD(I)=AMAX1(WSPD(I),0.1)
        BR(I)=GOVRTH(I)*ZA(I)*DTHVDZ/(WSPD(I)*WSPD(I))                        
!  IF PREVIOUSLY UNSTABLE, DO NOT LET INTO REGIMES 1 AND 2
        IF(MOL(I).LT.0.)BR(I)=AMIN1(BR(I),0.0)
!jdf
        RMOL(I)=-GOVRTH(I)*DTHVDZ*ZA(I)*KARMAN
!jdf

  260 CONTINUE                                                                   

!                                                                                
!-----DIAGNOSE BASIC PARAMETERS FOR THE APPROPRIATED STABILITY CLASS:            
!                                                                                
!                                                                                
!     THE STABILITY CLASSES ARE DETERMINED BY BR (BULK RICHARDSON NO.)           
!     AND HOL (HEIGHT OF PBL/MONIN-OBUKHOV LENGTH).                              
!                                                                                
!     CRITERIA FOR THE CLASSES ARE AS FOLLOWS:                                   
!                                                                                
!        1. BR .GE. 0.2;                                                         
!               REPRESENTS NIGHTTIME STABLE CONDITIONS (REGIME=1),               
!                                                                                
!        2. BR .LT. 0.2 .AND. BR .GT. 0.0;                                       
!               REPRESENTS DAMPED MECHANICAL TURBULENT CONDITIONS                
!               (REGIME=2),                                                      
!                                                                                
!        3. BR .EQ. 0.0                                                          
!               REPRESENTS FORCED CONVECTION CONDITIONS (REGIME=3),              
!                                                                                
!        4. BR .LT. 0.0                                                          
!               REPRESENTS FREE CONVECTION CONDITIONS (REGIME=4).                
!                                                                                
!CCCCC                                                                           

      DO 320 I=its,ite
!CCCCC                                                                           
!CC     REMOVE REGIME 3 DEPENDENCE ON PBL HEIGHT                                 
!CC          IF(BR(I).LT.0..AND.HOL(I,J).GT.1.5)GOTO 310                         
        IF(BR(I).LT.0.)GOTO 310                                                  
!                                                                                
!-----CLASS 1; STABLE (NIGHTTIME) CONDITIONS:                                    
!                                                                                
        IF(BR(I).LT.0.2)GOTO 270                                                 
        REGIME(I)=1.                                                           
        PSIM(I)=-10.*GZ1OZ0(I)                                                   
!    LOWER LIMIT ON PSI IN STABLE CONDITIONS                                     
        PSIM(I)=AMAX1(PSIM(I),-10.)                                              
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=10./ZA(I)*PSIM(I)
        PSIM10(I)=AMAX1(PSIM10(I),-10.)                               
        PSIH10(I)=PSIM10(I)                                          
        PSIM2(I)=2./ZA(I)*PSIM(I)
        PSIM2(I)=AMAX1(PSIM2(I),-10.)                              
        PSIH2(I)=PSIM2(I)                                         

!       1.0 over Monin-Obukhov length
        IF(UST(I).LT.0.01)THEN
           RMOL(I)=BR(I)*GZ1OZ0(I) !ZA/L
        ELSE
           RMOL(I)=KARMAN*GOVRTH(I)*ZA(I)*MOL(I)/(UST(I)*UST(I)) !ZA/L
        ENDIF
        RMOL(I)=AMIN1(RMOL(I),9.999) ! ZA/L
        RMOL(I) = RMOL(I)/ZA(I) !1.0/L

        GOTO 320                                                                 
!                                                                                
!-----CLASS 2; DAMPED MECHANICAL TURBULENCE:                                     
!                                                                                
  270   IF(BR(I).EQ.0.0)GOTO 280                                                 
        REGIME(I)=2.                                                           
        PSIM(I)=-5.0*BR(I)*GZ1OZ0(I)/(1.1-5.0*BR(I))                             
!    LOWER LIMIT ON PSI IN STABLE CONDITIONS                                     
        PSIM(I)=AMAX1(PSIM(I),-10.)                                              
!.....AKB(1976), EQ(16).                                                         
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=10./ZA(I)*PSIM(I)
        PSIM10(I)=AMAX1(PSIM10(I),-10.)                               
        PSIH10(I)=PSIM10(I)                                          
        PSIM2(I)=2./ZA(I)*PSIM(I)
        PSIM2(I)=AMAX1(PSIM2(I),-10.)                              
        PSIH2(I)=PSIM2(I)                                         

        ! Linear form: PSIM = -0.5*ZA/L; e.g, see eqn 16 of
        ! Blackadar, Modeling the nocturnal boundary layer, Preprints,
        ! Third Symposium on Atmospheric Turbulence Diffusion and Air Quality,
        ! Raleigh, NC, 1976
        ZOL(I) = BR(I)*GZ1OZ0(I)/(1.00001-5.0*BR(I))

        if ( ZOL(I) .GT. 0.5 ) then ! linear form ok
           ! Holtslag and de Bruin, J. App. Meteor 27, 689-704, 1988;
           ! see also, Launiainen, Boundary-Layer Meteor 76,165-179, 1995
           ! Eqn (8) of Launiainen, 1995
           ZOL(I) = ( 1.89*GZ1OZ0(I) + 44.2 ) * BR(I)*BR(I)    &
                + ( 1.18*GZ1OZ0(I) - 1.37 ) * BR(I)
           ZOL(I)=AMIN1(ZOL(I),9.999)
        end if

        ! 1.0 over Monin-Obukhov length
        RMOL(I)= ZOL(I)/ZA(I)

        GOTO 320                                                                 
!                                                                                
!-----CLASS 3; FORCED CONVECTION:                                                
!                                                                                
  280   REGIME(I)=3.                                                           
        PSIM(I)=0.0                                                              
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=0.                                                   
        PSIH10(I)=PSIM10(I)                                           
        PSIM2(I)=0.                                                  
        PSIH2(I)=PSIM2(I)                                           

                                                                                 
        IF(UST(I).LT.0.01)THEN                                                 
          ZOL(I)=BR(I)*GZ1OZ0(I)                                               
        ELSE                                                                     
          ZOL(I)=KARMAN*GOVRTH(I)*ZA(I)*MOL(I)/(UST(I)*UST(I)) 
        ENDIF                                                                    

        RMOL(I) = ZOL(I)/ZA(I)  

        GOTO 320                                                                 
!                                                                                
!-----CLASS 4; FREE CONVECTION:                                                  
!                                                                                
  310   CONTINUE                                                                 
        REGIME(I)=4.                                                           
        IF(UST(I).LT.0.01)THEN                                                 
          ZOL(I)=BR(I)*GZ1OZ0(I)                                               
        ELSE                                                                     
          ZOL(I)=KARMAN*GOVRTH(I)*ZA(I)*MOL(I)/(UST(I)*UST(I))
        ENDIF                                                                    
        ZOL10=10./ZA(I)*ZOL(I)                                    
        ZOL2=2./ZA(I)*ZOL(I)                                     
        ZOL(I)=AMIN1(ZOL(I),0.)                                              
        ZOL(I)=AMAX1(ZOL(I),-9.9999)                                         
        ZOL10=AMIN1(ZOL10,0.)                                          
        ZOL10=AMAX1(ZOL10,-9.9999)                                    
        ZOL2=AMIN1(ZOL2,0.)                                          
        ZOL2=AMAX1(ZOL2,-9.9999)                                    
        NZOL=INT(-ZOL(I)*100.)                                                 
        RZOL=-ZOL(I)*100.-NZOL                                                 
        NZOL10=INT(-ZOL10*100.)                                        
        RZOL10=-ZOL10*100.-NZOL10                                     
        NZOL2=INT(-ZOL2*100.)                                        
        RZOL2=-ZOL2*100.-NZOL2                                      
        PSIM(I)=PSIMTB(NZOL)+RZOL*(PSIMTB(NZOL+1)-PSIMTB(NZOL))                  
        PSIH(I)=PSIHTB(NZOL)+RZOL*(PSIHTB(NZOL+1)-PSIHTB(NZOL))                  
        PSIM10(I)=PSIMTB(NZOL10)+RZOL10*(PSIMTB(NZOL10+1)-PSIMTB(NZOL10))                                                    
        PSIH10(I)=PSIHTB(NZOL10)+RZOL10*(PSIHTB(NZOL10+1)-PSIHTB(NZOL10))
        PSIM2(I)=PSIMTB(NZOL2)+RZOL2*(PSIMTB(NZOL2+1)-PSIMTB(NZOL2))    
        PSIH2(I)=PSIHTB(NZOL2)+RZOL2*(PSIHTB(NZOL2+1)-PSIHTB(NZOL2))   

!---LIMIT PSIH AND PSIM IN THE CASE OF THIN LAYERS AND HIGH ROUGHNESS            
!---  THIS PREVENTS DENOMINATOR IN FLUXES FROM GETTING TOO SMALL                 
!       PSIH(I)=AMIN1(PSIH(I),0.9*GZ1OZ0(I))                                     
!       PSIM(I)=AMIN1(PSIM(I),0.9*GZ1OZ0(I))                                     
        PSIH(I)=AMIN1(PSIH(I),0.9*GZ1OZ0(I))
        PSIM(I)=AMIN1(PSIM(I),0.9*GZ1OZ0(I))
        PSIH2(I)=AMIN1(PSIH2(I),0.9*GZ2OZ0(I))
        PSIM10(I)=AMIN1(PSIM10(I),0.9*GZ10OZ0(I))
! AHW: mods to compute ck, cd
        PSIH10(I)=AMIN1(PSIH10(I),0.9*GZ10OZ0(I))

        RMOL(I) = ZOL(I)/ZA(I)  

  320 CONTINUE                                                                   
!                                                                                
!-----COMPUTE THE FRICTIONAL VELOCITY:                                           
!     ZA(1982) EQS(2.60),(2.61).                                                 
!                                                                                
      DO 330 I=its,ite
        DTG=THX(I)-THGB(I)                                                   
        PSIX=GZ1OZ0(I)-PSIM(I)                                                   
        PSIX10=GZ10OZ0(I)-PSIM10(I)
!     LOWER LIMIT ADDED TO PREVENT LARGE FLHC IN SOIL MODEL
!     ACTIVATES IN UNSTABLE CONDITIONS WITH THIN LAYERS OR HIGH Z0
        PSIT=AMAX1(GZ1OZ0(I)-PSIH(I),2.)

        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZL=ZNT(I)                                                            
        ELSE                                                                     
          ZL=0.01                                                                
        ENDIF                                                                    
        PSIQ=ALOG(KARMAN*UST(I)*ZA(I)/XKA+ZA(I)/ZL)-PSIH(I)   
        PSIT2=GZ2OZ0(I)-PSIH2(I)                                     
        PSIQ2=ALOG(KARMAN*UST(I)*2./XKA+2./ZL)-PSIH2(I)                                   
! AHW: mods to compute ck, cd
        PSIQ10=ALOG(KARMAN*UST(I)*10./XKA+10./ZL)-PSIH10(I)

! V3.7: using Fairall 2003 to compute z0q and z0t over water:
!       adapted from module_sf_mynn.F
        IF ( (XLAND(I)-1.5).GE.0. ) THEN
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
!             VISC=1.326e-5*(1. + 6.542e-3*SCR3(I) + 8.301e-6*SCR3(I)*SCR3(I) &
!                 - 4.84e-9*SCR3(I)*SCR3(I)*SCR3(I))
              RESTAR=UST(I)*ZNT(I)/VISC
              Z0T = (5.5e-5)*(RESTAR**(-0.60))
              Z0T = MIN(Z0T,1.0e-4)
              Z0T = MAX(Z0T,2.0e-9)
              Z0Q = Z0T

              PSIQ=max(ALOG((ZA(I)+Z0Q)/Z0Q)-PSIH(I), 2.)
              PSIT=max(ALOG((ZA(I)+Z0T)/Z0T)-PSIH(I), 2.)
              PSIQ2=max(ALOG((2.+Z0Q)/Z0Q)-PSIH2(I), 2.)
              PSIT2=max(ALOG((2.+Z0T)/Z0T)-PSIH2(I), 2.)
              PSIQ10=max(ALOG((10.+Z0Q)/Z0Q)-PSIH10(I), 2.)
        ENDIF

        IF ( PRESENT(ISFTCFLX) ) THEN
           IF ( ISFTCFLX.EQ.1 .AND. (XLAND(I)-1.5).GE.0. ) THEN
! v3.1
!             Z0Q = 1.e-4 + 1.e-3*(MAX(0.,UST(I)-1.))**2
! hfip1
!             Z0Q = 0.62*2.0E-5/UST(I) + 1.E-3*(MAX(0.,UST(I)-1.5))**2
! v3.2
              Z0Q = 1.e-4
              PSIQ=ALOG(ZA(I)/Z0Q)-PSIH(I)
              PSIT=PSIQ
              PSIQ2=ALOG(2./Z0Q)-PSIH2(I)
              PSIQ10=ALOG(10./Z0Q)-PSIH10(I)
              PSIT2=PSIQ2
           ENDIF
           IF ( ISFTCFLX.EQ.2 .AND. (XLAND(I)-1.5).GE.0. ) THEN
! AHW: Garratt formula: Calculate roughness Reynolds number
!        Kinematic viscosity of air (linear approc to
!                 temp dependence at sea level)
! GZ0OZT and GZ0OZQ are based off formulas from Brutsaert (1975), which
! Garratt (1992) used with values of k = 0.40, Pr = 0.71, and Sc = 0.60
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
!!            VISC=1.5E-5
              RESTAR=UST(I)*ZNT(I)/VISC
              GZ0OZT=0.40*(7.3*SQRT(SQRT(RESTAR))*SQRT(0.71)-5.)
              GZ0OZQ=0.40*(7.3*SQRT(SQRT(RESTAR))*SQRT(0.60)-5.)
              PSIT=GZ1OZ0(I)-PSIH(I)+GZ0OZT
              PSIQ=GZ1OZ0(I)-PSIH(I)+GZ0OZQ
              PSIT2=GZ2OZ0(I)-PSIH2(I)+GZ0OZT
              PSIQ2=GZ2OZ0(I)-PSIH2(I)+GZ0OZQ
              PSIQ10=GZ10OZ0(I)-PSIH(I)+GZ0OZQ
           ENDIF
        ENDIF
        IF(PRESENT(ck) .and. PRESENT(cd) .and. PRESENT(cka) .and. PRESENT(cda)) THEN
           Ck(I)=(karman/psix10)*(karman/psiq10)
           Cd(I)=(karman/psix10)*(karman/psix10)
           Cka(I)=(karman/psix)*(karman/psiq)
           Cda(I)=(karman/psix)*(karman/psix)
        ENDIF
        IF ( PRESENT(IZ0TLND) ) THEN
           IF ( IZ0TLND.EQ.1 .AND. (XLAND(I)-1.5).LE.0. ) THEN
              ZL=ZNT(I)
!             CZIL RELATED CHANGES FOR LAND
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
              RESTAR=UST(I)*ZL/VISC
!             Modify CZIL according to Chen & Zhang, 2009

              CZIL = 10.0 ** ( -0.40 * ( ZL / 0.07 ) )

              PSIT=GZ1OZ0(I)-PSIH(I)+CZIL*KARMAN*SQRT(RESTAR)
              PSIQ=GZ1OZ0(I)-PSIH(I)+CZIL*KARMAN*SQRT(RESTAR)
              PSIT2=GZ2OZ0(I)-PSIH2(I)+CZIL*KARMAN*SQRT(RESTAR)
              PSIQ2=GZ2OZ0(I)-PSIH2(I)+CZIL*KARMAN*SQRT(RESTAR)

           ENDIF
        ENDIF
! TO PREVENT OSCILLATIONS AVERAGE WITH OLD VALUE 
        UST(I)=0.5*UST(I)+0.5*KARMAN*WSPD(I)/PSIX                                             
! TKE coupling: compute ust without vconv for use in tke scheme
        WSPDI(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))
        IF ( PRESENT(USTM) ) THEN
        USTM(I)=0.5*USTM(I)+0.5*KARMAN*WSPDI(I)/PSIX
        ENDIF
        U10(I)=UX(I)*PSIX10/PSIX                                    
        V10(I)=VX(I)*PSIX10/PSIX                                   
        TH2(I)=THGB(I)+DTG*PSIT2/PSIT                                
        Q2(I)=QSFC(I)+(QX(I)-QSFC(I))*PSIQ2/PSIQ                   
!        T2(I) = TH2(I)*(PSFC(I)/100.)**ROVCP                     
        T2(I) = TH2(I)*(PSFCPA(I)/P1000mb)**ROVCP                     
!       LATER Q2 WILL BE OVERWRITTEN FOR LAND POINTS IN SURFCE     
!       QA2(I,J) = Q2(I)                                         
!       UA10(I,J) = U10(I)                                      
!       VA10(I,J) = V10(I)                                     
!       write(*,1002)UST(I),KARMAN*WSPD(I),PSIX,KARMAN*WSPD(I)/PSIX
!                                                                                
        IF((XLAND(I)-1.5).LT.0.)THEN                                            
          UST(I)=AMAX1(UST(I),0.1)
        ENDIF                                                                    
        MOL(I)=KARMAN*DTG/PSIT/PRT                              
        DENOMQ(I)=PSIQ
        DENOMQ2(I)=PSIQ2
        DENOMT2(I)=PSIT2
        FM(I)=PSIX
        FH(I)=PSIT
  330 CONTINUE                                                                   
!                                                                                
  335 CONTINUE                                                                   
                                                                                  
!-----COMPUTE THE SURFACE SENSIBLE AND LATENT HEAT FLUXES:                       
      DO i=its,ite
        QFX(i)=0.                                                              
        HFX(i)=0.                                                              
      ENDDO
  350 CONTINUE

      IF (ISFFLX.EQ.0) GOTO 410                                                
                                                                                 
!-----OVER WATER, ALTER ROUGHNESS LENGTH (ZNT) ACCORDING TO WIND (UST).
                                                                                 
      DO 360 I=its,ite
        IF((XLAND(I)-1.5).GE.0)THEN                                            
!         ZNT(I)=CZO*UST(I)*UST(I)/G+OZO                                   
! Since V3.7 (ref: EC Physics document for Cy36r1)
          ZNT(I)=CZO*UST(I)*UST(I)/G+0.11*1.5E-5/UST(I)
! COARE 3.5 (Edson et al. 2013)
!         CZC = 0.0017*WSPD(I)-0.005
!         CZC = min(CZC,0.028)
!         ZNT(I)=CZC*UST(I)*UST(I)/G+0.11*1.5E-5/UST(I)
! AHW: change roughness length, and hence the drag coefficients Ck and Cd
          IF ( PRESENT(ISFTCFLX) ) THEN
             IF ( ISFTCFLX.NE.0 ) THEN
!               ZNT(I)=10.*exp(-9.*UST(I)**(-.3333))
!               ZNT(I)=10.*exp(-9.5*UST(I)**(-.3333))
!               ZNT(I)=ZNT(I) + 0.11*1.5E-5/AMAX1(UST(I),0.01)
!               ZNT(I)=0.011*UST(I)*UST(I)/G+OZO
!               ZNT(I)=MAX(ZNT(I),3.50e-5)
! AHW 2012:
                ZW  = MIN((UST(I)/1.06)**(0.3),1.0)
                ZN1 = 0.011*UST(I)*UST(I)/G + OZO
                ZN2 = 10.*exp(-9.5*UST(I)**(-.3333)) + &
                       0.11*1.5E-5/AMAX1(UST(I),0.01)
                ZNT(I)=(1.0-ZW) * ZN1 + ZW * ZN2
                ZNT(I)=MIN(ZNT(I),2.85e-3)
                ZNT(I)=MAX(ZNT(I),1.27e-7)
             ENDIF
          ENDIF
          ZL = ZNT(I)
        ELSE
          ZL = 0.01
        ENDIF                                                                    
        FLQC(I)=RHOX(I)*MAVAIL(I)*UST(I)*KARMAN/DENOMQ(I)
!       FLQC(I)=RHOX(I)*MAVAIL(I)*UST(I)*KARMAN/(   &
!               ALOG(KARMAN*UST(I)*ZA(I)/XKA+ZA(I)/ZL)-PSIH(I))
        DTTHX=ABS(THX(I)-THGB(I))                                            
        IF(DTTHX.GT.1.E-5)THEN                                                   
          FLHC(I)=CPM(I)*RHOX(I)*UST(I)*MOL(I)/(THX(I)-THGB(I))          
!         write(*,1001)FLHC(I),CPM(I),RHOX(I),UST(I),MOL(I),THX(I),THGB(I),I
 1001   format(f8.5,2x,f12.7,2x,f13.10,2x,f13.10,2x,f13.10,2x,f12.8,f12.8,2x,i3)
        ELSE                                                                     
          FLHC(I)=0.                                                             
        ENDIF                                                                    
  360 CONTINUE

!                                                                                
!-----COMPUTE SURFACE MOIST FLUX:                                                
!                                                                                
!     IF(IDRY.EQ.1)GOTO 390                                                
!                                                                                
      DO 370 I=its,ite
        QFX(I)=FLQC(I)*(QSFC(I)-QX(I))                                     
        QFX(I)=AMAX1(QFX(I),0.)                                            
        LH(I)=( lv1-lv2*tsk(I) )*QFX(I)
  370 CONTINUE                                                                 
                                                                                
!-----COMPUTE SURFACE HEAT FLUX:                                                 
!                                                                                
  390 CONTINUE                                                                 
      DO 400 I=its,ite
        IF(XLAND(I)-1.5.GT.0.)THEN                                           
          HFX(I)=FLHC(I)*(THGB(I)-THX(I))                                
!!!  GHB: in CM1, dissipative heating is handled elsewhere
!!!          IF ( PRESENT(ISFTCFLX) ) THEN
!!!             IF ( ISFTCFLX.NE.0 ) THEN
!!!! AHW: add dissipative heating term
!!!                HFX(I)=HFX(I)+RHOX(I)*USTM(I)*USTM(I)*WSPDI(I)
!!!             ENDIF
!!!          ENDIF
        ELSEIF(XLAND(I)-1.5.LT.0.)THEN                                       
          HFX(I)=FLHC(I)*(THGB(I)-THX(I))                                
          HFX(I)=AMAX1(HFX(I),-250.)                                       
        ENDIF                                                                  
  400 CONTINUE                                                                 

  405 CONTINUE                                                                 
         
      DO I=its,ite
         IF((XLAND(I)-1.5).GE.0)THEN
           ZL=ZNT(I)
         ELSE
           ZL=0.01
         ENDIF
         CHS(I)=UST(I)*KARMAN/DENOMQ(I)
!        GZ2OZ0(I)=ALOG(2./ZNT(I))
!        PSIM2(I)=-10.*GZ2OZ0(I)
!        PSIM2(I)=AMAX1(PSIM2(I),-10.)
!        PSIH2(I)=PSIM2(I)
         CQS2(I)=UST(I)*KARMAN/DENOMQ2(I)
         CHS2(I)=UST(I)*KARMAN/DENOMT2(I)
      ENDDO
                                                                        
  410 CONTINUE                                                                   
!jdf
!     DO I=its,ite
!       IF(UST(I).GE.0.1) THEN
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(UST(I)*UST(I)*UST(I))
!       ELSE
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(0.1*0.1*0.1)
!       ENDIF
!     ENDDO
!jdf

!                                                                                
   END SUBROUTINE SFCLAY1D

!====================================================================
!!!   SUBROUTINE sfclayinit( allowed_to_read )         
   SUBROUTINE sfclayinit( )

!!!   LOGICAL , INTENT(IN)      ::      allowed_to_read
   INTEGER                   ::      N
   REAL                      ::      ZOLN,X,Y

   DO N=0,1000
      ZOLN=-FLOAT(N)*0.01
      X=(1-16.*ZOLN)**0.25
      PSIMTB(N)=2*ALOG(0.5*(1+X))+ALOG(0.5*(1+X*X))- &
                2.*ATAN(X)+2.*ATAN(1.)
      Y=(1-16*ZOLN)**0.5
      PSIHTB(N)=2*ALOG(0.5*(1+Y))
   ENDDO

   END SUBROUTINE sfclayinit

!-------------------------------------------------------------------          

END MODULE module_sf_sfclay
sfclayrev.F     1587424407  1602  20    100644  55097     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_sfclayrev

 REAL    , PARAMETER ::  VCONVC=1.
 REAL    , PARAMETER ::  CZO=0.0185
 REAL    , PARAMETER ::  OZO=1.59E-5

 REAL,   DIMENSION(0:1000 ),SAVE :: psim_stab,psim_unstab,psih_stab,psih_unstab

CONTAINS

!-------------------------------------------------------------------
   SUBROUTINE SFCLAYREV(U3D,V3D,T3D,QV3D,P3D,dz8w,                    &
                     CP,G,ROVCP,R,XLV,lv1,lv2,PSFC,CHS,CHS2,CQS2,CPM, &
                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
                     FM,FH,                                        &
                     XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                     U10,V10,TH2,T2,Q2,rhocm1,                     &
                     GZ1OZ0,WSPD,BR,ISFFLX,DX,                     &
                     SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                     KARMAN,EOMEG,STBOLT,                          &
                     P1000mb,                                      &
                     ids,ide, jds,jde, kds,kde,                    &
                     ims,ime, jms,jme, kms,kme,                    &
                     its,ite, jts,jte, kts,kte,                    &
!!!                     ustm,ck,cka,cd,cda,isftcflx,iz0tlnd,scm_force_flux           )
                     ustm,ck,cka,cd,cda,isftcflx,iz0tlnd                          )
!-------------------------------------------------------------------
      IMPLICIT NONE
!-------------------------------------------------------------------
!   Changes in V3.7 over water surfaces:
!          1. for ZNT/Cd, replacing constant OZO with 0.11*1.5E-5/UST(I)
!             the COARE 3.5 (Edson et al. 2013) formulation is also available
!          2. for VCONV, reducing magnitude by half
!          3. for Ck, replacing Carlson-Boland with COARE 3
!-------------------------------------------------------------------
!-- U3D         3D u-velocity interpolated to theta points (m/s)
!-- V3D         3D v-velocity interpolated to theta points (m/s)
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- dz8w        dz between full levels (m)
!-- CP          heat capacity at constant pressure for dry air (J/kg/K)
!-- G           acceleration due to gravity (m/s^2)
!-- ROVCP       R/CP
!-- R           gas constant for dry air (J/kg/K)
!-- XLV         latent heat of vaporization for water (J/kg)
!-- PSFC        surface pressure (Pa)
!-- ZNT         roughness length (m)
!-- UST         u* in similarity theory (m/s)
!-- USTM        u* in similarity theory (m/s) without vconv correction
!               used to couple with TKE scheme
!-- PBLH        PBL height from previous time (m)
!-- MAVAIL      surface moisture availability (between 0 and 1)
!-- ZOL         z/L height over Monin-Obukhov length
!-- MOL         T* (similarity theory) (K)
!-- REGIME      flag indicating PBL regime (stable, unstable, etc.)
!-- PSIM        similarity stability function for momentum
!-- PSIH        similarity stability function for heat
!-- FM          integrated stability function for momentum
!-- FH          integrated stability function for heat
!-- XLAND       land mask (1 for land, 2 for water)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          net upward latent heat flux at surface (W/m^2)
!-- TSK         surface temperature (K)
!-- FLHC        exchange coefficient for heat (W/m^2/K)
!-- FLQC        exchange coefficient for moisture (kg/m^2/s)
!-- CHS         heat/moisture exchange coefficient for LSM (m/s)
!-- QGH         lowest-level saturated mixing ratio
!-- QSFC        ground saturated mixing ratio
!-- U10         diagnostic 10m u wind
!-- V10         diagnostic 10m v wind
!-- TH2         diagnostic 2m theta (K)
!-- T2          diagnostic 2m temperature (K)
!-- Q2          diagnostic 2m mixing ratio (kg/kg)
!-- GZ1OZ0      log(z/z0) where z0 is roughness length
!-- WSPD        wind speed at lowest model level (m/s)
!-- BR          bulk Richardson number in surface layer
!-- ISFFLX      isfflx=1 for surface heat and moisture fluxes
!-- DX          horizontal grid size (m)
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- ck          enthalpy exchange coeff at 10 meters
!-- cd          momentum exchange coeff at 10 meters
!-- cka         enthalpy exchange coeff at the lowest model level
!-- cda         momentum exchange coeff at the lowest model level
!-- isftcflx    =0, (Charnock and Carlson-Boland); =1, AHW Ck, Cd, =2 Garratt
!-- iz0tlnd     =0 Carlson-Boland, =1 Czil_new
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
      INTEGER,  INTENT(IN )   ::        ids,ide, jds,jde, kds,kde, &
                                        ims,ime, jms,jme, kms,kme, &
                                        its,ite, jts,jte, kts,kte
!                                                               
      INTEGER,  INTENT(IN )   ::        ISFFLX
      REAL,     INTENT(IN )   ::        SVP1,SVP2,SVP3,SVPT0
      REAL,     INTENT(IN )   ::        EP1,EP2,KARMAN,EOMEG,STBOLT
      REAL,     INTENT(IN )   ::        P1000mb
!
      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                           dz8w
                                        
      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                           QV3D, &
                                                              P3D, &
                                                              T3D

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::             MAVAIL, &
                                                             PBLH, &
                                                            XLAND, &
                                                              TSK
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(OUT  )               ::                U10, &
                                                              V10, &
                                                              TH2, &
                                                               T2, &
                                                               Q2

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::             rhocm1

!
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)               ::             REGIME, &
                                                              HFX, &
                                                              QFX, &
                                                               LH, &
                                                             QSFC, &
                                                          MOL,RMOL
!m the following 5 are change to memory size
!
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
                                                  PSIM,PSIH,FM,FH

      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                            U3D, &
                                                              V3D
                                        
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::               PSFC, &
                                                               DX

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                            ZNT, &
                                                              ZOL, &
                                                              UST, &
                                                              CPM, &
                                                             CHS2, &
                                                             CQS2, &
                                                              CHS

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                      FLHC,FLQC

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                                 &
                                                              QGH


                                    
      REAL,     INTENT(IN   )               ::   CP,G,ROVCP,R,XLV,lv1,lv2
 
      REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme )              , &
                INTENT(INOUT)     ::              ck,cka,cd,cda,ustm

      INTEGER,  OPTIONAL,  INTENT(IN )   ::     ISFTCFLX, IZ0TLND
!!!      INTEGER,  OPTIONAL,  INTENT(IN )   ::     SCM_FORCE_FLUX
! LOCAL VARS

      REAL,     DIMENSION( its:ite ) ::                       U1D, &
                                                              V1D, &
                                                             QV1D, &
                                                              P1D, &
                                                              T1D

      REAL,     DIMENSION( its:ite ) ::                    dz8w1d

      INTEGER ::  I,J

      DO J=jts,jte
        DO i=its,ite
          dz8w1d(I) = dz8w(i,j,1)
        ENDDO
   
        DO i=its,ite
           U1D(i) =U3D(i,j,1)
           V1D(i) =V3D(i,j,1)
           QV1D(i)=QV3D(i,j,1)
           P1D(i) =P3D(i,j,1)
           T1D(i) =T3D(i,j,1)
        ENDDO

        !  Sending array starting locations of optional variables may cause
        !  troubles, so we explicitly change the call.

        CALL SFCLAYREV1D(J,U1D,V1D,T1D,QV1D,P1D,dz8w1d,               &
                CP,G,ROVCP,R,XLV,lv1,lv2,PSFC(ims,j),CHS(ims,j),CHS2(ims,j), &
                CQS2(ims,j),CPM(ims,j),PBLH(ims,j), RMOL(ims,j),   &
                ZNT(ims,j),UST(ims,j),MAVAIL(ims,j),ZOL(ims,j),    &
                MOL(ims,j),REGIME(ims,j),PSIM(ims,j),PSIH(ims,j),  &
                FM(ims,j),FH(ims,j),                               &
                XLAND(ims,j),HFX(ims,j),QFX(ims,j),TSK(ims,j),     &
                U10(ims,j),V10(ims,j),TH2(ims,j),T2(ims,j),        &
                Q2(ims,j),FLHC(ims,j),FLQC(ims,j),QGH(ims,j),      &
                QSFC(ims,j),LH(ims,j),rhocm1(ims,j),               &
                GZ1OZ0(ims,j),WSPD(ims,j),BR(ims,j),ISFFLX,DX(ims,j),  &
                SVP1,SVP2,SVP3,SVPT0,EP1,EP2,KARMAN,EOMEG,STBOLT,  &
                P1000mb,                                           &
                ids,ide, jds,jde, kds,kde,                         &
                ims,ime, jms,jme, kms,kme,                         &
                its,ite, jts,jte, kts,kte                          &
!!!#if ( EM_CORE == 1 )
!!!                ,isftcflx,iz0tlnd,scm_force_flux,                               &
                ,isftcflx,iz0tlnd,                                              &
                USTM(ims,j),CK(ims,j),CKA(ims,j),                  &
                CD(ims,j),CDA(ims,j)                               &
!!!#endif
                                                                   )
      ENDDO


   END SUBROUTINE SFCLAYREV


!-------------------------------------------------------------------
   SUBROUTINE SFCLAYREV1D(J,UX,VX,T1D,QV1D,P1D,dz8w1d,                &
                     CP,G,ROVCP,R,XLV,lv1,lv2,PSFCPA,CHS,CHS2,CQS2,CPM,PBLH,RMOL, &
                     ZNT,UST,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH,FM,FH,&
                     XLAND,HFX,QFX,TSK,                            &
                     U10,V10,TH2,T2,Q2,FLHC,FLQC,QGH,              &
                     QSFC,LH,rhocm1,GZ1OZ0,WSPD,BR,ISFFLX,DX,      &
                     SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                     KARMAN,EOMEG,STBOLT,                          &
                     P1000mb,                                      &
                     ids,ide, jds,jde, kds,kde,                    &
                     ims,ime, jms,jme, kms,kme,                    &
                     its,ite, jts,jte, kts,kte,                    &
!!!                     isftcflx, iz0tlnd,scm_force_flux,                            &
                     isftcflx, iz0tlnd,                                           &
                     ustm,ck,cka,cd,cda                            )
!-------------------------------------------------------------------
      IMPLICIT NONE
!-------------------------------------------------------------------
      REAL,     PARAMETER     ::        XKA=2.4E-5
      REAL,     PARAMETER     ::        PRT=1.

      INTEGER,  INTENT(IN )   ::        ids,ide, jds,jde, kds,kde, &
                                        ims,ime, jms,jme, kms,kme, &
                                        its,ite, jts,jte, kts,kte, &
                                        J
!                                                               
      INTEGER,  INTENT(IN )   ::        ISFFLX
      REAL,     INTENT(IN )   ::        SVP1,SVP2,SVP3,SVPT0
      REAL,     INTENT(IN )   ::        EP1,EP2,KARMAN,EOMEG,STBOLT
      REAL,     INTENT(IN )   ::        P1000mb

!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN   )               ::             MAVAIL, &
                                                             PBLH, &
                                                            XLAND, &
                                                              TSK
!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN   )               ::             PSFCPA, &
                                                               DX

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)               ::             REGIME, &
                                                              HFX, &
                                                              QFX, &
                                                         MOL,RMOL
!m the following 5 are changed to memory size---
!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
                                                  PSIM,PSIH,FM,FH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                            ZNT, &
                                                              ZOL, &
                                                              UST, &
                                                              CPM, &
                                                             CHS2, &
                                                             CQS2, &
                                                              CHS

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                      FLHC,FLQC

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                                 &
                                                         QSFC,QGH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(OUT)     ::                        U10,V10, &
                                                     TH2,T2,Q2,LH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN )     ::                         rhocm1

                                    
      REAL,     INTENT(IN   )               ::   CP,G,ROVCP,R,XLV,lv1,lv2

! MODULE-LOCAL VARIABLES, DEFINED IN SUBROUTINE SFCLAY
      REAL,     DIMENSION( its:ite ),  INTENT(IN   )   ::  dz8w1d

      REAL,     DIMENSION( its:ite ),  INTENT(IN   )   ::      UX, &
                                                               VX, &
                                                             QV1D, &
                                                              P1D, &
                                                              T1D
 
      REAL, OPTIONAL, DIMENSION( ims:ime )                       , &
                INTENT(OUT)     ::              ck,cka,cd,cda,ustm

      INTEGER,  OPTIONAL,  INTENT(IN )   ::     ISFTCFLX, IZ0TLND
!!!      INTEGER,  OPTIONAL,  INTENT(IN )   ::     SCM_FORCE_FLUX

! LOCAL VARS

      REAL,     DIMENSION( its:ite )        ::                 ZA, &
                                                        THVX,ZQKL, &
                                                           ZQKLP1, &
                                                           THX,QX, &
                                                            PSIH2, &
                                                            PSIM2, &
                                                           PSIH10, &
                                                           PSIM10, &
                                                           DENOMQ, &
                                                          DENOMQ2, &
                                                          DENOMT2, &
                                                            WSPDI, &
                                                           GZ2OZ0, &
                                                           GZ10OZ0
!
      REAL,     DIMENSION( its:ite )        ::                     &
                                                      RHOX,GOVRTH, &
                                                            TGDSA
!
      REAL,     DIMENSION( its:ite)         ::          SCR3,SCR4
      REAL,     DIMENSION( its:ite )        ::         THGB, PSFC
!
      INTEGER                               ::                 KL

      INTEGER ::  N,I,K,KK,L,NZOL,NK,NZOL2,NZOL10

      REAL    ::  PL,THCON,TVCON,E1
      REAL    ::  ZL,TSKV,DTHVDZ,DTHVM,VCONV,RZOL,RZOL2,RZOL10,ZOL2,ZOL10
      REAL    ::  DTG,PSIX,DTTHX,PSIX10,PSIT,PSIT2,PSIQ,PSIQ2,PSIQ10
      REAL    ::  FLUXC,VSGD,Z0Q,VISC,RESTAR,CZIL,GZ0OZQ,GZ0OZT
      REAL    ::  ZW, ZN1, ZN2
!
! .... paj ...
!
      REAL    :: zolzz,zol0
!     REAL    :: zolri,zolri2
!     REAL    :: psih_stable,psim_stable,psih_unstable,psim_unstable
!     REAL    :: psih_stable_full,psim_stable_full,psih_unstable_full,psim_unstable_full
      REAL    :: zl2,zl10,z0t
      REAL,     DIMENSION( its:ite )        ::         pq,pq2,pq10


!-------------------------------------------------------------------
      KL=kte

      DO i=its,ite
! PSFC cb
         PSFC(I)=PSFCPA(I)/1000.
      ENDDO
!                                                      
!----CONVERT GROUND TEMPERATURE TO POTENTIAL TEMPERATURE:  
!                                                            
      DO 5 I=its,ite                                   
        TGDSA(I)=TSK(I)                                    
! PSFC cb
!        THGB(I)=TSK(I)*(100./PSFC(I))**ROVCP                
        THGB(I)=TSK(I)*(P1000mb/PSFCPA(I))**ROVCP   
    5 CONTINUE                                               
!                                                            
!-----DECOUPLE FLUX-FORM VARIABLES TO GIVE U,V,T,THETA,THETA-VIR.,
!     T-VIR., QV, AND QC AT CROSS POINTS AND AT KTAU-1.  
!                                                                 
!     *** NOTE ***                                           
!         THE BOUNDARY WINDS MAY NOT BE ADEQUATELY AFFECTED BY FRICTION,         
!         SO USE ONLY INTERIOR VALUES OF UX AND VX TO CALCULATE 
!         TENDENCIES.                             
!                                                           
   10 CONTINUE                                                     

!     DO 24 I=its,ite
!        UX(I)=U1D(I)
!        VX(I)=V1D(I)
!  24 CONTINUE                                             
                                                             
   26 CONTINUE                                               
                                                   
!.....SCR3(I,K) STORE TEMPERATURE,                           
!     SCR4(I,K) STORE VIRTUAL TEMPERATURE.                                       
                                                                                 
      DO 30 I=its,ite
! PL cb
         PL=P1D(I)/1000.
         SCR3(I)=T1D(I)                                                   
!         THCON=(100./PL)**ROVCP                                                 
         THCON=(P1000mb*0.001/PL)**ROVCP
         THX(I)=SCR3(I)*THCON                                               
         SCR4(I)=SCR3(I)                                                    
         THVX(I)=THX(I)                                                     
         QX(I)=0.                                                             
   30 CONTINUE                                                                 
!                                                                                
      DO I=its,ite
         QGH(I)=0.                                                                
         FLHC(I)=0.                                                               
         FLQC(I)=0.                                                               
         CPM(I)=CP                                                                
      ENDDO
!                                                                                
!     IF(IDRY.EQ.1)GOTO 80                                                   
      DO 50 I=its,ite
         QX(I)=QV1D(I)                                                    
         TVCON=(1.+EP1*QX(I))                                      
         THVX(I)=THX(I)*TVCON                                               
         SCR4(I)=SCR3(I)*TVCON                                              
   50 CONTINUE                                                                 
!                                                                                
      DO 60 I=its,ite
        E1=SVP1*EXP(SVP2*(TGDSA(I)-SVPT0)/(TGDSA(I)-SVP3))                       
!  for land points QSFC can come from previous time step
        if(xland(i).gt.1.5.or.qsfc(i).le.0.0)QSFC(I)=EP2*E1/(PSFC(I)-E1)                                                 
! QGH CHANGED TO USE LOWEST-LEVEL AIR TEMP CONSISTENT WITH MYJSFC CHANGE
! Q2SAT = QGH IN LSM
        E1=SVP1*EXP(SVP2*(T1D(I)-SVPT0)/(T1D(I)-SVP3))                       
        PL=P1D(I)/1000.
        QGH(I)=EP2*E1/(PL-E1)                                                 
        CPM(I)=CP*(1.+0.8*QX(I))                                   
   60 CONTINUE                                                                   
   80 CONTINUE
                                                                                 
!-----COMPUTE THE HEIGHT OF FULL- AND HALF-SIGMA LEVELS ABOVE GROUND             
!     LEVEL, AND THE LAYER THICKNESSES.                                          
                                                                                 
      DO 90 I=its,ite
        ZQKLP1(I)=0.
!!!        RHOX(I)=PSFC(I)*1000./(R*SCR4(I))                                       
        RHOX(I)=rhocm1(i)
   90 CONTINUE                                                                   
!                                                                                
      DO 110 I=its,ite                                                   
           ZQKL(I)=dz8w1d(I)+ZQKLP1(I)
  110 CONTINUE                                                                 
!                                                                                
      DO 120 I=its,ite
         ZA(I)=0.5*(ZQKL(I)+ZQKLP1(I))                                        
  120 CONTINUE                                                                 
!                                                                                
      DO 160 I=its,ite
        GOVRTH(I)=G/THX(I)                                                    
  160 CONTINUE                                                                   
                                                                                 
!-----CALCULATE BULK RICHARDSON NO. OF SURFACE LAYER, ACCORDING TO               
!     AKB(1976), EQ(12).                                                         
                   
      DO 260 I=its,ite
        GZ1OZ0(I)=ALOG((ZA(I)+ZNT(I))/ZNT(I))   ! log((z+z0)/z0)                                     
        GZ2OZ0(I)=ALOG((2.+ZNT(I))/ZNT(I))      ! log((2+z0)/z0)                           
        GZ10OZ0(I)=ALOG((10.+ZNT(I))/ZNT(I))    ! log((10+z0)z0)                    
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZL=ZNT(I)                                                            
        ELSE                                                                     
          ZL=0.01                                                                
        ENDIF                                                                    
        WSPD(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))                        

        TSKV=THGB(I)*(1.+EP1*QSFC(I))                     
        DTHVDZ=(THVX(I)-TSKV)                                                 
!  Convective velocity scale Vc and subgrid-scale velocity Vsg
!  following Beljaars (1994, QJRMS) and Mahrt and Sun (1995, MWR)
!                                ... HONG Aug. 2001
!
!       VCONV = 0.25*sqrt(g/tskv*pblh(i)*dthvm)
!      Use Beljaars over land, old MM5 (Wyngaard) formula over water
        if (xland(i).lt.1.5) then
        fluxc = max(hfx(i)/rhox(i)/cp                    &
              + ep1*tskv*qfx(i)/rhox(i),0.)
        VCONV = vconvc*(g/tgdsa(i)*pblh(i)*fluxc)**.33
        else
        IF(-DTHVDZ.GE.0)THEN
          DTHVM=-DTHVDZ
        ELSE
          DTHVM=0.
        ENDIF
!       VCONV = 2.*SQRT(DTHVM)
! V3.7: reducing contribution in calm conditions
        VCONV = SQRT(DTHVM)
        endif
! Mahrt and Sun low-res correction
        VSGD = 0.32 * (max(dx(i)/5000.-1.,0.))**.33
        WSPD(I)=SQRT(WSPD(I)*WSPD(I)+VCONV*VCONV+vsgd*vsgd)
        WSPD(I)=AMAX1(WSPD(I),0.1)
        BR(I)=GOVRTH(I)*ZA(I)*DTHVDZ/(WSPD(I)*WSPD(I))                        
!  IF PREVIOUSLY UNSTABLE, DO NOT LET INTO REGIMES 1 AND 2
        IF(MOL(I).LT.0.)BR(I)=AMIN1(BR(I),0.0)
!jdf
        RMOL(I)=-GOVRTH(I)*DTHVDZ*ZA(I)*KARMAN
!jdf

  260 CONTINUE                                                                   

!                                                                                
!-----DIAGNOSE BASIC PARAMETERS FOR THE APPROPRIATED STABILITY CLASS:            
!                                                                                
!                                                                                
!     THE STABILITY CLASSES ARE DETERMINED BY BR (BULK RICHARDSON NO.)           
!     AND HOL (HEIGHT OF PBL/MONIN-OBUKHOV LENGTH).                              
!                                                                                
!     CRITERIA FOR THE CLASSES ARE AS FOLLOWS:                                   
!                                                                                
!        1. BR .GE. 0.0;                                                         
!               REPRESENTS NIGHTTIME STABLE CONDITIONS (REGIME=1),               
!                                                                                
!        3. BR .EQ. 0.0                                                          
!               REPRESENTS FORCED CONVECTION CONDITIONS (REGIME=3),              
!                                                                                
!        4. BR .LT. 0.0                                                          
!               REPRESENTS FREE CONVECTION CONDITIONS (REGIME=4).                
!                                                                                
!CCCCC                                                                           

      DO 320 I=its,ite
!                                                                           
      if (br(I).gt.0) then
        if (br(I).gt.250.0) then
        zol(I)=zolri(250.0,ZA(I),ZNT(I))
        else
        zol(I)=zolri(br(I),ZA(I),ZNT(I))
        endif
      endif
!
      if (br(I).lt.0) then
       IF(UST(I).LT.0.001)THEN
          ZOL(I)=BR(I)*GZ1OZ0(I)
        ELSE
        if (br(I).lt.-250.0) then
        zol(I)=zolri(-250.0,ZA(I),ZNT(I))
        else
        zol(I)=zolri(br(I),ZA(I),ZNT(I))
        endif
       ENDIF
      endif
!
! ... paj: compute integrated similarity functions.
!
        zolzz=zol(I)*(za(I)+znt(I))/za(I) ! (z+z0/L
        zol10=zol(I)*(10.+znt(I))/za(I)   ! (10+z0)/L
        zol2=zol(I)*(2.+znt(I))/za(I)     ! (2+z0)/L
        zol0=zol(I)*znt(I)/za(I)          ! z0/L
        ZL2=(2.)/ZA(I)*ZOL(I)             ! 2/L      
        ZL10=(10.)/ZA(I)*ZOL(I)           ! 10/L

        IF((XLAND(I)-1.5).LT.0.)THEN
        ZL=(0.01)/ZA(I)*ZOL(I)   ! (0.01)/L     
        ELSE
        ZL=ZOL0                     ! z0/L
        ENDIF

        IF(BR(I).LT.0.)GOTO 310  ! go to unstable regime (class 4)
        IF(BR(I).EQ.0.)GOTO 280  ! go to neutral regime (class 3)
!                                                                                
!-----CLASS 1; STABLE (NIGHTTIME) CONDITIONS:                                    
!
        REGIME(I)=1.
!
! ... paj: psim and psih. Follows Cheng and Brutsaert 2005 (CB05).
!
        psim(I)=psim_stable(zolzz)-psim_stable(zol0)
        psih(I)=psih_stable(zolzz)-psih_stable(zol0)
!
        psim10(I)=psim_stable(zol10)-psim_stable(zol0)
        psih10(I)=psih_stable(zol10)-psih_stable(zol0)
!
        psim2(I)=psim_stable(zol2)-psim_stable(zol0)
        psih2(I)=psih_stable(zol2)-psih_stable(zol0)
!
! ... paj: preparations to compute PSIQ. Follows CB05+Carlson Boland JAM 1978.
!
        pq(I)=psih_stable(zol(I))-psih_stable(zl)
        pq2(I)=psih_stable(zl2)-psih_stable(zl)
        pq10(I)=psih_stable(zl10)-psih_stable(zl)
!
!       1.0 over Monin-Obukhov length
        RMOL(I)=ZOL(I)/ZA(I) 
!                                                                                

        GOTO 320                                                                 
!                                                                                
!-----CLASS 3; FORCED CONVECTION:                                                
!                                                                                
  280   REGIME(I)=3.                                                           
        PSIM(I)=0.0                                                              
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=0.                                                   
        PSIH10(I)=PSIM10(I)                                           
        PSIM2(I)=0.                                                  
        PSIH2(I)=PSIM2(I)                                           
!
! paj: preparations to compute PSIQ.
!
        pq(I)=PSIH(I)
        pq2(I)=PSIH2(I)
        pq10(I)=0.
!
        ZOL(I)=0.                                             
        RMOL(I) = ZOL(I)/ZA(I)  

        GOTO 320                                                                 
!                                                                                
!-----CLASS 4; FREE CONVECTION:                                                  
!                                                                                
  310   CONTINUE                                                                 
        REGIME(I)=4.                                                           
!
! ... paj: PSIM and PSIH ...
!
        psim(I)=psim_unstable(zolzz)-psim_unstable(zol0)
        psih(I)=psih_unstable(zolzz)-psih_unstable(zol0)
!
        psim10(I)=psim_unstable(zol10)-psim_unstable(zol0)
        psih10(I)=psih_unstable(zol10)-psih_unstable(zol0)
!
        psim2(I)=psim_unstable(zol2)-psim_unstable(zol0)
        psih2(I)=psih_unstable(zol2)-psih_unstable(zol0)
!
! ... paj: preparations to compute PSIQ 
!
        pq(I)=psih_unstable(zol(I))-psih_unstable(zl)
        pq2(I)=psih_unstable(zl2)-psih_unstable(zl)
        pq10(I)=psih_unstable(zl10)-psih_unstable(zl)
!
!---LIMIOT PSIH AND PSIM IN THE CASE OF THIN LAYERS AND HIGH ROUGHNESS            
!---  THIS PREVENTS DENOMINATOR IN FLUXES FROM GETTING TOO SMALL                 
        PSIH(I)=AMIN1(PSIH(I),0.9*GZ1OZ0(I))
        PSIM(I)=AMIN1(PSIM(I),0.9*GZ1OZ0(I))
        PSIH2(I)=AMIN1(PSIH2(I),0.9*GZ2OZ0(I))
        PSIM10(I)=AMIN1(PSIM10(I),0.9*GZ10OZ0(I))
!
! AHW: mods to compute ck, cd
        PSIH10(I)=AMIN1(PSIH10(I),0.9*GZ10OZ0(I))

        RMOL(I) = ZOL(I)/ZA(I)  

  320 CONTINUE                                                                   
!                                                                                
!-----COMPUTE THE FRICTIONAL VELOCITY:                                           
!     ZA(1982) EQS(2.60),(2.61).                                                 
!                                                                                
      DO 330 I=its,ite
        DTG=THX(I)-THGB(I)                                                   
        PSIX=GZ1OZ0(I)-PSIM(I)                                                   
        PSIX10=GZ10OZ0(I)-PSIM10(I)

!     LOWER LIMIT ADDED TO PREVENT LARGE FLHC IN SOIL MODEL
!     ACTIVATES IN UNSTABLE CONDITIONS WITH THIN LAYERS OR HIGH Z0
!       PSIT=AMAX1(GZ1OZ0(I)-PSIH(I),2.)
       PSIT=GZ1OZ0(I)-PSIH(I)
       PSIT2=GZ2OZ0(I)-PSIH2(I)
!
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZL=ZNT(I)                                                            
        ELSE                                                                     
          ZL=0.01                                                                
        ENDIF                                                                    
!
        PSIQ=ALOG(KARMAN*UST(I)*ZA(I)/XKA+ZA(I)/ZL)-pq(I)
        PSIQ2=ALOG(KARMAN*UST(I)*2./XKA+2./ZL)-pq2(I)

! AHW: mods to compute ck, cd
        PSIQ10=ALOG(KARMAN*UST(I)*10./XKA+10./ZL)-pq10(I)

! V3.7: using Fairall 2003 to compute z0q and z0t over water:
!       adapted from module_sf_mynn.F
        IF ( (XLAND(I)-1.5).GE.0. ) THEN
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
              RESTAR=UST(I)*ZNT(I)/VISC
              Z0T = (5.5e-5)*(RESTAR**(-0.60))
              Z0T = MIN(Z0T,1.0e-4)
              Z0T = MAX(Z0T,2.0e-9)
              Z0Q = Z0T

              PSIQ=max(ALOG((ZA(I)+Z0Q)/Z0Q)-PSIH(I), 2.)
              PSIT=max(ALOG((ZA(I)+Z0T)/Z0T)-PSIH(I), 2.)
              PSIQ2=max(ALOG((2.+Z0Q)/Z0Q)-PSIH2(I), 2.)
              PSIT2=max(ALOG((2.+Z0T)/Z0T)-PSIH2(I), 2.)
              PSIQ10=max(ALOG((10.+Z0Q)/Z0Q)-PSIH10(I), 2.)
        ENDIF

        IF ( PRESENT(ISFTCFLX) ) THEN
           IF ( ISFTCFLX.EQ.1 .AND. (XLAND(I)-1.5).GE.0. ) THEN
! v3.1
!             Z0Q = 1.e-4 + 1.e-3*(MAX(0.,UST(I)-1.))**2
! hfip1
!             Z0Q = 0.62*2.0E-5/UST(I) + 1.E-3*(MAX(0.,UST(I)-1.5))**2
! v3.2
              Z0Q = 1.e-4
!
! ... paj: recompute psih for z0q
!
           zolzz=zol(I)*(za(I)+z0q)/za(I)    ! (z+z0q)/L
           zol10=zol(I)*(10.+z0q)/za(I)   ! (10+z0q)/L
           zol2=zol(I)*(2.+z0q)/za(I)     ! (2+z0q)/L
           zol0=zol(I)*z0q/za(I)          ! z0q/L
!
              if (zol(I).gt.0.) then
              psih(I)=psih_stable(zolzz)-psih_stable(zol0)
              psih10(I)=psih_stable(zol10)-psih_stable(zol0)
              psih2(I)=psih_stable(zol2)-psih_stable(zol0)
              else
                if (zol(I).eq.0) then
                psih(I)=0.
                psih10(I)=0.
                psih2(I)=0.
                else
                psih(I)=psih_unstable(zolzz)-psih_unstable(zol0)
                psih10(I)=psih_unstable(zol10)-psih_unstable(zol0)
                psih2(I)=psih_unstable(zol2)-psih_unstable(zol0)
                endif
              endif
!
              PSIQ=ALOG((ZA(I)+z0q)/Z0Q)-PSIH(I)
              PSIT=PSIQ
              PSIQ2=ALOG((2.+z0q)/Z0Q)-PSIH2(I)
              PSIQ10=ALOG((10.+z0q)/Z0Q)-PSIH10(I)
              PSIT2=PSIQ2
           ENDIF
          IF ( ISFTCFLX.EQ.2 .AND. (XLAND(I)-1.5).GE.0. ) THEN
! AHW: Garratt formula: Calculate roughness Reynolds number
!        Kinematic viscosity of air (linear approc to
!                 temp dependence at sea level)
! GZ0OZT and GZ0OZQ are based off formulas from Brutsaert (1975), which
! Garratt (1992) used with values of k = 0.40, Pr = 0.71, and Sc = 0.60
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
!!            VISC=1.5E-5
              RESTAR=UST(I)*ZNT(I)/VISC
              GZ0OZT=0.40*(7.3*SQRT(SQRT(RESTAR))*SQRT(0.71)-5.)
!
! ... paj: compute psih for z0t for temperature ...
!
              z0t=znt(I)/exp(GZ0OZT)
!
           zolzz=zol(I)*(za(I)+z0t)/za(I)    ! (z+z0t)/L
           zol10=zol(I)*(10.+z0t)/za(I)   ! (10+z0t)/L
           zol2=zol(I)*(2.+z0t)/za(I)     ! (2+z0t)/L
           zol0=zol(I)*z0t/za(I)          ! z0t/L
!
              if (zol(I).gt.0.) then
              psih(I)=psih_stable(zolzz)-psih_stable(zol0)
              psih10(I)=psih_stable(zol10)-psih_stable(zol0)
              psih2(I)=psih_stable(zol2)-psih_stable(zol0)
              else
                if (zol(I).eq.0) then
                psih(I)=0.
                psih10(I)=0.
                psih2(I)=0.
                else
                psih(I)=psih_unstable(zolzz)-psih_unstable(zol0)
                psih10(I)=psih_unstable(zol10)-psih_unstable(zol0)
                psih2(I)=psih_unstable(zol2)-psih_unstable(zol0)
                endif
              endif
!
!              PSIT=GZ1OZ0(I)-PSIH(I)+RESTAR2
!              PSIT2=GZ2OZ0(I)-PSIH2(I)+RESTAR2
              PSIT=ALOG((ZA(I)+z0t)/Z0t)-PSIH(I)
              PSIT2=ALOG((2.+z0t)/Z0t)-PSIH2(I)
!
              GZ0OZQ=0.40*(7.3*SQRT(SQRT(RESTAR))*SQRT(0.60)-5.)
              z0q=znt(I)/exp(GZ0OZQ)
!
           zolzz=zol(I)*(za(I)+z0q)/za(I)    ! (z+z0q)/L
           zol10=zol(I)*(10.+z0q)/za(I)   ! (10+z0q)/L
           zol2=zol(I)*(2.+z0q)/za(I)     ! (2+z0q)/L
           zol0=zol(I)*z0q/za(I)          ! z0q/L
!
              if (zol(I).gt.0.) then
              psih(I)=psih_stable(zolzz)-psih_stable(zol0)
              psih10(I)=psih_stable(zol10)-psih_stable(zol0)
              psih2(I)=psih_stable(zol2)-psih_stable(zol0)
              else
                if (zol(I).eq.0) then
                psih(I)=0.
                psih10(I)=0.
                psih2(I)=0.
                else
                psih(I)=psih_unstable(zolzz)-psih_unstable(zol0)
                psih10(I)=psih_unstable(zol10)-psih_unstable(zol0)
                psih2(I)=psih_unstable(zol2)-psih_unstable(zol0)
                endif
              endif
!
              PSIQ=ALOG((ZA(I)+z0q)/Z0q)-PSIH(I)
              PSIQ2=ALOG((2.+z0q)/Z0q)-PSIH2(I)
              PSIQ10=ALOG((10.+z0q)/Z0q)-PSIH10(I)
!              PSIQ=GZ1OZ0(I)-PSIH(I)+2.28*SQRT(SQRT(RESTAR))-2.
!              PSIQ2=GZ2OZ0(I)-PSIH2(I)+2.28*SQRT(SQRT(RESTAR))-2.
!              PSIQ10=GZ10OZ0(I)-PSIH(I)+2.28*SQRT(SQRT(RESTAR))-2.
           ENDIF
        ENDIF
        IF(PRESENT(ck) .and. PRESENT(cd) .and. PRESENT(cka) .and. PRESENT(cda)) THEN
           Ck(I)=(karman/psix10)*(karman/psiq10)
           Cd(I)=(karman/psix10)*(karman/psix10)
           Cka(I)=(karman/psix)*(karman/psiq)
           Cda(I)=(karman/psix)*(karman/psix)
        ENDIF
        IF ( PRESENT(IZ0TLND) ) THEN
           IF ( IZ0TLND.EQ.1 .AND. (XLAND(I)-1.5).LE.0. ) THEN
              ZL=ZNT(I)
!             CZIL RELATED CHANGES FOR LAND
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
              RESTAR=UST(I)*ZL/VISC
!             Modify CZIL according to Chen & Zhang, 2009

              CZIL = 10.0 ** ( -0.40 * ( ZL / 0.07 ) )
!
! ... paj: compute phish for z0t over land
!
              z0t=znt(I)/exp(CZIL*KARMAN*SQRT(RESTAR))
!
           zolzz=zol(I)*(za(I)+z0t)/za(I)    ! (z+z0t)/L
           zol10=zol(I)*(10.+z0t)/za(I)   ! (10+z0t)/L
           zol2=zol(I)*(2.+z0t)/za(I)     ! (2+z0t)/L
           zol0=zol(I)*z0t/za(I)          ! z0t/L
!
              if (zol(I).gt.0.) then
              psih(I)=psih_stable(zolzz)-psih_stable(zol0)
              psih10(I)=psih_stable(zol10)-psih_stable(zol0)
              psih2(I)=psih_stable(zol2)-psih_stable(zol0)
              else
                if (zol(I).eq.0) then
                psih(I)=0.
                psih10(I)=0.
                psih2(I)=0.
                else
                psih(I)=psih_unstable(zolzz)-psih_unstable(zol0)
                psih10(I)=psih_unstable(zol10)-psih_unstable(zol0)
                psih2(I)=psih_unstable(zol2)-psih_unstable(zol0)
                endif
              endif
!
              PSIQ=ALOG((ZA(I)+z0t)/Z0t)-PSIH(I)
              PSIQ2=ALOG((2.+z0t)/Z0t)-PSIH2(I)
              PSIT=PSIQ
              PSIT2=PSIQ2
!
!              PSIT=GZ1OZ0(I)-PSIH(I)+CZIL*KARMAN*SQRT(RESTAR)
!              PSIQ=GZ1OZ0(I)-PSIH(I)+CZIL*KARMAN*SQRT(RESTAR)
!              PSIT2=GZ2OZ0(I)-PSIH2(I)+CZIL*KARMAN*SQRT(RESTAR)
!              PSIQ2=GZ2OZ0(I)-PSIH2(I)+CZIL*KARMAN*SQRT(RESTAR)

           ENDIF
        ENDIF
! TO PREVENT OSCILLATIONS AVERAGE WITH OLD VALUE 
        UST(I)=0.5*UST(I)+0.5*KARMAN*WSPD(I)/PSIX                                             
! TKE coupling: compute ust without vconv for use in tke scheme
        WSPDI(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))
        IF ( PRESENT(USTM) ) THEN
        USTM(I)=0.5*USTM(I)+0.5*KARMAN*WSPDI(I)/PSIX
        ENDIF

        U10(I)=UX(I)*PSIX10/PSIX                                    
        V10(I)=VX(I)*PSIX10/PSIX                                   
        TH2(I)=THGB(I)+DTG*PSIT2/PSIT                                
        Q2(I)=QSFC(I)+(QX(I)-QSFC(I))*PSIQ2/PSIQ                   
        T2(I) = TH2(I)*(PSFCPA(I)/P1000mb)**ROVCP                     
!                                                                                
        IF((XLAND(I)-1.5).LT.0.)THEN                                            
          UST(I)=AMAX1(UST(I),0.001)
        ENDIF                                                                    
        MOL(I)=KARMAN*DTG/PSIT/PRT                              
        DENOMQ(I)=PSIQ
        DENOMQ2(I)=PSIQ2
        DENOMT2(I)=PSIT2
        FM(I)=PSIX
        FH(I)=PSIT
  330 CONTINUE                                                                   
!                                                                                
  335 CONTINUE                                                                   
                                                                                  
!-----COMPUTE THE SURFACE SENSIBLE AND LATENT HEAT FLUXES:                       
!!!      IF ( PRESENT(SCM_FORCE_FLUX) ) THEN
!!!         IF (SCM_FORCE_FLUX.EQ.1) GOTO 350
!!!      ENDIF
      DO i=its,ite
        QFX(i)=0.                                                              
        HFX(i)=0.                                                              
      ENDDO
  350 CONTINUE                                                                   

      IF (ISFFLX.EQ.0) GOTO 410                                                
                                                                                 
!-----OVER WATER, ALTER ROUGHNESS LENGTH (ZNT) ACCORDING TO WIND (UST).          
                                                                                 
      DO 360 I=its,ite
        IF((XLAND(I)-1.5).GE.0)THEN                                            
!         ZNT(I)=CZO*UST(I)*UST(I)/G+OZO                                   
! Since V3.7 (ref: EC Physics document for Cy36r1)
          ZNT(I)=CZO*UST(I)*UST(I)/G+0.11*1.5E-5/UST(I)
! COARE 3.5 (Edson et al. 2013)
!         CZC = 0.0017*WSPD(I)-0.005
!         CZC = min(CZC,0.028)
!         ZNT(I)=CZC*UST(I)*UST(I)/G+0.11*1.5E-5/UST(I)
! AHW: change roughness length, and hence the drag coefficients Ck and Cd
          IF ( PRESENT(ISFTCFLX) ) THEN
             IF ( ISFTCFLX.NE.0 ) THEN
!               ZNT(I)=10.*exp(-9.*UST(I)**(-.3333))
!               ZNT(I)=10.*exp(-9.5*UST(I)**(-.3333))
!               ZNT(I)=ZNT(I) + 0.11*1.5E-5/AMAX1(UST(I),0.01)
!               ZNT(I)=0.011*UST(I)*UST(I)/G+OZO
!               ZNT(I)=MAX(ZNT(I),3.50e-5)
! AHW 2012:
                ZW  = MIN((UST(I)/1.06)**(0.3),1.0)
                ZN1 = 0.011*UST(I)*UST(I)/G + OZO
                ZN2 = 10.*exp(-9.5*UST(I)**(-.3333)) + &
                       0.11*1.5E-5/AMAX1(UST(I),0.01)
                ZNT(I)=(1.0-ZW) * ZN1 + ZW * ZN2
                ZNT(I)=MIN(ZNT(I),2.85e-3)
                ZNT(I)=MAX(ZNT(I),1.27e-7)
             ENDIF
          ENDIF
          ZL = ZNT(I)
        ELSE
          ZL = 0.01
        ENDIF                                                                    
        FLQC(I)=RHOX(I)*MAVAIL(I)*UST(I)*KARMAN/DENOMQ(I)
!       FLQC(I)=RHOX(I)*MAVAIL(I)*UST(I)*KARMAN/(   &
!               ALOG(KARMAN*UST(I)*ZA(I)/XKA+ZA(I)/ZL)-PSIH(I))
        DTTHX=ABS(THX(I)-THGB(I))                                            
        IF(DTTHX.GT.1.E-5)THEN                                                   
          FLHC(I)=CPM(I)*RHOX(I)*UST(I)*MOL(I)/(THX(I)-THGB(I))          
!         write(*,1001)FLHC(I),CPM(I),RHOX(I),UST(I),MOL(I),THX(I),THGB(I),I
 1001   format(f8.5,2x,f12.7,2x,f13.10,2x,f13.10,2x,f13.10,2x,f12.8,f12.8,2x,i3)
        ELSE                                                                     
          FLHC(I)=0.                                                             
        ENDIF                                                                    
  360 CONTINUE                                                                   

!                                                                                
!-----COMPUTE SURFACE MOIST FLUX:                                                
!                                                                                
!     IF(IDRY.EQ.1)GOTO 390                                                
!                                                                                
!!!     IF ( PRESENT(SCM_FORCE_FLUX) ) THEN
!!!        IF (SCM_FORCE_FLUX.EQ.1) GOTO 405
!!!     ENDIF

      DO 370 I=its,ite
        QFX(I)=FLQC(I)*(QSFC(I)-QX(I))                                     
        QFX(I)=AMAX1(QFX(I),0.)                                            
!!!        LH(I)=XLV*QFX(I)
        LH(I)=( lv1-lv2*tsk(I) )*QFX(I)
  370 CONTINUE                                                                 
                                                                                
!-----COMPUTE SURFACE HEAT FLUX:                                                 
!                                                                                
  390 CONTINUE                                                                 
      DO 400 I=its,ite
        IF(XLAND(I)-1.5.GT.0.)THEN                                           
          HFX(I)=FLHC(I)*(THGB(I)-THX(I)) 
!         IF ( PRESENT(ISFTCFLX) ) THEN
!            IF ( ISFTCFLX.NE.0 ) THEN
! AHW: add dissipative heating term (commented out in 3.6.1)
!               HFX(I)=HFX(I)+RHOX(I)*USTM(I)*USTM(I)*WSPDI(I)
!            ENDIF
!         ENDIF 
        ELSEIF(XLAND(I)-1.5.LT.0.)THEN                                       
          HFX(I)=FLHC(I)*(THGB(I)-THX(I))                                
          HFX(I)=AMAX1(HFX(I),-250.)                                       
        ENDIF                                                                  
  400 CONTINUE                                                                 

  405 CONTINUE                                                                 
         
      DO I=its,ite
         IF((XLAND(I)-1.5).GE.0)THEN
           ZL=ZNT(I)
         ELSE
           ZL=0.01
         ENDIF
!v3.1.1
!         CHS(I)=UST(I)*KARMAN/(ALOG(KARMAN*UST(I)*ZA(I) &
!                /XKA+ZA(I)/ZL)-PSIH(I))
         CHS(I)=UST(I)*KARMAN/DENOMQ(I)
!        GZ2OZ0(I)=ALOG(2./ZNT(I))
!        PSIM2(I)=-10.*GZ2OZ0(I)
!        PSIM2(I)=AMAX1(PSIM2(I),-10.)
!        PSIH2(I)=PSIM2(I)
! v3.1.1
!         CQS2(I)=UST(I)*KARMAN/(ALOG(KARMAN*UST(I)*2.0  &
!               /XKA+2.0/ZL)-PSIH2(I))
!         CHS2(I)=UST(I)*KARMAN/(GZ2OZ0(I)-PSIH2(I))
         CQS2(I)=UST(I)*KARMAN/DENOMQ2(I)
         CHS2(I)=UST(I)*KARMAN/DENOMT2(I)
      ENDDO
                                                                        
  410 CONTINUE                                                                   
!jdf
!     DO I=its,ite
!       IF(UST(I).GE.0.1) THEN
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(UST(I)*UST(I)*UST(I))
!       ELSE
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(0.1*0.1*0.1)
!       ENDIF
!     ENDDO
!jdf

!                                                                                
   END SUBROUTINE SFCLAYREV1D

!====================================================================
   SUBROUTINE sfclayrevinit

    INTEGER                   ::      N
    REAL                      ::      zolf

    DO N=0,1000
! stable function tables
       zolf = float(n)*0.01
       psim_stab(n)=psim_stable_full(zolf)
       psih_stab(n)=psih_stable_full(zolf)
 
! unstable function tables
       zolf = -float(n)*0.01
       psim_unstab(n)=psim_unstable_full(zolf)
       psih_unstab(n)=psih_unstable_full(zolf)

    ENDDO

   END SUBROUTINE sfclayrevinit

      function zolri(ri,z,z0)
!
      if (ri.lt.0.)then
        x1=-5.
        x2=0.
      else
        x1=0.
        x2=5.
      endif
!
      fx1=zolri2(x1,ri,z,z0)
      fx2=zolri2(x2,ri,z,z0)
      Do While (abs(x1 - x2) > 0.01)
      if(abs(fx2).lt.abs(fx1))then
        x1=x1-fx1/(fx2-fx1)*(x2-x1)
        fx1=zolri2(x1,ri,z,z0)
        zolri=x1
      else
        x2=x2-fx2/(fx2-fx1)*(x2-x1)
        fx2=zolri2(x2,ri,z,z0)
        zolri=x2
      endif
!
      enddo
!

      return
      end function

!
! -----------------------------------------------------------------------
!
      function zolri2(zol2,ri2,z,z0)
!
      if(zol2*ri2 .lt. 0.)zol2=0.  ! limit zol2 - must be same sign as ri2
!
      zol20=zol2*z0/z ! z0/L
      zol3=zol2+zol20 ! (z+z0)/L
!
      if (ri2.lt.0) then
      psix2=log((z+z0)/z0)-(psim_unstable(zol3)-psim_unstable(zol20))
      psih2=log((z+z0)/z0)-(psih_unstable(zol3)-psih_unstable(zol20))
      else
      psix2=log((z+z0)/z0)-(psim_stable(zol3)-psim_stable(zol20))
      psih2=log((z+z0)/z0)-(psih_stable(zol3)-psih_stable(zol20))
      endif
!
      zolri2=zol2*psih2/psix2**2-ri2
!
      return
      end function
!
! ... integrated similarity functions ...
!
      function psim_stable_full(zolf)
        psim_stable_full=-6.1*log(zolf+(1+zolf**2.5)**(1./2.5))
      return
      end function

      function psih_stable_full(zolf)
        psih_stable_full=-5.3*log(zolf+(1+zolf**1.1)**(1./1.1))
      return
      end function
      
      function psim_unstable_full(zolf)
        x=(1.-16.*zolf)**.25
        psimk=2*ALOG(0.5*(1+X))+ALOG(0.5*(1+X*X))-2.*ATAN(X)+2.*ATAN(1.)
!
        ym=(1.-10.*zolf)**0.33
        psimc=(3./2.)*log((ym**2.+ym+1.)/3.)-sqrt(3.)*ATAN((2.*ym+1)/sqrt(3.))+4.*ATAN(1.)/sqrt(3.)
!
        psim_unstable_full=(psimk+zolf**2*(psimc))/(1+zolf**2.)

      return
      end function

      function psih_unstable_full(zolf)
        y=(1.-16.*zolf)**.5
        psihk=2.*log((1+y)/2.)
!
        yh=(1.-34.*zolf)**0.33
        psihc=(3./2.)*log((yh**2.+yh+1.)/3.)-sqrt(3.)*ATAN((2.*yh+1)/sqrt(3.))+4.*ATAN(1.)/sqrt(3.)
!
        psih_unstable_full=(psihk+zolf**2*(psihc))/(1+zolf**2.)

      return
      end function

! look-up table functions
      function psim_stable(zolf)
      integer :: nzol
      real    :: rzol
        nzol = int(zolf*100.)
        rzol = zolf*100. - nzol
        if(nzol+1 .le. 1000)then
           psim_stable = psim_stab(nzol) + rzol*(psim_stab(nzol+1)-psim_stab(nzol))
        else
           psim_stable = psim_stable_full(zolf)
        endif
      return
      end function

      function psih_stable(zolf)
      integer :: nzol
      real    :: rzol
        nzol = int(zolf*100.)
        rzol = zolf*100. - nzol
        if(nzol+1 .le. 1000)then
           psih_stable = psih_stab(nzol) + rzol*(psih_stab(nzol+1)-psih_stab(nzol))
        else
           psih_stable = psih_stable_full(zolf)
        endif
      return
      end function
      
      function psim_unstable(zolf)
      integer :: nzol
      real    :: rzol
        nzol = int(-zolf*100.)
        rzol = -zolf*100. - nzol
        if(nzol+1 .le. 1000)then
           psim_unstable = psim_unstab(nzol) + rzol*(psim_unstab(nzol+1)-psim_unstab(nzol))
        else
           psim_unstable = psim_unstable_full(zolf)
        endif
      return
      end function

      function psih_unstable(zolf)
      integer :: nzol
      real    :: rzol
        nzol = int(-zolf*100.)
        rzol = -zolf*100. - nzol
        if(nzol+1 .le. 1000)then
           psih_unstable = psih_unstab(nzol) + rzol*(psih_unstab(nzol+1)-psih_unstab(nzol))
        else
           psih_unstable = psih_unstable_full(zolf)
        endif
      return
      end function

!-------------------------------------------------------------------          

END MODULE module_sf_sfclayrev

!
! ----------------------------------------------------------
!



slab.F          1587424407  1602  20    100644  28254     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_slab

   !---SPECIFY CONSTANTS AND LAYERS FOR SOIL MODEL
   !---SOIL DIFFUSION CONSTANT SET (M^2/S)

   REAL, PARAMETER :: DIFSL=5.e-7

   !---FACTOR TO MAKE SOIL STEP MORE CONSERVATIVE

   REAL , PARAMETER :: SOILFAC=1.25

CONTAINS

!----------------------------------------------------------------
   SUBROUTINE SLAB(T3D,QV3D,P3D,FLHC,FLQC,                      &
                   PSFC,XLAND,TMN,HFX,QFX,LH,TSK,QSFC,CHKLOWQ,  &
                   GSW,GLW,CAPG,THC,SNOWC,EMISS,MAVAIL,         &
                   DELTSM,ROVCP,XLV,lv1,lv2,DTMIN,IFSNOW,       &
                   SVP1,SVP2,SVP3,SVPT0,EP2,                    &
                   KARMAN,EOMEG,STBOLT,                         &
                   TSLB,ZS,DZS,num_soil_layers,radiation,       &
                   P1000mb,                                     &
                   ids,ide, jds,jde, kds,kde,                   &
                   ims,ime, jms,jme, kms,kme,                   &
                   its,ite, jts,jte, kts,kte                    )
!----------------------------------------------------------------
    IMPLICIT NONE
!----------------------------------------------------------------
!                                                                        
!     SUBROUTINE SLAB CALCULATES THE GROUND TEMPERATURE TENDENCY 
!     ACCORDING TO THE RESIDUAL OF THE SURFACE ENERGY BUDGET           
!     (BLACKADAR, 1978B).                                              
!                                                                      
!     CHANGES:                                                         
!          FOR SOIL SUB-TIMESTEPS UPDATE SURFACE HFX AND QFX AS TG     
!          CHANGES TO PREVENT POSSIBLE INSTABILITY FOR LONG MODEL      
!          STEPS (DT > ~200 SEC).                                      
!                                                                      
!          PUT SNOW COVER CHECK ON SOIL SUB-TIMESTEPS                  
!                                                                      
!          MAKE UPPER LIMIT ON SOIL SUB-STEP LENGTH MORE CONSERVATIVE  
!                                                                      
!----------------------------------------------------------------          
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- FLHC        exchange coefficient for heat (m/s)
!-- FLQC        exchange coefficient for moisture (m/s)
!-- PSFC        surface pressure (Pa)
!-- XLAND       land mask (1 for land, 2 for water)
!-- TMN         soil temperature at lower boundary (K)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)      
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- CAPG        heat capacity for soil (J/K/m^3)
!-- THC         thermal inertia (Cal/cm/K/s^0.5)
!-- SNOWC       flag indicating snow coverage (1 for snow cover)
!-- EMISS       surface emissivity (between 0 and 1)
!-- DELTSM      time step (second)
!-- ROVCP       R/CP
!-- XLV         latent heat of melting (J/kg)
!-- DTMIN       time step (minute)
!-- IFSNOW      ifsnow=1 for snow-cover effects
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- TSLB        soil temperature in 5-layer model
!-- ZS          depths of centers of soil layers
!-- DZS         thicknesses of soil layers
!-- num_soil_layers   the number of soil layers
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!----------------------------------------------------------------
   INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &
                                    ims,ime, jms,jme, kms,kme,  &
                                    its,ite, jts,jte, kts,kte

   INTEGER, INTENT(IN)       ::     num_soil_layers
   LOGICAL, INTENT(IN)       ::     radiation

   INTEGER,  INTENT(IN   )   ::     IFSNOW

!
   REAL,     INTENT(IN   )   ::     DTMIN,XLV,lv1,lv2,ROVCP,DELTSM

   REAL,     INTENT(IN )     ::     SVP1,SVP2,SVP3,SVPT0
   REAL,     INTENT(IN )     ::     EP2,KARMAN,EOMEG,STBOLT
   REAL,     INTENT(IN )     ::     P1000mb

   REAL,     DIMENSION( ims:ime , jms:jme , 1:num_soil_layers ), &
             INTENT(INOUT)   :: TSLB

   REAL,     DIMENSION(1:num_soil_layers), INTENT(IN)::ZS,DZS

   REAL,    DIMENSION( ims:ime, jms:jme, kms:kme )            , &
            INTENT(IN   )    ::                           QV3D, &
                                                           P3D, &
                                                           T3D
!
   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN   )    ::                          SNOWC, &
                                                         XLAND, &
                                                         EMISS, &
                                                        MAVAIL, &
                                                           TMN, &
                                                           GSW, &
                                                           GLW, &
                                                           THC

!CHKLOWQ is declared as memory size
!
   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(INOUT)    ::                            HFX, &
                                                           QFX, &
                                                            LH, &
                                                          CAPG, &
                                                           TSK, &
                                                          QSFC, &
                                                       CHKLOWQ

   REAL,     DIMENSION( ims:ime, jms:jme )                    , &
             INTENT(IN   )               ::               PSFC
!
   REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(INOUT) ::     &
                                                          FLHC, &
                                                          FLQC

! LOCAL VARS

   REAL,     DIMENSION( its:ite ) ::                      QV1D, &
                                                           P1D, &
                                                           T1D
   REAL,     DIMENSION( its:ite , 1:num_soil_layers ) :: TSLB2D
   INTEGER ::  I,J,n

!$omp parallel do default(shared)   &
!$omp private(i,j,n,t1d,qv1d,p1d,tslb2d)
   DO J=jts,jte

      DO i=its,ite
         T1D(i) =T3D(i,j,1)
         QV1D(i)=QV3D(i,j,1)
         P1D(i) =P3D(i,j,1)
         do n=1,num_soil_layers
           TSLB2D(i,n) = TSLB(i,j,n)
         enddo
      ENDDO

! the indices to the PSFC argument in the following call look
! wrong; however, it is correct to call with its (and not ims)
! because of the way PSFC is defined in SLAB1D. Whether *that*
! is a good idea or not, this commenter cannot comment. JM

      CALL SLAB1D(J,T1D,QV1D,P1D,FLHC(ims,j),FLQC(ims,j),       &
           PSFC(ims,j),XLAND(ims,j),TMN(ims,j),HFX(ims,j),      &
           QFX(ims,j),TSK(ims,j),QSFC(ims,j),CHKLOWQ(ims,j),    &
           LH(ims,j),GSW(ims,j),GLW(ims,j),                     &
           CAPG(ims,j),THC(ims,j),SNOWC(ims,j),EMISS(ims,j),    &
           MAVAIL(ims,j),DELTSM,ROVCP,XLV,lv1,lv2,DTMIN,IFSNOW, &
           SVP1,SVP2,SVP3,SVPT0,EP2,KARMAN,EOMEG,STBOLT,        &
           TSLB2D       ,ZS,DZS,num_soil_layers,radiation,      &
           P1000mb,                                             &
           ids,ide, jds,jde, kds,kde,                           &
           ims,ime, jms,jme, kms,kme,                           &
           its,ite, jts,jte, kts,kte                            )

      DO i=its,ite
         do n=1,num_soil_layers
           TSLB(i,j,n) = TSLB2D(i,n)
         enddo
      ENDDO

   ENDDO

   END SUBROUTINE SLAB

!----------------------------------------------------------------
   SUBROUTINE SLAB1D(J,T1D,QV1D,P1D,FLHC,FLQC,                  &
                   PSFCPA,XLAND,TMN,HFX,QFX,TSK,QSFC,CHKLOWQ,   &
                   LH,GSW,GLW,CAPG,THC,SNOWC,EMISS,MAVAIL,      &
                   DELTSM,ROVCP,XLV,lv1,lv2,DTMIN,IFSNOW,       &
                   SVP1,SVP2,SVP3,SVPT0,EP2,                    &
                   KARMAN,EOMEG,STBOLT,                         &
                   TSLB2D,ZS,DZS,num_soil_layers,radiation,     &
                   P1000mb,                                     &
                   ids,ide, jds,jde, kds,kde,                   &
                   ims,ime, jms,jme, kms,kme,                   &
                   its,ite, jts,jte, kts,kte                    )
!----------------------------------------------------------------
    IMPLICIT NONE
!----------------------------------------------------------------
!                                                                        
!     SUBROUTINE SLAB CALCULATES THE GROUND TEMPERATURE TENDENCY 
!     ACCORDING TO THE RESIDUAL OF THE SURFACE ENERGY BUDGET           
!     (BLACKADAR, 1978B).                                              
!                                                                      
!     CHANGES:                                                         
!          FOR SOIL SUB-TIMESTEPS UPDATE SURFACE HFX AND QFX AS TG     
!          CHANGES TO PREVENT POSSIBLE INSTABILITY FOR LONG MODEL      
!          STEPS (DT > ~200 SEC).                                      
!                                                                      
!          PUT SNOW COVER CHECK ON SOIL SUB-TIMESTEPS                  
!                                                                      
!          MAKE UPPER LIMIT ON SOIL SUB-STEP LENGTH MORE CONSERVATIVE  
!                                                                      
!----------------------------------------------------------------          

   INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &
                                    ims,ime, jms,jme, kms,kme,  &
                                    its,ite, jts,jte, kts,kte,J 

   INTEGER , INTENT(IN)      ::     num_soil_layers
   LOGICAL,  INTENT(IN   )   ::     radiation

   INTEGER,  INTENT(IN   )   ::     IFSNOW
!
   REAL,     INTENT(IN   )   ::     DTMIN,XLV,lv1,lv2,ROVCP,DELTSM

   REAL,     INTENT(IN )     ::     SVP1,SVP2,SVP3,SVPT0
   REAL,     INTENT(IN )     ::     EP2,KARMAN,EOMEG,STBOLT
   REAL,     INTENT(IN )     ::     P1000mb

   REAL,     DIMENSION( its:ite , 1:num_soil_layers ),          &
             INTENT(INOUT)   :: TSLB2D

   REAL,     DIMENSION(1:num_soil_layers), INTENT(IN)::ZS,DZS

!
   REAL,    DIMENSION( ims:ime )                              , &
            INTENT(INOUT)    ::                            HFX, &
                                                           QFX, &
                                                            LH, &
                                                          CAPG, &
                                                           TSK, &
                                                          QSFC, &
                                                       CHKLOWQ
!
   REAL,    DIMENSION( ims:ime )                              , &
            INTENT(IN   )    ::                          SNOWC, &
                                                         XLAND, &
                                                         EMISS, &
                                                        MAVAIL, &
                                                           TMN, &
                                                           GSW, &
                                                           GLW, &
                                                           THC
!
   REAL,    DIMENSION( its:ite )                              , &
            INTENT(IN   )    ::                           QV1D, &
                                                           P1D, &
                                                           T1D
!
   REAL,     DIMENSION( ims:ime )                             , &
             INTENT(IN   )               ::             PSFCPA

!
   REAL,    DIMENSION( ims:ime ), INTENT(INOUT) ::              &
                                                          FLHC, &
                                                          FLQC
! LOCAL VARS

   REAL,    DIMENSION( its:ite )          ::              PSFC

   REAL,    DIMENSION( its:ite )          ::                    &
                                                           THX, &
                                                            QX, &
                                                          SCR3 

   REAL,    DIMENSION( its:ite )          ::            DTHGDT, &
                                                           TG0, &
                                                         THTMN, &
                                                          XLD1, &
                                                         TSCVN, &
                                                          OLTG, &
                                                        UPFLUX, &
                                                            HM, &
                                                          RNET, &
                                                         XINET, &
                                                            QS, &
                                                         DTSDT
!
   REAL, DIMENSION( its:ite, num_soil_layers )        :: FLUX
!
   INTEGER :: I,K,NSOIL,ITSOIL,L,NK,RADSWTCH
   REAL    :: PS,PS1,XLDCOL,TSKX,RNSOIL,RHOG1,RHOG2,RHOG3,LAMDAG
   REAL    :: THG,ESG,QSG,HFXT,QFXT,CS,CSW,LAMG(4),THCON,PL
 
!----------------------------------------------------------------------          
!-----DETERMINE IF ANY POINTS IN COLUMN ARE LAND (RATHER THAN OCEAN)             
!       POINTS.  IF NOT, SKIP DOWN TO THE PRINT STATEMENTS SINCE OCEAN           
!       SURFACE TEMPERATURES ARE NOT ALLOWED TO CHANGE.                          
!                                                                                
! from sfcrad   
!----------------------------------------------------------------------
   DATA CSW/4.183E6/
   DATA LAMG/1.407E-8, -1.455E-5, 6.290E-3, 0.16857/

   DO i=its,ite
! in cmb
      PSFC(I)=PSFCPA(I)/1000.
   ENDDO


      DO I=its,ite
! PL cmb
         PL=P1D(I)/1000.
         SCR3(I)=T1D(I)
!         THCON=(100./PL)**ROVCP
         THCON=(P1000mb*0.001/PL)**ROVCP
         THX(I)=SCR3(I)*THCON
         QX(I)=0.
      ENDDO

!     IF(IDRY.EQ.1) GOTO 81
      DO I=its,ite
         QX(I)=QV1D(I)
      ENDDO
   81 CONTINUE

!
!-----THE SLAB THERMAL CAPACITY CAPG(I) ARE DEPENDENT ON:
!     THC(I) - SOIL THERMAL INERTIAL, ONLY.
!
      DO I=its,ite
         CAPG(I)=3.298E6*THC(I)
         IF(num_soil_layers .gt. 1)THEN

! CAPG REPRESENTS SOIL HEAT CAPACITY (J/K/M^3) WHEN DIFSL=5.E-7 (M^2/S)
! TO GIVE A CORRECT THERMAL INERTIA (=CAPG*DIFSL^0.5)

            CAPG(I)=5.9114E7*THC(I)
         ENDIF
      ENDDO
!        
      XLDCOL=2.0                                                                 
      DO 10 I=its,ite
        XLDCOL=AMIN1(XLDCOL,XLAND(I))                                          
   10 CONTINUE                                                                   
!                                                                                
      IF(XLDCOL.GT.1.5)GOTO 90                                                   
!                                                                                
!                                                                                
!-----CONVERT SLAB TEMPERATURE TO POTENTIAL TEMPERATURE AND                      
!     SET XLD1(I) = 0. FOR OCEAN POINTS:                                         
!                                                                                
!                                                                                
      DO 20 I=its,ite
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          XLD1(I)=0.                                                             
        ELSE                                                                     
          XLD1(I)=1.                                                             
        ENDIF                                                                    
   20 CONTINUE                                                                   
!                                                                                
!-----CONVERT 'TSK(THETAG)' TO 'TG' FOR 'IUP' CALCULATION ....                   
!       IF WE ARE USING THE BLACKADAR MULTI-LEVEL (HIGH-RESOLUTION)              
!       PBL MODEL                                                                
!                                                                                
      DO 50 I=its,ite
        IF(XLD1(I).LT.0.5)GOTO 50                                                

! PS cmb
        PS=PSFC(I)

! TSK is Temperature at gound sfc
!       TG0(I)=TSK(I)*(PS*0.01)**ROVCP                                         
        TG0(I)=TSK(I)
   50 CONTINUE                                                                   
!                                                                                
!-----COMPUTE THE SURFACE ENERGY BUDGET:                                         
!                                                                                
!     IF(ISOIL.EQ.1)NSOIL=1                                                      
      IF(num_soil_layers .gt. 1)NSOIL=1                                                      


      IF (radiation) then
        RADSWTCH=1
      ELSE
        RADSWTCH=0
      ENDIF

      DO 70 I=its,ite
        IF(XLD1(I).LT.0.5)GOTO 70
!        OLTG(I)=TSK(I)*(100./PSFC(I))**ROVCP
        OLTG(I)=TSK(I)*(P1000mb*0.001/PSFC(I))**ROVCP
        UPFLUX(I)=RADSWTCH*STBOLT*TG0(I)**4                            
        XINET(I)=EMISS(I)*(GLW(I)-UPFLUX(I))    
        RNET(I)=GSW(I)+XINET(I)                                                
        HM(I)=1.18*EOMEG*(TG0(I)-TMN(I))                                       
!       MOISTURE FLUX CALCULATED HERE (OVERWRITES SFC LAYER VALUE FOR LAND)
                ESG=SVP1*EXP(SVP2*(TG0(I)-SVPT0)/(TG0(I)-SVP3))
                QSG=EP2*ESG/(PSFC(I)-ESG)
                THG=TSK(I)*(100./PSFC(I))**ROVCP
                HFX(I)=FLHC(I)*(THG-THX(I))
                QFX(I)=FLQC(I)*(QSG-QX(I))
                LH(I)=QFX(I)*( lv1-lv2*tsk(I) )
        QS(I)=HFX(I)+QFX(I)*( lv1-lv2*tsk(I) )
!       IF(ISOIL.EQ.0)THEN                                                       
        IF(num_soil_layers .EQ. 1)THEN                                                       
          DTHGDT(I)=(RNET(I)-QS(I))/CAPG(I)-HM(I)                              
        ELSE
          DTHGDT(I)=0.                                                           
        ENDIF                                                                    
   70 CONTINUE                                                                   
!     IF(ISOIL.EQ.1)THEN                                                         
      IF(num_soil_layers .gt. 1)THEN                                                         
        NSOIL=1+IFIX(SOILFAC*4*DIFSL/DZS(1)*DELTSM/DZS(1))   
        RNSOIL=1./FLOAT(NSOIL)                                                   
!                                                                                
!     SOIL SUB-TIMESTEP                                                          
!                                                                                
        DO ITSOIL=1,NSOIL                                                        
          DO I=its,ite
             DO L=1,num_soil_layers-1
              IF(XLD1(I).LT.0.5)GOTO 75                                          
              IF(L.EQ.1.AND.ITSOIL.GT.1)THEN                                     
!                PS1=(PSFC(I)*0.01)**ROVCP    
                PS1=(PSFCPA(I)/P1000mb)**ROVCP    

! for rk scheme A and B are the same
                PS=PSFC(I)
                THG=TSLB2D(I,1)/PS1                                              
                ESG=SVP1*EXP(SVP2*(TSLB2D(I,1)-SVPT0)/(TSLB2D(I,1) & 
                    -SVP3))                                                      
                QSG=EP2*ESG/(PS-ESG)                                             
!     UPDATE FLUXES FOR NEW GROUND TEMPERATURE                                   
                HFXT=FLHC(I)*(THG-THX(I))                                     
                QFXT=FLQC(I)*(QSG-QX(I))
                QS(I)=HFXT+QFXT*( lv1-lv2*tsk(I) )
!     SUM HFX AND QFX OVER SOIL TIMESTEPS                                        
                HFX(I)=HFX(I)+HFXT                                           
                QFX(I)=QFX(I)+QFXT                                           
              ENDIF                                                              
              FLUX(I,1)=RNET(I)-QS(I)                                            
              FLUX(I,L+1)=-DIFSL*CAPG(I)*(TSLB2D(I,L+1)-TSLB2D(I,L))/( & 
                          ZS(L+1)-ZS(L))                                         
              DTSDT(I)=-(FLUX(I,L+1)-FLUX(I,L))/(DZS(L)*CAPG(I))               
              TSLB2D(I,L)=TSLB2D(I,L)+DTSDT(I)*DELTSM*RNSOIL                     
              IF(IFSNOW.EQ.1.AND.L.EQ.1)THEN                              
                IF((SNOWC(I).GT.0..AND.TSLB2D(I,1).GT.273.16))THEN             
                  TSLB2D(I,1)=273.16                                             
                ENDIF                                                            
              ENDIF                                                              
              IF(L.EQ.1)DTHGDT(I)=DTHGDT(I)+RNSOIL*DTSDT(I)                      
              IF(ITSOIL.EQ.NSOIL.AND.L.EQ.1)THEN                                 
!     AVERAGE HFX AND QFX OVER SOIL TIMESTEPS FOR OUTPUT TO PBL                  
                HFX(I)=HFX(I)*RNSOIL                                         
                QFX(I)=QFX(I)*RNSOIL                                         
                LH(I)=QFX(I)*( lv1-lv2*tsk(I) )
              ENDIF                                                              
   75         CONTINUE                                                           
            ENDDO                                                                
          ENDDO                                                                  
        ENDDO                                                                    
      ENDIF                                                                      
!                                                                                
      DO 80 I=its,ite
        IF(XLD1(I).LT.0.5) GOTO 80                                                
        TSKX=TG0(I)+DELTSM*DTHGDT(I)                                             

! TSK is temperature
!       TSK(I)=TSKX*(100./PS1)**ROVCP                                          
        TSK(I)=TSKX
   80 CONTINUE                                                                   

!                                                                                
!-----MODIFY THE THE GROUND TEMPERATURE IF THE SNOW COVER EFFECTS ARE            
!     CONSIDERED: LIMIT THE GROUND TEMPERATURE UNDER 0 C.                        
!                                                                                
      IF(IFSNOW.EQ.0)GOTO 90                                              
      DO 85 I=its,ite
        IF(XLD1(I).LT.0.5)GOTO 85                                                
!       PS1=(PSFC(I)*0.01)**ROVCP             
!       TSCVN(I)=TSK(I)*PS1                                            
        TSCVN(I)=TSK(I)
        IF((SNOWC(I).GT.0..AND.TSCVN(I).GT.273.16))THEN                        
          TSCVN(I)=273.16                                                        
        ELSE                                                                     
          TSCVN(I)=TSCVN(I)                                                      
        ENDIF                                                                    
!       TSK(I)=TSCVN(I)/PS1                                                    
        TSK(I)=TSCVN(I)
   85 CONTINUE                                                                   
!                                                                                
   90 CONTINUE                                                                   
      DO I=its,ite
! QSFC and CHKLOWQ needed by Eta PBL
! WA added check for flqc = 0 to accomodate TEMF (and others?)
        if ( FLQC(I) .ne. 0.) then
           QSFC(I)=QX(I)+QFX(I)/FLQC(I)
        else
           QSFC(I) = QX(I)
        end if
        CHKLOWQ(I)=MAVAIL(I)
      ENDDO
!                                                                                
  140 CONTINUE                                                                   

   END SUBROUTINE SLAB1D

!================================================================
   SUBROUTINE slabinit(TSK,TMN,                                 &
                       TSLB,ZS,DZS,num_soil_layers,             &
                       allowed_to_read, start_of_simulation,    &
                       ids,ide, jds,jde, kds,kde,               &
                       ims,ime, jms,jme, kms,kme,               &
                       its,ite, jts,jte, kts,kte                )
!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
   LOGICAL , INTENT(IN)      ::      allowed_to_read
   LOGICAL , INTENT(IN)      ::      start_of_simulation
   INTEGER, INTENT(IN   )    ::      ids,ide, jds,jde, kds,kde, &
                                     ims,ime, jms,jme, kms,kme, &
                                     its,ite, jts,jte, kts,kte

   INTEGER, INTENT(IN   )    ::      num_soil_layers
!   
   REAL,     DIMENSION( ims:ime , 1:num_soil_layers , jms:jme ), INTENT(INOUT) :: TSLB

   REAL,     DIMENSION(1:num_soil_layers), INTENT(IN)  ::  ZS,DZS

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN)    ::                               TSK, &
                                                           TMN

!  LOCAR VAR

   INTEGER                   ::      L,J,I,itf,jtf
   CHARACTER*1024 message

!----------------------------------------------------------------
 
   itf=min0(ite,ide-1)
   jtf=min0(jte,jde-1)

   END SUBROUTINE slabinit
!-------------------------------------------------------------------          

END MODULE module_sf_slab
oml.F           1587424407  1602  20    100644  12184     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_oml

CONTAINS

!----------------------------------------------------------------
   SUBROUTINE OCEANML(tml,t0ml,hml,h0ml,huml,hvml,ust,u_phy,v_phy, &
                      tmoml,f,g,oml_gamma,                         &
                      XLAND,HFX,LH,TSK,GSW,GLW,EMISS,              &
                      DELTSM,STBOLT,                               &
                      ids,ide, jds,jde, kds,kde,                   &
                      ims,ime, jms,jme, kms,kme,                   &
                      its,ite, jts,jte, kts,kte                    )

!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
!
!  SUBROUTINE OCEANML CALCULATES THE SEA SURFACE TEMPERATURE (TSK)
!  FROM A SIMPLE OCEAN MIXED LAYER MODEL BASED ON
!  (Pollard, Rhines and Thompson (1973).
!
!-- TML         ocean mixed layer temperature (K)
!-- T0ML        ocean mixed layer temperature (K) at initial time
!-- TMOML       top 200 m ocean mean temperature (K) at initial time
!-- HML         ocean mixed layer depth (m)
!-- H0ML        ocean mixed layer depth (m) at initial time
!-- HUML        ocean mixed layer u component of wind
!-- HVML        ocean mixed layer v component of wind
!-- OML_GAMMA   deep water lapse rate (K m-1)
!-- UAIR,VAIR   lowest model level wind component
!-- UST         frictional velocity
!-- HFX         upward heat flux at the surface (W/m^2)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- EMISS       emissivity of the surface
!-- XLAND       land mask (1 for land, 2 for water)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- F           Coriolis parameter
!-- DT          time step (second)
!-- G           acceleration due to gravity

   INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &
                                    ims,ime, jms,jme, kms,kme,  &
                                    its,ite, jts,jte, kts,kte

   REAL,     INTENT(IN   )   ::     DELTSM, STBOLT

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN   )    ::                          EMISS, &
                                                         XLAND, &
                                                           GSW, &
                                                           GLW, &
                                                           HFX, &
                                                            LH

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(INOUT)    ::                            TSK

   REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(INOUT) ::     &
                                    TML,T0ML,HML,H0ML,HUML,HVML

   REAL,    DIMENSION( ims:ime, jms:jme, kms:kme ), INTENT(IN   ) ::     &
                                             U_PHY,V_PHY

   REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(IN   ) ::     &
                                             UST, F, TMOML

   REAL,    INTENT(IN   )   ::     G
   REAL,    INTENT(IN   )   ::     OML_GAMMA

! LOCAL VARS

   INTEGER ::  I,J

   DO J=jts,jte

!!!      CALL wrf_debug( 100, 'Call OML' )
         DO i=its,ite
            IF (XLAND(I,J).GT.1.5) THEN
               CALL OML1D(I,J,TML(i,j),T0ML(i,j),HML(i,j),H0ML(i,j),           &
                          HUML(i,j),HVML(i,j),TSK(i,j),HFX(i,j),               &
                          LH(i,j),GSW(i,j),GLW(i,j),TMOML(i,j),                &
                          U_PHY(i,j,kts),V_PHY(i,j,kts),UST(i,j),F(i,j),       &
                          EMISS(i,j),STBOLT,G,DELTSM,OML_GAMMA,                &
                          ids,ide, jds,jde, kds,kde,                           &
                          ims,ime, jms,jme, kms,kme,                           &
                          its,ite, jts,jte, kts,kte                            )
            ENDIF
         ENDDO

   ENDDO

   END SUBROUTINE OCEANML

!----------------------------------------------------------------
   SUBROUTINE OML1D(I,J,TML,T0ML,H,H0,HUML,                              &
                    HVML,TSK,HFX,                                        &
                    LH,GSW,GLW,TMOML,                                    &
                    UAIR,VAIR,UST,F,EMISS,STBOLT,G,DT,OML_GAMMA,         &
                    ids,ide, jds,jde, kds,kde,                           &
                    ims,ime, jms,jme, kms,kme,                           &
                    its,ite, jts,jte, kts,kte                            )

!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
!
!  SUBROUTINE OCEANML CALCULATES THE SEA SURFACE TEMPERATURE (TSK) 
!  FROM A SIMPLE OCEAN MIXED LAYER MODEL BASED ON 
!  (Pollard, Rhines and Thompson (1973).
!
!-- TML         ocean mixed layer temperature (K)
!-- T0ML        ocean mixed layer temperature (K) at initial time
!-- TMOML       top 200 m ocean mean temperature (K) at initial time
!-- H           ocean mixed layer depth (m)
!-- H0          ocean mixed layer depth (m) at initial time
!-- HUML        ocean mixed layer u component of wind
!-- HVML        ocean mixed layer v component of wind
!-- OML_GAMMA   deep water lapse rate (K m-1)
!-- OMLCALL     whether to call oml model
!-- UAIR,VAIR   lowest model level wind component
!-- UST         frictional velocity
!-- HFX         upward heat flux at the surface (W/m^2)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- EMISS       emissivity of the surface
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- F           Coriolis parameter
!-- DT          time step (second)
!-- G           acceleration due to gravity
!
!----------------------------------------------------------------
   INTEGER, INTENT(IN   )    ::      I, J
   INTEGER, INTENT(IN   )    ::      ids,ide, jds,jde, kds,kde, &
                                     ims,ime, jms,jme, kms,kme, &
                                     its,ite, jts,jte, kts,kte

   REAL,    INTENT(INOUT)    :: TML, H, H0, HUML, HVML, TSK

   REAL,    INTENT(IN   )    :: T0ML, HFX, LH, GSW, GLW,        &
                                UAIR, VAIR, UST, F, EMISS, TMOML

   REAL,    INTENT(IN) :: STBOLT, G, DT, OML_GAMMA

! Local
   REAL :: rhoair, rhowater, Gam, alp, BV2, A1, A2, B2, u, v, wspd, &
           hu1, hv1, hu2, hv2, taux, tauy, tauxair, tauyair, q, hold, &
           hsqrd, thp, cwater, ust2
   CHARACTER(LEN=120) :: time_series

      hu1=huml
      hv1=hvml
      rhoair=1.
      rhowater=1000.
      cwater=4200.
! Deep ocean lapse rate (K/m) - from Rich
      Gam=oml_gamma
!     if(i.eq.1 .and. j.eq.1 .or. i.eq.105.and.j.eq.105) print *, 'gamma = ', gam
!     Gam=0.14
!     Gam=5.6/40.
!     Gam=5./100.
! Thermal expansion coeff (/K)
!     alp=.0002
!     temp dependence (/K)
      alp=max((tml-273.15)*1.e-5, 1.e-6)
      BV2=alp*g*Gam
      thp=t0ml-Gam*(h-h0)
      A1=(tml-thp)*h - 0.5*Gam*h*h
      if(h.ne.0.)then
        u=hu1/h
        v=hv1/h
      else
        u=0.
        v=0.
      endif

!  time step

        q=(-hfx-lh+gsw+glw*emiss-stbolt*emiss*tml*tml*tml*tml)/(rhowater*cwater)
!       wspd=max(sqrt(uair*uair+vair*vair),0.1)
        wspd=sqrt(uair*uair+vair*vair)
        if (wspd .lt. 1.e-10 ) then
!          print *, 'i,j,wspd are ', i,j,wspd
           wspd = 1.e-10
        endif
! limit ust to 1.6 to give a value of ust for water of 0.05
!       ust2=min(ust, 1.6)
! new limit for ust: reduce atmospheric ust by half for ocean
        ust2=0.5*ust
        tauxair=ust2*ust2*uair/wspd
        taux=rhoair/rhowater*tauxair
        tauyair=ust2*ust2*vair/wspd
        tauy=rhoair/rhowater*tauyair
! note: forward-backward coriolis force for effective time-centering
        hu2=hu1+dt*( f*hv1 + taux)
        hv2=hv1+dt*(-f*hu2 + tauy)
! consider the flux effect
        A2=A1+q*dt

        huml=hu2
        hvml=hv2

        hold=h
        B2=hu2*hu2+hv2*hv2
        hsqrd=-A2/Gam + sqrt(A2*A2/(Gam*Gam) + 2.*B2/BV2)
        h=sqrt(max(hsqrd,0.0))
! limit to positive h change
        if(h.lt.hold)h=hold

! no change unless tml is warmer than layer mean temp tmol or tsk-5 (see omlinit)
        if(tml.ge.tmoml .and. h.ne.0.)then

! no change unless tml is warmer than layer mean temp tmoml or tsk-5 (see omlinit)
          if(tml.ge.tmoml)then
            tml=max(t0ml - Gam*(h-h0) + 0.5*Gam*h + A2/h, tmoml)
          else 
            tml=tmoml
          endif
          u=hu2/h
          v=hv2/h
        else
          tml=t0ml
          u=0.
          v=0.
        endif
        tsk=tml
!        if(h.gt.100.)print *,i,j,h,tml,' h,tml'

! ww: output point data
!     if( (i.eq.190 .and. j.eq.115) .or. (i.eq.170 .and. j.eq.125) ) then
!        write(jtime,fmt='("TS ",f10.0)') float(itimestep)
!        CALL wrf_message ( TRIM(jtime) )
!        write(time_series,fmt='("OML",2I4,2F9.5,2F8.2,2E15.5,F8.3)') &
!              i,j,u,v,tml,h,taux,tauy,a2
!        CALL wrf_message ( TRIM(time_series) )
!     end if

   END SUBROUTINE OML1D

!================================================================
   SUBROUTINE omlinit(outfile,oml_hml0, tsk,                   &
                      tml,t0ml,hml,h0ml,huml,hvml,tmoml,       &
                      allowed_to_read, start_of_simulation,    &
                      ids,ide, jds,jde, kds,kde,               &
                      ims,ime, jms,jme, kms,kme,               &
                      its,ite, jts,jte, kts,kte                )
!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
   INTEGER, INTENT(IN   )    ::      outfile
   LOGICAL , INTENT(IN)      ::      allowed_to_read
   LOGICAL , INTENT(IN)      ::      start_of_simulation
   INTEGER, INTENT(IN   )    ::      ids,ide, jds,jde, kds,kde, &
                                     ims,ime, jms,jme, kms,kme, &
                                     its,ite, jts,jte, kts,kte

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN)    ::                               TSK

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(INOUT)    ::     TML, T0ML, HML, H0ML, HUML, HVML, TMOML
   REAL   , INTENT(IN   )    ::     oml_hml0

!  LOCAR VAR

   INTEGER                   ::      L,J,I,itf,jtf
   CHARACTER*1024 message

!----------------------------------------------------------------
 
   itf=min0(ite,ide-1)
   jtf=min0(jte,jde-1)

   IF(start_of_simulation) THEN
     DO J=jts,jtf
     DO I=its,itf
       TML(I,J)=TSK(I,J)
       T0ML(I,J)=TSK(I,J)
     ENDDO
     ENDDO
     IF (oml_hml0 .gt. 0.) THEN
!!!        WRITE(message,*)'Initializing OML with HML0 = ', oml_hml0
!!!        CALL wrf_debug (0, TRIM(message))
!!!        write(outfile,*) 'Initializing OML with HML0 = ', oml_hml0
        DO J=jts,jtf
        DO I=its,itf
          HML(I,J)=oml_hml0
          H0ML(I,J)=HML(I,J)
          HUML(I,J)=0.
          HVML(I,J)=0.
          TMOML(I,J)=TSK(I,J)-5.
        ENDDO
        ENDDO
     ELSE
!!!        WRITE(message,*)'Initializing OML with real HML0, h(1,1) = ', h0ml(1,1)
!!!        CALL wrf_debug (0, TRIM(message))
!!!        write(outfile,*) 'Initializing OML with real HML0, h(1,1) = ', h0ml(1,1)
        stop 34543
        DO J=jts,jtf
        DO I=its,itf
          HML(I,J)=H0ML(I,J)
! fill in near coast area with SST: 200 K was set as missing value in ocean pre-processing code
          IF(TMOML(I,J).GT.200. .and. TMOML(I,J).LE.201.) TMOML(I,J)=TSK(I,J)
        ENDDO
        ENDDO
     ENDIF
   ENDIF

   END SUBROUTINE omlinit
!-------------------------------------------------------------------          
END MODULE module_sf_oml
